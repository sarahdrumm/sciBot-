Dynamic and Historical Shortest Path Distance Queries on
Large Evolving Networks by Pruned Landmark Labeling
Takuya Akiba
The University of Tokyo Tokyo , 113 0033 , Japan
Yoichi Iwata
Yuichi Yoshida
The University of Tokyo Tokyo , 113 0033 , Japan
National Institute of Informatics ,
Preferred Infrastructure , Inc . takiba@issu tokyoacjp yiwata@issu tokyoacjp
Tokyo , 101 8430 , Japan yyoshida@niiacjp
ABSTRACT We propose two dynamic indexing schemes for shortest path and distance queries on large time evolving graphs , which are useful in a wide range of important applications such as real time network aware search and network evolution analysis . To the best of our knowledge , these methods are the first practical exact indexing methods to efficiently process distance queries and dynamic graph updates .
We first propose a dynamic indexing scheme for queries on the last snapshot . The scalability and efficiency of its offline indexing algorithm and query algorithm are competitive even with previous static methods . Meanwhile , the method is dynamic , that is , it can incrementally update indices as the graph changes over time . Then , we further design another dynamic indexing scheme that can also answer two kinds of historical queries with regard to not only the latest snapshot but also previous snapshots .
Through extensive experiments on real and synthetic evolving networks , we show the scalability and efficiency of our methods . Specifically , they can construct indices from large graphs with millions of vertices , answer queries in microseconds , and update indices in milliseconds .
Categories and Subject Descriptors E.1 [ Data ] : Data Structures—Graphs and networks
General Terms Algorithms , Experimentation , Performance
Keywords Graphs , dynamic graphs , shortest paths , query processing
1 .
INTRODUCTION
A shortest path query asks the shortest path between two vertices in a graph , and a distance query asks the distance between two vertices in a graph . As two of the most fundamental and important operations on graph data , it has a
Copyright is held by the International World Wide Web Conference Committee ( IW3C2 ) . IW3C2 reserves the right to provide a hyperlink to the author ’s site if the Material is used in electronic media . WWW’14 , April 7–11 , 2014 , Seoul , Korea . ACM 978 1 4503 2744 2/14/04 . http://dxdoiorg/101145/25664862568007 e c n a t s D i
9
8
7
6
5
4
3
2
1
Time
( a ) An ego network
( b ) Distances to the neighbors
Figure 1 : An example of social network analysis on a dynamic Facebook subgraph [ 33 ] using our method for historical shortest path distance queries . wide range of applications including network aware search [ 32 , 35 , 31 , 24 ] , social network analysis [ 17 , 6 ] , bioinformatics [ 26 , 27 ] , computer network management [ 23 , 9 ] , and so on . Consequently , indexing methods for efficiently answering these queries have been intensely studied [ 11,24,34,5,25,16,4,15 ] . However , while many real world networks are dynamic and growing rapidly , these methods are designed for static networks and none of them can immediately reflect changes on graphs nor answer queries on graphs in the past . To address this issue , in this paper , we study dynamic indexing methods for these queries on large evolving networks . We assume the following two scenarios : one is to ask only contemporary queries , and the other is to also ask historical queries .
1.1 Contemporary Queries
One of two scenarios that we consider in this paper is that we have a real time dynamic network and we are especially interested in the latest snapshot . In this scenario , we first construct an index from the current graph , then we process ( i ) incremental index updates for graph changes and ( ii ) shortest path or distance queries on the latest snapshot . In this paper , we refer to queries to the latest snapshot as contemporary queries .
Applications in network aware search : Distance between two users on social networks is considered to indicate the closeness , and used in socially sensitive search to help users to find more related users or contents [ 32 , 35 ] . Similarly , distance between two pages in web graphs is one of indicators of relevance , and used in context aware search to give higher ranks to pages more related to the currently visiting page [ 31 , 24 ] .
237 Real time index update would definitely improve user experience because these networks are highly dynamic and , more importantly , operations of users are bursty with regard to temporal locality [ 7 ] . For example , on an online social networking service , when a user begins a friendship with another user , chances are high for the user to keep using the service for a few more minutes . Using our dynamic indexing method , the new friendship can be immediately reflected , which has never been possible with static methods that require periodic index reconstruction ( see Section 9 for further discussion ) .
1.2 Historical Queries
When analyzing historical networks , for which timestamps of vertices and edges are also available , in addition to the latest snapshot , the shortest paths and distances on previous snapshots or transition of them by time are also of interest . In this paper , we call such queries about previous snapshots historical queries . In particular , we study two kinds of historical queries . A snapshot query asks the shortest path or distance on a specified previous snapshot , and a changepoint query asks all the moments when the distance between two vertices has changed ( see the definition in Section 32 )
Applications in evolving network analysis : Indexing schemes supporting historical queries would be a powerful back end for time evolving network analysis , as it enables many new interesting studies . For example , from the transition of the shortest paths between two vertices , we can grasp the events that shortened the distance or important links that lie in the shortest paths for a long duration , which would provide valuable insights . Moreover , it would also enable distance based analysis of influential people and communities [ 17 , 6 ] on dynamic networks . In particular , transition of closeness centrality and distance distribution can be efficiently computed with historical change point queries ( see Section 8 ) .
Case study : Figure 1 illustrates an example of analysis on a real world Facebook subgraph [ 33 ] based on historical change point queries . Figure 1a depicts an ego network , ie , the induced subgraph of a center vertex and its neighbors , where the center vertex is the gray one . From the figure , we can observe that there are two clusters on the left and right of the center vertex . Figure 1b shows the transition of the distances between the center vertex and its neighbors , where the colors of the lines correspond to those of the vertices in Figure 1a . We can confirm that the time periods of the appearance of the friendship links are different between the two clusters . Moreover , we find that the two clusters happened quite differently . That is , while the left cluster gradually approached the center vertex , the right cluster became neighbors almost instantly .
1.3 Contributions
In this paper , we propose two dynamic indexing schemes tailored to the two scenarios introduced above . Our methods are exact , that is , answers to queries contain no error . To the best of our knowledge , our method for contemporary queries is the first practical exact indexing method to efficiently process distance queries and dynamic graph updates , and our method for historical queries is the first practical exact indexing method to efficiently handle these historical queries and dynamic graph updates . The two methods are referred to as dynamic pruned landmark labeling and historical pruned landmark labeling .
Experimental results presented in Section 6 show the efficiency and robustness of our methods . They can construct indices from large networks with millions of vertices , and their query time is very small and around microseconds , which are competitive with previous static methods . Meanwhile , the proposed methods can update their indices for single graph modification in around milliseconds , which is several orders of magnitude faster than reconstructing indices from scratch .
In what follows , we assume undirected unweighted graphs and consider only distance queries for simplicity of exposition , but supporting directed and/or weighted graphs and shortest path queries is discussed in Section 7 .
Supported updates : In this paper , we focus on two kinds of graph updates : vertex additions and edge additions . This is due to the following reasons .
1 . As we can see that no previous methods support any incremental updates , supporting only additions is already quite technically challenging .
2 . Supporting removals is even much harder and it seems impossible to efficiently support removals without making big compromise on performance such as index size and query time .
3 . Removals never happen in certain kinds of real world dynamic networks such as interaction networks in social media and instant messaging services , co author networks , co starring networks , e mail networks , telephone networks , and so on .
4 . In other kinds of real dynamic networks , still , additions are much more frequent than removals [ 21 ] .
5 . For these reasons , it is quite common to ignore removals when analyzing and modeling dynamic networks [ 8 , 19 , 21 , 33 ] . As an evidence , widely used public datasets of time evolving graphs do not contain any removal12 .
See Section 9 for further discussion on the practicability of proposed methods .
2 . RELATED WORK
In this section , we review previous indexing methods on exact and approximate distance queries . As none of previous methods support incremental updates , all of them are static .
Approximate methods : The major approach to approximate distances is the landmark based approach [ 29,32,24,13 , 25 , 30 ] , which precompute and store a number of shortestpath trees rooted at landmarks . While these methods easily attain preferable scalability , some of them have critical precision problems for close pairs [ 25,5 ] , and the other methods with better precision have three orders of magnitude slower query time . Consequently , focus of the research community is shifting toward undermentioned exact methods , leading to recent large improvement on exact methods . In this paper , we also concentrate on exact methods .
Exact methods : Large portion of exact methods can be considered as based on the idea of 2 hop cover [ 12 ] . Finding small 2 hop covers efficiently is a challenging and longstanding problem , and thus several algorithms have been 1http://socialnetworksmpi swsorg/ 2http://konectuni koblenzde/
238 developed [ 12 , 11 , 1 , 16 , 4 ] . Among them , the most recent method pruned landmark labeling [ 4,36,3 ] achieves orders of magnitude better scalability than previous methods by exploiting the structures of real networks such as existence of highly central vertices and the core–fringe structure [ 10 , 22 ] . The proposed methods are built on this method .
IS Label [ 15 ] is another recent method that also gained prominent scalability . It partially constructs a 2 hop cover index and combines it with bidirectional Dijkstra ’s algorithm to answer each query . We compare the proposed methods with this method in our experiments .
An approach based on tree decompositions is also reported to be efficient [ 34,5 ] . A tree decomposition of a graph G is a tree T with each vertex associated with a set of vertices in G , called a bag [ 28 ] . Also , the set of bags containing a vertex in G forms a connected component in T . It heuristically computes a tree decompositions and stores shortest distance matrices for each bag . We also present the results of a treedecomposition based method in our experiments .
3 . PRELIMINARIES
3.1 Notations and Basic Facts Static graph ( latest snapshot ) : Let G = ( V , E ) be a graph with vertex set V and edge set E . We use symbols n and m to denote the number of vertices |V | and the number of edges |E| , respectively , when the graph is clear from the context . We suppose V = {v1 , v2 , . . . , vn} and refer to i as the ID of vertex vi . We also denote the vertex set of G by V ( G ) and the edge set of G by E(G ) . Let d(u , v ) denote the distance between vertices u , v . If u and v are disconnected in G , we define d(u , v ) = ∞ . We denote the set of neighbors of a vertex v ∈ V by N ( v ) . That is , N ( v ) = {u ∈ V | ( u , v ) ∈ E} .
Dynamic graph : When we consider dynamic networks , we use symbol G to denote the latest network , and symbol Gτ to denote the network at time τ . We use these notations for both graphs stored with timestamps for edges and real time dynamic graphs . For simplicity , we assume time is described by positive integers ( ie , graph snapshots are G1 , G2 , . . . ) , and we define G0 as an empty graph . Since we only consider vertex and edge additions , for any τ > 0 , V ( Gτ −1 ) ⊆ V ( Gτ ) and E(Gτ −1 ) ⊆ E(Gτ ) . We denote the distance between vertices u , v in graph Gτ by dτ ( u , v ) . For edge ( u , v ) ∈ G , we define t(u , v ) = τ , where τ is the time when the edge appeared in the graph ( ie , ( u , v ) 6∈ E(Gτ −1 ) and ( u , v ) ∈ E(Gτ ) ) .
Decreasing distance : As we only consider vertex and edge additions , the following lemma is a key for designing algorithms .
Lemma 31 Let Gτ , Gτ ′ be graphs where E(Gτ ) ⊆ E(Gτ ′ ) .
For any pairs of vertices s and t , dτ ( s , t ) ≥ dτ ′ ( s , t ) .
That is , for any pairs of vertices , distance between them never increases by adding vertices or edges . This is actually trivial since the path that was the shortest path in Gτ is also present in Gτ ′ .
Please note that this lemma does not tell that distance on a dynamic graph without removals is uninteresting . For example , diameter or average distance do not necessarily always decrease because of vertex additions ( see Figure 3 in Section 8 ) .
3.2 Problem Definition
In this paper , we study indexing methods that , given a graph , construct an index to quickly answer the following queries .
Problem 1 ( Contemporary Distance Query ) : Given : Two query vertices s , t . Answer : Distance dτ ( s , t ) , where τ is the last time when a vertex or an edge is added .
Problem 2 ( Historical Snapshot Distance Query ) : Given : Two query vertices s , t and time τ . Answer : Distance dτ ( s , t ) .
Problem 3 ( Historical Distance Change point Query ) : Given : Two query vertices s , t . Answer : Set C(s , t ) = {(τ1 , δ1 ) , ( τ2 , δ2 ) , . . .} where ( τi , δi ) ∈ C(s , t ) if and only if δi = dτi ( s , t ) 6= dτi−1(s , t ) .
In addition to answering these queries , we also discuss ways to efficiently update the index as graph changes . As we mentioned before , we focus on the two most important operations , vertex additions and edge additions . Please note that we can assume the newly inserted vertex is isolated since otherwise we can process it by first inserting an isolated vertex and then inserting edges incident to it . Similarly , if multiple edges are inserted simultaneously , we process them one by one .
4 . CONTEMPORARY QUERIES
In this section , we propose our dynamic indexing method named dynamic pruned landmark labeling for contemporary queries . The method is based on the simple but effective notion of pruned landmark labeling [ 4 ] . First , we review the index data structure and query algorithm of the 2 hop cover framework in Section 41 Next , we explain our offline indexing algorithm in Section 42 Finally , we present the incremental update algorithm in Section 43
4.1 2 Hop Cover Framework
The general framework of 2 hop cover [ 12 , 11 , 1 ] is as follows . Our method also follows this framework . For each vertex v , we precompute and store a label denoted as L(v ) , which is a set of pairs ( u , δuv ) , where u is a vertex and δuv = d(u , v ) . We call the set of labels {L(v)}v∈V as an index , and a pair in a label as a label entry . We sometimes abbreviate ( v , δuv ) ∈ L(u ) to v ∈ L(u ) .
To answer a distance query between vertices s and t , we compute and answer Query(s , t , L ) defined as follows ,
Query(s , t , L ) = min {δvs + δvt | ( v , δvs ) ∈ L(s ) , ( v , δvt ) ∈ L(t)} .
We define Query(s , t , L ) = ∞ if L(s ) and L(t ) do not share any vertex . Index L is called a ( distance aware ) 2 hop cover of G if Query(s , t , L ) = d(s , t ) for any pair of vertices s and t .
For each vertex v , we store the label L(v ) so that pairs in it are sorted by their vertices . Then , we can compute Query(s , t , L ) in O(|L(s)| + |L(t)| ) time using a merge sortlike algorithm .
4.2 Offline Indexing Algorithm
In this subsection , we explain our labeling algorithm that efficiently computes small labels for the 2 hop cover framework by conducting pruned BFSs from every vertex . We
239 explain the algorithm in two steps : we first introduce the naive landmark labeling algorithm , which computes labels by conducting normal BFSs from every vertex in Section 421 , then introduce pruning to the algorithm in Section 422
421 Naive Landmark Labeling Algorithm
Let V = {v1 , v2 , . . . , vn} . We start with an empty index L0 , where L0(u ) = ∅ for any u ∈ V . We conduct BFSs from all vertices in the order of v1 , v2 , . . . , vn . After the k th BFS from vertex vk , we update the index as follows . For all the vertices u that are reachable from vk , we set Lk(u ) = Lk−1(u ) ∪ {(vk , d(vk , u))} . For all the unreachable vertices u , we do not change their labels , that is , we just set Lk(u ) = Lk−1(u ) .
After n BFSs , Ln is the final index . Obviously Query(s , t , Ln ) = d(s , t ) for any pair of vertices s and t , since ( s , 0 ) ∈ L(s ) and ( s , d(s , t ) ) ∈ L(t ) if they are reachable . Therefore , Ln is a correct 2 hop cover for exact distance queries . However , this method is also obviously inefficient , due to Θ(mn ) indexing time and Θ(n2 ) index space .
Lemma 41 Query(s , t , Ln ) = d(s , t ) for any pair of ver tices s and t .
422 Pruned Landmark Labeling Algorithm
As with the naive method above , we conduct pruned BFSs from all vertices in the order of v1 , v2 , . . . , vn . We start with an empty index L′ 0 , and we construct index L′ and the result of the k th pruned BFS from vk . k from L′ k−1 k from L′
We prune BFSs as follows . Suppose we are conducting the k th pruned BFS from vk to create index L′ k−1 , and visiting vertex u with distance δ . We issue a query between vk and u to the current incomplete index L′ k−1 , and compare the answer to δ . If Query(vk , u , L′ k−1 ) ≤ δ , then we prune u . That is , we do not add pair ( vk , δ ) to the label of u ( ie L′ k−1(u) ) , and we do not traverse any edges incident to u . Otherwise , as usual , we set L′ k−1(u)∪{(vk , δ)} and traverse all the edges incident to u . As with the previous method , we also set L′ k−1(u ) for all vertices u ∈ V that were not visited in the k th pruned BFS . This pruned BFS algorithm is described in Algorithm 1 . After n pruned BFSs , L′ n is the final index . k(u ) = L′ k(u ) = L′ k(u ) = L′
Theorem 41 For any s , t ∈ V and 1 ≤ k ≤ n , we have
Query(s , t , L′ k ) = Query(s , t , Lk ) .
We give a proof sketch ( refer to [ 4 ] for details ) .
Proof sketch . Let Pk(s , t ) be a shortest path between s and t passing through one of v1 , . . . , vk , and let dk(s , t ) be the length of it . Note that Query(s , t , Lk ) = dk(s , t ) .
Suppose that the theorem holds for k′ < k , and we show the theorem for k . Fix vertices s and t in V . Let vi ( 1 ≤ i ≤ k ) be the vertex in Pk(s , t ) with the lowest index . It suffices to show that vi is added to L′ i(t ) as it implies that Query(s , t , L′ k ) ≤ d(s , vi ) + d(vi , t ) = dk(s , t ) . i(s ) and L′
Suppose that vi is not added to L′ i(s ) ( t can be handled analogously ) . Then , there exists some vertex u on the path Pk(vi , s ) such that the BFS from vi is pruned at u . The reason it is pruned is that there exists a path between vi and u of length at most d(vi , u ) passing through some vertex vi′ with i′ < i . This implies that there exists a shortest path between vi and s passing through vi′ and hence a shortest path between s and t passing through vi′ . This contradicts the choice of i . k−1 ) k[v ] ← L′ k−1[v ] for all v ∈ V ( G ) .
Q ← a queue with only one element vk . P [ vk ] ← 0 and P [ v ] ← ∞ for all v ∈ V ( G ) \ {vk} . L′ while Q is not empty do
Algorithm 1 Pruned BFS from vk ∈ V to create index L′ k . 1 : procedure PrunedBFS(G , vk , L′ 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : 10 : 11 : 12 : 13 :
L′ k[u ] ← L′ for all w ∈ NG(v ) st P [ w ] = ∞ do
Dequeue u from Q . if Query(vk , u , L′
P [ w ] ← P [ u ] + 1 . Enqueue w onto Q . k−1[u ] ∪ {(vk , P [ vk])} k−1 ) ≤ P [ u ] then continue return L′ k
The theorem above says that we can answer exact distance with the index L′ n . Furthermore , it says that , during the k th pruned BFS , we prune vertices whose shortest path to vk passes through at least one of vertices v1 , v2 , . . . , vk−1 .
Time complexity : We present an estimate . Let l be the average size of labels and d be the average degree . We visit O(nl ) vertices in total , where we traverse O(d ) edges and evaluate a query in O(l ) time . Therefore , the time complexity is roughly estimated as O(nl(d + l ) ) time , which corresponds with our experimental results in Section 6 to some extent . In our experiments , l was around hundreds .
423 Vertex Ordering Strategy
In real world networks , by properly choosing the order of vertices from which we conduct BFSs , the pruning drastically reduces the search space and label sizes , leading to the high efficiency of the proposed method . In real world networks , there are highly central vertices ( sometimes called hubs ) . By conducting BFSs from these vertices first , label entries to these vertices greatly contribute to pruning since many shortest paths pass through these central vertices . Since it is obviously too costly to compute the optimal order of vertices , as a heuristic vertex ordering strategy , we choose vertices by the decreasing order of degrees . Experimental results in Section 6 show that this simple vertex ordering strategy makes our method sufficiently effective .
4.3 Online Incremental Update Algorithm
Finally , we present our new algorithm that incrementally updates the current index to reflect graph changes . As we noted in Section 3.2 , when a new vertex is added , we can assume it is an isolated vertex . Under the 2 hop framework , inserting a new isolated vertex v can be easily done by setting a new empty label L(v ) = ∅ . Thus , in what follows , we focus on edge additions . The idea behind our efficient update algorithm is to carefully resume and stop pruned BFSs .
Suppose that we are maintaining index M for dynamic graph G and we want to update M to reflect a newly inserted edge ( a , b ) that was previously absent . We refer to the old graph without the new edge as Gτ −1 and the new graph with the new edge as Gτ . Similarly , we refer to the old and new index as Mτ −1 and Mτ , respectively .
From Lemma 3.1 , it is sound to keep outdated distances in the index since we never underestimate distances because of them . Therefore in our method , we do not remove outdated label entries since detecting them is too costly . We only
240 0
1
1
2
2
3
3
4
4
( a ) A graph
5
5
6
6
0
1
1
2
2
3
3
3
4
2
4
3
4
( b ) The graph after inserting a new edge ( drawn in blue )
Figure 2 : A running example for the update algorithm . The green vertex is the root , and the distance to the root is written in each vertex . add new label entries or rewrite distances of existing label entries . Under this strategy , the minimality of the index Mτ as a whole is broken after updates , but we will later see that the set of newly added label entries is minimal to answer correct distances in Gτ . Moreover , we will see that the increase of label sizes is satisfyingly small in practice ( Section 623 )
431 Update Algorithm for Naive Labeling
We first describe an update algorithm for the naive landmark labeling method . The obvious way is to conduct full BFSs from every vertex again and update labels , which is not different from the indexing algorithm at all . To update labels more efficiently , let us reduce the search space of each BFS . The two key insights here are the following .
Lemma 42 If the distance from vertex vk to vertex u has changed , then all the new shortest paths between them pass through the new edge ( a , b ) .
Lemma 43 Suppose the shortest path P between vk and u 6= a , b has changed . Then the distance between vk and w has changed , where w is the penultimate vertex in P .
We can assume dτ −1(vk , a ) ≤ dτ −1(vk , b ) without loss of generality . Based on these facts , for every vk , it suffices to resume the BFS from b originally rooted at vk and stop at unchanged vertices . That is , instead of inserting ( vk , 0 ) to the initial queue , we insert ( b , dτ −1(vk , a ) + 1 ) to the initial queue , which corresponds to the position after passing through the new edge ( a , b ) , and we do not traverse edges from vertex u if δ ≥ dτ −1(vk , u ) , where δ is the tentative distance for u drawn from the queue . Figure 2 illustrates an example .
432 Update Algorithm for Pruned Labeling
Now we explain our update algorithm for the pruned landmark labeling . We introduce pruning to the previous update algorithm . Let s , t be vertices and k be an integer . We define a new function PrefixalQuery as follows ,
PrefixalQuery(s , t , M , k ) = min {δs + δt | ( vi , δs ) ∈ M ( s ) , ( vi , δt ) ∈ M ( t ) , i ≤ k} .
That is , PrefixalQuery(s , t , M , k ) is the answer to the query between vertices s and t computed from the index M only using distances to vertices whose IDs are at most k . We define PrefixalQuery(s , t , M , k ) = ∞ if M ( s ) and M ( t ) do not share any vertex whose ID is at most k . Using this function , suppose we are conducting a resumed BFS originally rooted at vk and visiting vertex u with distance δ , we prune u if PrefixalQuery(vk , u , M , k ) ≤ δ .
However , one crucial question is left : for which roots do we need to resume BFSs ? The obvious solution is resuming for all vk ∈ M ( a ) ∪ M ( b ) from lower k do
ResumePBFS(G , vk , b , d(vk , a ) + 1 , M ) if vk ∈ M [ a ] ResumePBFS(G , vk , a , d(vk , b ) + 1 , M ) if vk ∈ M [ b ]
Algorithm 2 Update index M for newly added edge ( a , b ) 1 : procedure InsertEdge(G , a , b , M ) 2 : 3 : 4 : 5 : procedure ResumePBFS(G , vk , u , δru , M ) 6 : 7 : 8 : 9 : 10 : 11 : 12 : 13 :
Q ← a queue with only one element ( u , δru ) . while Q is not empty do Dequeue ( v , δ ) from Q . if PrefixalQuery(vk , v , M , k ) ≤ δ then continue
M [ v ] ← M [ v ] ∪ {(vk , δ)} for all w ∈ N ( v ) do
Enqueue ( w , δ + 1 ) onto Q .
BFSs no matter what their roots are as with the previous algorithm , but it is too inefficient since it takes at least Ω(|V | ) time . Interestingly , the answer is exactly what we have in M ( a ) and M ( b ) . That is , it suffices to conduct resumed BFSs originally rooted at vk if vk ∈ M ( a ) ∪ M ( b ) . This is because , if vk 6∈ M ( a)∪M ( b ) , both a and b are pruned or unreached during previous ( resumed ) BFSs rooted at vk , and since the shortest path between vk and them has not changed from the last snapshot , the situation does not change at all . The total algorithm is described as Algorithm 2 .
Time complexity : To roughly estimate the time complexity , we assume |L(v)| = O(l ) and the number of vertices visited during each resumed BFS is O(s ) , where l and s are some integers . Then , since we conduct resumed BFSs O(l ) times and each pruning test takes O(l ) time , in total , each update can be done in O(l2s ) time . In our experiments , l was around hundreds and s was around tens on average ( see Section 623 )
433 Proof of Correctness
We prove the correctness of the proposed incremental update algorithm . For vertices s , t and 0 ≤ k ≤ n , we define the restricted distance between s and t with respect to k as d′(s , t , k ) = mini≤k {d(s , vi ) + d(vi , t)} . We define d′(s , t , k ) = ∞ if k = 0 or vi is unreachable from s or t for all i ≤ k . As with dτ , we denote the restricted distance at time τ by d′ τ ( s , t , k ) . The following notion of correctness is important .
Definition 4.1
( Prefixal Correctness ) . Let M be a 2 hop cover index for graph G . Index M is prefixally correct if PrefixalQuery(s , t , M , k ) = d′(s , t , k ) for any s , t ∈ V and 0 ≤ k ≤ n .
Note that prefixal correctness is stronger than normal correctness . Due to Theorem 4.1 , the initial index constructed by the full pruned landmark labeling algorithm satisfies prefixal correctness . In what follows , we prove that prefixal correctness of an index is maintained by the incremental update algorithm .
In what follows , let Mτ −1 be a prefixally correct index for graph Gτ −1 , let Gτ be the graph created by inserting edge ( a , b ) 6∈ E(Gτ −1 ) to Gτ −1 , and Mτ be the index updated by the Algorithm 2 from Mτ −1 for the edge addition .
Lemma 44 For any pair of vertices s and t and 0 < k ≤ n , we have PrefixalQuery(s , t , Mτ , k − 1 ) = d′ τ ( s , t , k − 1 ) . For any vertex u and 0 < k ≤ n , if dτ ( vk , u ) < dτ −1(vk , u ) and dτ ( vk , u ) < d′ τ ( vk , u , k−1 ) , then we have ( vk , dτ ( vk , u ) ) ∈ Mτ ( u ) .
241 Proof . Since dτ ( vk , u ) < dτ −1(vk , u ) , all the shortest paths from vk to u in the new snapshot Gτ pass through the new edge ( a , b ) . We assume dτ ( vk , a ) < dτ ( vk , b ) with out loss of generality , and suppose that one of the shortest paths is of the form ( vk , . . . , a , b = w0 , w1 , w2 , . . . , u = wl ) . We can observe that , not only u but also for any wi , dτ ( vk , wi ) < dτ −1(vk , wi ) holds . Moreover , since dτ ( vk , u ) < d′ τ ( vk , u , k − 1 ) , none of the shortest paths between vk and u in Gτ goes through the vertex vj for any j < k . This also holds for any wi , that is , none of the shortest paths between vk and wi in Gτ passes through vj for any j < k , and thus dτ ( vk , wi ) < d′
τ ( vk , wi , k − 1 ) .
During the resumed BFS originally rooted at vk , we have
PrefixalQuery(vk , wi , Mτ , k ) ≥ min{d′ dτ −1(vk , wi)} for any wi . Therefore , PrefixalQuery(vk , wi , Mτ , k ) ≥ dτ ( vk , wi ) , and wi is not pruned . Thus , the BFS reaches vertex u with the correct distance dτ ( vk , u ) , and pair ( vk , dτ ( vk , u ) ) is newly added to the label Mτ ( u ) .
τ ( vk , wi , k − 1 ) ,
Theorem 42 Mτ is a prefixally correct index for Gτ .
Proof . We prove the prefixal correctness of Mτ by mathematical induction on k . For k = 0 , it is true as , for any pair of vertices s and t with s 6= t , PrefixalQuery(s , t , Mτ , 0 ) = d′(s , t , 0 ) = ∞ . Now we assume k > 0 and PrefixalQuery( s , t , Mτ , k−1 ) = d′(s , t , k−1 ) for any pairs of vertices s and t , and prove PrefixalQuery(s , t , Mτ , k ) = d′(s , t , k ) for any pairs of vertices s , t .
Let δ′ = d′
τ ( s , t , k ) . If δ′ = d′
τ ( s , t , k − 1 ) , then we have nothing to show due to the assumption of the mathematical induction . Otherwise , since δ′ < d′ τ ( s , t , k − 1 ) , δ′ = it suffices to show that dτ ( s , vk ) + dτ ( vk , t ) . Therefore , ( vk , dτ ( vk , s ) ) ∈ Mτ ( s ) and ( vk , dτ ( vk , t ) ) ∈ Mτ ( t ) . Due to the symmetry between s and t , we only show ( vk , dτ ( vk , s ) ) ∈ Mτ ( s ) .
First , we consider the case dτ ( vk , s ) = dτ −1(vk , s ) . From d′ τ ( s , t , k ) = dτ ( s , vk ) + dτ ( vk , t ) < d′ τ ( s , t , k − 1 ) , there is no vertex vi with i ≤ k − 1 on any shortest path between s and vk in Gτ . This is the case in Gτ −1 since dτ ( vk , s ) = dτ −1(vk , s ) . It follows that d′ τ −1(vk , s , k ) . Thus if ( vk , dτ ( vk , s ) ) 6∈ Mτ −1(s ) , then PrefixalQuery(vk , s , Mτ −1 , k ) = d′ τ −1(vk , s , k ) , which contradicts to the prefixal correctness of Mτ −1 . Therefore , ( vk , dτ ( vk , s ) ) ∈ Mτ −1(s ) ⊆ Mτ ( s ) holds .
τ −1(vk , s , k − 1 ) > d′
τ −1(vk , s , k−1 ) > d′
Otherwise , we can assume dτ ( vk , s ) < dτ −1(vk , s ) . As δ′ < d′ τ ( s , t , k − 1 ) , none of the shortest paths from vk to s goes through the vertex vi for any i < k , and thus dτ ( vk , s ) < d′ τ ( vk , s , k−1 ) . From Lemma 4.4 , ( vk , dτ ( vk , s ) ) ∈ Mτ ( s ) .
Corollary 41 Let M1 be the index constructed by the offline indexing algorithm for graph G1 . For 2 ≤ i ≤ τ , let Mi be the index updated by Algorithm 2 from Mi−1 for the edge addition to make Gi from Gi−1 . Then , the index Mτ is a correct 2 hop index for Gτ .
Moreover , the sufficient condition for a pair to be added shown in Lemma 4.4 is actually also a necessary condition . Therefore , the minimality of newly added pairs is derived .
Theorem 43 The label entries added by the update algorithm are minimal . That is , for any vertex u and any pair in Mτ ( u)\Mτ −1(u ) , if we remove the pair from Mτ ( u ) , then Mτ becomes an incorrect 2 hop index for Gτ .
Bit parallel labeling .
As with static pruned landmark labeling , the dynamic method can be combined with bit parallel labeling [ 4 ] to further improve the performance . Due to the space limit , we omit the details , but bit parallel labels can be also updated incrementally . For each root r , we resume the BFS from one of the endpoints of the new edge . The main difference is that , for any visited vertex v , even if d(r , v ) has not changed , we push v to the queue if the associated bitsets are changed .
5 . HISTORICAL QUERIES
In this section , we propose a new indexing scheme referred to as historical pruned landmark labeling to efficiently process historical queries defined in Section 3 . Unlike our first method for contemporary queries , as there is no previous work on these queries , we start from designing a new index framework ( ie , data structure and query algorithms ) , named historical 2 hop cover , in Section 51 Then , we propose an offline indexing algorithm that constructs an index from a stored historical graph in Section 52 Since it is more involved than that for contemporary queries , we explain our indexing algorithm with three steps : we start from an algorithm based on dynamic programming , next we turn the algorithm into a BFS like algorithm , and then introduce pruning to the algorithm . Finally , we present an online incremental update algorithm for online graph changes in Section 53
5.1 Historical 2 Hop Cover Framework
First , we propose a new indexing framework ( ie , data structure and query algorithms ) referred to as the historical 2 hop cover framework . Since there is no previous work on these queries , it is the first framework for historical distance queries . The main technical challenge here is to design ( almost ) linear time query algorithms for both kinds of historical queries .
511 Data Structure
For each vertex v , we store a label L(v ) . Label L(v ) is a set of triples ( u , τ , δuv ) , where u is a vertex , τ describes time , and δuv = dτ ( u , v ) . Due to Lemma 3.1 , ( u , τ , δuv ) ∈ L(v ) also indicates dτ ′ ( u , v ) ≤ δuv for τ ′ ≥ τ .
As with the normal 2 hop cover framework , we store triples in a label in the ascending order of the IDs of destination vertices . In addition , we sort triples that share the same destination vertex in ascending order of distance ( ie descending order of time ) .
512 Answering Snapshot Queries
A snapshot query between a pair of vertices s and t at time τ can be answered in O(|L(s)| + |L(t)| ) time . Though we basically conduct a merge sort like algorithm as with normal 2 hop cover , there are several differences . First , we need to ignore label entries with time later than τ . In addition , to handle triples in a label that share the same destination vertex , among them we only see the newest label entry with time earlier than or equal to τ . That is , if ( ui , τi , δi ) and ( ui+1 , τi+1 , δi+1 ) are consecutive labels in L(s ) where ui = ui+1 and τ ≥ τi > τi+1 , then we ignore the second label since δi ≤ δi+1 from Lemma 31
242 513 Answering Change point Queries
Answering a change point query between vertices s and t is a little more involved , but can be done in O(l log l ) time , where l = |L(s)| + |L(t)| . First , we conduct a merge sortlike algorithm to enumerate candidates of distance changepoints . From pairs of triples ( u , τs , δs ) ∈ L(s ) and ( u , τt , δt ) ∈ L(t ) , we enumerate pairs ( τ , δ ) = ( max {τs , τt} , δs + δt ) , which indicates dτ ( s , t ) ≤ δ . Then , we sort these pairs by time τ . Finally , we remove unnecessary pairs . That is , if ( τi , δi ) and ( τi+1 , δi+1 ) are consecutive pairs , where τi ≤ τi+1 and δi ≤ δi+1 , then we remove the second pair .
Again , the remaining issue is to handle triples in a label that share the same destination vertex . If we check every pair of these triples , in the worst case , it would take quadratic time . However , for these triples , we can also apply a merge sort like scan algorithm by considering time of these triples . In total , the first step and the final step can be done in linear time , and the time complexity is dominated by sorting .
5.2 Offline Indexing Algorithm
For presenting the indexing algorithm for contemporary queries , we first described a naive labeling algorithm without pruning , then we introduced pruning to present the indexing algorithm . However , designing an algorithm for historical queries is more challenging since , while the naive labeling algorithm was obvious for contemporary queries , this time , even the naive labeling algorithm without pruning is not trivial for historical 2 hop cover . Therefore , we explain our indexing algorithm with three steps : we start from an algorithm based on dynamic programming , next we turn the algorithm into a BFS like algorithm , and finally introduce pruning to the algorithm to obtain our indexing algorithm .
521 Dynamic Programming
As usual , we start from an empty index L0 and construct index Lk from Lk−1 by adding triples whose destination vertex is vk . Let D be the maximum distance to a connected vertex from vk regarding all the snapshots . Let T be a ( D + 1 ) × |V | table . We conduct dynamic programming on the table T so that each cell T [ δ][u ] denotes the earliest time τ with dτ ( vk , u ) ≤ δ . First , we fill the cells with distance zero as T [ 0][vk ] = 0 and T [ 0][u ] = ∞ for any u 6= vk . Then , we compute the values of cells with distance δ > 0 from smaller δ by the following recurrence relation :
T [ δ][u ] = min w∈N ( u )
{max {T [ δ − 1][w ] , t(w , u)}} , for any u 6= vk and T [ δ][vk ] = 0 .
Lemma 51 Each cell T [ δ][u ] denotes the earliest time τ with dτ ( vk , u ) ≤ δ .
This lemma can be proved by mathematical induction on δ . After computing the table , we add triple ( vk , δ , τ ) to label Lk(u ) where τ = T [ δ][u ] if T [ δ][u ] 6= ∞ and δ = 0 or T [ δ][u ] < T [ δ − 1][u ] .
522 Historical Naive Landmark Labeling
While the algorithm above computes the correct index , it takes Θ(D |E| ) time and Θ(D |V | ) space . In this subsection , we reduce the time and space complexity by skipping unnecessary computations . Again , we suppose we are to construct index Lk from Lk−1 by adding triples whose destination vertex is vk . k[v ] ← L′
Q′ ← an empty queue . for all u ∈ Q do continue k−1 ) k−1[v ] for all v ∈ V ( G ) .
L′ Q ← a queue with only one element vk . T [ vk ] ← 0 and T [ v ] ← ∞ for all v ∈ V ( G ) \ {vk} . T ′[v ] ← ∞ for all v ∈ V ( G ) . for all δ = 0 , 1 , . . . until Q gets empty do
Algorithm 3 Pruned BFS from vk ∈ V to create index L′ k for historical queries . 1 : procedure PrunedBFS(G , vk , L′ 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : 10 : 11 : 12 : 13 : 14 : 15 : 16 : 17 : 18 : 19 : 20 :
T [ u ] ← T ′[u ] , T ′[u ] ← ∞ for all u ∈ Q′ . Q ← Q′ .
τ ′ = max {T [ u ] , t(u , w)} if τ ′ < T ′[w ] and τ ′ < T [ w ] then k[u ] ← L′
L′ for all w ∈ NG(v ) do k[u ] ∪ {(vk , T [ u ] , δ)} if QuerySnapshot(vk , u , T [ u ] , L′ k−1 ) ≤ δ then if T ′[w ] = ∞ then
Enqueue w onto Q′ .
T ′[w ] ← τ ′ . return L′ k
The key insight here is the following simple fact . For simplicity , we define T [ −1][u ] = ∞ for any vertex u in the following . For any vertex u and δ ≥ 0 , if T [ δ−1][w ] = T [ δ][w ] for all w ∈ N ( u ) , then T [ δ + 1][u ] = T [ δ][u ] . Therefore , we avoid vainly computing values of such cells as follows . For each distance δ ≥ 0 and vertex u , we initially set T [ δ+1][u ] = T [ δ][u ] . Then , we only check edges ( w , u ) incident to vertex w with T [ δ − 1][w ] 6= T [ δ][w ] , and update T [ δ + 1][u ] by max {T [ δ][w ] , t(w , u)} if it is smaller than the current value . This can be efficiently achieved by managing vertices with queues .
However , even using queues , it still takes Ω(D |V | ) time and Θ(D |V | ) space due to the two dimensional table . Thus , instead of straightforwardly using a two dimensional table , we use two one dimensional arrays with length O(|V | ) , and avoid full initialization for each distance δ . Consequently , conducting queue based dynamic programming and avoiding Θ(|V | ) time initialization for each step , the total time complexity becomes O(m′ ) , where m′ is the number of traversed edges including duplications . Also note that , by using queues , we do not need to obtain the maximum distance D beforehand , as it suffices to stop when the queues get empty .
523 Historical Pruned Landmark Labeling
We finally introduce pruning to the previous algorithm to obtain our indexing algorithm . Suppose we have started 0 and we are constructing index L′ with an empty index L′ k from L′ k−1 and the result of the k th pruned BFS from vk . Along with the labeling algorithm for contemporary queries , after drawing vertex u from the queue Q , we issue a query between vk and u , and if the distance is at most δ , we prune vertex u . The difference from the algorithm for contemporary queries here is that we issue a snapshot query with regard to time T0[u ] . The total algorithm is described as Algorithm 3 .
The correctness of this algorithm is not obvious , but can be proved as the almost same way as the correctness of the pruned landmark labeling algorithm for contemporary queries .
243 Table 2 : Comparing our dynamic method ( Dynamic PLL ) with other static state of the art methods with regard to indexing time ( IT ) , index size ( IS ) and query time ( QT ) . LN denotes average label size for each vertex . DNF means it did not finish in one day or ran out of memory .
Dataset
Epinions Enron P2P YouTube Wikipedia DMS ForestFire
IT 4.0 s 1.9 s 334.6 s 163.5 s 774.3 s 204.5 s 158.7 s
Dynamic PLL
IS
QT 55 MB 0.6 µs 29 MB 0.4 µs 3.3 GB 6.4 µs 2.1 GB 1.2 µs 2.7 GB 3.0 µs 1.1 GB 1.9 µs 1.6 GB 2.9 µs
LN 40.1 15.0 769.9 104.8 317.6 218.4 345.7
IT 49.4 s 62.5 s 1997.8 s 1217.5 s 14010.9 s 3912.1 s 282.7 s
IS Label [ 15 ] IS QT 14.2 MB 0.4 ms 306.5 MB 0.1 ms 230.9 MB 1.0 ms 230.6 MB 16.6 ms 8.9 ms 727.4 MB 571.3 MB 1.8 ms 131.8 MB 26.9 ms
Tree Decomposition [ 5 ]
IT 333.5 s 43.2 s DNF DNF DNF DNF DNF
IS
QT 75.0 MB 8.5 µs 23.1 MB 8.1 µs
BFS
9.8 ms 7.8 ms 140.3 ms 338.4 ms 551.5 ms 176.8 ms 159.7 ms
Dataset
|V |
Table 1 : Datasets
132 K 831 K Epinions 87 K 1.1 M Enron 1.1 M 6.3 M P2P 3.2 M 9.4 M YouTube 1.9 M 36.5 M Wikipedia 1.0 M 10.5 M DMS ForestFire 1.0 M 7.6 M
|E| Snapshots Avg . deg Max . deg 3.6 K 38.8 K 4.3 K 91.8 K 226.1 K 63.3 K 26.8 K
421 K 574 K 3.1 M 4.7 M 18.3 M 5.2 M 3.8 M
12.8 26.3 11.9 5.8 38.6 20.0 14.6
Theorem 51 For any pair of vertices s , t and i , τ ≥ 0 , i ) .
QuerySnapshot(s , t , τ , Li ) = QuerySnapshot(s , t , τ , L′
Corollary 51 For any pair of vertices s and t and τ ≥
0 , QuerySnapshot(s , t , τ , L′ n ) = dτ ( s , t ) .
Corollary 52 For any pair of vertices s and t , ( τ , δ ) ∈ n ) if and only if dτi−1(s , t ) 6=
QueryChangePoints(s , t , L′ dτi ( s , t ) = δ .
By the same discussion as Section 422 the time complexity is estimated as O(nl(d+l ) ) time . As with the method for contemporary queries , to exploit central vertices , we order vertices from those with higher degree in the final snapshot .
Note on weighted graphs : For handling weighted graphs , the algorithm can be applied by simply using a priority queue instead of a normal queue . We push triple ( v , δ , τ ) to the priority queue if v is reachable by distance δ at time τ . We pop the triple with the smallest distance to compute labels and traverse edges .
5.3 Online Incremental Update Algorithm
Incrementally updating the index to reflect graph changes can be done in the almost same way as Section 43 For a newly added vertex , we just prepare a new empty label , and for a newly added edge , we resume pruned BFSs from the endpoints . The time complexity is also the same .
6 . EXPERIMENTAL EVALUATION
6.1 Setup
We conducted experiments on a Linux server with Intel Xeon X5670 and 48GB of main memory . The proposed methods were implemented in C++ . Only indexing was parallelized to use the six cores , and all the other timing results are sequential . We use 32 bits for each pair in an index for contemporary queries ( 8 bits for distance and 24 bits for vertex IDs ) and 64 bits for each triple in that for historical queries ( additional 32 bits represent time ) .
To show the efficiency and robustness of our method , we conducted experiments on large scale real world and synthetic dynamic networks . For some of the datasets with coarse grind timestamps , we randomly determined the order of insertions of edges with the same timestamps . Moreover , to avoid startup effects , we assume the first half of the edges exist from the beginning . We treated all the graphs as undirected graphs . Statistics of the datasets are given in Table 1 . The detailed description of each dataset is as follows .
Real time evolving networks : Epinions [ 20 ] is the online social network in Epinions ( wwwepinionscom ) ; Enron [ 18 ] is an e mail network among employees of Enron between 1999 and 2003 ; P2P [ 2 ] is a graph constructed from a log of an eDonkey server where vertices describe users and a link between two users appears when one provided a file to the other ; YouTube [ 21 ] is the online social network among users of YouTube ( wwwyoutubecom ) crawled daily in 2007 ; Wikipedia [ 21 ] is a web graph between English Wikipedia pages ( enwikipediaorg ) constructed from edit history .
Synthetic time evolving networks : DMS is a synthetic graph constructed under the Dorogovtsev Mendes Samukhin model [ 14 ] , which is a simple growth model based on preferential attachment that exhibits power law degree distribution ; ForestFire is a graph generated by the forest fire model [ 19 ] , which exhibits not only standard static properties but also common properties on dynamic networks like densification power laws and shrinking diameter . For the DMS network , we set the power law exponent as around 23 We generated the ForestFire network by Stanford Network Analysis Platform with the default parameters .
In both experiments for contemporary queries and historical queries , we conducted the experiments as follows . ( 1 ) We first construct an index from a graph with all the edges except last 10,000 edges by the offline indexing algorithm . ( 2 ) Then , we measure average update time by inserting the last 10,000 edges . ( 3 ) Finally , we measure the average query time with 1,000,000 random queries after reflecting all the dynamic updates . As a baseline , the average time of BFSs for 1,000 random pairs is also reported . Justification of this configuration is discussed in Section 9 .
6.2 Contemporary Queries
In this subsection , we evaluate our first method for contemporary queries ( Table 2 ) . As there are no previous dynamic exact methods for contemporary queries , we compare the proposed method with two state of the art static exact methods : a tree decomposition based method [ 5 ] and ISLabel [ 15 ] ( introduced in Section 2 ) .
244 Table 4 : Experimental results of our method for historical queries against real world and synthetic networks .
Dataset Dataset
Epinions Enron P2P YouTube Wikipedia DMS Forestfire
Indexing time 23.1 s 5.4 s 2596.4 s 1281.8 s 5165.9 s 920.0 s 1056.3 s
Index size 236 MB 86 MB 9.7 GB 9.1 GB 13.0 GB 3.8 GB 6.5 GB
Historical Pruned Landmark Labeling Snapshot Change point Update time 0.3 ms 0.2 ms 10.7 ms 2.1 ms 8.3 ms 1.0 ms 3.9 ms query time 4.6 µs 3.0 µs 22.0 µs 8.1 µs 12.7 µs 5.6 µs 12.8 µs query time 2.7 µs 1.6 µs 12.4 µs 4.5 µs 9.8 µs 4.0 µs 8.2 µs
Label size 234.2 128.5 1227.9 374.7 919.5 481.1 835.9
Label increase 2.6 × 10−4 4.0 × 10−4 2.7 × 10−4 4.0 × 10−5 3.0 × 10−5 8.6 × 10−5 3.6 × 10−4
BFS
Snapshot Change point query time 2593 s 3041 s > 1day > 1day > 1day > 1day > 1day query time 6.2 ms 5.3 ms 79.5 ms 177.5 ms 413.3 ms 126.4 ms 91.4 ms
Table 3 : Experimental results of our online update algorithm for contemporary queries .
Dataset
Epinions Enron P2P YouTube Wikipedia DMS ForestFire
Update time 0.2 ms 0.5 ms 4.0 ms 4.3 ms 6.1 ms 1.9 ms 2.6 ms
Label Visited vertices 5.7 4.6 2.9 11.4 5.4 8.2 9.8 increase 1.0 × 10−4 3.2 × 10−4 1.5 × 10−4 1.6 × 10−4 4.0 × 10−5 1.8 × 10−4 3.7 × 10−4
621 Indexing Time , Index Size and Label Size
We first confirm the high scalability of our method from the results on indexing time , index size and average label size ( Table 2 ) . We set the number of times we conduct bitparallel BFSs as 16 . The results indicate the competitive scalability of the proposed method in comparison even with static state of the art methods .
622 Query Time
Then , we study the average query time reported in Table 2 . It shows that the query time of our method is generally microseconds . It is several orders of magnitude faster than BFSs and competitive with other static methods , indicating applicability to query intensive applications such as network sensitive search . In particular , the query time of the proposed method is thousands times faster than ISLabel . This is because the query algorithm visits only two consecutive regions ( ie , two labels ) in the main memory for each query .
623 Update Time and Label Increase
We observe that the average update time is generally milliseconds ( Table 3 ) , which is four or five orders of magnitude faster than full index reconstruction and sufficiently fast for real time processing . Average label increase in Table 3 describes the average difference of the average label size before and after inserting an edge . As the average label increase is also small , we confirm that the label size grows slowly . Table 3 also lists the average number of vertices visited during each BFS for dynamic index updates . More precisely , we define that a vertex is visited if it is inserted in the queue . It shows the numbers of visited vertices are very small , that is , the dynamic update is certainly done quite locally .
6.3 Historical Queries
631
Indexing Time , Index Size and Label Size
Indexing time , index size and average label size are shown in Table 4 . Although indexing time and index size are a little larger than those for contemporary queries , they are still acceptable even for large dynamic networks . For example , it took only two hours for constructing an index from the Wikipedia dataset . Also note that , since our method can incrementally update an index , we do not need to reconstruct an index frequently . The index size was 13 GB , which adequately fits in the main memory of commodity computers of the day .
632 Query Time
Average query time is also reported in Table 4 . As a baseline for change point queries , we suppose a naive method that conducts a BFS for each snapshot . Since this baseline method takes too long query time , we estimated the average query time by the product of the average snapshotquery time and the number of snapshots . For both snapshot queries and change point queries , the query time of our method for historical queries is also generally microseconds and orders of magnitude faster than the baselines .
633 Update Time and Label Increase
Average update time is also listed in Table 4 . As with the method for contemporary queries , this method for historical queries also handles each update in milliseconds . Moreover , as average label increase in Table 4 is small , we can confirm that the label size grows slowly .
7 . EXTENSIONS Shortest path queries : To efficiently answer not only distance but also the shortest path , we store parents of label entries in BFS trees , and ascend the trees from the two endpoints to restore the path . If the index size is more critical than the query time , then another way to answer the shortest path is to repeatedly move to a vertex that has smaller distance from one endpoint to the other endpoint by using distance queries .
Directed graphs : If the input graph is a directed graph , we store and maintain two labels LIN(v ) and LOUT(v ) for each vertex v , where LIN(v ) contains distances from v and LOUT(v ) contains distances to v . To construct or update an index , we conduct pruned BFSs twice from each vertex in the forward and reverse directions .
Second , we present experimental results on our second method for historical queries ( Table 4 ) . This time , since there are no previous methods for historical distance queries , the proposed method is not compared with other methods .
Weighted graphs : To handle weighted graphs , for both indexing and updating , we conduct or resume pruned Dijkstra ’s algorithm instead of pruned BFSs . As for edge weight update , our methods can only handle weight decrease .
245 e c n a i t s d e g a r e v A
6
5.5
5
4.5
4
3.5
3
2.5
2
14
12
8
6
4
Enron Epinions P2P
YouTube Wikipedia DMS
Snapshot
Forestfire f f
E
10 i t r e e m a d e v i t c e
Enron Epinions P2P
YouTube Wikipedia DMS
Forestfire e l i t n e c r e P
1
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
1 2 3 4 5 6 7 8 9
1
0.8 e l i t n e c r e P
0.6
0.4
0.2
0
1 2 3 4 5 6 7
Snapshot
Snapshot
Snapshot
( a ) Average distance
( b ) Effective diameter
( a ) YouTube
( b ) Wikipedia
Figure 3 : Transition of average distance and effective diameter .
Figure 5 : Temporal hop plot . y t i l a r t n e C s s e n e s o C l
0.1
0.095
0.09
0.085
0.08
0.075
0.07
0.065
0.06 y t i l a r t n e C s s e n e s o C l
0.13
0.12
0.11
0.1
0.09
0.08
0.07
0.06
Snapshot
( a ) Enron
Snapshot
( b ) Epinions
Figure 4 : Transition of the closeness centrality of some popular vertices .
8 . APPLICATION TO EVOLVING NETWORK
ANALYSIS
In this section , we demonstrate the usefulness of our historical indexing method for evolving network analysis . The proposed method enables quick and fine grind temporal analysis of large scale dynamic networks . For example , with our index , users can instantly and interactively check the transition of various features related to distances , which has never been available at all without our index .
As shown by the case study in Section 1.2 , transitions of distance and shortest path themselves are useful and of interest . Furthermore , based on our method , we can also efficiently compute the transition of the following kinds of network features .
Average distance and effective diameter : Distance distribution is one of the most important features of networks , and the transition of distance distribution of dynamic networks is of strong interest to the data mining and social network analysis community [ 19 ] . Though calculating distance distribution of one graph is already too costly , to obtain the transition of it , we need to do so for many snapshots of graphs , which would be impossible for large historical networks . Using our historical indexing method , however , we can estimate the transition just by evaluating random change point queries with regard to a set of randomly sampled pairs of vertices . To demonstrate the effectiveness of our method , we computed the transition of the average distance between pairs and the effective diameter ( the 90th percentile distance ) of various networks ( Figure 3 ) . We can observe that average distance decreases over time , which confirms the claim of [ 19 ] , but the effective diameter sometimes increases .
Closeness centrality : Closeness centrality is one of the most popular network centralities defined on vertices . There are several different definitions , but all of them are based on distances to other vertices , and thus they can be efficiently estimated by random change point queries . Here , we adopt the definition that defines the closeness centrality of ver|V | Pu∈V 2−d(v,u ) . We picked up several vertices tex v as of high closeness centralities from Enron and Epinions and
1 computed the transition of their closeness centralities by the proposed method ( Figure 4 ) . We can see that the closeness centrality sometimes drastically increases as some moment .
Hop Plot : To study distance distribution in depth , the ( temporal ) hop plot , which is the transition of the fraction of pairs within a fixed distance , is also used . We can approximate the hop plot by evaluating change point queries with regard to a set of randomly sampled pairs of vertices . In Figure 5 , we illustrate the hop plot of YouTube and Wikipedia for various distances . We observe that it tends to increase over time , as expected from the fact that average distance decreases over time .
9 . DISCUSSION ON PRACTICABILITY FOR
NETWORK AWARE SERVICES
In this section , we argue that supporting no removals does not limit applicability of the proposed methods , and rather , it is a more promising approach than seeking for fully dynamic methods .
First of all , we emphasize again that all the existing methods are static . Thus , we were only able to handle edge updates by reconstructing the index from scratch . Since it can be only done periodically ( say , once per day ) , we have to wait for a long time to reflect edge updates . With our index , however , we can instantly reflect edge additions .
Having said that , when handling edge updates , it is inevitable to fully reconstruct the index periodically since we often want to exploit the global information of the current graph such as centrality or clustering . Thus , a practical way to handle edge updates is a combination of periodic index reconstruction and incremental index update , and our method enables this combination for the first time . We note that edge removals are reflected when reconstructing the index while edge additions are reflected immediately .
We also mention that fully dynamic methods that supporting edge removals would be too complicated and impractical at all . As a realistic compromise , we have focused only on edge additions and have established a method that has a competitive performance .
10 . ACKNOWLEDGEMENTS
This work is supported by Grant in Aid for JSPS Fellows ( 256563 and 256487 ) , JSPS Grant in Aid for Research Activity Start up ( 24800082 ) , MEXT Grant in Aid for Scientific Research on Innovative Areas ( 24106003 ) , and JST , ERATO , Kawarabayashi Large Graph Project .
246 11 . REFERENCES [ 1 ] I . Abraham , D . Delling , A . V . Goldberg , and R . F .
Werneck . Hierarchical hub labelings for shortest paths . In ESA , pages 24–35 . 2012 .
[ 2 ] F . Aidouni , M . Latapy , and C . Magnien . Ten weeks in the life of an edonkey server . In IPDPS , pages 1–5 , 2009 .
[ 3 ] T . Akiba , Y . Iwata , K . Kawarabayashi , and
Y . Kawata . Fast shortest path distance queries on road networks by pruned highway labeling . In ALENEX , pages 147–154 , 2014 .
[ 4 ] T . Akiba , Y . Iwata , and Y . Yoshida . Fast exact shortest path distance queries on large networks by pruned landmark labeling . In SIGMOD , pages 349–360 , 2013 .
[ 5 ] T . Akiba , C . Sommer , and K . Kawarabayashi .
Shortest path queries for complex networks : exploiting low tree width outside the core . In EDBT , pages 144–155 , 2012 .
[ 6 ] L . Backstrom , D . Huttenlocher , J . Kleinberg , and X . Lan . Group formation in large social networks : membership , growth , and evolution . In KDD , pages 44–54 , 2006 .
[ 7 ] A L Barabasi . The origin of bursts and heavy tails in human dynamics . Nature , 435:207–211 , 2005 .
[ 8 ] A L Barab´asi and R . Albert . Emergence of scaling in random networks . Science , 286(5439):509–512 , 1999 . [ 9 ] S . Boccaletti , V . Latora , Y . Moreno , M . Chavez , and
D . Hwang . Complex networks : Structure and dynamics . Physics reports , 424(4 5):175–308 , 2006 .
[ 10 ] D . S . Callaway , M . E . J . Newman , S . H . Strogatz , and
D . J . Watts . Network robustness and fragility : Percolation on random graphs . Physical Review Letters , 85:5468–5471 , 2000 .
[ 11 ] J . Cheng and J . X . Yu . On line exact shortest distance query processing . In EDBT , pages 481–492 , 2009 . [ 12 ] E . Cohen , E . Halperin , H . Kaplan , and U . Zwick .
Reachability and distance queries via 2 hop labels . In SODA , pages 937–946 , 2002 .
[ 13 ] A . Das Sarma , S . Gollapudi , M . Najork , and
R . Panigrahy . A sketch based distance oracle for web scale graphs . In WSDM , 2010 .
[ 14 ] S . N . Dorogovtsev , J . F . F . Mendes , and A . N . Samukhin . Structure of growing networks with preferential linking . Phys . Rev . Lett . , 85:4633–4636 , 2000 .
[ 15 ] A . W C Fu , H . Wu , J . Cheng , S . Chu , and R . C W
Wong . Is label : an independent set based labeling scheme for point to point distance querying on large graphs . PVLDB , 6(6):457–468 , 2013 .
[ 16 ] R . Jin , N . Ruan , Y . Xiang , and V . Lee . A highway centric labeling approach for answering distance queries on large sparse graphs . In SIGMOD , pages 445–456 , 2012 .
[ 17 ] D . Kempe , J . Kleinberg , and E . Tardos . Maximizing the spread of influence through a social network . In KDD , pages 137–146 , 2003 .
[ 18 ] B . Klimt and Y . Yang . The enron corpus : A new dataset for email classification research . In ECML , volume 3201 of LNCS , pages 217–226 . 2004 .
[ 19 ] J . Leskovec , J . Kleinberg , and C . Faloutsos . Graph evolution : Densification and shrinking diameters . TKDD , 1(1 ) , 2007 .
[ 20 ] P . Massa and P . Avesani . Controversial users demand local trust metrics : an experimental study on epinions.com community . In AAAI , pages 121–126 , 2005 .
[ 21 ] A . Mislove . Online Social Networks : Measurement ,
Analysis , and Applications to Distributed Information Systems . PhD thesis , Rice University , 2009 .
[ 22 ] M . E . J . Newman , S . H . Strogatz , and D . J . Watts . Random graphs with arbitrary degree distributions and their applications . Physical Review E , 64(2):026118 1–17 , 2001 .
[ 23 ] R . Pastor Satorras and A . Vespignani . Evolution and structure of the Internet : A statistical physics approach . Cambridge University Press , 2004 .
[ 24 ] M . Potamias , F . Bonchi , C . Castillo , and A . Gionis .
Fast shortest path distance estimation in large networks . In CIKM , pages 867–876 , 2009 .
[ 25 ] M . Qiao , H . Cheng , L . Chang , and J . X . Yu . Approximate shortest distance computing : A query dependent local landmark scheme . In ICDE , pages 462–473 , 2012 .
[ 26 ] S . A . Rahman , P . Advani , R . Schunk , R . Schrader , and D . Schomburg . Metabolic pathway analysis web service ( pathway hunter tool at cubic ) . Bioinformatics , 21(7):1189–1193 , 2005 .
[ 27 ] S . A . Rahman and D . Schomburg . Observing local and global properties of metabolic pathways : ‘load points’ and ‘choke points’ in the metabolic networks . Bioinformatics , 22(14):1767–1774 , 2006 .
[ 28 ] N . Robertson and P . D . Seymour . Graph minors . III .
Planar tree width . J . Comb . Theory , Ser . B , 36(1):49–64 , 1984 .
[ 29 ] L . Tang and M . Crovella . Virtual landmarks for the internet . In SIGCOMM , pages 143–152 , 2003 .
[ 30 ] K . Tretyakov , A . Armas Cervantes ,
L . Garc´ıa Ba˜nuelos , J . Vilo , and M . Dumas . Fast fully dynamic landmark based estimation of shortest path distances in very large graphs . In CIKM , pages 1785–1794 , 2011 .
[ 31 ] A . Ukkonen , C . Castillo , D . Donato , and A . Gionis .
Searching the wikipedia with contextual information . In CIKM , pages 1351–1352 , 2008 .
[ 32 ] M . V . Vieira , B . M . Fonseca , R . Damazio , P . B .
Golgher , D . d . C . Reis , and B . Ribeiro Neto . Efficient search ranking in social networks . In CIKM , pages 563–572 , 2007 .
[ 33 ] B . Viswanath , A . Mislove , M . Cha , and K . P .
Gummadi . On the evolution of user interaction in facebook . In WOSN , pages 37–42 , 2009 .
[ 34 ] F . Wei . Tedi : efficient shortest path query answering on graphs . In SIGMOD , pages 99–110 , 2010 .
[ 35 ] S . A . Yahia , M . Benedikt , L . V . S . Lakshmanan , and
J . Stoyanovich . Efficient network aware search in collaborative tagging sites . PVLDB , 1(1):710–721 , 2008 .
[ 36 ] Y . Yano , T . Akiba , Y . Iwata , and Y . Yoshida . Fast and scalable reachability queries on graphs by pruned labeling with landmarks and paths . In CIKM , pages 1601–1606 , 2013 .
247
