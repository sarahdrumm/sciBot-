Answering Provenance Aware Regular Path Queries on
RDF Graphs Using an Automata Based Algorithm
Xin Wang†‡ , Jun Ling†‡ , Junhu Wang§ , Kewen Wang§ , Zhiyong Feng†‡ †School of Computer Science and Technology , Tianjin University , Tianjin , China ‡Tianjin Key Laboratory of Cognitive Computing and Application , Tianjin , China
§School of Information and Communication Technology , Griffith University , Australia
{wangx , lingjun}@tjueducn , {j.wang , kwang}@griffitheduau , zyfeng@tjueducn
ABSTRACT This paper presents an automata based algorithm for answering the provenance aware regular path queries ( RPQs ) over RDF graphs on the Semantic Web . The provenanceaware RPQs can explain why pairs of nodes in the classical semantics appear in the result of an RPQ . We implement a parallel version of the automata based algorithm using the Pregel framework Giraph to efficiently evaluate provenanceaware RPQs on large RDF graphs . The experimental results show that our algorithms are effective and efficient to answer provenance aware RPQs on large real world RDF graphs .
Categories and Subject Descriptors H24 [ Database Management ] : Systems
Keywords Automata ; provenance aware ; RDF ; regular path queries
1 .
INTRODUCTION
RDF is a graph based data model for describing things and their relationships on the Semantic Web . Regular path queries , or RPQs , are widely considered an essential querying mechanism for large RDF graphs . The classical semantics of an RPQ Q over a graph G is a set of pairs ( u , v ) of end points of paths in G that satisfies Q , however , such a semantics provides no clue as to why a pair of nodes satisfies Q . For example , the RPQ ?u ( part_of/part_of)+|(part_of/is_a)+ ?v asks for pairs of terms ( u , v ) such that u can reach v through an even number of part_of relations or an alternating sequence of part_of and is_a relations over the biological dataset GO . For u = GO:0044333 , the answers ( ie , the set of v ) to this RPQ are listed in the table shown in Figure 1(a ) , from which one cannot know how each term is reached from GO:0044333 at all . In contrast , the graph shown in Figure 1(b ) is the provenance aware answer to the above RPQ , from which one can easily tell how the terms ( the gray nodes ) can be reached from GO:0044333 ( the black node ) through the paths that satisfy the above RPQ .
To the best of our knowledge , Dey et al [ 1 ] have been the first to investigate the provenance aware semantics of RPQs . Their work resorted to translating provenance aware RPQs into Datalog or SQL implementations . However , from their
Copyright is held by the author/owner(s ) . WWW’14 Companion , April 7–11 , 2014 , Seoul , Korea . ACM 978 1 4503 2745 9/14/04 . http://dxdoiorg/101145/25679482577284
?v
GO:0048565 GO:0044767 GO:0009653 GO:0032502
GO:0044333 part of
GO:0048546
GO:0009653 part of
GO:0032502 is a GO:0048856
GO:0048565 part of is a is a
GO:0044767
( a ) Classical
( b ) Provenance aware
Figure 1 : Two semantics of RPQs experimental results on relatively small graphs of the Nqueens problem , we could see that their approach can be hardly scalable for large real world RDF graphs . In this paper , we also study the provenance aware feature of RPQs . Compared with [ 1 ] , our work makes two contributions : ( 1 ) we present an automata based algorithm that answers the provenance aware RPQs natively , and ( 2 ) we parallelize our automata based algorithm using the Pregel framework Giraph [ 3 ] to efficiently evaluate provenance aware RPQs on large scale real world RDF graphs .
2 . PROBLEM AND OUR APPROACH
An RDF graph T is a set of triples , each triple ( s , p , o ) representing a statement of a predicate p between a subject s and an object o . We use subj(T ) , pred(T ) , and obj(T ) to denote the set of subjects , predicates and objects in T respectively . More formally , an RDF graph T can be modeled as a directed labeled graph G = ( V , E , l ) , where the node set V = {v | v ∈ subj(T ) ∪ obj(T )} , the edge set E ⊆ V × V , and l : E → pred(T ) is a function that assigns a label to each edge . For each ( s , p , o ) ∈ T , there exists an edge e = ( s , o ) ∈ E and l(e ) = p . A path in G from node x to y is a sequence ρ = v0e0v1 ··· vn−1en−1vn , vi ∈ V , v0 = x , vn = y , and ei = ( vi , vi+1 ) ∈ E . The label of ρ , denoted by λ(ρ ) , is the string l(e0)l(e1)··· l(en−1 ) in Σ∗ , where Σ = pred(T ) . An RPQ over G is of the form ?x r−→?y , where ?x and ?y are variables , and r is a regular expression over the alphabet where p ∈ Σ and / , | , ∗ , and + are concatenation , alternation , Kleene closure , and Kleene plus respectively that have the usual meanings . L(r ) is the language expressed by r . The classical semantics of an RPQ Q over a graph G is dea path ρ in G from node u to v whose label λ(ρ ) is in L(r)} . We use Pr(x , y ) to denote the set of all paths from x to y in G whose labels are in L(r ) . The provenance aware semantics of an RPQ Q over a graph G is a set of graphs ( ie , subgraphs
Σ = pred(T ) , which is defined as r ::= pfifi r/rfifi r|rfifi r∗fifi r+ , fined as a set of pairs of nodes(cid:74)Q(cid:75)G = {(u , v ) | there exists
395 of G ) ( cid:74)Q(cid:75)prov G = {GQ(x , y ) = ( VQ(x , y),EQ(x , y ) ) | ( x , y ) ∈ ( cid:74)Q(cid:75)G} such that VQ(x , y ) = {v | v ∈ ρ ∧ ρ ∈ Pr(x , y)} , and
EQ(x , y ) = {e | e ∈ ρ ∧ ρ ∈ Pr(x , y)} .
Let G = ( V , E , l ) be an RDF graph and A = ( S , Σ , q0 , δ , F ) be the DFA converted from the regular expression r of an RPQ Q . We construct ˆG = ( ˆV , ˆE , l ) from G , where ˆV = V ∪ {ˆv} ( ie , ˆv is a newly added node to V ) , ˆE = E ∪ {ˆe | ˆe = ( ˆv , v ) ∧ v ∈ V } , and l(ˆe ) = ε . Also , we construct ˆA = ( ˆS , ˆΣ , ˆq0 , ˆδ , F ) from A , where ( 1 ) ˆS = S ∪ { ˆq0 , qd} , ( 2 ) ˆΣ = Σ ∪ {ε} , ( 3 ) ˆδ(q , a ) = δ(q , a ) , ˆδ(q , ε ) = qd for q ∈ S ∧ a ∈ Σ , and ( 4 ) ˆδ( ˆq0 , a ) = q0 , ˆδ(qd , a ) = qd for a ∈ ˆΣ . The product automaton of ˆG and ˆA is an NFA 0 , δ , F ) , where S ⊆ ˆV × ˆS , q ˆG × ˆA = ( S , ˆΣ , q 0 = ( ˆv , ˆq0 ) , δ : S × ˆΣ → 2S , and F = {(v , qf ) | v ∈ ˆV ∧ qf ∈ F} . For ( u , s1 ) ∈ S and p ∈ ˆΣ , we have ( v , s2 ) ∈ δ((u , s1 ) , p ) iff ˆδ(s1 , p ) = s2 and e = ( u , v ) ∈ ˆE ∧ l(e ) = p . Algorithm 1 shows the procedure for evaluating a provenance aware RPQ using the above product automaton , in which the function GetResults is used to extract the answers from the product automaton recursively . We have proved that Algorithm 1 can be done in O(| ˆG| · | ˆA| ) time .
// Provenance aware semantics
// F of ˆG × ˆA
// S of ˆG × ˆA
Algorithm 1 Evaluating a provenance aware RPQ Input : A graph G and an RPQ Q Output : GQ = ( VQ,EQ ) 1 : Construct ˆA from Q and ˆG from G 2 : Construct the product automaton ˆG × ˆA 3 : for each ( v , qf ) ∈ F do ( Vt,Et ) ← GetResults( ˆG × ˆA , ( v , qf ) ) 4 : VQ ← VQ ∪ Vt and EQ ← EQ ∪ Et 5 : 6 : end for 7 : function GetResults( ˆG × ˆA , ( v , qf ) ) 8 : 9 : 10 : 11 : 12 : 13 : 14 : 15 : 16 : 17 : 18 : 19 : 20 : end function
Vt ← ∅ and Et ← ∅ if ( v , s ) ∈ S is visited then return ( Vt,Et )
Et ← Et ∪ {(u , v)} ( V Vt ← Vt ∪ V end for Mark ( v , s ) visited return ( Vt,Et ) t,E t ) ← GetResults( ˆG × ˆA , ( u , s ) ) end if Vt ← Vt ∪ {v} for each ( u , s ) such that ( v , s ) ∈ δ((u , s ) , p ) do t and Et ← Et ∪ E t
To efficiently evaluate provenance aware RPQs on largescale RDF graphs , we parallelize Algorithm 1 using the Pregel framework [ 2 ] that is more suitable for large graph processing than MapReduce according to [ 2 ] . In our parallel setting , every node of ˆG computes independently and keeps track of its own data , which include incoming and outgoing nodes , states of ˆA in which the node currently is , and other necessary information . We observe that the construction of the product automaton and the recursive answer extraction can be well parallelized . Due to space limitations , we can only present preliminary experimental results in the next section . 3 . EXPERIMENTS
Our experiments were conducted on a 4 node cluster connected by a gigabit Ethernet switch . Each node has 4 Intel
Figure 2 : Experimental results
Xeon CPUs E5 4607 ( 2.2GHz , 6cores ) , 64GB memory , and 64 bit Ubuntu 12.04 as the OS . We implemented Algorithm 1 in Java on one single node in the cluster and the parallel algorithm using the Giraph [ 3 ] Pregel framework on all 4 cluster nodes . We evaluated two versions of our algorithm over 3 real world RDF graphs , ie , GO ( 86MB , 160775 nodes , 701043 edges ) , BioGRID ( 225MB , 817093 nodes , 2162520 edges ) , and DBpedia ( 3.5GB , 4079463 nodes , 25910645 edges ) . Each graph is explored by three queries : ( 1 ) Q1 ( is_a)+ , Q2 ( part_of)+ , and Q3 ( regulates)+ on GO , ( 2 ) Q4 ( 0407)+ , Q5 ( 0915)+ , and Q6 ( 0915/0407)+ on BioGRID , and ( 3 ) Q7 ( influenced)∗ , Q8 ( successor|child)∗ , and Q9 ( spouse/child)∗ on DBpedia . Figure 2 shows the results of the above queries . We can observe that the parallel version outperforms the single node version for all queries in general . Since the GO graph is relatively small , the performance improvement of the parallel version for GO is not so obvious as for BioGRID and DBpedia .
4 . CONCLUSION
In this paper , we present an automata based algorithm for answering the provenance aware RPQs over RDF graphs , which can provide users the reason why pairs of nodes satisfy a given RPQ . We also implement a parallel version of our automata based algorithm using the Pregel framework Giraph . The preliminary experimental results show that our algorithms can answer the provenance aware RPQs on large scale real world RDF graphs effectively and efficiently . We will perform an experimental comparison between our approach and [ 1 ] in the future full version of this paper .
Acknowledgments . This work is supported by the National Natural Science Foundation of China ( 61100049 ) , the National High tech R&D Program of China ( 863 Program ) ( 2013AA013204 ) , and the Australia Research Council ( ARC ) Discovery grants DP130103051 and DP1093652 .
5 . REFERENCES [ 1 ] S . Dey , V . Cuevas Vicentt´ın , S . K¨ohler , E . Gribkoff ,
M . Wang , and B . Lud¨ascher . On implementing provenance aware regular path queries with relational query engines . In Proceedings of EDBT/ICDT , pages 214–223 . ACM , 2013 .
[ 2 ] G . Malewicz , M . H . Austern , A . J . Bik , J . C . Dehnert ,
I . Horn , N . Leiser , and G . Czajkowski . Pregel : a system for large scale graph processing . In Proceedings of SIGMOD , pages 135–146 . ACM , 2010 .
[ 3 ] The Apache Software Foundation . Apache Giraph . http://giraphapacheorg/ , 2013 .
0 5 10 15 20 25 30 35Q1Q2Q3Q4Q5Q6Q7Q8Q9Execution time ( sec.)QueriesSingle nodeParallel396
