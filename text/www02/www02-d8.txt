XL : An XML Programming Language for Web Service Specification and Composition
Daniela Florescu
XQRL , Inc . , dana@xqrl.com
Andreas Gr¨unhagen
TU M¨unchen , gruenhag@intumde
Donald Kossmann
XQRL , Inc.,TU M¨unchen , kossmann@intumde
Abstract
We present an XML programming language designed for the implementation of Web services . XL is portable and fully compliant with W3C standards such as XQuery , XML Protocol , and XML Schema . One of the key features of XL is that it allows programmers to concentrate on the logic of their application . XL provides high level and declarative constructs for actions which are typically carried out in the implementation of a Web service ; eg , logging , error handling , retry of actions , workload management , events , etc . Issues such as performance tuning ( eg , caching , horizontal partitioning , etc . ) should be carried out automatically by an implementation of the language . This way , the productivity of the programmers , the ability of evolution of the programs , and the chances to achieve good performance are substantially enhanced .
Key words : XML , Web Service , Programming Language
1 Introduction
XML is the lingua franca for data exchange on the Internet . Among its many possible uses , XML based languages are ideal for publishing documents on Web sites , for storing catalogs in electronic market places , and for exchanging data between business processes . Even though some data sources will probably continue to use relational and object relational database systems as a primary form of storage ( at least for a certain time ) , we expect that most data sources will eventually provide XML access for their published data .
Preprint submitted to Elsevier Science
23 March 2003
Since XML based services are provided via Internet , the term “ Web services ” became recently very popular ; however , there is no clear agreed upon definition yet . By a Web service we understand an autonomous piece of software uniquely identified by an URI and that can interact with peer Web services via messages using Internet protocols like XML Protocol [ 26 ] or HTTP . Web services can , but they are not required to , preserve an internal state . In addition , Web services can participate in complex conversations . A conversation is an exchange of correlated messages among a certain number of participant Web services .
1.1 Deficiencies of Web Service Implementations
As a result most Web services are built using classic programming languages , such as Java or Visual Basic , and some kind of SQL based RDBMS ( eg , Oracle or DB2 ) , a mixture of paradigms that inherently implies a number of logically irrelevant but costly and error prone intermediate data transformations . An XML Web application built on such technologies will have to deal with difficulties such as :
( 1 ) XML Java mismatch : XML data must be converted into Java objects ( or the internal representation of another language of the sorts ) before it can be processed by the program . Likewise , Java objects must be converted back into XML data at the end of processing .
( 2 ) Java Database mismatch : Java objects must be marshaled back and forth through JDBC like interfaces to access and update the RDBMS . This is the infamous “ database impedance mismatch ” that triggered the development of object databases technology [ 9 ] .
We believe that the type systems of XML , Java , and relational database systems are simply too different and ultimately incompatible for productively building large scale applications that span across the three different paradigms .
In addition to the double impedance mismatch , programmers face another problem that drastically impacts both the productivity and the performance of Web services . The problem is that , very often , the application tier mixes in a dangerous way , in the same imperative language ( eg , Java ) , very different semantic actions . For example , low level protocols manipulation and performance improvements are often mixed with data validation and real application logic . Furthermore , a WSDL interface must be constructed manually if a language like Java is used because such interface descriptions cannot be extracted automatically .
Furthermore , a WSDL interface must be constructed manually if a language like Java is used because such interface descriptions cannot be extracted automatically .
2
1.2 Our contribution
The alternative that we are pursuing with this paper is to introduce a new high level programming language called XL for the specification of Web services . There are a couple of reasons why we believe that such a language can simplify the above problems . First , we believe that programmers should use a single data representation and type system to program a Web service . For obvious reasons we believe that this unique type system should be based on XML . Moreover , the language should be , as much as possible , declarative and high level . Tuning and optimisation should be carried out automatically , rather than hand coded . Furthermore , the interface description ( ie , WSDL ) should be generated and published automatically using such a language .
1.3 Requirements for a Web Service Programming Language
In the following , a list of more specific requirements that drove the design of XL is given . A comprehensive list is given in [ 14 ] . ( 1 ) High level programming and service composition The language must be high level and use declarative constructs whenever possible . The language must also support high level exception handling and other special constructs to easily implement more complex services like logging , data lineage , time triggered actions , etc . Moreover XL must allow the construction of high level services out of the composition of more basic services which are not necessarily written in XL .
( 2 ) Business processes , Web conversations . The language must provide constructs to implement business processes and , more generally , it must support conversations between two or more Web services .
( 3 ) Unique XML based data model and type system The data manipulated must be modeled by the standard XML data model and type system [ 23 ] . No other data models and type systems are allowed .
( 4 ) Location independent invocation . Web services must be uniquely identified using URIs . The invocation of a Web service must use the respective URI and be independent from the location where its code is stored or executed .
( 5 ) Compliance with the W3C standards . XL must be compliant with the XML W3C standards such as XML Schema [ 25 ] , XQuery [ 23 ] , XPath [ 7 ] , XSLT [ 34 ] , XML Forms [ 32 ] , XML Protocol [ 31 ] , and WSDL [ 6 ] .
The following sections we will try to build up our picture of Web services . Section 2 gives a brief overview of related Web and XML standards . Section 3 explains how Web services are specified in XL . Section 4 gives a brief overview of the basic statements of XL . Section 5 illustrates XL Web services by giving a short example . Section 6 sketches the architecture of our implementation . Sections 7 summarises related work . Section 8 concludes this paper and shows avenues for future work .
3
2 Overview of Relevant Web Technology
2.1 Data Model
The W3C XML data model describes , in an E/R fashion [ 5 ] , a set of entities present in an XML document and a set of relationships among them . The entities describe the data itself ( eg , nodes , values , sequences ) and schema components . The data is modeled as a general mathematical structures , ie , as ordered trees of nodes [ 25 ] . The internal nodes have node identity and they can be of several kinds ( eg , document nodes , element nodes , attribute nodes , comment nodes , processing instruction nodes , namespace nodes and text nodes ) . The leaves of the trees , ie , the values , can be values in the domains of the XML Schema basic types ( eg , integer , decimal , string , duration ) .
2.2 XML expressions and XML queries
A complementary W3C standard , XQuery , deals with XML expressions and XML queries [ 23 ] . XQuery is a functional language . Like all functional languages , XQuery expressions are constructed using first order and second order function . Examples of first order functions are : logical , arithmetic , string manipulation , collection oriented operations like union , intersection , and difference . Examples of second order functions are map and sort . Additionally XQuery includes FLWOR expressions which contain variable bindings ( FORand LET clause ) , predicates ( WHERE clause ) and result construction ( ORDER BY and RETURN clauses ) . FLWOR expressions are the XQuery analogon to SQL ’s SELECT statement . Special expressions called path expressions are used in order to navigate in an XML tree ; the syntax and semantics of path expressions are defined in the XPath standard [ 7 ] . XML queries [ 23 ] are declarative , side effect free programs that manipulate XML data . A query is composed of a preamble containing function definitions , local type declarations , function declarations , XML schema imports , plus a main expression to be evaluated and returned as a result of the execution of the program .
2.3 XML Protocol ( SOAP )
In the context of Web Services , SOAP and the XML Protocol [ 31 ] provide a common XML based message format . A simple but extensible messaging schema for inter process communication is defined . Interface definitions and communication links should be easy to setup and to maintain or evolve . Possible enhancements as for example authentication or session management are foreseen and can be integrated into XML Protocol .
4
2.4 Web Service Description Language ( WSDL )
As mentioned previously , interface description is a crucial part of deploying a Web service . The WSDL working draft [ 6 ] describes the message types , the service interface itself including the message exchange patterns to be used , and the transport protocol bindings . The message exchange patterns include for example synchronous and asynchronous operation calls .
3 Web services in XL
3.1 Design Philosophy
The language XL is designed to provide the missing link between the various XML standards set by the W3C . By combining the type system , expressions and the service interfaces into a single language , XL takes advantage of existing standards without abandoning possible optimisations . In other words , XL extends the existing W3C standards in order to obtain a complete and uniform programming model for Web services .
3.2 Web service declarations
A Web service in XL generalises the notion of an XQuery entity . In addition , a Web service specification in XL is identified by a URI . XL Web services can contain a set of local function declarations plus a set of type definitions and schema and namespace imports . In addition , a Web service specification in XL can contain : ( a ) local data declarations , ( b ) declarative clauses , and ( c ) specifications of the Web service operations . The syntax of XL for Web services is as follows . Here and in the rest of the paper , keywords are denoted in bold face and non terminals are enclosed in angle brackets . Optional parts are denoted in square brackets . Comments are represented in italics . An asterisk is used if a clause can occur 0 or more times . The order in which the individual clauses occur is arbitrary ; the individual clauses are separated by semi colons . service <uri>
< FUNCTIONS & LOCAL OPERATIONS > < LOCAL DECLARATIONS > < DECLARATIVE WEB SERVICE CLAUSES > < PUBLIC OPERATION SPECIFICATIONS > endservice
Functions are defined in XL in exactly the same way as in XQuery . In the following subsections we will describe variable declarations , declarative Web service clauses , and public operation specifications which are specific to XL . The difference between local and public operations is that local operations can
5 only be invoked internally ; ie , only public operations are part of the WSDL description generated for an XL Web service .
321 Variable declarations As in XQuery , a Web service implemented in XL can have local types and imported schema components . In addition , an XL Web service can declare local variables . Such variables hold only XML data and their potential values can be constrained by the XML type system . Two kinds of local variables can be declared in XL . The first kind of variables represents the internal state of the whole Web service . These variables are instantiated once when the Web service is installed and persist the whole life time of the Web service . The scope of these variables is the whole Web service . An example is the warehouse database of an online shop . The second kind of variables represents the internal state of a particular conversation that the Web service is involved in . Examples are the session id when a user logs into the system or the maximum bid for an item in an auctioning system . These variables are instantiated when the Web service joins a new conversation ; in other words , when the Web service receives the first message with a specific conversation URI . We assume here that the SOAP messages which are exchanged between Web services can carry the unique identifier ( URI ) of a conversation in their envelop . This kind of variables can be used in the body of all operations of the Web service that participate in conversations ; ie , all operations that are able to receive messages that carry the URI of a conversation . The life time of such variables is bound by the life time of the conversation . Since the Web service can be involved in several conversations at the same time , multiple instances of such variables can exist at the same time ; one instance of each variable for each conversation . In some sense , the set of all instances of these variables can be thought of as an array that is indexed by the URIs of conversations . In the buy operation of an online shop , for instance , a session id variable will be used in order to determine which customer invoked the buy operation ; the right value ( ie , instance ) of this variable will automatically be set using the conversation URI of the message sent from the customer to the online shop . The syntax for declaring these two kinds of variables is the following : service <uri>
! ! f u n c t i o n d e f i n i t i o n s , l o c a l t y p e s , schema imports
. . . s t a t e o f
! ! ( l e t [ < type>]< variablename> [ := < expression > ] ; )∗ t h e Web s e r v i c e s t a t e o f a c o n v e r s a t i o n o f
! ! ( context l e t [ < type>]< variablename> [ := < expression > ] ; )∗ t h e s e r v i c e
! ! d e c l a r a t i v e Web s e r v i c e s c l a u s e s and o p e r a t i o n s
. . . endservice
6
In this syntax , the “ type ” is an optional type constraining the type of the variable ’s value , while “ expression ” is an XQuery expression describing the initial value of the variable . If no “ expression ” is given , then the variable is initialised to the empty sequence ; if no “ type ” is given then the variable can be bound to any valid instance of the XML data model .
322 Declarative Web service clauses This part contains a set of high level declarations that control the Web services global state , how the Web service operations are executed , and how the Web services interacts with other Web services . In the following , we will briefly describe the individual clauses which are part of the Web service header declaration . The meaning of the individual clauses will become clearer in the discussions and the example given in Section 5 . A more detailed description and a syntax definition is provided in [ 14 ] .
HISTORY If this clause is specified , all calls to operations of the Web service are automatically logged and recorded in an implicitly declared read only $history variable . The data automatically recorded in this variable includes for example the name of the operation that is called , the identifier ( URI ) of the caller , the value of the input and output messages , and the timestamp when the operation was called .
DEFAULT & UNKNOWNOPERATION These clauses declare the Web services behaviour in cases when a message is sent to the Web service and it is unclear which operation should process the message . The DEFAULT operation is executed whenever a message is sent to the service and no operation name is specified as part of the message . The UNKNOWN operation is executed if a message is sent to the server and the caller specifies the name of an operation which is not defined in the Web service .
INIT , CLOSE These clauses specify a pair of operations that are automatically invoked when the Web service is created and destroyed , respectively . These operations can only be invoked once and they take no input .
INVARIANTS In this clause , global Web services integrity constraints ( or invariants ) are defined . A Web service can define an arbitrary number of invariants . Typically , invariants are defined for stateful services and constrain the value of user defined variables . Invariants , however , can also constrain the value of the $history variable and contexts of conversations . If at any time an invariant is violated , the statement that caused the violation is undone , an exception is raised , and the execution of the current operation is stopped if the exception is not handled .
7
ON CHANGE In this clause , a simplified form of triggers can be specified . The semantics are straightforward : if the value of a certain variable changes , the specified operation is called with an empty input . Changes to any variable declared in the Web services local declarations can be monitored in this way .
ON EVENT This clause allows to declare more elaborate triggers and periodic tasks . Whenever a given boolean expression evaluates to true , a specified operation is invoked . If an INPUT is specified , the corresponding expression is evaluated and passed to the operation as input .
ON ERROR INVOKE This optional clause specifies an operation that is called whenever an operation of the Web service fails ; eg , if an INVARIANT is violated . In other words , if an operation raises an exception , this exception is passed as input to the operation specified in the ON ERROR INVOKE clause and the output of this operation is then returned to the client of the Web service . This way , application logic can be separated from error handling ; in particular , all texts for error messages are employed by one operation only .
CONVERSATIONPATTERN This clause specifies in a declarative manner how the Web service interacts with other services as part of conversations . There are many alternative models conceivable how to implement business conversations . As mentioned earlier , in our model we assume that the SOAP messages which are exchanged between Web services can carry a conversation URI in their envelop . Using this model , it would be very tiresome to specify for each message individually to which particular conversation it belongs ( if any ) . Fortunately , there are only a handful of different patterns in which Web services typically interact and maintain conversations . Consequently , XL allows to specify the conversation pattern as part of the declaration of a Web service . If such a pattern is specified , then the URI of the conversation is set implicitly whenever the Web service sends a message to another Web service . Currently , the conversation patterns supported by XL correspond one to one to the different kinds of scopes of transactions supported by J2EE [ 18 ] . These patterns are described in Table 1 — for each pattern , two situations must be considered : ( a ) the ingoing message is not part of a conversation ( defined as none in the second column of Table 1 ) ; ( b ) the ingoing message is part of a conversation ( defined as C1 in the second column of Table 1 ) . As part of future work , we are going to assess these particular patterns and see whether they meet the requirements of typical Web applications . For instance , the Required pattern has the following semantics : ( a ) if the Web service receives a message that has no conversation URI ( ie , is not part of a conversation ) , then the Web service will generate a new conversation URI and all other Web services it calls as part of processing the input message will be called using this new conversation URI ( C2 in table 1 ) . ( b ) If the Web service receives a message with a conversation URI , then all other Web services it calls
8
Pattern
Required
RequiredNew
Mandatory
NotSupported
Supports
Never
Table 1 Conversation Patterns
URI of
Input Message Outgoing Message none C1 none C1 none C1 none C1 none C1 none C1
C2 C1 C2 C2 error C1 none none none C1 none error as part of processing the input message will be called using the conversation URI of the input message . Each single operation can overwrite this default pattern by specifying its own pattern . The online shop is an example of a Web service that is based on the Mandatory pattern . Customers first invoke the login operation ; after that , all other operations ( eg,buy ) must be called as part of the same conversation . As mentioned earlier , a Web service can be involved in several conversations at the same time . For each conversation , the Web service maintains a separate context ; ie , a separate set of instances of each variable declared in a CONTEXT LET clause ( see previous section ) . These variables can only be used if the ingoing message carries a conversation URI . Naturally , thus , such variables cannot be used if the conversation pattern is set to Never .
CONVERSATIONTIMEOUT A timeout can be specified that terminates a conversation after a certain time since the last message exchanged as part of the conversation . An operation can be declared that is invoked if such a timeout takes effect . As part of the termination process , all the Web service ’s resources allocated to the conversation ( eg , context variables ) are released . If a message is sent to the Web service after the time out , the Web service will assume that this message is part of a new conversation ; in particular , the context of the ( old ) conversation is lost after the time out . An explicit termination of a conversation is thought about , but it is not included yet . We plan to add an explicit mechanism to terminate conversations as part of future work . Terminating a conversation is a local event . In other words , other Web services can communicate in a conversation , even though one Web service has decided to bail out of the conversation
9
3.3 XL operations
Each Web service can perform multiple tasks , each described by an operation . As mentioned earlier , an operation is called every time a Web service receives a message . An operation , therefore , gets the content of a message as input , carries out a number of statements based on this input , and generates a message with the output . Consequently , unlike XQuery functions that can have multiple inputs and exactly one answer , XL operations have exactly one input and at most one output . Within every operation , two variables are defined implicitly : $input and $output . The $input variable is automatically bound with the content of the XML message sent to the operation . The value of the $output variable is computed in the implementation of the operation and automatically sent back as a message to the caller of the Web service . The execution of the operations can also result in errors which are sent back as XML messages to the caller . In XL the specification of an operation is composed of the operation ’s declarative clauses and the operation body . As for the whole Web service , the declarative clauses of an operation control the run time behaviour of the given operation . Some of the clauses are identical in syntax and semantics to those of the Web service and serve only to refine the global Web service behaviour ( HISTORY , CONVERSATION PATTERN and ON ERROR INVOKE ) . Other clauses like the PRECONDITIONS , POSTCONDITIONS , and NO SIDEEFFECT are specific to operations , and we will describe them next . As in the previous section the syntax definition is skipped here , but can be looked up in [ 14 ] . An example is given in Section 5 .
PRECONDITION For each operation a set of preconditions can be specified which are checked before the first statement of the body of the operation is executed . If one of the conditions fails ( ie , evaluates to the boolean value FALSE ) , an exception is raised . This exception is specified in a THROW clause . If there are several preconditions , these preconditions are evaluated in a random order . Typically , preconditions will test certain properties of the $input variable ; eg , the existence of certain elements or the range of the value of certain elements .
POSTCONDITION Likewise a set of postconditions can be specified . Each condition is checked after the last statement of the operation has been executed . Typically , a postcondition will involve the $output variable but , again , any kind of boolean expression can be used . If a postcondition fails , the given exception is raised . If more than one postcondition is defined , the postconditions are evaluated in a random order . If an exception is raised by a precondition or in the body of the operation , no postcondition is evaluated .
10
NO SIDEEFFECTS This clause specifies that the operation has no sideeffects ; ie , the operation is an observer and does not change the internal state of the Web service or of any other Web service it might call . Specifically , this clause makes it possible to invoke a Web service as part of the evaluation of an expression .
4 XL statements
XL extends the notion of XQuery expressions to statements . The body of an XL operation is described by such a statement . In addition to classic imperative statements like variable assignment , conditional statements , loops , error handling and return statements , XL supports some additional ones : some are XML specific ( eg , the update statements ) and others are Web services specific ( eg , Web services invocation , logging , sleep ) . Finally , in addition to the classic imperative statement combinator ( sequencing ) , XL contains other statement combinators borrowed from the workflow and dataflow theory ( eg , dataflow , parallelism , choice ) . In the following sections the most important statements will be defined . A complete list is given in [ 16 ] .
4.1 Basic statements
In this section we introduce some of the basic atomic statements that can be used in the body of an XL program .
Variable assignments The simplest statement is the assignment of a local variable . The syntax is as follows : l e t [ type ] v a r i a b l e := e x p r e s s i o n
Local variables need not be declared before being used . However , the ( XML schema ) type of a variable can optionally be set as part of the first assignment to this variable . The scope of a variable is the block where the variable is defined ( see Subsection 42 ) Expressions can be any expression defined by the W3C XQuery proposal [ 23 ] .
Update Statements Unfortunately , the W3C has not yet released a recommendation to manipulate XML data ; there is only an initial proposal [ 10 ] . Once a recommendation has been released by the W3C , XL is going to adopt the syntax and semantics of that recommendation . In the meantime , we will use the following statements to manipulate XML data : • insert in order to add new nodes to the XML hierarchy ( eg , an additional credit card element ) insert < creditcard > . . . < / creditcard > into $customer
• delete in order to delete nodes from the XML hierarchy ( eg , the Visa card )
11 delete $customer / c r e d i t c a r d [ type= ” Visa ” ]
• replace in order to adjust elements ( eg , the telephone number ) replace $customer /phone with <phone>(408)8901−23</phone>
• rename in order to rename certain nodes ( element or attributes ) rename $customer /name as ” fullname ”
• move in order to move some XML nodes to a different location in the XML tree , while still preserving the internal structure and the node identifiers . move
$customer / t e l e p h o n e after $customer / c i t y
Service Invocation Statements Probably the most relevant atomic statements in XL are those used for invoking other Web services ; ie , sending a message to another Web service . Often , the other Web service will be written in XL , but messages can be sent to any service that has a URI and responds to SOAP messages [ 26 ] . Web services are invoked independently of the specific way they are implemented . We propose two ways to invoke a Web service as part of an XL program : synchronous and asynchronous . The syntax of a synchronous call is as follows : <expression > −−> <uri> [ : :<operation > ] The semantics are straightforward . A message with the value of expression is sent to the Web service identified by uri . If a specific operation of that Web service should be called , then the name of the operation can also be specified . Otherwise , the default operation of the Web service is invoked . In a synchronous call , the execution is halted until the called Web service finishes its execution and returns the entire result ( also wrapped in a SOAP message ) . If a variable is given as part of the call , then the body of the message returned by the called service is copied into this variable . The message is sent exactly once and in a best effort way . The syntax of an asynchronous call is similar to the synchronous one : <expression > ==> <uri> [ : :<operation > ]
[ −−> < variable > ]
[ ==> < operation > ]
In terms of the semantics : in this case the execution will not block and the program will immediately continue executing the next statement after the message to the called service has been sent . If the output ( normal reply message or error ) needs to be processed , then the name of the operation that will process the asynchronous result can be given as part of the call ; this operation has to be a member of the Web service that originated the asynchronous call . Again , the message is sent exactly once and in a best effort way .
Conditional statements Just like most other programming languages , XL provides conditional statement like IF THEN ELSE or SWITCH .
12 i f ( <booleanExpression > ) then
<statement> endif else
<statement> endelse switch i f ( <booleanExpression > ) then <statement> end i f ( <booleanExpression > ) then <statement> end . . .
! !
[ default <statement> end ] endswitch
The semantics are again straightforward . Note that the switch statement is more expressive than the switch statement in Java . The boolean expressions are checked from the top to the bottom until an expression evaluates to TRUE . At most one statement is executed — after that the switch statement terminates without considering any other boolean expression . A more expressive switch statement is necessary in order to implement personlized Web services ; ie , Web services that react to messages from different kinds of users . In order to achieve good performance , an XL implementation should carry out optimisations depending on the boolean expressions .
Iteration statements XL supports three different kinds of loops : WHILE loops , DO WHILE ( not shown ) loops , and FOR LET WHERE DO loops , with the following syntax : while ( < booleanExpression > ) do
<statement> endwhile for < variable > in < expression > l e t < variable > in < expression > where < booleanExpression > do
<statement>
For WHILE loops , DO WHILE the semantics are just the same as in Java . The FOR LET WHERE DO loop corresponds to FLWOR expressions in XQuery [ 23 ] . For instance , these loops are very useful if an application has a list of addresses and tries to send a message to each address .
Exception handling statements Web services implemented using XL signal failure by throwing exceptions — just as in Java or C++ . The syntax of the XL statement that raises an exception is as follows : throw < expression >
Here , expression can be any kind of XQuery expression . If the exception is not handled locally , the execution of the operation terminates and the value of the expression ( instead of the value of the $output variable ) is returned as a message to the caller of the service . In order to handle exceptions locally , XL adopts the try catch syntax from Java .
Block We use the following syntax to identify a block of statements .
13 begin
<statement> end
The body of an XL program , for instance , is formed as a block of statements . The scope of a variable is the block of statements in which the variable is used for the first time .
Several additional statements ( eg , log points or a sleep statement ) are omitted at this place due to a lack of space . These statements are not just syntactic sugar . But as we are simply trying to give an impression what XL is about these statement can be skipped without too much loss . In [ 14 ] a full language description and several examples are provided .
4.2 XL statement Combinators
Obviously , the body of an XL program can contain more than one atomic statement . There are several ways to combine statements . In the following “ statement1 ” and “ statement2 ” can refer to any atomic statement as the ones described in the previous sections or to any combination of statements . Compaq ’s Web language WebL [ 30 ] uses similiar combinators . • Sequence . The typical way to combine statements is by using the “ ; ” symbol , like in C++ or Java . Thus , the following means that “ statement1 ” is executed before “ statement2 . ”
<statement1> ; <statement2>
• Failure . If “ statement1 ” fails , execute “ statement2 . ”
<statement1> ? <statement2>
• Choice . Execute either “ statement1 ” or “ statement2 , ” but not both . Which one is executed is nondeterministic . <statement1> | <statement2>
• Parallel execution . Execute “ statement1 ” and “ statement2 ” in parallel . In other words , the order in which the individual statements are carried out is not specified .
<statement1> | | <statement2>
• Dataflow . If there are data dependencies between “ statement1 ” and “ statement2 ” ( eg , “ statement1 ” binds a variable that is used in “ statement2 ” ) , then execute the statement that depends on the other statement last . If there are no dependencies , then execute “ statement1 ” and “ statement2 ” in any order ( or in parallel ) . If there is a cyclic dependency , then this combination of statements is illegal .
<statement1> & <statement2>
14
5 Example
The example below shows a Web service written in XL . This program could be part of the implementation of an online shop . Only the two operations login and buy are listed to given an impression of an XL Web Service definition .
This example demonstrates how conversation variables are implicitly set . In this case a client Web Service starts a conversation by calling the method login . Every time a new conversation is started a new instance of the context variable $customer is created and initialised by default . In every further operation call in the conversation the same content is bound to the variable $customer . The term conversationpattern mandatory ; in the service header defines that for example the operation buy can only be called if a conversation has been started already by calling login . The operation login itself has the conversation pattern requiredNew and starts therefore a new conversation in any case . service HTTP://www . shop . com namespace x f = ” h t t p : //www . w3 . org /2001/08/ xquery−operators ”
! ! Web s e r v i c e i n t e r n a l data l e t $warehouseDB := <warehouseDB /> ; l e t $customerDB := <customerDB /> context l e t $customer := < customer /> ; e n t i r e Web s e r v i c e a c t i v i t y i s monitored
! ! history ;
! ! d e f a u l t o p e r a t i o n i s unknownOP defaultoperation unknownOP ; conversationpattern mandatory ;
! ! a c o n v e r s a t i o n cannot l a s t more than 1 0 days conversationtimeout x f : d u r a t i o n ( ” P10D ” ) l o g o u t ;
! ! i f an e r r o r occurs , on error invoke l o g o u t ; l o g o u t i s c a l l e d operation l o g i n i n p u t v a r i a b l e i s
! ! precondition $input validates as customerLoginSchema ; v a l i d
! ! customer needs a v a l i d l o g i n precondition x f : e x i s t s ( for $c in $input / customer ,
$db in $customerDB/ customer where $c / i d eq $db/ i d
15
$c /passwd eq $db/passwd and return $ c ) ;
! ! a new c o n v e r a t i o n i s conversationpattern requiredNew ; s t a r t e d body ! ! l e t $customer := <customer> i n i t i a l i s e t h e c o n v e r s a t i o n v a r i a b l e
<id> $input / customer / i d </id> <o r d e r s />
</customer> ; r e t u r n v a l u e
! ! l e t $output := ’ Login s u c c e s s f u l ’ endbody endoperation operation buy i n p u t
! ! precondition $input validates as buySchema ; i s v a l i d
! ! check a v a i l a b i l i t y o f product precondition for $p in $warehouseDB/ products ,
$o in $input / order $p/ i d eq $o/ i d where return $p/ a v i a l a b l e gt $o/ q u a n t i t y ; body
! ! update t h e c o n v e r s a t i o n v a r i a b l e insert $input / order into $customer / o r d e r s ; endbody endoperation operation unknownOP body nothing endbody endoperation operation l o g o u t body nothing endbody endoperation endservice
16
6 Implementation
In this section , we describe our prototype implementation of XL . The design of our prototype was driven by the following goals : • Distribution The declarative nature of the XL language offers various optimisation approaches . Among other things it should be possible to distribute the execution of a Web service over different computers . • Platform independence In order to utilise existing resources it should be possible to execute XL Web services on different platforms and operating systems . • Expressions As the semantics of expressions ( or any r value ) in the XLlanguage is defined according to the XML Query definition , an XML Query engine has to be integrated into the XL Runtime system . • Optimization Provide the basis for powerful and automatic tuning and optimization . Optimization techniques for an XL implementation are described in [ 15 ] . nisation points are set automatically .
The implementation of XL is in various ways different from other programming languages like Java : • the virtual machine exploits implicit or explicit given parallelism . Synchro• the XL virtual machine handles the context of conversations . • the XL virtual machine handles variables which do not fit in main memory • the XL virtual machine handles persistence and supports transactions .
( eg , the customer database of an online shop ) .
6.1 Statement Graph
Each operation in an XL Web service is translated into a directed and attributed graph which is the basis for all further considerations . The XL syntax is mapped on to a set of basic statements . These basic statements reflect the command set of an interpreter and nodes in the statement graph . In the following , we describe the structure of the graph and the set of basic statements of our XL implementation
Parsing
611 Each statement is represented by a node in the statement graph . Theses nodes are connected by directed edges so called combinators . Each combinator is attributed by a ( boolean ) variable . If a statement has been executed each outgoing combinator is examined . If the associated variable evaluates to TRUE the succeeding statement has to be executed as well . Combinators can be attributed also with the negation of a variable ; in this case , the next statement is executed if the value of the variable is FALSE . If the combinator is not attributed with a variable , the next statement is always executed . Each combinator therefore define a one to one predecessor successor relationship
17 if then else parallel statements l e t $a := { 0 } ; ( $a = 0 ) then i f l e t $a := { 1 , 3 , 5 } l e t $a := { 2 , 4 , 6 } endif else endelse l e t $b := $ a ; l e t $a := { 1 , 2 , 3 } ; l e t $num := count($a ) l e t $sum := sum($a ) ; l e t $avg := $sum/$num ;
| |
Fig 1 . Two example XL programs with the corresponding statement graphs between single statements . The statement graph is a very expressive representation of a program . A usual imperative if clause can be expressed by an assignment which evaluates the if predicate and two outgoing combinator , one carrying a temporary variable containing the predicate result and the other one its negation . If two outgoing combinators carry the same boolean value both succeeding statements have to be executed . The statement graph does not imply any ordering between succeeding statements .
Figure 1 shows two short XL programs together with the corresponding statement graphs .
612 Basic statements Assignment Probably , the most frequent statement is the assignment . As in any other language the assignment contains an r value ( or expression ) which can be evaluated and an l value ( or variable ) which stores the result . Sending a message Sending a message requires two expressions , the content of the message itself and the destination of the message . The second expression provides a value which can be interpreted as an address according to XL . This can be either a URI or a URI with an operation name .
Receiving a message The receive statement waits for a certain message to come . Typically this message is a response to a message sent before . The correlation between sending a message and the associated return message is either implemented by adding a message ID or by keeping an opened HTTP connection while waiting for an answer .
Wait statement The wait statement contains an expression and waits until this expression evaluates to TRUE . It is up to the interpreter to determine when to evaluate the expression .
Synchronise statement As the statement graph definition allows implicit
18 let $a := {1,3,5}let $a := { 0 }let $a := {2,4,6}let $b := $alet $_p := ( $a = 0)(not $_p)($_p)let $sum := sum($a)let $num := count($a)synclet $a := {1,2,3}let $avg := $sum/$num Fig 2 . The architecture of the XL Runtime System parallelism the different execution paths have to be synchronised . Even so exploiting the parallelism is left to the interpreter in the virtual machine the synchronisation is expressed in the statement graph . The synchronise statement schedules succeeding statements only if itself has been executed as often as there are direct predecessor statements .
613 Auxiliary Statement
Additionally to these basic statement some auxiliary statements are needed . As the initially parsed program is translated into a graph some information gets lost . To avoid information losses , these auxiliary statements are introduced .
Begin and EndBlock ( Variable Scope ) So far the variable scope is not expressed in the statement graph . At runtime the virtual machine provides each statement with a context which contains among other things a set of variables which can be accessed by the statement . By adding Begin and End Block statements to the graph , this information remains part of the statement graph .
Update Statements Supplementary to the assignment we implemented a set of XML Update statements which do not add further expressiveness . In return altering XML content is much more convenient . These statements could be either mapped on to a JDBC Interface or implemented by natively in the XL system itself .
19 engineXML− Query Threadscontextstmt−graphExecutable Stmt−graphcontextcontextcontextcontextcontextcontextconversation 2conversation 3conversation 4conversation 1default contextcontext−treeoperation 5operation 4operation 1operation 2operation 3List of operationsstmt−graphstmt−graphstmt−graphstmt−graphstmt−graphMessage HandlersHTTP−ServerMessage DispatcherVirtual MachineSOAPSOAPOutside WorldInterpretersDebugErrorActionTestDebuggerDefaultInterpreterXML Database 6.2 Runtime System Architecture
Figure 2 shows the basic structure of the XL virtual machine . The XL communicates only by sending XML SOAP messages via HTTP . Each SOAP message can to indicate it message type . Currently the XL prototype supports two different message types : • operation call • debug messages Depending on this message type different message handlers are selected which continue processing the message . If the message type debug is specified , a special debugging interpreter is used which provides an interface for a remote debugging client . If no message type is specified a usual operation call is executed . In case of an operation call the message handler initiates an appropriate interpreter . This interpreter initialises the input variable $input , starts the execution , waits for the execution to finish and returns the result – either an error message or the content of the variable $output . The context information is contained in so called control blocks . These control blocks are nested inside each other in a tree structure . Each control block contains a set of variables . At execution time each statement holds a reference to one control block . As the statement is executed it can access all variables which are contained in its control block or any parent control block . The root control block therefore holds all global variables . The auxiliary statements Begin and EndBlock in the statement graph indicate where a new control block has to be used or an old one can be disposed .
621 Conversation Handling The basic feature of conversation handling is the context information which is associated with an existing conversation . Each SOAP message which is send as part of an conversation has to contain a conversation URI . The XL runtime system has to map these URIs on to existing context representation ( control blocks ) . If an operation call as part of an existing conversation occurs the associated control block is used as parent control block for this execution . By doing so the conversation variable contained in this control block are joined by all operation calls in a conversation in one runtime system . If the service is not part of the conversation and the adequate conversation pattern is specified an new context has to be created and added to the URIcontext map .
622 Interpreter Each specific execution of XL operations is controlled by a so called interpreter object . Each time an operation is to be executed the interpreter fetches the associated statement graph for this operation . The Interpreter creates a new context representation which inherits the global and conversation variables
20
Dimension
Description
Data granularity
Execution Unit
Execution Point
Decision Time
The dataflow between statements can be implemented as whole variables or smaller entities . Each interpreter might use a different internal representation of an XL program . The term execution unit denotes the smallest part of the XL program which can be executed by the specific interpreter without being interrupted . In a distributed environment a statement or an operation can possibly be executed on different servers . It is up to the virtual machine to realize explicit or implicit parallelism . The decision which parts are to be executed concurrently can be made at compile or runtime . Likewise the decision on the execution point can be deferred until runtime current Implementation whole variables single statements every thing is executed locally at runtime
Table 2 Dimensions of the execution model from a selected parent context . Then a dynamic binding between statement graph and context representation is generated . The execution of statements is specific for our implementation of the XLInterpreter . In our case the context binding is represented by so called execstatements . Each of these exec statements references a context and an associated statement . These exec statements are scheduled on to a set of existing threads . The interpreter fetches the initial exec statement , appends it to a waiting queue and notifies the threads . One of the waiting threads fetches the execstatement from the waiting queue and executes it . Generally speaking execution models for XL can vary in different dimensions . The different dimensions we distinguish are shown in table 2 . By implementing different interpreters which vary in one or more dimension we can instrument different optimisation strategies .
6.3 XML Query Expressions
XML Query expressions are executed by an external query engine for XQuery . In fact the two systems are relatively loosely coupled as XL treats expressions as simple character strings . These strings are passed the interface of the query engine which is closely related to the common JDBC interface for relational databases . Instead of parsing XQuery expressions XL creates XQuerypreparedStatements . To execute these statements XL has to provide a the context information namely the variables . In return the XQuery statements
21 return the XML result represented as a token stream . The loose coupling between the two systems certainly costs CPU performance and optimisation possibilities are lost . On the other hand the XQuery engine can eventually be easily replaced by another implementation . The currently used XQuery engine is implemented by XQRL [ 33 ] .
7 Related Work
The development and composition of Web services ( or e services ) is currently a very active area in both industry and academic research . The main purpose of our work was to provide a clean basis for a new XML programming language for rapid development of Web services . In the industry , there have been a number of concrete proposals for new languages and frameworks related but not identical to our programming language proposal—most prominently , SUN ’s J2EE [ 18 ] and SunOne [ 27 ] , and Microsoft ’s .NET initiative [ 24 ] . Compaq has developed the WebL language [ 30 ] ; HP has developed the eFlow and eSpeak systems [ 4 , 11 ] , IBM is working on a language called Web Service Flow Language [ 22 ] , and Microsoft has recently released their BizTalk Server 2000 [ 1 ] and XLANG [ 28 ] . While there are many similarities between WSFL and XLANG on one hand and XL on the other hand , there are a couple of major differences . First , both WSFL and XLANG are XML programming languages in the sense that they have an XML syntax ; our understanding of an XML programming language is a language that manipulates only XML data , independently of the syntax of the language itself . Second , both WSFL and XLANG are able to describe only how to compose existing Web service components ( that are expected to be implemented using other languages ) , while XL is complete not only with respect to Web service composition but also specification . Using XL , it should be possible to implement complex Web services entirely without any need for any other programming language . Finally , and more importantly , XL adds to Web services the concepts of declarative behaviour specification inherited first from relational databases and then from J2EE . The recently started language projects ( Water [ 29 ] , JWIG [ 20 ] ) provide efficient methods for Web service specification , but still both languages do not solve the mismatches between XML , Java and databases . Two other specifications worth mentioning are the Business Process Model Initiative whose goal is to implement cross organisation processes and workflows on the Internet [ 2 ] and DAML S whose goal is the automation of Web services using ontologies [ 8 ] . DAML S accomplishes an automatic selection , composition , and interoperation of Web services . Like XL , DAML S provides control statements to specifiy application logic . Moreover , the state of the art in the Java world is to support XML via so called servlets that translate ( XML and HTML ) requests into Java classes and back [ 19 ] . Furthermore , the J2EE framework provides a number of features for service composition ,
22 conversations , database interaction , transactions , and security [ 18 ] . Recently , Sun Microsystems introduced the JXTA project on peer to peer computing to support distributed computing on the Internet [ 21 ] .
Finally , the notion of a service composition is based on a solid theoretical background consisting on the calculi developed first by Hoare [ 17 ] and more recently by Cardelli [ 3 ] .
However , none of those languages and frameworks are totally consistent with the current W3C standards , and we believe that this is a mandatory condition for the success of such a programming language .
Two recent and independent projects have a similar design philosophy and encourage us to pursue XL . BPEL [ 12 ] is very similar to XL . Like XL , BPEL declarative Web service description based on several XML standards . The Web Service Modeling Framework [ 13 ] focuses on interface description and the mediation of different data types and processing concepts between different Web services .
On the WWW conference 2002 the language XL was introduced for the first time [ 14 ] . At the CIDR conference in January 2003 another XL publication ( [15 ] ) is about to appear . This paper focuses upon optimisation aspects of XL Web services . A detailed description of the language XL is given in the technical report [ 16 ] .
8 Conclusion
This paper described the design and prototype implementation of a new programming model for Web services called XL . XL has a number of advantages compared to the programming models used in practice today ( eg , Java , C# , or Visual Basic ) . • The programmer can focus on the description of the Web service . Using XL , marshalling between different data formats and data models is not necessary and optimization is automatic . • XL is fully compliant with all W3C standards . Using SOAP , the integration of other Web services can be easily accomodated ; even if these Web services are not written in XL .
There are several avenues for future work . Most importantly , there are a number of aspects that need to be integrated into the XL programming model ; specifically , a distributed transaction model , life cycle management , data push ( pro activeness ) , and syntactic constructs in order to facilitate authentification and authorization . Furthermore , we would like to enhance our prototype implementation in order to achieve best possible performance , availability , and security for all Web services written in XL .
23
References
[ 1 ] BizTalkorg Biztalk initiative . http://wwwmicrosoftcom/BizTalk/ [ 2 ] BPMIorg Business Management Initiative . http://wwwbpmiorg/indexesp [ 3 ] L . Cardelli and R . Davies . Service Combinators for Web Computing . In IEEE
( TSE ) , 1999 .
[ 4 ] F . Casati , S . Ilnicki , L . Jin , V . Krishnamoorthy , and M C Shan . eFlow : a Platform for Developing and Managing Composite e Services . Technical report , Hewlett Packard , 2000 .
[ 5 ] Peter P . Chen . The entity relationship model toward a unified view of data .
TODS , 1(1):9–36 , 1976 .
[ 6 ] E . Christensen , F . Curbera , G . Meredith , and S . Weerawarana . Web Services Description Language ( WSDL ) 11 http://wwww3org/TR/wsdl , Mar 2001 .
[ 7 ] Clark J . , et al . XML Path Language ( XPath ) . http://wwww3org/TR/xpath ,
Nov 1999 .
[ 8 ] DAML Service Coalition . DAML S : Semantic Markup for Web Services . http://wwwdamlorg/services
[ 9 ] G . Copeland and D . Maier . Making Smalltalk a database system . In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data , pages 316–325 . ACM , 1984 .
[ 10 ] D . Chamberlin , D . Florescu , et al . Updates for XQuery . internal W3C Working
Draft , to appear , Dec 2002 .
[ 11 ] eSpeak . The Universal Language of E Services . http://wwwe speakhpcom/ [ 12 ] F . Curbera , F . Leymann , et al . Business Process Execution Language for Web
Services . http://wwwibmcom/developerworks/library/ws bpel , Jul 2002 .
[ 13 ] D . Fensel and C . Bussler . The Web Service Modeling Framework WSMF . http://wwwcsvunl/˜dieter/wese/wsmfbis2002pdf , 2002 .
[ 14 ] D . Florescu , A . Gr¨unhagen , and D . Kossmann . XL : An XML Programming Language for Web Service Specification and Composition . In WWW2002 Conference Proceedings , pages 65–76 , 2002 .
[ 15 ] D . Florescu , A . Gr¨unhagen , and D . Kossmann .
XL : A Platform for http://www
Web Services . dbcswiscedu/cidr/program/p8pdf
In CIDR 2003 , Asilomar , Jan 2003 .
[ 16 ] D . Florescu and D . Kossmann . An XML Programming Language for Web Service Specification and Composition . Technical report , TU Munich , June 2001 .
[ 17 ] CAR Hoare . Communicating Sequential Processes . Prentice Hall Interna tional , 1985 .
[ 18 ] J2EE . Java 2 Enterprise Edition . http://javasuncom/j2ee/tutorial [ 19 ] JAKARTA . The JAKARTA Project . http://jakartaapacheorg/ [ 20 ] JWIG . for High Level Web Service Development .
Java Extensions http://wwwbricsdk/JWIG/
[ 21 ] JXTA . The JXTA Project . http://wwwjxtaorg/ [ 22 ] Frank Leymann . Web Services Flow Language . http://wwwibmcom/ software/solutions/webservices/pdf/WSFL.pdf , May 2001 .
[ 23 ] M . Marchiori , et al . XML Query . http://wwww3org/XML/Query , Nov 2002 .
24
[ 24 ] Microsoft Corp . net http://wwwmicrosoftcom/net , 2003 . [ 25 ] Schema . XML Schema . http://wwww3org/XML/Schema , May 2001 . [ 26 ] SOAP . Simple Object Access Protocol . http://wwww3org/2000/xp/Group/ ,
Dec 2002 .
[ 27 ] Sun . SunOne . http://wwwsuncom/software/sunone [ 28 ] S . Thatte . Xlang overview . http://wwwgotdotnetcom/team/xml wsspecs/xlang c/defaulthtm
[ 29 ] Water . Simplified Web Services Programming . http://wwwwaterlangorg [ 30 ] WebL . Compaq ’s Web Language . http://wwwresearchcompaqcom/SRC/WebL [ 31 ] Williams S . , et al . XML Protocol ; Abstract Model
. http://wwww3org/TR/xmlp am/ , Jul 2001 .
[ 32 ] XForms Working Group . XForms : The Next Generation of Web Forms
. http://wwww3org/MarkUp/Forms/ , Feb 2003 .
[ 33 ] XQRL , Inc . http://wwwxqrlcom/ , Dec 2002 . [ 34 ] XSL Working Group .
Extensible http://wwww3org/Style/XSL/ , Jan 2002 .
Stylesheet Language XSLT .
25
