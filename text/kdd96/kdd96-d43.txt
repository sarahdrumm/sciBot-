From : KDD 96 Proceedings . Copyright © 1996 , AAAI ( wwwaaaiorg ) All rights reserved .
Pattern Discovery in Temporal Databases : A Temporal Logic Approach’
I’
Balaji Padmanabhan and Alexander Tuzhilin
Leonard N . Stern School of Business
New York University
{bpadmana , atuzhili}@sternnyuedu
Abstract
The work of Mannila et al . [ 4 ] of fmding frequent episodes in sequences is extended to finding temporal logic patterns in temporal databases . It is argued that temporal logic provides an appropriate formalism for expressing temporal patterns defined over categorical data . It is also proposed to use Temporal Logic Programming as a mechanism for the discovery of frequent patterns expressible in temporal logic . It is explained in the paper how frequent temporal patterns can be discovered by constructing temporal logic programs .
Introduction this paper , we address the problem of finding In interesting patterns in temporal databases [ 1,2 ] defined over categorical ( symbolic ) data . This is an important problem that frequently occurs in various applications such as molecular biology ( finding patterns in genetic sequences ) , telecommunications ( finding patterns in network behavior ) and financial services ( finding patterns in analysts’ recommendations of stocks ) . To address this problem , a language for expressing temporal patterns has to be defined and mechanisms to discover patterns in temporal databases need to be developed . This is a broad problem , and it has been addressed before in such fields as speech recognition , signal processing , as well as in the KDD field itself . For example , Agrawal et al . [ 3 ] provide a shape de$nifion language , SDL , for expressing shapes in sequences . In the context of categorical data , the problem has been addressed by Mannila et al . [ 4 ] and by the string matching research community [ 5 ] .
Mannila et al
[ 4 ] define temporal patterns in sequences of events with episodes , where episodes are defined as partially ordered sets of events that can be described by directed acyclic graphs . Given a class of such episodes they describe an efficient algorithm that finds all fi equent episodes from that class . Their paper presents an on interesting telecommunications data . However , the episodes defined in [ 4 ] have a limited expressive power in specifying temporal patterns . For example , it is unclear how episodes can define such temporal patterns as “ event A always occurs until event B occurs ” or that “ either event A or event I3 occurs at the same time . ” In addition , their approach works on sequences , and not on temporal databases ( ie temporalpredicafes changing over time ) .
String matching researchers use regular expressions to define patterns on strings of alphabets and develop tested approach that was
‘This work was supported in part by the NSF under grant IRI 93 18773 efficient string matching algorithms . Ah0 [ 5 ] presents a survey of such algorithms . Regular expressions are defined over an alphabet , and therefore this approach works well with strings of symbols but does not generalize to temporal databases , where predicates change over time . In this paper we extend the work of Mannila et al . [ 4 ] ( finding frequent patterns in temporal categorical data ) and propose the use of first order temporal logic ( FOTL ) [ 6 ] to express patterns in temporal databases ( the propositional case constitutes a special case of the firstorder case ) . As an example of how episodes can be expressed in Temporal Logic ( TL ) , the partial order of symbols “ A+B+C ” , defining a serial episode of [ 4 ] , can be expressed as “ A Before B and B Before C ” . In addition , TL can also be used to express patterns such “ Hold(Stock ) Unfil Bearish Market Sentiment ” , where Hold is a temporal predicate . Moreover , we propose to use TL for discovering temporal patterns by generating femporal logicprograms ( TLP ) [ 7,8,9 ] for these patterns . TL provides several important advantages as a mechanism for the specification and discovery of patterns in temporal databases . It is a well studied , expressive and theoretically sound formalism that has been extensively used in various fields of computer science for dealing with temporal phenomena . TL can be used both for the specification of temporal patterns and for their discovery in temporal databases ( using TLP techniques described below ) . Therefore , TL provides a sound framework for integrating the specification and discovery methods .
Preliminaries
We use FOTL [ 6,10 ] to express temporal patterns . The syntax of FOTL is obtained from first order logic by adding temporal operators such as Since , Until , Next ( o ) , and Previous ( 0 ) and some of the derived operators , such as Always ( O ) , Future and Past Sometimes ( O,+ ) , Before , After and While . In addition , we consider bounded temporal operators [ 9,12 ] UntiIK , SinceK etc . For example , AUntilxB is defined as : ( Qt ) I= A Unt& B iff 3m , t I m 2 t+k , such that
( D,m ) I= B and ‘v’i , t I i < m , ( Dj ) I= A
The semantics of FOTL is defined in terms of temporal structures , ie , predicates changing over time [ lo ] . We assume that time is discrete , linear and bounded , that temporal predicates define a temporal database [ 1,2 ] , and that temporal relations are represented as event tables [ 13],ie tables with a single temporal attribute .
A temporal paffern is a ground FOTL formula , ie a FOTL formula containing only ground atoms and no
Spatial , Temporal , 6r Multimedia Data Mining
351 variables and quantifiers . A class of temporal patterns is defined by a temporal formula , v , with one or more variables in it . An instantiation of all variables in \v with specific ground values , defines a temporal pattern . In this paper we adopt the convention of using uppercase alphabet to represent variables in a temporal formula .
Temporal Logic Programming . A TLP program consists of a set of temporal rules of the form BODY + HEAD , where various TLP systems make different assumptions about the structure of BODY and HEAD . For example , a rule that “ Employees who have been fired from a firm ( worked there sometime in the past , but not now ) cannot be hired by that firm in the future ” can be expressed in an extension of TLP system , Templog [ 7 ] as : +EMPLOY(firm , person ) A EMPLOY(firm , person )
+
0 EMPLOY(firm , person )
Alternatively , as done in Datalogls [ 141 , we can also express TLP programs in first order logic using explicit references to time . For example , instead of using the temporal predicate EMPLOY ( firm , person ) , we can use its FOL equivalent EMPLOY(firm , person , time ) specifying the employment history of the person over time . Moreover , Templog and the corresponding FOL language Datalogl s are equivalent in their expressive power [ 8 ] . We will use an extension of Datalogls to express TLP programs . Datalogls will be extended by allowing negation both in the body and in the head of a rule , as done in doubly negated Datalog’* [ 151 , and by allowing comparisons between temporal variables ( eg tl < t2 ) in the body of Datalogls rules . We will call the resulting extension eDatalogls . We will adhere to the parallel inflationary semantics of Datalog * [ 15 ] when we define semantics of eDatalogls . Intuitively , all the eDatalogls rules are fired in parallel , and if there are conflicts in rnles,program execution terminates , as done in Datalog * .
Finding Frequent Temporal Patterns
In this paper we address the problem of finding frequent and most frequent patterns in temporal databases . For example , if D is a temporal database , then we may want to find all the frequent patterns in the class of temporal patterns , \I , = X1 Unt& X2 , where X1 and X2 are secondorder variables ranging over the predicates in the temporal database D . To do this , for any temporal pattern that belongs to the class v , , we can count the number of time instances for which the pattern holds on D . The pattern is then frequent if it exceeds a threshold value c . in D , X
For example , assume that X1 is associated with predicate p(X ) , Xz with predicate q(X ) is instantiated to a~ , and K=5 . If a pattern “ p( % ) Until , , q(aJ’ occurs 90 times in D and c is 70 , we conclude that the pattern occurs frequently in D . Alternatively , we could have searched for the most frequent patterns in D , ie , the patterns having maximal frequency counts in comparison to other patterns in the given class .
In the unrestricted case , the problem of finding the most frequent patterns can be trivially non interesting . If we consider the ( infinite ) class comprising of all TL
352
Technology Spotlight formulae , then an example of the most frequent pattern would be “ p(a ) v ~p($ “ , where p(X ) is a temporal predicate in a temporal database D . Therefore , we have to restrict our consideration to certain well defined classes of temporal patterns for which the problem becomes nontrivial . For example , some classes of temporal patterns can be defined as follows : 1 . A single FOTL formula , where the “ variables ” could be arguments of predicates , but cannot be of second order , ie range over predicates . 2 . A parameterized single FOTL formula defines a class temporal patterns that may differ from each other by of some parameters of the the temporal operators . In example discussed above , “ IS’ is a parameter of Until . 3 . The class of all the temporal patterns defined using only AND and NEXT operators .
Class Defined By A Single FOTL Formula
To illustrate the discovery methods described in this section , consider the following class of temporal patterns defined by the expression y(X,Y,Z ) = a(X,Y ) Until b(Y,Z )
( 1 ) where a and b are temporal predicates from the temporal database D . We want to find all possible instantiations for the variables X , Y and Z for which pattern ( 1 ) occurs frequently ( its frequency is above a certain threshold ) . To find such instances , we construct a TLP that will identify all the occurrences of temporal patterns that belong to v .
Let a(X,Y,T ) , b(Y,Z,T ) , and v(X,Y,Z,T ) be the temporal predicates that appear in ( l ) , but with explicit references to time . Figure 1 illustrates a TLP program , written in eDatalog,s , that computes v(X,Y,Z,T ) using a distinguished predicate q(X,Y,Z,T ) .
( i ) simtime(0 ) ( ii ) simtime(T ) + simtime(T+l ) , 7 simtime(T ) ( iii ) simtime(T ) , a(X,Y,T ) , ,a(X,Y,T 1 ) + flag1 ( XYJ ) , flagW,Y,T )
( iv ) simtime(T ) , a(X,Y,T ) , a(X,Y,T 1 ) + ( v ) simtime(T ) , b(Y,Z,T ) , flagl(X,Y,Tl ) , ( Tl I T2 5 T ) + q(X,Y,Z,T2 ) flag2(X,Y,T ) flag2(X,Y,T l ) ,
( vi ) simtime(T ) , +(X,Y,T
( Tl I T2 ST ) + dag2(X,Y,T2 ) ,
) , flagl(X,Y,Tl),flag2(X,Y,T I ) , dlagl(X,Y,Tl )
( vii ) b(Y,Z,T )
+ q(X,Y,Z,T )
Figure 1 . TLP computing a(X,Y ) Until b(Y,Z ) .
To simulate the forward movement in time , the program in Fig 1 uses predicate simtime that acts as a system clock , and Rule ( ii ) advances it forward on a tickby tick basis . Rule ( iii ) sets flag1 when the predicate a(X,Y ) is true for the first time instant in a period of time when it holds continuously , and rule ( iv ) continues to set a new flag ( flag2 ) for all time points in that period . Now when b(Y,Z ) is encountered with flag1 and flag2 on , rule ( v ) sets the distinguished predicate , q(X,Y,Z ) to be true for all instances of time from when flag1 was first set until the time when b(Y,Z ) holds . Rule ( vi ) resets flags after the end of any continuous period of time when a(X,Y ) holds .
To find frequent ( or most frequent ) patterns of the form ( l ) , the program in Fig 1 can easily be extended to incorporate a counter of the number of instances when q(X,Y,Z,T ) is true . Note that the use of ( first order ) variables in the program facilitates construction of a single TLP program to find all instances of temporal patterns in D that belong to the class \v . We can generalize this example into the following theorem , the proof of which can be found in [ 111 : Theorem . For any class of temporal patterns specified by a single FOTL formula cp defined on a temporal database D , there exists a TLP program PROG with the distinguished predicate 4 , such that for any finite instance of D , 4 E cp , ie CJ holds whenever cp holds and vice versa .
The proof of this theorem is by induction on the formula cp , and is number of operators in constructive . Also , there is a notion of “ safety ” of FOTL expressions , without which TLP programs may not terminate . Our TLP programs can be shown to terminate if D is finite and the domains of the arguments in predicates are all finite . the TL
Class of Patterns Consisting of AND and
NEXT Operators
Here we consider the class of temporal patterns TLJr\,o ) consisting of A and o operators and study two problems of finding the most frequent and all frequent patterns . Most Frequent Patterns . Because of the distributivity of A and o operators , any pattern from TL{A,o} depending on temporal predicates X , , X1 , , . . , X , , can be converted to the following canonical form ( for clarity we omit arguments of the predicates ) : x ,
A Ok’& A 0%~ , I h and for i#j , Xi # Xj when ki= kj . where 1s kl I The mostfiequenf patterns in this case will be of the form :
. . . A Oh&
( 2 )
Wij(K )
= Xi A OK Xj
( 3 )
The TLP that counts the occurrences of all the temporal patterns that belong to v+(X,Y,K ) = a(X ) A ok b(Y ) is given in Figure 2 , where predicate com&,b ( X,Y,K,VAL ) specifies how many times ( VAL ) the pattern v&b ( X,Y,K ) occurred in the database .
( i ) simtime(0 ) ( ii ) simtime(T ) + simtime(T+l ) ( iii ) simtime(T ) , a(X,T ) , b(Y,T+K ) , count+ ( X,Y,K,VAL ) , ‘b,b ( X,Y,~T)++‘,b ‘XY,KT),co’ u &b ( X,Y,K,V~+l > Figure 2 . TLP program that simulates a A oK b .
The program counting the most frequent occurrences of patterns belonging to ( 3 ) is obtained by combining the TLP programs presented in Fig 2 for all possible pairs of predicates a and b and adding the “ control ” logic selecting the highest values ( VAL ) in predicate cou&,b for various values of a , b , X , Y and K . We would like to point out that the program that finds the most frequent patterns of the form ( 3 ) ( and hence ( 2) ) , does it in one single forward
,i
“ sweep ” in time during the execution of the program , and , thus , its complexity is linear in time . finding Frequent Patterns . The starting point frequent patterns from TL{A,o} is the canonical form ( 2 ) of these patterns . Since frequency of patterns is a monotonically decreasing function of n in ( 2 ) , there is a value of n for which no temporal pattern given by ( 2 ) is frequent . Therefore , our goal is to find such maximal value of n ( N ) and also find all frequent patterns of the form ( 2 ) for n<N . for
Unlike the case of the most frequent patterns , we cannot reduce ( 2 ) to a simplified expression and will be dealing with the general case of ( 2 ) . A naive approach would be to find frequent patterns for ( 2 ) for successive values of n ( until the next value of n does not generate any new frequent patterns ) without using the outputs from previous iterations . However , we will use a more efficient algorithm that is based on the idea of generating larger candidate patterns from smaller ones . This method of generating candidate patterns was used effectively by Agrawal et al.[16 ] and by Mannila et al [ 4 ] to mine association rules and episodes respectively .
We will first start with finding frequent patterns for a single predicate p . In other words , the expression ( 2 ) is reduced to the case : p(X)AOklP(;Y)AOuP(~AOhp(X)A
The algorithm , described in Fig 3 , where X is a vector of the attributes of predicate p .
( 4 ) iteratively generates frequent patterns for successive values of n in ( 4 ) by utilizing the frequent patterns discovered in the previous iteration . T* is the largest value in the time domain ( such value exists since the time domain is bounded ) , freq,,(X,K,,,Kd is the class of all the frequent patterns found at stage n , count(X,K1,,K,,,VAL ) is a predicate that tracks the frequency count , VAL , and c is Predicate the holds(T,X,Kl , , Ka is used in Rule ( iii ) to avoid doublecounting . Initially , it is set to False for all of its values . The algorithm executes until the saturation point is reached , ie until freq , , = 4 . frequency threshold value . n=l and fieqo = set of all frequent ground predicates p repeat compute freq , , with TLP program TLP , ; n=n+l ; until ( f?eq , = 4 ) ; print freqi , i=l,Z , , n l where the program TLP , , is :
( i ) simtime(0 ) ( ii ) simtime(T ) ,T 5 T* + simtime(T+l ) ( iii ) simtime(T ) , p(X,T ) , p(X,T+Kl ) , , p(X,T+K& , fieq,.l ( X,KI , , Kn l ) , p(X,T+K& count(X,Kl , , K,,,VAL ) , Tholds(T,X,KI , , Kn ) + holds ( T,X,Kl , , Kn ) , count(X,Kl , , K, , , VAZ . +1 ) ( iv ) simtime(T*+l ) , count(X,Kl,,K, , , VAL ) , ( VAL > c )
+ fiq , ( X,&,KJ
Figure 3 . Algorithm to find all frequent patterns of form ( 4 )
Spatial , Temporal , 6r Multimedia Data Mining
353
Note that in rule ( iii ) in Figure 3 , we add the ( X,Kl , . . . ,Knml ) to the body of the rule . This predicate fre% ln 1 can improve efficiency if a smart rule evaluation strategy is used since , for all values of T , freqnml ( X,K , , , Kflel ) 3 p(X,T ) , p(X,T+KI ) , , p(X,T+K,.& Thus , we have to evaluate p(X,T ) , p(X,T+K,),,p(X,T+K& only for the frequent values of X,KI,,K,I in Rule ( iii ) . thus , we omit
The generalization of the algorithm presented in Figure 3 to the class of patterns of the form ( 2 ) that are defined by multiple predicates is straightforward but notationally cumbersome and , it . Furthermore , it leads to the combinatorial explosion in the size of the TLP programs constructed by the algorithm ( as a function of the number of predicates in the database ) . We would like to note that , in contrast to the “ most frequent patterns ” case , we construct multiple TLP programs ( one program per iteration ) in this algorithm . This means that the complexity of the algorithm is no longer linear in T* .
Experiments and Conclusion
We used TL to express patterns and implemented TLP programs in OPS5 for an application in which different financial analysts rate various stocks in terms of buying , selling , or holding recommendations . In this application , we wanted to find the most frequent recommendation change patterns made by various analysts and the correlation patterns of stock recommendations across different analysts ( eg frequently , analyst A recommends “ buy ” for a stock until analyst B recommends “ sell ” ) . For example , a recommendation change pattern can be expressed as :
Analyst Report(analyst,stock,recommendat ) T o Analyst Report(analyst,stock,recommendat ) In this case we want to find the analysts that changed their recommendations most often for different stocks . The eDatalogls program that finds such patterns is very similar to the one presented in Figure 2 , and we simulated this program in OPS5 on a Sun Sparc20 using an artificially generated data set consisting of 3 analysts , 3 stocks , and 300 days ( we assumed that the frequency of recommendations was one day ) . The performance as a function of the size of the data set is presented in Figure 4 .
A
3ooBm
933
15m
1203 # ofTuples
18m
2103
24C0
27C0
Figure 4 . Execution Time Vs . Database Size
These preliminary the performance of our implementation is quite slow . We attribute this to the following factors . Mainly , our version of OPS5 does not support arithmetic in the body of a rule . results demonstrate that
354
Technology Spotlight
Therefore , we simulated expressions of the form P(A,T+l ) by creating new predicates and making the OPS5 program bigger and less efficient . Second , the OPS5 interpreter has the serial semantics ( one tuple instantiation per recognizeact cycle ) , and this also slowed the execution of the TLP program . In summary , to make the TLP technology practical for the pattern discovery purposes , there is a need to develop efficient TLP interpreters that support such important features as pseudo parallel execution of temporal rules and that would provide an efficient support for the temporal dimension .
References and
[ l ] Tansel , AU , Clifford , J . , Gadia , S . , Jajodia , S . , Segev , A . and Snodgrass , R . , 1993 . In Temporal Databases , Theory Design Implementation . Benjamin/Cummings . [ 2 ] Clifford J . , Tuzhilin A . , 1995 . Recent Advances in Temporal Databases . Springer Verlag . [ 3 ] Agrawal , R . , Giuseppe , P . , Edward , WL , and Zait , M . , 1995 . Querying Shapes of Histories . In Proceedings of the 21st VLDB Conference , pp . 502 514 . [ 4 ] Mannila , H . , Toivonen , H . , and Verkamo , AI , 1995 . Discovering Frequent Episodes in Sequences . In The First International Co@ on Knowledge Discovery in Databases ( KDD 95 ) , pp 210 215 . [ 5 ] Aho , AV , 1990 . Algorithms for Finding Patterns in Strings . In van Leeuwen , J . , ed . , Handbook of Theoretical Comp . SC . , Vol A :AIgorithms and Complexity . Elsevier . [ 6 ] Manna , Z . , and Pnueli , A . , 1992 . Temporal Logic . In The Temporal Logic of Reactive and Concurrent Systems . Springer Verlag . [ 7 ] Abadi , M . , and Manna , Z . , 1989 . Temporal Logic Programming . J . of Symb . Computation ~8 , pp . 277 295 . [ S ] Baudinet , M . , Chomicki , J . , and Wolper , P . , 1993 . Temporal Deductive Databases . Ch13 in [ 11 . [ 9 ] Tuzhilin , A . , 1992 . SimTL : A Simulation Language Based on Temporal Logic . Transactions of the Society for Computer Simulation , 9(2 ) , pp . 87 100 . [ lo ] Kroger , F . , 1987 . Temporal Logic of Programs , volume 8 . Springer Verlag . [ ll ] Padmanabhan , B . , and Tuzhilin , A . , 1996 . Using Temporal Logic to Find Patterns in Temporal Databases . Working Paper #IS 96 2 , Dept . of Info . Systems , NYU . [ 12 ] Koymans , R,1990 Specifying Real Time Properties with Metric Temporal Logic . J . of Real Time Systems , v2 . [ 131 Snodgrass , RT , 1995 . The TSQLZ Temporal Query Language . Kluwer . [ 14 ] Chomicki , J . , and Imielinski , T . , 1988 . Temporal Deductive Databases and Infinite Objects . Proc of PODS . [ 151 Abiteboul , S . , and Vianu , V . , 1991 . Datalog Extensions for Database Queries and Updates . J . of Computer and System Sciences , vol . 43 , pp . 62 124 . [ 16 ] Agrawal , R . , Mannila , H . , Srikant , R . , Toivonen , H . and Verkamo,AI , 1995 . Fast Discovery of Association Rules . In Fayyad , UM , Piatetsky Shapiro , G . , Smyth , P . , and Uthurusamy , R . eds . , Advances in Knowledge Discovery and Data Mining . AAAl Press .
