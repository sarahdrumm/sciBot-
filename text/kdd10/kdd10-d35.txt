Community based Greedy Algorithm for Mining Top K
Influential Nodes in Mobile Social Networks
Yu Wang† , Gao Cong‡ , Guojie Song†∗ , Kunqing Xie†
†Key Laboratory of Machine Perception , Ministry of Education , Peking University , China wangyu@cispkueducn , gaocong@ntuedusg , gjsong@cispkueducn ,
‡School of Computer Engineering , Nanyang Technological University , Singapore kunqing@cispkueducn
ABSTRACT With the proliferation of mobile devices and wireless technologies , mobile social network systems are increasingly available . A mobile social network plays an essential role as the spread of information and influence in the form of "word of mouth" . It is a fundamental issue to find a subset of influential individuals in a mobile social network such that targeting them initially ( eg to adopt a new product ) will maximize the spread of the influence ( further adoptions of the new product ) . The problem of finding the most influential nodes is unfortunately NP hard . It has been shown that a Greedy algorithm with provable approximation guarantees can give good approximation ; However , it is computationally expensive , if not prohibitive , to run the greedy algorithm on a large mobile network . In this paper we propose a new algorithm called Communitybased Greedy algorithm for mining top K influential nodes . The proposed algorithm encompasses two components : 1 ) an algorithm for detecting communities in a social network by taking into account information diffusion ; and 2 ) a dynamic programming algorithm for selecting communities to find influential nodes . We also provide provable approximation guarantees for our algorithm . Empirical studies on a large real world mobile social network show that our algorithm is more than an order of magnitudes faster than the state of the art Greedy algorithm for finding top K influential nodes and the error of our approximate algorithm is small .
Categories and Subject Descriptors F22 [ Analysis of Algorithms and Problem Complexity ] : Nonnumerical Algorithms and Problems
General Terms Algorithms , Experimentation , Performance , Reliability
Keywords Social Networks , Community Detection , Influence Maximization ∗Corresponding author . Email : gjsong@cispkueducn
1 .
INTRODUCTION
A social network is a social structure connecting individuals or organizations . Examples of social networks include email networks , online FaceBook , and scientific collaboration networks[11 ] . A social network plays an important role as the spread of information and influence in the form of "word of mouth" [ 16 ] . It is a fundamental issue to find a small subset of influential individuals in a social network such that they can influence the largest number of people in the network [ 9 ] .
Finding a subset of influential individuals has many applications . Let us recall the motivating example given by Kempel et al . [ 10 ] . Consider a social network together with the estimates for the extent to which individuals influence one another , and the network performs as the platform for marketing . A company would like to market a new product , hoping it will be adopted by a large fraction of the network . The company plans to initially target a small number of "influential" individuals of the network by giving them free samples of the product ( the product is expensive or the company has limited budge so that they can only choose a small number of people ) . The company hopes that the initially selected users will recommend the product to their friends , their friends will influence their friends’ friends and so on , thus many individuals will ultimately adopt the new product through the powerful word of mouth effect ( or called viral marketing ) . The problem here is to choose a set of individuals to send the free samples such that they eventually influence the largest number of people in the network . Formally , the problem is called as influence maximization [ 10 ] , which is , for a parameter K , to find a K node set of maximum influence , where influence is propagated in the network according to a stochastic cascade model [ 10 ] .
Kempel et al . establishes that the optimization problem of influence maximization is NP hard [ 10 ] . They use the Greedy algorithm and prove that the optimal solution for influence maximization can be approximated to within a factor of ( 1 − 1 − ) . Their empirical study shows that the Greedy algorithm significantly outperforms the degree or centrality based heuristics in influence maximization . The main problem of Greedy algorithm is efficiency , especially when the social network contains a large number of nodes . Recently , Chen et al.[4 ] propose an improved version of Greedy algorithm , called NewGreedy . To make the result better , it takes the first round with NewGreedy algorithm and the rest rounds using CELF Greedy algorithm[14 ] , called MixedGreedy , which is shown to be more efficient than previously proposed Greedy algorithms[4 , 10 ] . However , finding a small set of influential nodes in a large network with 723k nodes could still take days to complete on a modern server ( as to be shown in our experiments ) . e
1039 In this paper , we tackle the problem of influence maximization in a Mobile Social Network ( MSN ) where individuals communicate with one another using mobile phones[7 ] . A MSN can be extracted from call logs and is modeled as a weighted directed graph : a phone user corresponds to a node ; a directed edge from node v to node u is established , if there exits communication from v to u , with the corresponding communication time as the weight of the edge .
We propose a new algorithm for mining top K influential nodes , called Community based Greedy Algorithm ( CGA ) . The basic idea is to exploit the community structure property of social networks . Intuitively , a community is a densely connected subset of nodes that are only sparsely linked to the remaining network [ 8 ] . Communities in a MSN represent real social groups [ 7 ] , and thus individuals in a community will influence each other in the form of "wordof mouth" . The prohibitive cost of finding influential nodes over the whole network would be reduced greatly if we find influential nodes with regard to communities .
The main technical challenge of exploiting community structures to find top K influential nodes is to choose which communities to mine the top K influential nodes such that the results can be as close as the optimal solution . A straightforward solution is to mine top K influential nodes in each community and then aggregate them to get the best K nodes . This is not desirable as it results in unnecessary computation . Instead we propose a dynamic programming method to incrementally choose which communities to process . Within a community we can adopt any existing algorithm to detect influential nodes . We also provide the provable approximation precision of our proposed solution .
Another technical issue is that we need an efficient algorithm to partition the network into communities based on information diffusion model[10 ] . There exist a number of algorithms [ 3,8,13,18,20 , 21 , 23 , 24 ] for community detection . However , none of them takes into account information diffusion between nodes . To this end , we extend the algorithm[18 ] running in O(E ) , where E is the number of edges , one of the most efficient algorithm for community partitioning , in three aspects : 1 ) We accommodate information diffusion model into the algorithm ; 2 ) The algorithm[18 ] is designed for undirected and unweighted graphs and needs to be extended for weighted directed graphs ; 3 ) The algorithm generates too many small dispersed communities and finding influential nodes with regard to the small communities is prone to errors . To remedy the problem , we extend the algorithm with a combination step : we define combination entropy to measure the connection of two communities and combine them if the combination entropy between them is larger than a threshold .
The proposed algorithm has two salient features . First , it can greatly improve the efficiency of the existing algorithms for finding top K influential nodes while the loss in approximation precision is small . Second , it is orthogonal to existing algorithms for finding influential nodes in that it can combine with any of them by using them to detect influential nodes in a community .
In summary our contributions are twofold . First , we propose a new algorithm for finding top K influential nodes ; the algorithm exploits the community property of social networks . We offer the provable performance guarantee of the algorithm . Second , we conduct experiments on a large mobile social network with 723K nodes ( the largest network used in previous work has 37K nodes ) to evaluate the performance of our algorithm . Experimental results show that our algorithm can improve the stateof the art Greedy algorithm[4 ] by orders of magnitude while the approximation ratio is comparable to the Greedy algorithm .
The remainder of this paper is organized as follows . Section 2 reviews related work . Section 3 presents problem statement . Sec tion 4 details the Community based Top K Greedy algorithm and analyzes the precision of the algorithm . We report a performance evaluation in Section 5 . Finally , we offer conclusions and research directions in Section 6 .
2 . RELATED WORK
Domingos and Richardson [ 6 ] are the first to study the influence maximization as an algorithmic problem and propose a probabilistic solution . Kempe et al . formulate the problem of finding a set of influential individuals as an optimization problem . They establish that the optimization problem is NP hard [ 10 ] , and present a Greedy Algorithm ( GA ) , guaranteeing that the influence degree is within ( 1 − 1 e ) of the optimal influence degree . The basic idea of the GA algorithm is to calculate the influence set of each individual , and take turns to choose the node maximizing the marginal influence value until K nodes are selected .
Leskovec et al.[14 ] present an optimized greedy algorithm , which is referred to as the "Cost Effective Lazy Forward" ( CELF ) scheme . The CELF optimization uses the submodularity property of the influence maximization objective to reduce the number of evaluations on the influence spread of nodes . Recently , Chen et al.[4 ] propose two faster greedy algorithms called NewGreedy and MixedGreedy , respectively . Experiments show that MixedGreedy slightly outperforms NewGreedy . The main idea behind NewGreedy is to remove the edges that will not contribute to propagation from the original graph to get a smaller graph and do the influence diffusion on the smaller graph . The first round of MixedGreedy uses NewGreedy algorithm , and the rest rounds employ CELF algorithm . An earlier approach proposed by Kimura et al . [ 12 ] also removes edges that do not contribute to information diffusion , and does the propagation on the subnetwork . In addition , Chen et al.[4 ] also presents a degree discount heuristic algorithm called DegreeDiscount that runs faster than MixedGreedy . DegreeDiscount assumes that the influence spread increases with the degree of nodes . Unlike Greedy algorithm , DegreeDiscount algorithm has no provable performance guarantee .
The aforementioned approaches attack the efficiency issue by either improving GA algorithm or using new heuristics . However none of them takes into consideration the community property of social networks .
We also note that Scripps et al.[20 , 21 ] present a metric to estimate the number of communities to which a node is attached and define community based roles for a node ( eg a node that links to many nodes from different communities takes a so called ambassador role ) . They also briefly discuss the application of communitybased roles , ie selecting nodes with an ambassador role to maximize the number of communities influenced by the selected nodes . The application problem is different from the influence maximization problem addressed in this paper and our algorithm is completely different from the approach [ 20 , 21 ] .
Our work is also related to community detection . There are a host of algorithms for community detection . However , it remains to be a challenging problem for a large social network . Some approaches assume that the number or size of the partitions into which the network is to be split is known in advance . They usually optimize a quality measure of network clustering , such as popular modularity measure [ 17 ] , and need to solve an NP complete problem . Some popular heuristic algorithms include min max cut method [ 3 ] , normalized cut [ 22 ] , SCAN[3 ] and Spectral Clustering[13 ] . In a Mobile Social Network , the number of communities and the size of communities are unknown . Also , these methods are quite expensive when applied to a large network . A hierarchical clustering method [ 5 ] is proposed with complexity O(Eh log N ) , where E
1040 is the number of edges , N the number of nodes and h the depth of hierarchical clusters . Raghavan et al . [ 18 ] propose a near linear algorithm running in O(E ) time , E the number of edges , which is less expensive than earlier algorithms . In [ 18 ] , it uses a simple label propagation algorithm that uses the network structure alone as its guide and requires neither optimizing an objective function nor prior information about the communities . However , none of existing approach takes into account information diffusion .
Although we focus on mobile social network in this paper , mobile social network reflects the properties of other scale free networks , such as paper citation graph , in which degrees follow the the power law distribution[19 ] , and so does link based similarity [ 2 ] , and thus the proposed techniques would be applicable to other scale free networks .
3 . PRELIMINARIES AND PROBLEM
STATEMENT
We introduce the Independent Cascade information diffusion model , and then the problem statement . Table 1 lists the notations to be used extensively in the rest of this paper .
Table 1 : Notation explanation
Notation G = ( V,E,W ) A weighted directed MSN with vertex set V , edge
Description
N E d K I Ci M λ R(A ) Rm(A ) set E and weight W The number of nodes in G The number of edges in G The average degree of the network The number of influential nodes to be mined The set of K influential nodes The ith community The number of communities The average diffusion speed Influence degree in G of nodes in set A Influence degree in community Cm of nodes in A
Mobile Social Networks . We extract a Mobile Social Network from the call log and model it as a directed weighted graph : a phone user corresponds to a node ; a directed edge from node u to node v is established , if there exits communication from u to v , with the corresponding communication time as the weight of the edge . We denoted the graph as G = ( V,E,W ) , where V , E , and W represent nodes , edges , and weights , respectively . Independent Cascade Model . The model is originally proposed by Lopez Pintado[15 ] , and is the most common dynamic model in information diffusion . It is widely used in maximizing the number of individuals who are influenced by the merchandize information in direct marketing . It is used in previous work on influence maximization [ 4 , 10 ] . In the model we assign two states to nodes : active and inactive . Active nodes are those that are influenced by other active nodes , and are able to influence their inactive neighbors ; inactive nodes are those that are not influenced by their active neighbors . The state of a node can be switched from being inactive to being active , but not vice versa . The model has an important parameter called diffusion speed λ . When an active node vi contacts an inactive node vj , the inactive node becomes active at a probability ( rate ) λ . In a viral marketing , diffusion speed models the tendency of individuals to accept a product . Thus the diffusion is affected by diffusion speed , node degree , and the number of initial active nodes .
The Independent Cascade model does not take edge weight into consideration . However , a mobile social network is a directed weighted graph , and the weight should play an important role in information diffusion . Intuitively , the more contacts between two nodes , the more likely the influence will happen . We extend the definition diffusion speed in the Independent Cascade model to accommodate the edge weight . The influence rate raises as the weight between nodes increases . We note that Weighted Independent Cascade model [ 10 ] , a special case of Independent Cascade model , considers node weight but not edge weight , and thus is still not directly applicable to a MSN . We also note that Kempe et al . [ 10 ] also considers Linear Threshold model . As proved in [ 9 ] , Linear Threshold model and Independent Cascade model can be unified with proper parameter initialization . We can extend the linear threshold model as we do for Independent Cascade model to accommodate edge weight , and our proposed algorithm is equally applicable .
DEFINITION 1 . ( Diffusion Speed . ) The diffusion speed from node vi to node vj λij is defined as :
λij = 2λ wij wmax + wmin
( 1 ) where λ is the average diffusion speed of the whole network , wij is the weight of direct edge from vi to vj , wmin is the minimum weight of directed edge and wmax the maximum weight in the network .
Then the diffusion mechanism can be described as follows : 1 . The diffusion process begins with an initial set of active nodes
A at step t=0 . Let S0 = A ;
2 . At each step t , an active node vi from last step St−1 will be given a single chance to influence each of its inactive neighbors vj , with success probability λij . If vj is successfully influenced , it is activated and is added set St .
3 . The process terminates when St is empty . The set of nodes influenced by A is the union of all the St generated at each step . We denote the number of nodes influenced by A as VA . DEFINITION 2 . ( Influence Degree ) Let A be the initial set of active nodes . The influence degree of set A is computed as :
R(A ) = VA/N
( 2 ) where VA is the number of nodes influenced by A during information diffusion process . ProblemStatement : Given a mobile social network G = ( V,E , W ) , we aim to mine a set of top K influential nodes S on the network such that R(S ) is maximized using the extended Independent Cascade information diffusion model .
It has been proved that the optimization problem is NP hard [ 10 ] . A greedy algorithm can approximate the optimum to within a factor of ( 1− 1 e ) . However , the greedy algorithm is expensive for solving the influence maximization problem on a large scale network . So we propose a community based greedy algorithm which mine the influential nodes in each community rather than the whole network .
4 . MINING TOP K INFLUENTIAL NODES We first present the proposed algorithm CGA for mining top K influential nodes in communities , and then present the partitioning algorithm that takes into account the diffusion model . We also provide precision analysis of the proposed algorithm .
1041 4.1 CGA:Community Based Greedy Algorithm
Although a greedy algorithm gives a good approximation to the problem of finding top K influential nodes , it is expensive for large networks .
We first present an important concept to be used in the rest of subsection . We say that a node v influences node u if node v activates node u , ie u becomes active from inactive , for at least Q/2 times out of Q simulations of the diffusion process of Independent Cascade model . We also say that u is influenced by v . Recall that whether v can influence u depends on the influence speed and also the weight from v to u .
The main idea of our method is to divide a network into communities , and then choose communities to find top K influential nodes within communities . The community structure is a salient property of social network features : Individuals within a community have frequent contact and thus are more likely to influence each other ; In contrast , individuals across communities have much less contact with each other and thus are less likely to influence each other . This property suggests that it might be a good approximation to choose influential nodes within communities instead of the whole network . Obviously it will be more efficient to choose influential nodes within communities .
Suppose that we already divide a network into M communities ( to be discussed in the next subsection ) . The remaining technical challenge is to choose which communities to find the top K influential nodes . A straightforward solution is to mine top K influential nodes in each community and then aggregate them to get the top K nodes . This is not desirable as it wastes some computation . We propose a dynamic programming algorithm to choose which community to find the kth influential node , k ∈ [ 1 , K ] . Let Ik−1 be the set of influential nodes obtained in the previous k 1 steps . We are then ready to compute the maximal increase of the influence degree with regard to community Cm if we mine the kth node in Cm . The maximal increase is denoted as ΔRm and we have : ΔRm = max{Rm(Ik−1 ∪ vj ) − Rm(Ik−1)|vj ∈ Cm} ( 3 ) Note that in Equation 3 the influence degree Rm( . ) is computed with regard to the community Cm rather than the whole network . To mine the kth influential node , we need to choose the community that will yield the largest increase of influence degree among all the communities . Let R[m , k ] ( m ∈ [ 1 , M ] and k ∈ [ 1 , K ] ) be the influence degree of mining the kth influential node in the first m communities . We have :
R[m , k ] = max{R[m − 1 , k ] , R[M , k − 1 ] + ΔRm}
( 4 )
R[m , 0 ] = 0 , R[0 , k ] = 0
( 5 ) The Equation 4 can be understood as follows : If the influence degree of mining the kth node in the first m 1 communities is smaller than that of mining the kth node in Cm , we mine the kth node in Cm ; otherwise , we mine it in the former m 1 communities . We select a community from the first m communities to mine the kth influential node , and the selected community is represented by a sign function s[m , k ] . It is defined as follows :
. s[m , k ] = s[m − 1 , k ] , R[m − 1 , k ] ≥ R[M , k − 1 ] + ΔRm R[m − 1 , k ] < R[M , k − 1 ] + ΔRm m , s[0 , k ] = 0
( 6 )
To find the kth , k ∈ [ 1 , K ] , influential node , we choose the community s[M , k ] ( Note that these sign functions s[m , k ] , m < M , are used to compute s[M , k] ) .
In principle , we can use any existing algorithm to find the kth influential node in community s[M , k ] . In this paper , we adopt the MixedGreedy algorithm [ 4 ] since it has the same approximation precision as previously proposed greedy algorithms and is shown to be more efficient .
R[m , 0 ] = 0 ; for m = 1 to M do
R[0 , k ] = 0 ; s[0 , k ] = 0 ;
Algorithm 1 CGA Algorithm Input : network G = ( V , E , W ) , size of results K , influence speed λ ; Output : I : Top K influential nodes ; 1 : C ← detect communities in G ; 2 : M = |C| 3 : I = I1 = I2 = = IM = ∅ ; 4 : for k = 1 to K do 5 : 6 : end for 7 : for m = 1 to M do 8 : 9 : end for 10 : for k = 1 to K do 11 : 12 : 13 : 14 : 15 : 16 : 17 : 18 : 19 : 20 : 21 : 22 : 23 : end for
ΔRm = max{Rm(I ∪ {vi} ) − Rm(I)|vi ∈ Cm} ; R[m , k ] = max{R[m − 1 , k ] , R[M , k − 1 ] + ΔRm} ; if R[m − 1 , k ] ≥ R[M , k − 1 ] + ΔRm then else end if end for j = s[M , k ] ; vmax = argmax vi∈Cj Ij = Ij ∪ {vmax} , I = I ∪ {vmax} ; s[m , k ] = s[m − 1 , k ] ; s[m , k ] = m ;
( Rj ( Ij ∪ {vi} ) − R(Ij ) )
The algorithm is outlined in Algorithm 1 . It first detects communities ( line 1 ) , and initializes the set of influential nodes discovered in the whole network ( I ) and in each community ( I1 , , IM ) as NULL ( line 3 ) . The algorithm initializes R[m , k ] and s[m , k ] ( lines 4–9 ) . In lines 10 – 19 , the algorithm chooses which community to mine kth influential node using dynamic programming algorithm . If the sum of the influence degree ΔRm and R[M , k−1 ] is smaller than R[m − 1 , k ] , ie the influence degree of mining kth node in the first m 1 communities ( line 14 ) , we should not find the kth node in community Cm and thus label s[m , k ] as s[m − 1 , k ] ( line 15 ) ; otherwise we mine the kth node in community Cm and set s[m , k ] as m ( line 17 ) . The algorithm will find the kth influential node in the community Cj , j= s[M , k ] ( line 20 ) . We employ MixedGreedy algorithm[4 ] to find the node vmax that maximizes Rj(Ij ∪ {vi} ) − R(Ij ) in community Cj ( line 21 ) . We proceed to illustrate the CGA Algorithm with an example . 1 . We mine top 2 nodes from a network . Assume that the network is partitioned into three communities C1,C2 , and C3 , and based on Independent Cascade model we have : the maximal influence degree increment , denoted by ΔR1 , ΔR2 and ΔR3 for each community , is 0.2 , 0.3 , 0.1 , respectively , for each community ; and the second most maximal influence degree increment is 0.08 , 0.06 , 0.04 , respectively , for each community . CGA works as follows :
2 . We proceed to find which community to mine top=1 node . R[1 , 1 ] = max{R[0 , 1 ] , R[3 , 0 ] + ΔR1} = 0.2 , s[1 , 1 ] = C1 ;
1042 R[2 , 1 ] = max{R[1 , 1 ] , R[3 , 0 ] + ΔR2} = max{0.2 , 0 + 0.3} = 0.3 , s[2 , 1 ] = C2 ; R[3 , 1 ] = max{R[2 , 1 ] , R[3 , 0 ] + ΔR3}= max{0.3 , 0.1} = 0.3 , s[3 , 1 ] = C2 ; Hence , we mine the top 1 node in community C2 because s[3 , 1 ] = C2 is the result .
3 . Next , R[1 , 2 ] = max{R[0 , 2 ] , R[3 , 1 ] + ΔR1} = max{0 , 0.3 + 0.2} = 0.5 , s[1 , 2 ] = C1 ; R[2 , 2 ] = max{R[1 , 2 ] , R[3 , 1]+ΔR2} = max{0.5 , 0.3+ 0.06} = 0.5 , s[2 , 2 ] = C1 ; R[3 , 2 ] = max{R[2 , 2 ] , R[3 , 1]+ΔR3} = max{0.5 , 0.3+ 0.1} = 0.5 , s[3 , 2 ] = C1 . Note that ΔR2 in this step is 0.06 , but not 03 We mine the second node in community C1 because s[3 , 2 ] = C1 .
Complexity Analysis : We consider the complexity of lines 2–23 of Algorithm 1 ( line 1 will be analyzed in next subsection ) . The algorithm needs O(K ) time in lines 4–6 , and O(M ) time in lines 7–9 . Suppose the largest community after community detection is Cp , thus lines 10–19 take O(M KTp ) time , and lines 20–23 of mining nodes using MixedGreedy algorithm [ 4 , 14 ] ( that uses NewGreedy [ 4 ] in the first round and uses CELF algorithm [ 14 ] for the rest rounds ) take O(K|Cp|Tp ) time , where Tp is the time to compute the influence degree of a node in community Cp , and it takes O(QEp ) time ( where Q is the number of simulations for the Independent Cascade model , and Ep is the number of edges in community Cp ) . Hence the worst case complexity of lines 2–23 of Algorithm 1 is O(M KTp + K|Cp|Tp ) . 4.2
Influential Model Based Community Detection Algorithm
Community structure is a basic property of a MSN and communities represent real circles of social groups in which members are more likely to influence each other[1 , 7 ] . We will make use of the detected communities to approximate the influence of nodes in the whole network . Hence , we want to detect communities based on the influences between nodes , rather than only the connection between nodes , such that the influence degree of nodes within a community can be as close as that in the whole network . There exist a number of algorithms for community detection , and they partition graphs based on the node connections . However , none of them takes into account information diffusion between nodes .
Our community detection algorithm consists of two steps , partition and combination . 1 ) Partition . we extend the algorithm[18 ] with the information influence mechanism based on Independent Cascade model . The algorithm[18 ] , a nearly linear algorithm for community detection , is designed for undirected and unweighted graph , and thus is not directly applicable to a MSN . 2 ) Combination . The generated communities in a MSN by the partition step are very small and dispersed ; we develop a method to combine communities such that the difference between influence degree of a node in its community and its influence degree in the whole network is restricted . We proceed to present the two steps . 421 Community Partition We proceed to present an overview of our partitioning method . 1 ) Initially , each node is assigned a unique community label from 1 to N ( the number of nodes ) ; 2 ) for each node we compute the set of its influenced neighbors using Independent Cascade diffusion model ; 3 ) we iteratively propagate the labels through the network in finite iterations . The main principle of the label propagation is that a node v should belong to the community that contains the maximum number of its influenced neighbors . In algorithm [ 18 ] , label propagation is performed among a node and its neighbors while we perform the propagation among a node and its neighbors that can be influenced by the node ( based on Independent Cascade model ) . Note that this principle also renders our community detection problem different from that considered in previous proposals , eg [ 18 ] . Steps 1 and 2 are straightforward and we proceed to explain the step 3 , ie to perform the propagation of community label . This propagation is iterative in nature . At each iteration of the label propagation , we assign the community label for a node v based on the labels of its neighbors that are influenced by v . Specifically , for each node v we find out the label of the community that the majority of its influenced neighbors belong to , and the label will become the label of v . Formally , the label , denoted by v.Ct , of a node v at iteration t is represented as follows :
) v.C t
= maxCMT(u1.C t−1 , u2.C t−1 , , usv .C t−1
( 7 ) where t denotes the tth iteration , sv denotes the number of neighbors that are influenced by v , ui ( i ∈ [ 1 , sv ] ) represents an influenced neighbor of node v , ui.C t−1 represents the community label of ui at iteration t 1 , and maxCMT is to compute the majority label of ui.C t−1 ( i ∈ [ 1 , sv] ) . The partition step is detailed in lines 1–16 in Algorithm 2 . The algorithm takes in three arguments , a network G , the number of iterations τ and a threshold θ to be used by the combination step . In the algorithm , a node v belongs to a community and its community label is denoted as vC Node v is also associated with a bit vector Hv of length dv that is the degree of node v . Each neighbor uj of v corresponds to a bit Hv(j ) , j = 1 , , dv , in Hv . If v influences its neighbor uj , the corresponding bit Hv(j ) is set to 1 and otherwise 0 . We can easily compute sv , the number of neighbors influenced by v , by counting the number of bit 1 in Hv . The algorithm initializes the community label of each node v and finds the set of neighbors that are influenced by node v in lines 1–10 . The function IsInfluence is implemented according to the definition of influence ( Section 41 ) The algorithm then iteratively propagates community labels in lines 11–16 : At each iteration t , we update the label of node v with the majority label of its neighbors that are influenced by v . It has been shown in[18 ] that the propagation will become relatively stable in a few iterations . 422 Community Combination We expect that the difference between the node ’s influence degree in its community and its influence degree in the whole network is small . To achieve a good set of top K influential nodes with a good influence degree in our algorithm , we define combination entropy to measure the connections of two communities and combine two communities if the combination entropy between them is larger than a threshold .
DEFINITION 3 . ( CombinationEntropy ) If a node v influences ( activates ) its neighbor u , we label the edge evu as live [ 10 ] . If evu is live and v belongs to community Cm , but u belongs to a different community Cl , we say that u is a live node of Cm . Let L[Cm ] be the set of live nodes of Cm . The combination entropy of community Cl to Cm is defined as :
CoEntropy(CE l m ) = v∈Cm,u∈L[Cm],u∈Cl max
Rm({u} ) Rm({v} )
, where Rm({u} ) denotes the influence degree of node u outside the community Cm , and Rm({v} ) denotes the influence degree of node
1043 else
Hv(j ) = 0 ;
Hv(j ) = 1 ; end if end for for each v ∈ V do end for t = t + 1 ; v.Ct = maxCMT(u1.Ct−1 , u2.Ct−1 , , usv .Ct−1 ) ; v.C0 ← a distinct community label ; for each neighbor uj of v do if IsInfluence(v , uj ) then
Algorithm 2 Community Detection Input : G = ( V , E , W ) , threshold θ , number of iterations τ ; Output : the set of communities C ; 1 : for each v ∈ V do 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : 10 : end for 11 : for t =1 to τ do 12 : 13 : 14 : 15 : 16 : end for 17 : L[Ci ] = ∅ , i ∈ [ 1 , Z ] ; {Z is the number of communities from Step 1} 18 : for each v ∈ V do 19 : 20 : 21 : 22 : 23 : 24 : end for 25 : isComb = 1 ; 26 : while isComb = 1 do 27 : 28 : 29 : 30 : 31 : for each community Cm do S = {u.C|u ∈ L[Cm]} ; isComb = 0 ; for each Cl ∈ S do Compute combination entropy CoEntropy(CE l munity Cl if ( CoEntropy(CE l for each neighbor uj , j ∈ [ 1 , dv ] , of v do if ( (v.C = uj .C ) and ( Hv(j ) = 1 ) ) then end if end for
L[Ci ] = L[Ci ] ∪ {uj} ;
{The following is the combination step} m ) for com m ) > θ ) then
Integrate Cl into Cm and update Cm ; isComb=1 ;
32 : 33 : 34 : 35 : 36 : 37 : end for 38 : end while end if end for v in its community Cm . As we detect the communities based on diffusion model , we have Rm({u} ) ≈ Rl({u} ) . For a node v in Cm , L[Cm ] includes its influenced neighbors such that they will make diffusion degree of v with regard to Cm different from diffusion degree of v with regard to the whole network . Intuitively , combination entropy measures the difference of diffusion spread of a node v ( v in Cm ) between in the community and in the whole network through a node in L[Cm ] . The difference reflects the precision loss due to diffusion within communities . We set a threshold θ . If the combination entropy CoEntropy ( CE l m ) of community Cm to community Cl is bigger than θ , then Cm and Cl will be combined . The combination step is outlined in lines 17–38 in Algorithm 2 . In lines 17–24 , we compute the set L[Cm ] for each community . The algorithm checks each node in L[Cm ] set and decides whether Cl is combined into community Cm ( lines 25–38 ) . To make sure the combination entropy between any two communities is less than θ , we perform the combination iteratively . We use a variable isComb to record whether two communities are combined in each iteration ; if no combination is done in an iteration ( isComb =0 ) , we terminate the while loop .
Complexity Analysis : It needs O(EQ ) time in lines 1–10 , where Q , the rounds of simulations , is constant . Lines 11–16 need O(Eτ ) time , where τ is constant . Lines 17–24 needs O(E ) time . Let Z and M denote the number of communities before and after combination , respectively . Let Cp be the maximal community . Recall that computing the influence degree for one node in Cp take Tp time . Lines 25–38 take O((Z − M )N Tp ) time in the worst case : the number of iterations is Z M in the worst case ; each iteration takes O(N Tp ) time in the worst case , where we compute influence degree at N nodes at most . Note that in practice it will be much less expensive than the worst case complexity since it is very likely that we do not need to compute influence degree for all nodes , and the number of iterations is smaller than Z M , and many communities are smaller than the maximal community Cp . Hence the worst case complexity of Algorithm2 is O(E+(Z−M )N Tp ) . Taken together with the complexity of Algorithm1 , the total worst case complexity is O(E + ( Z − M )N Tp + M KTp + K|Cp|Tp ) . 4.3 Precision Analysis of CGA
We proceed to derive the performance guarantee of the CGA by analyzing the approximation ratio of CGA .
LEMMA 1 . Consider a node v in community Cm . The influence degree Rm({v} ) of node v in its community is 1+Δd∗θ approximate to the influence degree in the whole network G , where θ is the threshold used in the combination step in Algorithm 2 and Δd is the maximal difference between the number of nodes affected by a node in network G and that in community Cm . We have
1
Rm({v} ) ≥
1
1 + Δd ∗ θ
R({v} )
( 8 )
PROOF . Let ΔR({v} ) = R({v})− Rm({v} ) be the difference of the diffusion degree in Cm and G . As the combination is based on combination entropy CoEntropy(CE l m ) and follows threshold θ , we have the following :
ΔR({v} ) = R({v} ) − Rm({v} ) fi fi
Rm({u} ) ≤
θ ∗ Rm({v} )
= u∈L[Cm ] u∈L[Cm ]
= ( d[v ] − dm[v])θ ∗ Rm({v} ) = Δd[v ] ∗ θ ∗ Rm({v} ) where d[v ] denotes the number of active neighbors of node v influenced by v in the whole network , dm[v ] denotes the number of active neighbors of node v influenced by v in the community Cm and Δd[v ] = d[v ] − dm[v ] . Thus , we have Rm({v} ) ≥
R({v} ) ≥
R({v} ) .
1
1
1 + Δd[v ] ∗ θ
1 + Δd ∗ θ
We get the proof . When the directed weighted mobile social network G = ( V,E,W ) and diffusion speed λ are given , the number of neighbors that a node can activate in network G or a community can be estimated . Thus Δd is a small number . θ is a constant .
2
THEOREM 1 . Let I∗ be the set of K nodes that maximize the influence degree , ie the optimal solution to our problem ; let I be the set of K nodes discovered by our algorithm ; let R(I∗ ) and R(I ) be the influence degree of the two sets , respectively . The proposed CGA obtains a ( 1 − e− 1 1+ΔdΘ ) approximation , that is 1+ΔdΘ )R(I∗ R(I ) ≥ ( 1 − e− 1
)
( 9 )
1044 PROOF . Let Rm({vi} ) be the influence degree of node vi in community Cm and R({vi} ) be the influence degree of node in the whole network . Let I(k ) be the first k nodes in I . Let the kth node in I be vk . At least R(I∗ ) − R(I(k − 1 ) ) individuals that are not covered by R(I(k− 1 ) ) are covered by the k subsets of R(I∗ )[16 ] . Hence , according to the pigeonhole principle , one of the k subsets in the optimal solution must cover at least R(I∗(k))−R(I(k−1 ) ) individuals[16 ] . As we spread the diffusion in community Cm , the influence degree of vk , R({vk} ) ≥ R(I∗(k))−R(I(k−1 ) ) . From the above analysis , we have R(I(1 ) ) ≥ R(I∗(K ) ) K(1+Δdθ ) . Thus , we have the following deduction process : k(1+Δdθ ) k
R(I(K ) ) = R(I(K − 1 ) ) + R{vK}
R(I∗(K))−R(I(K−1 ) )
≥ R(I(K − 1 ) ) + = ( 1 − ≥ ( 1 −
1
K(1+Δdθ )
K(1+Δdθ ) )R(I(K − 1 ) ) + K(1+Δdθ ) )2R(I(K − 2))+ R(I∗(K ) ) k(1+Δdθ )
K(1+Δdθ ) ) )
1
1
R(I∗(K ) ) K(1+Δdθ )
( 1 + ( 1 − ≥ ( 1 − 'K−2 i=0 ( 1 − ≥ ( 1 − ( 1 −
1
K(1+Δdθ ) )K−1R(I(1))+ K(1+Δdθ ) )i R(I∗(K ) ) K(1+Δdθ ) )K )R(I∗ K(1+Δdθ ) ( K ) )
1
1 k→∞(1 − lim
1
K(1+Δdθ ) )K = lim k→∞((1 − k→∞(1 −
= ( lim = e− 1
1+Δdθ
1
K(1+Δdθ ) )K(1+Δdθ ) ) K(1+Δdθ ) )K(1+Δdθ ) )
1
1
1+Δdθ
1
1+Δdθ
1
1
1+Δdθ
As f ( K ) = ( 1 − tion , e− 1 is the lower bound of 1 − ( 1 − e− 1
1+Δdθ is the upper bound of f ( K ) . Hence 1 − e− 1
K(1+Δdθ ) )K is a monotone increasing funcK(1+Δdθ ) )K . So R(I ) ≥ ( 1 −
) . We get the proof .
1+ΔdΘ )R(I∗ Based on Theorem 1 , we can derive that CGA is a more general formulation compared with greedy algorithm for mining top K influential nodes in social networks . When θ=0 , as K approaches ∞ , the approximation factor ( 1 − ( 1 − K(1+Δdθ ) )K ) will become ( 1 − 1/e ) , the approximation factor of Greedy Algorithm ( GA ) . It shows the lower bound of our CGA is ( 1 − 1/e ) at θ = 0 , which is the same precision with that of GA . This is to say that GA is an instance of CGA .
Remarks : The parameter θ actually plays a role in balancing the approximation precision and efficacy . When θ = 0 , the number of generated communities will be 1 , ie all communities will be combined into one , our algorithm is the same as the original Greedy algorithm with ( 1 − 1/e) approximation . If θ > 0 , we have ( 1 − e− 1 1+Δdθ ) approximation . As θ becomes smaller , the precision becomes higher ; the number of generated communities M will become smaller and thus the complexity becomes larger .
1
5 . EXPERIMENTS
We evaluate the effectiveness and efficiency of the proposed CGA algorithm .
The data sets we used and experimental setup beforehand are described at first , and then the results with different parameters are shown .
All the experiments were conducted on a server with 2.0 GHz Intel Xeon 8 Core CPU and 8G memory running Debian/4.0 Operating system .
Figure 1 : Degree distribution of mobile social network
5.1 Experimental setup 511 Data Sets We have a three month CDR ( call detailed record ) data of a city from China Mobile , the largest mobile communication service provider in China . We extract a Mobile Social Network from the CDR data using the method presented in Section 3 , and obtain a network with 723,201 nodes and an average degree of 134 Figure 1 shows the degree distribution of the mobile social network . We can see that it follows the power law distribution , ie it is a scale free network as many other social networks . 512 Algorithms and Parameters We take MixedGreedy [ 4 ] as the benchmark to evaluate the proposed algorithm CGA for two reasons . First , MixedGreedy is the state of the art Greedy Algorithm for influence maximization , and it is shown that MixedGreedy outperforms previously proposed Greedy Algorithms , such as GA[10 ] and CELF[14 ] . Second , CGA adopts MixedGreedy to find influential nodes within communities , and thus a performance comparison between them will reveal their pros and cons .
Additionally , we compare with the other greedy algorithm proposed by Chen et al . NewGreedy[4 ] . We also compare with two heuristic algorithms DegreeDiscount[4 ] ( See related work ) and Random ( simply select K random nodes in the graph ; it is evaluated in [ 4 , 10] ) . To study the usefulness of the proposed community detection algorithm for CGA , we modify the algorithm CGA by replacing its community detection method ( Section 3.2 ) with the community detection algorithm in [ 18 ] , and the modified CGA is denoted as SPCGA .
We use two metrics to evaluate performance , namely the influence degree and runtime , by following the previous work on influence maximization .
We also evaluate the effect of parameters on performance , including the number of required nodes ( K ) , the average influence speed ( λ ) , and the threshold for community combination ( θ ) . For parameters K and λ , we take both the previous work [ 4,12 ] and our actual network into consideration to choose the range of values . 5.2 Experimental Results 521 Experiment on community detection This experiment is to evaluate the performance of the proposed community detection algorithm on a Mobile Social Network . In the Independent Cascade diffusion model , we use the diffusion speed 0.05 , and set the number of simulations as 100 ; a neighbor of a node is influenced by the node if the neighbor is activated by the node for at least 50 times in 100 simulations . To choose a value for the parameter θ , the threshold for combination , we do experiment on a sub graph with 1000 nodes ( we randomly select a node from the whole MSN , and do a depth first traversal starting from the se
1045 As expected , the two heuristic methods run much faster than all greedy algorithms , especially Random needs only around 3 seconds . However , they perform poorly in terms of influence degree . This is consistent with the experimental results reported in previous work[4 , 10]—"significantly better marketing results can be obtained by explicitly considering the dynamics of information in a network , rather than relying solely on structural properties of the graph[10]." This would also explain why the greedy algorithms are proposed and used for influence maximization in previous work although heuristic methods run faster . The heuristic methods do not take information influence model into consideration , and they cannot guarantee the precision .
We find that CGA outperforms SPCGA in terms of influence degree while their runtime is similar . The only difference between them is community detection method . Hence , this demonstrates the usefulness of the proposed community detection method of CGA in finding top K influential nodes .
523 Varying the diffusion speed λ This experiment is to compare with other algorithms in terms of influence degree and efficiency when we vary the average diffusion speed λ . We vary λ from 0.01 to 0.10 ( 0.01 , 0.1 are used in [ 4,12] ) . This experiment is conducted on the whole network with 723,201 nodes and we set K = 20 . Figures 3(b ) and 4(b ) show the influence degree and runtime of different algorithms , respectively . Note that we use logarithmic scale for y axis in Figure 4(b ) .
Figure 3(b ) shows that the influence degree of CGA is very close to the influence degree of MixedGreedy and NewGreedy at all values of λ . We observe that the influence degree of the two methods is nearly the same when λ < 0.07 ( although it cannot be seen clearly in the figure ) ; the influence degree disparity between CGA and MixedGreedy becomes a bit larger as we increase the diffusion speed . This is because as the influence speed increases , a node in one community is more likely to influence the nodes in other communities , and thus the approximation of CGA would become less accurate .
Figure 4(b ) shows that CGA runs orders of magnitude faster than MixedGreedy . We also find that when we increase λ the efficiency of MixedGreedy drops quickly ( almost exponentially ) while the runtime of CGA only increases slightly .
As the size of community is much smaller than the size of the whole network , increasing λ would incur much more computation on the whole network than each community . This would explain why the runtime of MixedGreedy increases nearly exponentially while the runtime of CGA only increases moderately . When λ is smaller than 0.02 , our CGA costs more time than MixedGreedy , this is because our CGA includes community detection time , the community detection time is relative large when λ is very small . So CGA shows its advantages when λ is larger than 002 When λ is larger than 0.06 , experiments on MixedGreedy and NewGreedy cannot complete in 10 days , and thus we do not give the runtime in Figure 4(b ) .
It can be seen that the influence degree ( precision ) of DegreeDiscount and Random is much worse than those of greedy algorithms . For example , at λ = 0.01 , the influence degree of DegreeDiscount ( resp . Random ) is 40.42 % ( resp . 29.87 % ) of that of MixedGreedy while CGA is 95.44 % of MixedGreedy .
As expected , DegreeDiscount and Random are much faster than all greedy algorithms that take into account Independent Cascade model . However , their precision is much worse than that of greedy algorithms , rendering the heuristic algorithms less attractive than greedy algorithms [ 10 ] .
Figure 2 : Size distribution of extracted communities lected node to get 1000 nodes ) . We do experiment with different θ from 0.1 to 0.6 to combine the communities generated in the partition step . When θ=0.1 , all the communities are combined ; when θ=0.2 , most of the communities are combined and the number of final communities is only 5 ; when θ=0.5 , the generated communities are dispersed and small ( 24 of them have less than 10 nodes ) ; when θ=0.3 , we get 11 communities and this appear to be an appropriate number after we check the data manually . Hence we set θ=0.3 as the threshold . Another parameter to be set is the number of iterations . It is suggested that the partitioning result would usually become relatively stable after 5 iterations in [ 18 ] . We observe that it is not completely stable after 5 iterations , ie the partitions of some nodes are still changed . To be safe , we set the number of iterations at 20 to make it more stable .
It takes 8,702 seconds for the proposed community detection algorithm to complete on the whole graph . In this paper , we take the runtime of community detection as part of runtime of CGA algorithm . However , in practice the community detection could be regarded as a pre processing step since after the community detection is done we can find top K nodes with different K values . The algorithm partitions the whole network into communities . It returns 36 communities(ignoring very small communities ) , among which the size of the largest community is 95,690 and the others are smaller . The size distribution of extracted communities is shown in Figure 2 . 522 This experiment is to evaluate the effect of the parameter K on the influence degree and efficiency of different algorithms . We fix the average influence speed λ at 0.05 , network size at 723k and combination threshold at 03 We vary K from 1 to 30 . The results are shown in Figure 3(a ) and 4(a ) . Note that the reported runtimes of CGA and SPCGA include the time used to detect communities , which are 8,702 seconds and 1,714 seconds , respectively . Note that we use logarithmic scale for y axis in Figure 4(a ) .
Varying K
It can be seen in Figure 3(a ) that 1 ) the influence degree of CGA is close to those of MixedGreedy and NewGreedy ( the curve of MixedGreedy is almost overlapping with that of NewGreedy ) at all values of K , and 2 ) the influence degree of CGA is much better than those of two heuristic methods DegreeDiscount and Random . For example , at K= 20 , the influence degree of CGA is 89.96 % of that of MixedGreedy while the influence degree of DegreeDiscount ( resp . Random ) is only 57.62 % ( resp . 55.72 % ) of that of MixedGreedy .
We also observe in Figure 4(a ) that CGA is orders of magnitude faster than MixedGreedy . For example , at K= 20 , CGA is 14.56 times faster than MixedGreedy . This is because CGA finds influential nodes in several communities , following the divide andconquer principle ; however MixedGreedy is based on the whole network . We also find that the speedup factor increases as we increase the value of K .
1046 ( a ) Varying the size of results K
( b ) Varying λ
Figure 3 : Influence Degree
( c ) Scalability
( a ) Varying the size of results K
( b ) Varying λ Figure 4 : Runtime
( c ) Scalability
Table 2 : Community number M versus θ 0.6 0 θ M 1 127
0.2 25
0.1 9
0.3 36
0.4 55
0.5 86
Scalability with the network size N
524 The objective of this experiment is to evaluate the scalability of CGA and other algorithms when we increase the network size . We set diffusion speed λ at 0.05 and K at 20 . Figure 3(c ) and Figure 4(c ) show the results of influence degree and runtime , respectively , when we vary the network size N from 10K to 100K . Here we randomly select a node , and then starting from the node do a bread first traversal to generate subnetworks of different sizes .
Figure 3(c ) shows the influence degree is relatively stable across the networks of different sizes for all the methods . It is consistent with the previous experiments that the precision of the two heuristic methods is much worse than that of greedy algorithms . We can see from Figure 4(c ) that the runtime of both CGA and MixedGreedy increases with the increase of network size ; however CGA scales better than MixedGreedy .
525 Varying θ This experiment is to evaluate the effect of community combination threshold θ ( ie , the number of network communities in MSN ) on the performance of CGA . This experiment is conducted on the whole network with 723,201 nodes and we set K = 20 and λ=005 Since this experiment is to study the effect of θ on CGA , we do not compare with MixedGreedy .
Table 2 gives the number of communities detected when we increase θ from 0 to 06 The results of influence degree and runtime are shown in Figures 5(a ) and 5(b ) , respectively .
( a ) Influence degree
( b ) Runtime
Figure 5 : Varying θ
As shown in Figure 5(a ) , the influence degree drops slowly as we increase θ . The reason is that CGA finds influential nodes within a community and does not consider the influences on nodes in other communities ; thus as the network is partitioned into more communities , the precision of CGA will drop . Figure 5(b ) shows that CGA runs faster with the increase of θ . The reason is that with the increase of θ , more communities will be generated and the average size of community will be smaller , thus CGA will run faster .
We observe that θ plays a tradeoff between the runtime and influence degree : with the increase of θ , CGA achieves better efficiency but at the price of slight loss of influence degree . For example , when we increase θ from 0.1 to 0.5 , CGA runs about 39.63 times faster , while the influence spread drops about 3825 % This is consistent with our theoretical analysis in Section 4 . Note that when θ is 0 , CGA works on the whole network and is actually the same as MixedGreedy .
1047 6 . CONCLUSIONS AND FUTURE WORK In this paper we propose a new algorithm called Communitybased Greedy algorithm for mining top K influential nodes in a MSN . We first extend the basic Independent Cascade model to take weight edge of MSN into consideration . CGA has two main components , an algorithm for detecting communities by taking into account information diffusion , and a dynamic programming algorithm for selecting communities to find influential nodes . We also provide provable approximation guarantees for CGA . Empirical studies on a large real world mobile social network show that our algorithm is more than an order of magnitudes faster than the stateof the art Greedy algorithm for finding top K influential nodes and the error of CGA is small compared with Greedy algorithm .
This work opens to several interesting directions for future work . Notably , it is relevant to take spatial information of mobile customers into consideration , and construct locations based social networks to find influential nodes ; it is also interesting to study the evolution of influential nodes over time .
7 . ACKNOWLEDGMENTS
This work is supported by the National Natural Science Foundation of China ( 60703066 , 60874082 ) , and Beijing municipal natural science foundation ( 4102026 ) .
8 . REFERENCES [ 1 ] R . Albert and A . L . Barabasi . Statistical mechanics of complex networks . In Reviews of Modern Physics , 74 , pages 47 97 , 2002 . [ 2 ] Y . Cai , G . Cong , X . Jia , H . Liu , J . He , J . Lu , and X . Du . Efficient algorithm for computing link based similarity in real world networks . In ICDM , pages 734 739 , 2009 .
[ 3 ] J . Chen , O . R . Zaiane , and R . Goebel . Detecting communities in social networks using max min modularity . In SIAM , 2009 .
[ 4 ] W . Chen , Y . Wang , and S . Yang . Efficient influence maximization in social networks . In KDD , pages 199 208 , 2009 .
[ 5 ] A . Clauset , M . E . J . Newman , and C . Moore . Finding community structure in very large networks . Physical Review E , 70 , 2004 . [ 6 ] P . Domingos and M . Richardson . Mining the network value of customers . In KDD , pages 57 66 , 2001 .
[ 7 ] Z . B . Dong , G . J . Song , K . Q . Xie , and J . Y . Wang . An experimental study of large scale mobile social network . In WWW , pages 1175 1176 , 2009 .
[ 8 ] M . Girvan and M . E . J . Newman . Community structure in social and biological networks . In ProcNatlAcadSciUSA 99 , pages 7821 7826 , 2002 .
[ 9 ] D . Kempe , J . Kleinberg , and E . Tardos . Influential nodes in a diffusion model for social networks . In International colloquium on automata , languages and programming No32 , pages 1127 1138 , 2005 .
[ 10 ] D . Kempel , J . Kleinberg , and E . Tardos . Maximizing the spread of inffluence through a social network . In ACM SIGKDD , pages 137 146 , 2003 .
[ 11 ] M . Kimura and K . Saito . Tractable models for information diffusion in social networks . In PKDD 2006 , LNAI 4213 , pages 259 271 , 2006 . [ 12 ] M . Kimura , K . Saito , and R . Nakano . Extracting influential nodes for information diffusion on social network . In AAAI , pages 1371 1376 , 2007 .
[ 13 ] M . Kurucz , A . Benczur , K . Csalogany , and L . Lukacs . Spectral clustering in telephone call graphs . In SNAKDD , pages 82 91 , 2007 . [ 14 ] J . Leskovec , A . Krause , C . Guestrin , C . Faloutsos , J . VanBriesen , and
N . S . Glance . Cost effective outbreak detection in networks . In In Proc . SIGKDD , pages 420 429 , 2007 .
[ 15 ] D . Lopez Pintado . Diffusion in complex social networks . In Journal of Economic Literature , pages 573 590 , 2004 .
[ 16 ] H . Ma , H . Yang , M . R . Lyu , and I . King . Mining social networks using heat diffusion processes for marketing candidates selection . In CIKM , pages 233 242 , 2008 .
[ 17 ] M . E . J . Newman and M . Girvan . Finding and evaluating community structure in networks . Physical Review E , 69 , 2004 .
[ 18 ] U . N . Raghavan , R . Albert , and S . Kumara . Near linear time algorithm to detect community structures in large scale networks . In PhysRevE76 , 2007 .
[ 19 ] S . Redner . How popular is your paper ? An empirical study of the citation distribution . European Physical Journal B , 4:131 134 , Aug . 1998 .
[ 20 ] J . Scripps , P . N . Tan , and A . H . Esfahanian . Exploration of link structure and community based node roles in network analysis . In Data Mining , IEEE International Conference , pages 649 654 , 2007 .
[ 21 ] J . Scripps , P . N . Tan , and A . H . Esfahanian . Node roles and community structure in networks . In Joint 9th WEBKDD , pages 26 35 , 2007 .
[ 22 ] J . Shi and J . Malik . Normalized cuts and image segmentation . IEEE
Trans . Pattern Anal . Mach . Intell . , 22(8):888 905 , 2000 .
[ 23 ] L . Wan , J . Liao , and X . Zhu . Cdpm : Finding and evaluating community structure in social networks . In ADMA , pages 620 627 , 2008 .
[ 24 ] X . Xu , N . Yuruk , Z . Feng , and T . A . J . Schweiger . Scan : A structural clustering algorithm for networks . In KDD , pages 824 833 , 2007 .
1048
