k Support Anonymity Based on Pseudo Taxonomy for
Outsourcing of Frequent Itemset Mining
Chih Hua Tai,†,‡ Philip S . Yu,‡ Ming Syan Chen†,§
†Department of Electrical Engineering , National Taiwan University , Taipei , Taiwan
‡Department of Computer Science , University of Illinois at Chicago , Chicago , IL 60607
§Research Center for Information Technology Innovation , Academia Sinica , Taiwan hana@arboreentuedutw , psyu@uic.edu , mschen@cceentuedutw
ABSTRACT For any outsourcing service , privacy is a major concern . This paper focuses on outsourcing frequent itemset mining and examines the issue on how to protect privacy against the case where the attackers have precise knowledge on the supports of some items . We propose a new approach referred to as k support anonymity to protect each sensitive item with k − 1 other items of similar support . To achieve k support anonymity , we introduce a pseudo taxonomy tree and have the third party mine the generalized frequent itemsets under the corresponding generalized association rules instead of association rules . The pseudo taxonomy is a construct to facilitate hiding of the original items , where each original item can map to either a leaf node or an internal node in the taxonomy tree . The rationale for this approach is that with a taxonomy tree , the k nodes to satisfy the ksupport anonymity may be any k nodes in the taxonomy tree with the appropriate supports . So this approach can provide more candidates for k support anonymity with limited fake items as only the leaf nodes , not the internal nodes , of the taxonomy tree need to appear in the transactions . Otherwise for the association rule mining , the k nodes to satisfy the k support anonymity have to correspond to the leaf nodes in the taxonomy tree . This is far more restricted . The challenge is thus on how to generate the pseudo taxonomy tree to facilitate k support anonymity and to ensure the conservation of original frequent itemsets . The experimental results showed that our methods of k support anonymity can achieve very good privacy protection with moderate storage overhead .
Categories and Subject Descriptors H28 [ Database Management ] : Database Applications— Data Mining
General Terms Algorithms
Keywords frequent itemsets , privacy , outsourcing
1 .
INTRODUCTION
In recent years , an increasing number of people in various fields such as business , networks , bioinformatics and to name a few are interested in data mining due to its great promise [ 4 , 8 , 22 ] . For those who lack of expertise in data mining and/or computational resources , they have the need of outsourcing data mining tasks to a professional third party . At the same time , the advance of cloud computing [ 3 ] also facilitates the providing of outsourcing services , especially for the computational intensive tasks . We note that the frequent itemset mining could be very time consuming if the dataset or the pattern is long [ 22 , 24 ] .
For the problem of outsourcing frequent itemset mining , a data owner concerns most about ( 1 ) the correctness and completeness of the mining results and ( 2 ) the privacy protection of sensitive information , including the raw data and the frequent itemsets . The perturbation approaches [ 2 , 5 ] and the bloom filter approaches [ 9 , 17 ] require the sacrifice of the precise mining results for better privacy protection , while the encryption approach [ 23 ] provides much privacy protection under the conservation of precise mining results . To best of our knowledge , the work in [ 23 ] is the first encryption solution to the security in the outsourcing of precise association rule mining , which is closely related to the outsourcing of frequent itemset mining since one must get frequent itemsets first for finding association rules . Their method encrypts real items by a mapping function , and adds fake items independently into the encrypted transactions to enlarge the search space of inverse item mappings to enhance the protection . However , a very recent work in [ 15 ] noted that the independently added fake items can be removed by detecting the low correlations between items , and showed some success in re identifying top frequent items .
The challenge of privacy protection in the outsourcing frequent itemset mining is that , since a third party is professional in data mining , he may learn knowledge about frequent itemsets and the support information from his past experience [ 14 ] . Then , not only the frequent itemsets are clues to the decryption , but also the support information
473 can drastically reduce the search space of possible inverse mappings of an encrypted item . Especially , top frequent items are usually unique within a range of their supports and thus can be easily identified by exact or approximate support information . That is , in the worst case , there could be only one possible inversion for an encrypted item of a particular support or within a small support range .
Defending against attacks of support information , we note that still another approach to privacy protection is the group based approach which hides individual entity behind a group of entities . There are many variations to this approach , including k anonymity [ 18 ] , l diversity [ 12 ] , t closeness [ 10 ] , etc . This approach has been applied to not only conventional database records , but also other types of data like graphs or social networks [ 11 , 16 ] . We then adopt the idea of k anonymity in our encrpytion scheme .
Specifically , this paper studies the problem of enhancing the security in outsourcing frequent itemset mining under the conservation of precise mining results . We assume an experienced attacker referred to as an α knowledgeable attacker , who knows not only α % of the frequent items but also the exact support information of the known frequent items . To defend an α knowledgeable attacker , we introduce the ksupport anonymity to protect each encrypted sensitive item with k − 1 other encrypted items of similar support . The insight is that it is difficult for a data owner to estimate how much knowledge a malicious third party has . However , the protection against precise supports can indicate the protections against approximate supports and top frequent items , which are much easier for the third party to learn from his background knowledge . That is , if there are k items with the same support sup(x ) in the encrypted database to prevent unique identification of each real item x by its exact support , there are at least k items with a support within the range [ sup(x ) − δ , sup(x ) + δ ] . Similarly , there are also k items in the encrypted database as frequent as a top frequent real item . Therefore , our purpose is then to achieve the ksupport anonymity and retain all original frequent itemsets in the encrypted database for outsourcing frequent itemset mining .
Fig 1 is an overview of a straightforward scheme for outsourcing frequent itemset mining . The naive solution to the problem of k support anonymity is to introduce many fake item occurrences into the encrypted database so that the fake items can have the same support as the sensitive items . However , this method suffers from unreasonable large overhead in the dataset size when a large k support anonymity is required .
Alternatively , our method is to introduce a pseudo taxonomy tree and have the third party mine the frequent itemsets under generalized association rules [ 7 , 20 ] , referred to as the generalized frequent itemsets , instead . Fig 2 is the overview of our scheme . The pseudo taxonomy is an artificial construct to facilitate hiding of the original items and to achieve better storage efficiency . The rationale for this approach is that we can hide each original item in either a leaf node or an internal node , and make other nodes in the taxonomy tree as cohorts for k support anonymity . Note that an internal node does not directly appear in the transactions , but gets supports from a set of transactions inferred through the taxonomy . By using internal nodes in the taxonomy tree , we can avoid expanding the transaction database due to the fake items . In addition , note that fake items here are added according to the pseudo taxonomy tree . Since fake items are not independent from other items , the attack method in [ 15 ] cannot break our encryption . The challenge is then on how to generate the pseudo taxonomy tree to facilitate k support anonymity and to ensure the conservation of original frequent itemsets . The experimental results showed that our methods of the k support anonymity can achieve very good privacy protection with moderate storage overhead .
Figure 1 : A general scheme of outsourcing frequent itemset mining .
Figure 2 : The scheme of our approach .
2 . PRELIMINARY 2.1 Problem Statement
Let I be a set of items , and TI is a transaction database where each transaction t is a subset of I . A transaction t contains an itemset X if and only if X is a subset of t . The support of X in TI , denoted as supTI ( X ) , is the number of transactions in TI containing X . An itemset X is frequent if the support of X is not less than the given minimal support . The problem of mining frequent itemsets is to discover all the frequent itemsets in TI .
Our purpose in this paper is to protect the security in the outsourcing of frequent itemset mining against an experienced attacker . The attacker can learn knowledge about the database TI from his past experiences and background knowledge .
Definition 1 . ( α knowledgeable attacker ) Let L be the set of frequent items in TI , and αL be the set containing α % of frequent items in L . An attacker is α knowledgeable if he knows αL and the exact support information of the known frequent items .
The encryption of the original database is an effective way to shelter original data from the attacker . To ensure ( 1 ) the correctness and completeness of the mining results and ( 2 ) the security of the outsourced data , the applied encryption method should have the following properties .
1 . Let E(· ) be the encryption function , and TN is the encrypted database where N is the set of encrypted items . For any itemset X ⊆ I , the support of E(X ) in the encrypted database TN equals to the support
474 of X in the original database TI , ie , supTN ( E(X ) ) = supTI ( X ) .
2 . There exists a decryption function D(· ) . For any encrypted itemset Y ⊆ N , D(Y ) = X if there is an itemset X ⊆ I and E(X ) = Y . Otherwise , D(Y ) = ∅ .
3 . The original database TI , the functions E(· ) and D(· ) are only known to the data owner . It is difficult for the attacker to derive TI , E(· ) and D(· ) from his knowledge αL and the given encrypted database TN .
Properties 1 and 2 ensure that no frequent itemset is missed and no infrequent itemset is introduced because of the encryption/decryption . Property 3 allows only the data owner to correctly discover the real frequent itemsets from the mining results of the encrypted database TN .
In addition , note that the α knowledgeable attacker can attack with exact support information . To enhance the security , we propose k support anonymity , which is to hide each sensitive item in a group of at least k encrypted items with the same support .
Definition 2 . ( k support anonymity ) Let S be the set of sensitive items in the transaction database TI , ie , S ⊆ I . An encrypted database TN of TI satisfies k support anonymity if and only if , for every sensitive item x ∈ S , there are at least k encrypted items y ∈ N and supTN ( y ) = supTI ( x ) .
Example 1 . Given the original database TI in Table 1(a ) . In this example , we suppose that ’beer’ and ’tea’ are the sensitive items in TI , and TN in Table 1(b ) is an encrypted database of TI . ( We will show the mappings between TI and TN in Section 3 . ) Then , TN satisfies 3 support anonymity because there are 3 encrypted items ’a’ , ’g’ , and ’h’ with support 2 . Consequently , the attacker cannot correctly reidentify ’beer’ and ’tea’ from TN with the item support of 2 . '
Proposition 1 .
If a dataset is k1 support anonymity , then it is also k2 support anonymity for every k2 < k1 .
The concept of k support anonymity can effectively prevent single identification of an item by the exact support information . Our problem , named the k support anonymity problem , is to have the encryption satisfy the above three properties and the fourth property below .
4 . The encrypted database TN satisfies k support anonymity .
2.2 A Naive Solution
A naive solution to the k support anonymity problem is that , for the desired support level supTI ( x ) of sensitive items x , first repeatedly create a fake item p and randomly insert p into supTI ( x ) transactions , until there are k items with support supTI ( x ) . Then , replace the items with encrypted items . The disadvantage of this method is the very large storage overhead , which is about ( k − 1)Px∈S supTI ( x ) additional item occurrences in the worst case . Instead , we transform the frequent itemset mining to the generalized/multi level frequent itemset mining , and limit the additional item occurrences with the help of a pseudo taxonomy tree . Compared to the naive approach , our methods can achieve better storage efficiency while protecting the sensitive information with the k support anonymity . 2.3 Background
Different from the frequent itemset mining defining each item in a single concept level , the generalized ( or said ,
Table 1 : Database examples .
( a ) Original DB TI trans . ID real items
( b ) Encrypted DB TN trans . ID encryptions
1 2 3 4 5 c , d , g b , d , g b , h a , b , c a , c , d , h
1 2 3 4 5 wine cigar , wine cigar , tea beer , cigar , wine beer , tea , wine multi level ) frequent itemset mining [ 7 , 20 ] defines items in hierarchical concepts and extends the mining to the discovery of all frequent itemsets across concept levels . For example , if 60 % customers buy low fat milk and wholewheat bread together , {low fat milk , whole wheat bread} is a frequent itemset given a minimal support smaller than 60 % . In addition , given the concept ’low fat milk is a kind of milk’ , the generalized frequent itemset mining also discovers {milk , whole wheat bread} as a frequent itemset .
In the generalized frequent itemset mining , what is usually used to indicate the hierarchical concepts is the taxonomy tree , where the root is the most general concept of all items and the leaf is the most specific concept of an item .
Definition 3 . ( taxonomy tree , = ) A taxonomy tree = of a transaction database T is a directed acyclic graph , where a node nj is a specialization of its parent node nj−1 ( or said , the parent node nj−1 is a generalization of nj ) in concept . A transaction containing a leaf node nj will support nj and all the ancestor nodes of nj . Let T ( nj ) be the set of transactions in T supporting nj . The support of nj in T , denoted as supT ( nj ) , is the cardinality of the set T ( nj ) .
A taxonomy tree has the property of support dependency . Because each node nj is a kind of its parent node nj−1 in concept , transactions supporting nj will also supporting nj−1 . Therefore , T ( nj ) ⊆ T ( nj−1 ) and supT ( nj ) ≤ supT ( nj−1 ) always hold .
Example 2 . Fig 3(a ) is the taxonomy trees of TI in Table 1(a ) . ( In this paper , we list T ( nj ) under each leaf node nj and count supT ( nj ) in all the corresponding nodes nj for illustrative purposes . ) Referred to TI and the taxonomy tree in Fig ’alcoholic beverage’ represents a more general concept of ’beer’ and ’wine’ . Therefore , TI(alcoholic beverage ) = TI(beer ) ∪ TI(wine ) = {1 , 2 , 4 , 5} and supTI ( alcoholic beverage ) = 4 . '
3(a ) ,
( a )
( b )
Figure 3 : Taxonomy trees of ( a ) TI and ( b ) TN .
Given a transaction database together with a taxonomy tree and a user specified minimal support , there are many researches [ 7 , 20 ] studying efficient algorithms for the generalized frequent itemset mining problem and the variations .
475 3 . ALGORITHM
3.1 Overview
For the k support anonymity problem , it is necessary to introduce fake items in the encrypted database . To limit the storage overhead , we transform the frequent itemset mining to the generalized frequent itemset mining . Note that this method does not require a real taxonomy tree . Instead , we construct a pseudo taxonomy tree to protect real items which may appear in different node levels of the tree . This is in contrast to the traditional taxonomy tree in generalized association rule mining , where the real items only appear in the leaf level . However , this will increase the confusion to the attackers as any node in the hierarchical tree may be mapped to a real item , or a cohort of the anonymous group , or neither . Finally , we encrypt the original database such that the discovered generalized frequent itemsets contain the real frequent itemsets as a subset .
Example 3 . Consider the database TI in Table 1(a ) and assume that all items are sensitive items . Fig 4(a ) shows a correct way to protect the items in the nodes of a pseudo taxonomy tree . First , note that every real item gets supports from the same transactions as in TI . Since the generalized frequent itemset mining finds all frequent itemsets across concept levels , the real frequent itemset like {beer , wine} with a minimal support of 2 will be included in the mining result of generalized frequent itemsets . Next , by a one to one mapping , we can obtain the taxonomy tree in Fig 3(b ) , and TN in Table 1(b ) is the corresponding encrypted database . Note that there are only 4 additional item occurrences introduced into transactions 1 , 2 and 5 in TN , while each sensitive item is protected in a 3 support anonymous group because there are 3 nodes in the tree with the same support . '
Our method has three advantages as follows . First , it does not need new mining algorithms . The third party can treat the given encrypted database and the corresponding pseudo taxonomy tree as the usual ones , and apply any existing generalized frequent itemset mining algorithm to find a super set of the real result . Second , our method has good storage efficiency for the k support anonymity problem . We utilize the internal nodes in the pseudo taxonomy tree to alleviate the need to introduce fake items at the leaf level as well as additional item occurrences in the encrypted database . Third , the extra frequent itemsets discovered by the generalized frequent itemset mining can also help to confuse the attacker in the re identifications of items . The experimental results show that our method can also protect the security against the attack of exact itemset supports , even though the k support anonymity only anonymizes item supports .
The challenges are ( 1 ) pattern conservation and ( 2 ) support anonymity . First , pattern conservation is the need to ensure that the real frequent itemsets are included in the generalized frequent itemsets under the same minimal support . A naive solution is to treat real items as leaf nodes similar to the traditional generalized association rule mining . However , this will make the detection trivial even with fake items inserted . Second , support anonymity is to create enough nodes with the same support . Note that the taxonomy tree has the property of support dependency . There is a cascading effect on support upward and downward when a node with a particular support is created . The cascad ing effect may undo the previously created cohorts of the anonymous groups .
Example 4 . Consider the database TI in Table 1(a ) . Fig 4(b ) shows a pseudo taxonomy tree violating pattern conservation . Note that because ’cigar’ gets supports from transactions {3,4,5} but not from transactions {2,3,4} as in TI , this tree cannot preserve the correct mining result of TI even under the generalized frequent itemset mining . '
( a )
( b )
Figure 4 : Examples of ( a ) good and ( b ) bad protections for real items in the taxonomy trees .
We take care of the challenges in two steps . First , in Section 3.2 , we present a k bud pseudo taxonomy tree , and show that the k bud pseudo taxonomy tree can ensure the pattern conservation and facilitate the accomplishment of k support anonymity . After that , in Section 3.3 , we propose three alteration operations on the taxonomy tree to achieve the support anonymity . These operations posses the property of anonymous group preservation which means that once the cohorts are created for an anonymous group , they will not be undone in the subsequent creations of another anonymous group . Finally , Section 3.4 presents a linear time decryption algorithm for the discovery of the real result from the generalized frequent itemsets . 3.2 Generalization of the Mining Task
For the k support anonymity problem , our first step is to transform the frequent itemset mining into the generalized frequent itemset mining . That is , the purpose in this subsection is to build a pseudo taxonomy tree that can conserve the real frequent itemsets in the generalized frequent itemsets , given any minimal support . Note that there are many ways to build such a pseudo taxonomy tree . In the following , we introduce one way and show that our method builds a pseudo taxonomy tree that can also facilitate the support anonymity in Section 33 In this paper , we build a pseudo taxonomy tree on a full binary tree structure . Nevertheless , our methods can be easily extended to other tree structures . First , we define a k bud taxonomy tree , which ensures the conservation of real results and the capability of facilitating the k support anonymity .
Let xM be the most frequent sensitive item in the original database TI . Given a taxonomy tree of TI , we define three sets A> , A= and A< as follows . A> is the set of leaf nodes with supports larger than supTI ( xM ) . A= is the set of nodes with supports supTI ( xM ) . A< is the set of nodes with supports smaller than supTI ( xM ) , where the parent nodes have supports larger than supTI ( xM ) .
Definition 4 . ( k bud pseudo taxonomy tree , =k ) A taxonomy tree is a k bud pseudo taxonomy tree of a transaction
476 database TI if and only if all items in I are at the leaf level and k ≤ |A>| + |A=| + |A<| holds .
Example 5 . Fig 5(a ) shows a 3 bud pseudo taxonomy tree of TI in Table 1(a ) . Suppose that ’wine’ is the most frequent sensitive item . Then , A> is an empty set , A= is the set {p1 , wine} , and A< is the set {tea} . '
Proposition 2 . If a taxonomy tree is k1 bud , then it is also k2 bud for every k2 < k1 .
A k bud taxonomy tree =k can preserve the real frequent itemsets as a subset of the generalized frequent itemsets . Specifically , note that in the frequent itemset mining problem , each item is considered in a single concept level and there is no hierarchical relationships between items . Therefore , a pseudo taxonomy tree with real items at the leaf nodes can conserve the real result . In Section 3.3 , we will introduce our methods to raise up real items from leaf level to internal level for better security .
On the other hand , a k bud taxonomy tree =k can also facilitate the accomplishment of k support anonymity . Specifically , for the most frequent sensitive item xM , we can include the nodes in A= as the created cohorts for the anonymous group of xM , and create new nodes with support supTI ( xM ) as the descendants of the nodes in A> and as the parents of the nodes in A< . According to Definition 4 , there are at least k places where we can have nodes with support supTI ( xM ) . As for the other sensitive items with smaller supports , we can always get cohorts as the descendants of the nodes with support supTI ( xM ) .
In the following , we present the algorithm of constructing a k bud pseudo taxonomy tree on a full binary tree structure ( Algorithm 1 ) . The inputs include a transaction database TI and an integer k . First , to conserve the real frequent itemsets , we randomly partition real items into k groups , and build a full binary subtree =Gp for each group Gp with real items at the leaf nodes ( Lines 1 2 ) . Then , we iteratively connect the k subtrees into a single tree as follows ( Lines 36 ) . At each iteration , note that there is at least one subtree =Gp where the support of the root is larger than or equal to supTI ( xM ) since the item xM is a leaf node of some subtree . Let =Ga be a randomly selected subtree where the root has a support larger than or equal to supTI ( xM ) ( Line 4 ) , and =Gb be another randomly selected subtree ( Line 5 ) . We then connect =Ga with =Gb by creating a new node as the parent node of the roots of =Ga and =Gb ( Line 6 ) . When the k subtrees are connected , the single tree is a k bud taxonomy tree . Algorithm 1 The ConstructKbudTree Algorithm Input : ( TI , k ) ; Output : =k 1 : Randomly partition real items into k groups Gp , p = 1 , , k 2 : ∀ Gp , build a subtree =Gp with real items at leaf nodes 3 : while there is more than one subtrees 4 : 5 : 6 : 7 : return =Gq Theorem 1 . Algorithm 1 generates a k bud taxonomy
=Ga := =Gp , where supTI ( xM ) ≤ supTI ( Root(=Gp ) ) =Gb := RandomSelect( ) Build a new subtree =Gq with =Ga and =Gb as subtrees tree .
Proof . We shows that k ≤ |A>| + |A=| + |A<| holds when the algorithm terminates . Specifically , consider the k subtrees of k groups . All the subtrees , where the supports of the roots are larger than or equal to supTI ( xM ) , contribute to A> , A= , or A< at the beginning . The other subtrees contribute to A= or A< when being connected to a subtree
=Ga . Consequently , k ≤ |A>| + |A=| + |A<| holds when the k subtrees are connected into a single tree . Theorem 1 is proved . fi
( a )
( c )
( b )
( d )
Figure 5 : Examples of ( a ) a 3 bud tree , ( b ) the insertion , ( c ) the split and ( d ) the increase operations .
3.3 k Support Anonymity with Taxonomy Tree In this subsection , our purpose is to alter the k bud tree to achieve the k support anonymity . We propose three alteration operations : insertion , split and increase . These operations have the property of the anonymous group preservation , which means that once the cohorts are created for an anonymous group , they will not be undone in the subsequent creations of another anonymous group . By first marking nodes of real items as the created cohorts to be preserved for the anonymous groups , we can thus achieve the k support anonymity without destroying the conservation of real result . In addition , as we shall see later , the split operation can raise up the real items from leaf nodes to internal nodes , and the insertion operation can introduce fake items as leaf nodes . Therefore , the detection of a real item from a set of nodes becomes non trivial even with the item support information .
The challenge is that the taxonomy tree has the property of support dependency . Whenever a node of a particular support is created , there is a cascading effect on support upward and downward . To alleviate the cascading effect and prevent the created cohorts from being undone , we would need to carefully manage the occurrences of fake items in the encrypted transaction database TN . That is , the alteration operations not only alter the taxonomy tree but also update the encrypted database TN .
Before introducing the alteration operations , we define the notations used .
Notations . Consider the nodes related to a node nj . The parent node of nj is denoted as nj−1 , the sibling of nj is denoted ns j , and the two child nodes of nj are denoted as nj+1 and ns j+1 respectively . TN(nj ) is the set of transactions in the database TN supporting nj .
( 1 ) Insertion . This operation creates cohorts of the anonymous groups by inserting nodes onto edges . For a sensitive
477 item x , the insertion operation is applicable on a node nj if supTN ( nj ) < supTI ( x ) < supTN ( nj−1 ) holds . Specifically , this operation creates a new node na with support supTI ( x ) in between nj and nj−1 . Note that , due to the support dependency , the support of na is contributed from nj . To eliminate the cascading effect downward , the operation adds a new leaf node nb as the other child node of na , and makes the additional support needed for na come from nb . Simultaneously , to eliminate the cascading effect upward , the occurrences of nb in the database TN is limited to a subset of the transactions supporting nj−1 . That is , TN ( nb ) ⊂ TN ( nj−1 ) − TN(nj ) and |TN ( nb)| = supTI ( x ) − supTN ( nj ) . Finally , na is marked as a created cohort for its preservation . Example 6 . Given the 3 bud taxonomy tree in Fig 5(a ) , consider how to create a node with a support of 4 by the insertion operation , for increasing the number of cohorts in the anonymous group of ’wine’ . Note that the insertion is applicable on ’tea’ because supTN ( tea ) < 4 < supTN ( p3 ) holds . As the black nodes shown in Fig 5(b ) , an internal node ’p4’ is inserted on the edge ( p3 , tea ) together with a new leaf node ’p5’ . Simultaneously , because the node ’tea’ only contributes a support of 2 to the node ’p4’ , 2 transactions {1,2} are selected from TN(p3 ) − TN(tea ) , which is {1,2,4} , to contain the item ’p5’ . Consequently , the supports of the nodes ’p3’ and ’tea’ are unchanged , and the support of the node ’p4’ is 4 with only 2 , instead of 4 , additional item occurrences in the encrypted database . '
In addition to create cohorts of the anonymous groups , the insertion operation has the side effect of introducing fake items as leaf nodes . However , this makes the detections of real items more difficult .
( 2 ) Split . This operation creates cohorts of the anonymous groups by allocating the support of some leaf node to its newly created child nodes from the split operation . For a sensitive item x , the split operation is applicable on a node nj if nj is a leaf node and supTI ( x ) < supTN ( nj ) holds . Specifically , this operation creates two nodes na and nb as the child nodes of nj , and allocates the occurrences of nj in the database TN to na and nb such that the support of na is supTI ( x ) , ie , TN ( na ) ⊂ TN(nj ) , TN(nb ) ⊂ TN(nj ) and |TN ( na)| = supTI ( x ) . Finally , na is marked as a created cohort for its preservation .
Example 7 . Follow Example 6 . Consider how to create a node with a support of 3 by the split operation , for increasing the number of cohorts of ’cigar’ in the taxonomy tree in Fig 5(b ) . Note that the split is applicable on ’wine’ because ’wine’ is a leaf node and 3 < supTN ( wine ) holds . As the black nodes shown in Fig 5(c ) , the nodes ’p6’ and ’p7’ are created as the child nodes of ’wine’ . Simultaneously , 3 transactions {1,4,5} in the set TN ( wine ) are allocated to contain p6 instead , while the other transaction {2} is allocated to contain p7 instead . Consequently , the node ’wine’ still receives supports from the set of transactions {1,2,4,5} , and the support of ’p6’ is 3 without additional item occurrences in the encrypted database . '
In addition to create cohorts of the anonymous groups , the split operation also raises up the leaf nodes to internal nodes as well as the levels of all the ancestor nodes . Therefore , real items can also be at internal nodes when the k support anonymity is achieved , even though all real items are at the leaf level at first .
( 3 ) Increase . This operation creates cohorts of the anonymous groups by increasing the supports of nodes . For a sensitive item x , the increase operation is applicable on a node nj if supTN ( nj ) < supTI ( x ) < supTN ( nj−1 ) holds and , within the subtree of nj , there is a path from nj to some leaf node nj+m , m ≥ 0 , such that all the nodes nj , nj+1 , , and nj+m on the path are not the cohorts of any anonymous group . ( The latter condition prevents the existing cohorts from being undone . ) Specifically , this operation increases the support of nj to supTI ( x ) by simultaneously increasing the supports of its descendant nodes nj+1 , , and nj+m ( or , said , by increasing the occurrences of nj+m in the database TN ) . Note that , to eliminate the cascading effect upward and to contribute new supports to nj , the additional occurrences of nj+m in the database TN are limited to a subset of the transactions which support nj−1 but not nj , ie , TN ( nj−1 ) − TN(nj ) . Finally , nj is marked as a created cohort for its preservation .
Example 8 . Follow Example 7 . Consider how to create another node with a support of 3 by the increase operation , for increasing the number of cohorts of ’cigar’ in the taxonomy tree in Fig 5(c ) . Note that the increase operation is applicable on ’p7’ because supTN ( p7 ) < 3 < supTN ( wine ) holds and , within the subtree of ’p7’ , ’p7’ is a leaf node and is not a cohort of any anonymous group . As the black node shown in Fig 5(d ) , to increase the support of ’p7’ from 1 to 3 , 2 transactions {1,5} are selected from TN(wine)−TN(p7 ) , which is {1,4,5} , to contain the item ’p7’ . Consequently , the support of ’wine’ is not changed and the support of ’p7’ becomes 3 with only 2 additional item occurrences in the encrypted database . '
We now present our encryption algorithm ( Algorithm 2 ) . The inputs include a transaction database TI , a k bud taxonomy tree =k of TI , the set of sensitive items S ⊆ I , and an integer k . First , the encrypted database TN is initialized with TI ( Line 1 ) . All leaf nodes in the taxonomy tree =k are marked as created cohorts for the conservation of real result ( Line 2 ) , because the leaves are real items at the beginning and the supports of these nodes should not be changed by the subsequent alteration operations . After that , we start the taxonomy alteration process and generate the anonymous groups for sensitive items ( Lines 3 13 ) as follows . For each sensitive item x , we first assume that the three alteration operations are applicable on some nodes in the tree ( Line 4 ) , and mark the existing nodes with the same support as created cohorts ( Lines 5 6 ) . Then , until there are at least k nodes with support supTI ( x ) in TN , we iteratively choose a possibly applicable operation op ( Line 8 ) . If there exists a node nj on which op is applicable for the sensitive item x , we alter the taxonomy tree =k and update the encrypted database TN as explained above ( Line 9 10 ) . Otherwise , op is considered not applicable anywhere for the sensitive item x ( Line 13 ) . After the k support anonymous groups for all sensitive items are completed , we generate a one to one mapping function M(· ) ( Lines 14 ) and encrypt each item nj in =k and TN with M(nj ) ( Lines 15 ) . Finally , the algorithm outputs the encrypted database TN together with the altered taxonomy tree =k and the mapping function M(· ) ( Lines 16 ) .
Note that Algorithm 2 guarantees to terminate and achieve the k support anonymity , because the alteration operations have the property of the anonymous group preservation and it is proved in Section 3.2 that we can find or create k cohorts for each sensitive item in the inputted k bud tree .
478 else
OpSet := OpSet − {op}
Choose an op from OpSet if ∃ a node nj in =k , op is applicable for x
Alter =k and update TN by applying op on nj Update Aanon
Algorithm 2 The ConstructKsupAnonTree Algorithm Input : ( TI , =k , S , k ) ; Output : ( TN , =k , M(· ) ) 1 : TN := TI 2 : Mark all the leaves of =k as created cohorts 3 : for each sensitive item x ∈ S 4 : OpSet := {Insertion , Split , Increase} 5 : Aanon := {na|supTN ( na ) = supTI ( x)} 6 : Mark all nodes in Aanon as created cohorts 7 : while |Aanon| < k 8 : 9 : 10 : 11 : 12 : 13 : 14 : Generate a one to one mapping function M(· ) 15 : Replace each nj in =k and TN with M(nj ) 16 : return ( TN , =k , M(· ) ) Example 9 . Now we show the complete process how the original database TI in Table 1(a ) is encrypted into the encrypted database TN in Table 1(b ) with the help of the 3 bud taxonomy tree in Fig 5(a ) . Suppose that all items are sensitive items . First , all the leaf nodes of the 3 bud taxonomy tree in Fig 5(a ) are marked as created cohorts . Then , the 3 support anonymous groups for ’wine’ and ’cigar’ are completed as shown in Examples 6˜8 . The 3 support anonymous group for ’tea’ and ’beer’ is completed by the side effects in the previous alterations . After the alterations , the taxonomy tree is shown in Fig 4(a ) . Finally , we can get the encrypted database TN in Table 1(b ) and the taxonomy tree in Fig 3(b ) after the encryption of items .
When outsourcing the mining task , the data owner gives TN in Table 1(b ) and the taxonomy tree in Fig 3(b ) to the third party , and asks the third party to mine the generalized frequent itemsets . ' 3.4 Decryption of the Results
In our method , each item is encrypted as a node , either an internal node or a leaf node , in a pseudo taxonomy tree . Even though the α knowledgeable attacker is prevented from knowing the correct mappings by the k support anonymity , the data owner can easily decrypt the mining results by filtering out the fake items .
Example 10 . Given the database TN in Table 1(b ) together with the taxonomy tree in Fig 3(b ) . Suppose that the third party mines the generalized frequent itemsets with a minimal support 2 . Then , to name a few , the itemsets {a}˜{k} , {a , c} , {a , f} , {b , f} and {b , j} are frequent , and the itemsets {a , b} , {a , d} and {a , g} are infrequent . Note that the data owner knows the mappings between real items and nodes , which are M(beer)=a , M(cigar)=b , M(wine)=f , and M(tea)=h . By filtering out the fake items , the remaining frequent itemsets are {a} , {b} , {f} , {h} , {a , f} and {b , f} , which are {beer} , {cigar} , {wine} , {tea} , {beer , wine} and {cigar , wine} , respectively . Consequently , the data owner finds the real frequent itemsets . '
4 . PERFORMANCE STUDIES
This section evaluates the security of k support anonymity and the cost effectiveness of our approaches . We consider both the real Retail dataset and the synthetic T10I1kD100k dataset . The programs are implemented in C++ . All experiments are performed on a Debian GNU/Linux server with double dual core 2.4 GHz Opteron processors and 4GB RAM .
Retail dataset is provided by anonymous Belgian retail store , and is publicly available from FIMI Repository1 . After a preprocessing to remove rare items with supports smaller than 83 ( the item appears in less than 0.1 % of all transactions ) , Retail dataset contains 88162 transactions and 2117 different items . The average length of a transaction is 75 Fig 6 is the support distribution ( from 89 to 3000 ) of items . Beyond the 3000 support level , there are only 10 items , and the most frequent item appears in 50675 transactions . In this analysis , we observe the following two facts . First , the more frequent an item is , the fewer other items with the same supports are . Beyond the 500 ( 0.56 % ) support level , there are at most three items with the same supports . Second , top frequent items can be singly identified even if the item supports are approximate . Beyond the 2000 ( 2.25 % ) support level , the items sparsely distribute in a large range of support values . Therefore , support anonymity is needed to protect security in outsourcing frequent itemset mining . s m e t I
. f f i
D f o
. m u N
30 25 20 15 10 5 0
500
1000
1500
2000
2500
Item Support
Figure 6 : Analysis of Retail : Number of different items under the same support .
T10I1kD100k dataset is synthetically generated by the IBM data generator [ 1 ] with similar parameters to that of the applied dataset in [ 23 ] . T10I1kD100k dataset contains 100k transactions , 1000 different items , and about 400 frequent itemsets . The average transaction length is 10 .
In the experiments , we assume all the items are sensitive items , ie , S = I . To see whether the order of creating anonymous groups has an impact on the security and storage efficiency , we alter the taxonomy tree for items in the order of decreasing , increasing , and random item supports . 4.1 Security Analysis
In this experiment , we test our approaches against the genetic algorithm [ 19 ] , which is widely used in cryptanalysis as an attacker [ 13 ] . Working as a malicious third party and an α knowledgeable attacker , the genetic algorithm utilizes the exact item supports as well as the taxonomy tree to reidentify real items.2 We evaluate the security with α varying from 50 % to 100 % . This represents a stress case as the attacker is assumed to have knowledge of at least half of the frequent items .
For the performance study , we perform the same type of evaluations as the work in [ 23 ] . Specifically , we evaluate the security from the item accuracy and the database accuracy . αL is the knowledge of the attacker . Let Z denote the set of items appearing in αL and D(· ) be the genetic algorithm . The item accuracy is defined as the correct ratio of the item 1http://fimicshelsinkifi/data/ 2The fitness function is defined as the average support differences between a pattern in the attacker ’s knowledge and the guessed pattern in the encrypted database .
479 Y C A R U C C A M E T I
Y C A R U C C A B D
40 %
30 %
20 %
10 %
0 %
40 %
30 %
20 %
10 %
0 %
Y C A R U C C A M E T I
Y C A R U C C A B D
40 %
30 %
20 %
10 %
0 %
40 %
30 %
20 %
10 %
0 % k = 20
DECREASING INCREASING RANDOM
50 % 60 % 70 % 80 % 90 %100 %
α
DECREASING INCREASING RANDOM
50 % 60 % 70 % 80 % 90 %100 %
α
( a )
Y C A R U C C A M E T I
Y C A R U C C A B D
40 %
30 %
20 %
10 %
0 %
40 %
30 %
20 %
10 %
0 % k = 100
DECREASING INCREASING RANDOM
50 % 60 % 70 % 80 % 90 %100 %
α
DECREASING INCREASING RANDOM
50 % 60 % 70 % 80 % 90 %100 %
α
Y C A R U C C A M E T I
Y C A R U C C A B D
40 %
30 %
20 %
10 %
0 %
40 %
30 %
20 %
10 %
0 % k = 20
DECREASING INCREASING RANDOM
50 % 60 % 70 % 80 % 90 %100 %
α
DECREASING INCREASING RANDOM
50 % 60 % 70 % 80 % 90 %100 %
α
( b )
Y C A R U C C A M E T I
Y C A R U C C A B D
40 %
30 %
20 %
10 %
0 %
40 %
30 %
20 %
10 %
0 % k = 100
DECREASING INCREASING RANDOM
50 % 60 % 70 % 80 % 90 %100 %
α
DECREASING INCREASING RANDOM
50 % 60 % 70 % 80 % 90 %100 %
α
Figure 7 : Given item supports , the attack accuracy on ( a ) Retail and ( b ) T10I1kD100k . k = 20
DECREASING INCREASING RANDOM
50 % 60 % 70 % 80 % 90 %100 %
α
DECREASING INCREASING RANDOM
50 % 60 % 70 % 80 % 90 %100 %
α
( a )
Y C A R U C C A M E T I
Y C A R U C C A B D
40 %
30 %
20 %
10 %
0 %
40 %
30 %
20 %
10 %
0 % k = 100
DECREASING INCREASING RANDOM
50 % 60 % 70 % 80 % 90 %100 %
α
DECREASING INCREASING RANDOM
50 % 60 % 70 % 80 % 90 %100 %
α
Y C A R U C C A M E T I
Y C A R U C C A B D
40 %
30 %
20 %
10 %
0 %
40 %
30 %
20 %
10 %
0 % k = 20
DECREASING INCREASING RANDOM
50 % 60 % 70 % 80 % 90 %100 %
α
DECREASING INCREASING RANDOM
50 % 60 % 70 % 80 % 90 %100 %
α
( b )
Y C A R U C C A M E T I
Y C A R U C C A B D
40 %
30 %
20 %
10 %
0 %
40 %
30 %
20 %
10 %
0 % k = 100
DECREASING INCREASING RANDOM
50 % 60 % 70 % 80 % 90 %100 %
α
DECREASING INCREASING RANDOM
50 % 60 % 70 % 80 % 90 %100 %
α
Figure 8 : Given itemset supports , the attack accuracy on ( a ) Retail and ( b ) T10I1kD100k .
|Z|
|tα| mappings normalized by Z , ie , |{x|D(E(x))=x,x∈Z}| , because an attacker can never find the correct mappings for the items that are not in his knowledge . For the same reason , the decryption accuracy of a transaction t is defined as the intersection of the decrypted transaction and the original transaction normalized by the items known to the attacker , ie , |D(E(t))∩tα| , where tα = t ∩ Z . Then , the database accuracy is the average of decryption accuracy of the transactions for which tα 6= ∅ . The lower the accuracy is , the better the security our methods provide .
First , consider the attack of exact item supports , which is the case our scheme designed for . Fig 7 shows that the decreasing , increasing and random orders achieve similar security levels on the Retail and T10I1kD100k datasets under 20 support anonymity ( k =20 ) and 100 support anonymity ( k =100 ) . For the case k =100 , our approaches can almost perfectly protect the sensitive items ( the item accuracy is about 0%˜3% ) . For the case k =20 , the privacy protection is a little bit lower ( the item accuracy is about 5%˜8% ) . This is because , with exact item supports , an attacker has about 1/k probability to correctly guess the mapping of an item protected with the k support anonymity . Moreover , the attacker can further reduce the privacy protection a lit tle bit according to the taxonomy tree since we assume that the attacker is a malicious third party . On the other hand , the database accuracy for the case k =100 is also lower than the database accuracy for the case k =20 . Compared to the item accuracy , the database accuracy may be lower as shown in Fig 7(a ) or higher as shown in Fig 7(b ) . This is because the database accuracy is the average of decryption accuracy of transactions for which tα 6= ∅ .
Next , we consider a more challenging case , where a super α knowledgeable attacker knows not only exact item supports but also exact itemset supports . Under the same parameter settings , the attack accuracies in Fig 8 are similar to those in Fig 7 . Both the item and database accuracies against attack of itemset supports are about only 0˜2 % higher than the accuracies against attack of item supports . These results show that our approaches can also work well for attacker knowledge on itemset supports .
4.2 Cost of Encryption
In this subsection , we study the storage and time efficiencies of our methods on the Retail and T10I1kD100k datasets . First , we compare the storage overhead , ie , the number of additional item occurrences in the encrypted transac
480
I
)
S M E T I
L A N O I T I D D A F O N O I T C A R F
D O H T E M E V A N O T D E R A P M O C
(
0.7 0.6 0.5 0.4 0.3 0.2 0.1 0
DECREASING INCREASING RANDOM
20
40
60 k
80
100
( a )
350 300 250 200 150 100 50 0
) S C E S (
E M I T N O I T U C E X E
DECREASING INCREASING RANDOM
20
40
60 k
80
100
I
)
S M E T I
L A N O I T I D D A F O N O I T C A R F
D O H T E M E V A N O T D E R A P M O C
(
0.5
0.4
0.3
0.2
0.1
0
DECREASING INCREASING RANDOM
20
40
60 k
80
100
( b )
200
150
100
50
0
) S C E S (
E M I T N O I T U C E X E
DECREASING INCREASING RANDOM
20
40
60 k
80
100
Figure 9 : The fraction of additional items in the encrypted database , and the execution efficiency of our encryption algorithm on ( a ) Retail and ( b ) T10I1kD100k datasets . tion database , introduced in our approaches with that in the naive method . Fig 9 shows that our methods can achieve ksupport anonymity with less than 45 % of the overhead in the naive method . Furthermore , the decreasing and increasing orders achieve better storage efficiency ( less than 25 % of the overhead in the naive method ) than the random order does . This is because our methods protect real items with nodes in the hierarchical taxonomy tree , and each occurrence of items is permitted to contribute a support to the cohorts of the anonymous groups as many times as possible through support dependency on the taxonomy tree , especially in the decreasing and increasing orders .
In addition , our approaches except for the random order can achieve the privacy protections with moderate storage overhead . For the case k = 20 , the sizes of the encrypted databases processed in the decreasing ( increasing ) order are about 1.26 ( 1.37 ) times of the size of T10I1kD100k dataset and about 1.9 ( 2.9 ) times of the size of Retail dataset . Under a similar security level ( but we are against a stronger attacker model ) , the work in [ 23 ] has their encrypted databases about 1.6 and 2.4 times of the size of original database . Our methods achieve the protections against a stronger attacker model with comparable storage overheads to the work in [ 23 ] .
Next , we study the time efficiency of our approaches . Note that our methods do not encrypt the original database under a particular minimal support . The comparison of the encryption efficiency and the mining efficiency is not appropriate since we can mine the frequent itemsets from the same encrypted database many times with different minimal supports . Instead , we study the execution time for different k support anonymity . As shown in Fig 9 , the three orders are comparable on the execution efficiency . The execution time grows almost linear to the parameter k .
Summing up the results in the security analysis and cost efficiency , we note that the three encryption orders provide similar degree on privacy protection , but the decreasing and increasing orders have better saving on storage efficiency and are compatible with the random order on the execution time of encryption . We can conclude that the k support anonymity has more impact in the privacy protection than the number of additional items .
5 . RELATED WORKS
Various approaches have been studied to achieves the privacy protections in the problem of pattern mining , and these approaches suffer differently .
In [ 2 , 5 ] , the raw data is randomly perturbed before it is given to a third party . The works in [ 9 , 17 ] protect privacy through an approximation protocol , the bloom filter . Still another work [ 21 ] directly decreases the occurrences of items to eliminate sensitive patterns . All these method above sacrifice the precision of mining result .
On the other hand , for the conservation of precise patterns in secured outsourcing of association rule mining , the works in [ 6 , 23 ] replace items with meaningless symbols and add noise to prevent re identification . In [ 6 ] , the noise is a set of fake transactions consisting of the original items . However , this approach can affect not only the number of occurrences of a pattern but also the total number of transactions , ie , both the numerator and denominator of the support calculation . To filter out false positive patterns from the mining results , this method suffers from the need to determine the false positive patterns in advance , especially when the patterns are long . Differently , the other approach [ 23 ] adds fake items into original transactions to avoid this problem . We hence take this approach in the paper .
6 . CONCLUSIONS
The background knowledge such as the supports of frequent itemsets can be utilized to obtain privacy information in the outsourcing of frequent itemset mining . In this paper , we propose k support anonymity to provide protection against a knowledgeable attacker with exact support information . To achieve k support anonymity , we introduce a pseudo taxonomy tree and have the third party mine the generalized frequent itemsets instead . The construct of the pseudo taxonomy tree facilitates hiding of the original items and limits the fake items introduced in the encrypted database . The experimental results showed that our methods of the k support anonymity can achieve very good privacy protection with moderate storage overhead .
7 . ACKNOWLEDGEMENTS
This work is supported in part by NSF through grant IIS0914934 and by National Science Council , Taiwan , ROC under Contract No . NSC97 2917 I 002 130 .
8 . REFERENCES [ 1 ] R . Agrawal and R . Srikant . Mining sequential patterns . In Proc . of ICDE , 1995 .
[ 2 ] R . Agrawal and R . Srikant . Privacy preserving data mining . In Proc . of ACM SIGMOD , 2000 .
[ 3 ] R . Buyya , C . S . Yeo , and S . Venugopal .
Market oriented cloud computing : Vision , hype , and
481 reality for delivering it services as computing utilities , in . In Proc . of CSSE , pages 10–1016 , 2008 .
[ 4 ] L . Cao , P . S . Yu , C . Zhang , and H . Zhang . Data Mining for Business Applications . Springer , 2008 .
[ 5 ] A . Evfimievski , R . Srikant , R . Agrawal , and
J . Gehrke . Privacy preserving mining of association rules . In Proc . of ACM SIGKDD , 2002 .
[ 6 ] F . Giannotti , L . V . Lakshmanan , A . Monreale ,
D . Pedreschi , and H . Wang . Privacy preserving mining of association rules from outsourced transaction databases . In SPCC Workshop , 2010 .
[ 7 ] J . Han and Y . Fu . Discovery of multiple level association rules from large databases . In Proc . of VLDB , 1995 .
[ 8 ] M . Kamber and J . Han . Data Mining : Concepts and
Techniques . Morgan Kaufmann ; 2 edition , 2005 .
[ 9 ] M . Kantarcioglu , R . Nix , and J . Vaidya . An efficient approximate protocol for privacy preserving association rule mining . In Proc . of PAKDD , 2009 .
[ 10 ] N . Li , T . Li , and S . Venkatasubramanian . t closeness : Privacy beyond k anonymity and l diversity . In Proc . of ICDE , 2007 .
[ 11 ] K . Liu and E . Terzi . Towards indentity anonymization on graphs . In Proc . of ACM SIGMOD , 2008 . [ 12 ] A . Machanavajjhala , J . Gehrke , D . Kifer , and
M . Venkitasubramaniam . l diversity : Privacy beyond k anonymity . ACM TKDD , 1(1 ) , 2007 .
[ 13 ] A . J . Menezes , P . C . van Oorschot , and S . A .
Vanstone . Handbook of Applied Cryptography . CRC Press , 1996 .
[ 14 ] T . Mielik¨ainen . Privacy problems with anonymized transaction databases . In Proc . of Discovery Science , 2004 .
[ 15 ] I . Molloy , N . Li , and T . Li . On the ( in)security and
( im)practicality of outsourcing precise association rule mining . In Proc . of ICDM , 2009 .
[ 16 ] J . Pei and B . Zhou . Preserving privacy in social networks against neighborhood attacks . In Proc . of ICDE , 2008 .
[ 17 ] L . Qiu , Y . Li , and X . Wu . Preserving privacy in association rule mining with bloom filters . J . Intell . Inf . Syst , 29(3):253–278 , 2007 .
[ 18 ] P . Samarati and L . Sweeney . Generalizing data to provide anonymity when disclosing information . In Proc . of ACM PODS , 1998 .
[ 19 ] R . Spillman , M . Janssen , B . Nelson , and M . Kepner .
Use of a genetic algorithm in the cryptanalysis of simple substitution ciphers . Cryptologia , XVII(1):31–44 , 1993 .
[ 20 ] R . Srikant and R . Agrawal . Mining generalized association rules . In Proc . of VLDB , 1995 .
[ 21 ] X . Sun and P . S . Yu . A border based approach for hiding sensitive frequent itemsets . In Proc . of ICDM , 2005 .
[ 22 ] J . T . L . Wang , M . J . Zaki , H . T . T . Toivonen , and
D . Shasha . Data Mining in Bioinformatics . Springer Verlag London , UK , 2005 .
[ 23 ] W . K . Wong , D . W . Cheung , E . Hung , B . Kao , and N . Mamoulis . Security in outsourcing of association rule mining . In Proc . of VLDB , 2007 .
[ 24 ] F . Zhu , X . Yan , J . Han , P . S . Yu , and H . Cheng . Mining colossal frequent patterns by core pattern fusion . In Proc . of ICDE , 2007 .
482
