Web Service Interfaces⁄
Dirk Beyer
EPFL , Lausanne , Switzerland dirkbeyer@ep(cid:176)ch
Arindam Chakrabarti University of California ,
Berkeley , USA arindam@csberkeleyedu
Thomas A . Henzinger
EPFL , Lausanne , Switzerland
& University of California ,
Berkeley , USA
ABSTRACT We present a language for specifying web service interfaces . A web service interface puts three kinds of constraints on the users of the service . First , the interface specifles the methods that can be called by a client , together with types of input and output parameters ; these are called signature constraints . Second , the interface may specify propositional constraints on method calls and output values that may occur in a web service conversation ; these are called consistency constraints . Third , the interface may specify temporal constraints on the ordering of method calls ; these are called protocol constraints . The interfaces can be used to check , flrst , if two or more web services are compatible , and second , if a web service A can be safely substituted for a web service B . The algorithm for compatibility checking verifles that two or more interfaces fulflll each others’ constraints . The algorithm for substitutivity checking verifles that service A demands fewer and fulfllls more constraints than service B .
[ Software
Categories and Subject Descriptors D21 Requirements/Speciflcations ; D24 [ Software Engineering ] : Software/Program Veriflcation|Formal methods , Model checking ; D212 [ Software Engineering ] : Interoperability|Interface deflnition languages
Engineering ] :
General Terms Design , Reliability , Veriflcation
Keywords Web services , Web service interfaces , Web service compatibility , Web service substitutivity , Formal speciflcation , Formal veriflcation
⁄This research was supported in part by the ONR grant N00014 02 1 0671 and by the NSF grants CCR 0234690 and CCR 0225610 .
Copyright is held by the International World Wide Web Conference Committee ( IW3C2 ) . Distribution of these papers is limited to classroom use , and personal use by others . WWW 2005 , May 10 14 , 2005 , Chiba , Japan . ACM 1 59593 046 9/05/0005 . tah@ep(cid:176).ch
1 .
INTRODUCTION
Interface formalisms are used to avoid errors in component based system design . In particular , by checking at design time if two or more interfaces are compatible , we can ensure that the corresponding components work together properly at run time . For example , programminglanguage types ofier a simple interface formalism : it can be checked at compile time if the number and types of the parameters of a function call and the function deflnition match . Richer interface formalisms have been devised for software components whose correct interaction depends on communication protocols [ 7 ] , timing [ 9 ] , or resource use [ 5 ] .
Web services ofier a particularly natural and important application domain for interface formalisms . A web service often depends on other web services , which have been implemented by difierent vendors , and their correct usage is governed by rules . Such rules may constrain data types , but they may also express temporal constraints ( eg , \a shipping order should be placed only if a credit card check has succeeded" ) . We present a language for equipping web services with interfaces that formalize such rules . The beneflts of our language are two fold . First , it can be checked algorithmically if two or more interfaces fulflll each other ’s rules ; in this case the interfaces are called compatible . Second , it can be checked algorithmically if one interface can be safely replaced by another one ; in this case the latter interface is said to reflne the former .
Compatibility and reflnement checks , like model checking , reduce the burden on testing for system integration and validation . However , we explicitly propose to use formal methods to specify and verify the interfaces of web services , not their implementations ( for implementation checking see , eg , [ 13 , 15 , 11 , 20] ) . Interface checking stands a much better chance of succeeding in practice than implementation checking , as interfaces are usually less complex than the corresponding implementations . Indeed , good interface design suggests that an interface exposes all information about a web service that is needed to use the service properly , and that the interface does not expose more than that . This is why we ofier not one , but three interface languages , which are increasingly more expressive .
The flrst language , called web service signatures , exposes only the names and types of externally callable methods and their return values . For example , a web service signature may ofier the method credit card check with the two return values success and failure . The second language , called consistency interfaces , equips web service signatures with propositional constraints on the consistency between various method calls and return values . For example , it may be inconsistent to have both hcredit card check ; failurei and hship order ; successi in the same web service conversation . The third and richest language , called protocol interfaces , equips web service signatures with temporal constraints between method calls . interface may prohibit conversations where hship order ; successi occurs before hcredit card check ; successi .
For example , a protocol
The compatibility and reflnement of web service signatures can be type checked . Consistency interfaces are stateless ; their compatibility and reflnement can be checked by solving propositional ( boolean ) constraints . Protocol interfaces are stateful ; they can be naturally expressed by automata ( state machines ) with nondeterminism , recursion , and thread creation . Their compatibility can be checked by model checking temporal safety constraints .
2 . WEB SERVICE SIGNATURES
Let M be a flnite set of web methods and O be a flnite set of outcomes . The outcome is used to encode a return value from the web method , or other behavioral difierences between various calls to the web method ; for instance , if the invocation will lead to a call to a callback method or not . An action a on M and O is a pair hm ; oi 2 M £ O . An action hm ; oi constitutes an \assumption" at the invocation point that the call to web method m will eventually lead to the outcome o for this call . This coupling of the call together with its eventual outcome is found to be very useful in reasoning about the behavior of web services . The set of actions on M and O is denoted by A ( cid:181 ) M £ O .
A web service signature S is a partial function S : A ! 2A , which assigns to an action a a set of actions which can be invoked by a . A web service signature S supports an action a 2 A if S(a ) is deflned ; S supports a web method m 2 M if some action hm ; oi is supported by S . An action a requires an action a0 in S if a0 2 S(a ) . A web service signature S requires an action a0 if some action a requires action a0 in S . A web service signature S is well formed if for every web method m supported by S , every action hm ; oi 2 A required by S is supported by S . In the rest of the paper , the word \signature" stands for \well formed signature" .
Intuitively , a signature element ( hm ; oi ; S ) says that when the web method m is called , and the caller assumes the outcome o , this signature pledges to support this action , and itself relies on that the assumptions carried by the actions a0 2 S are fulfllled ( by either this signature , or by the environment ) . Thus , a web service signature relates the \guarantees" made ( actions supported ) by the interface to the \assumptions" ( actions assumed to be supported , either by the interface itself or by the environment ) under which they are made . The signature is well formed if the assumptions and guarantees are mutually consistent .
Example 1 . ( Supply chain management application ) We brie(cid:176)y describe a supply chain management application [ 2 ] that we will use as a running example in the rest of the paper to illustrate concepts as we introduce them . The application consists of flve web services : Shop , Store , Bank , Transport , and Supplier . We will present interface models for Shop and Store in the following sections . We will focus on particular aspects of the services and not provide a full (cid:176)edged model .
Figure 1 : The supply chain management application
Figure 1 gives an overview of the interactions between the web services . The Shop interface supports the web method SellItem which is called by the Client application to start the selling process , and it supports ChkAvail which is a subroutine ( called by Shop itself ) that checks availability of items for sale . Shop requires the web method ChkStore to be implemented by Store to check whether the desired items are available in stock . It also requires ShipItem to be implemented by Transport to ship the sold items to the customer , and it requires ProcPay to be implemented by Bank to process credit card payments . Store requires two web methods to be implemented by Supplier : GetOffer and Order , to get an ofier for an item , and to order new items if the stock falls below a certain threshold .
Example 2 . ( Well formed signature ) To model the Shop we need the following sets of methods , outcomes and actions , before we can deflne a web service signature for it :
M = fSellItem ; ChkAvail ; ChkStore ; ProcPay ; ShipItem ;
GetOffer ; Orderg
O = fSOLD ; NOTFOUND ; OK ; FAIL ; RECg A = fhSellItem ; SOLDi ; hSellItem ; FAILi ; hSellItem ; NOTFOUNDi ; hChkAvail ; OKi ; hChkAvail ; FAILi ; hChkStore ; OKi ; hChkStore ; FAILi ; hProcPay ; OKi ; hProcPay ; FAILi ; hShipItem ; OKi ; hShipItem ; FAILi ; hGetOffer ; RECi ; hOrder ; OKig
The Shop interface can be modeled as the following web service signature :
SShop = f hSellItem ; SOLDi 7! fhChkAvail ; OKi ; hProcPay ; OKi ; hShipItem ; OKig hSellItem ; FAILi 7! fhChkAvail ; OKi ; hChkAvail ; FAILi ; hProcPay ; OKi ; hProcPay ; FAILi ; hShipItem ; FAILig hChkAvail ; OKi 7! fhChkStore ; OKig hChkAvail ; FAILi 7! fhChkStore ; FAILig g instance , is action hSellItem ; SOLDi
For supported by SShop , and actions hChkAvail ; OKi ; hProcPay ; OKi and hShipItem ; OKi are assumed to be supported by the environment . Signature SShop is well formed , because it supports all possible actions for its supported methods .
Compatibility and composition . For two web service interfaces , we want to check whether they can cooperate properly , ie , whether their signatures mutually fulflll their guarantees and assumptions .
Given two web service signatures S1 and S2 with dom(S1 ) \ dom(S2 ) = ; , if Sc = S1 [ S2 is well formed , then S1 and S2 are compatible ( denoted by comp(S1 ; S2) ) , and their composition ( denoted by S1 k S2 ) is Sc . The composition operation is commutative and associative . Compatibility and composition of web service signatures can be computed in linear time .
Composing web services allows us to reason about the behavior exhibited when , for instance , a particular airline reservation service Sa and a particular hotel reservation service Sh are used as part of a larger system . Note that the composition is still an open system . For instance , Sa and Sh may both use a credit card processing service Sc . Assumptions made about the environment are allowed ; the goal is to check whether an environment fulfllling such assumptions can exist . The airline ticket reservation service and the hotel room reservation service may make assumptions about the behavior they expect of each other , and additionally about the credit card processing service in their environment , which they both use . Our formalism considers the airline and hotel reservation web services compatible as long as their mutual behavioral assumptions and guarantees are consistent , assuming that a credit card processing service fulfllling all expected requirements can exist . Intuitively , this is why our formalism is an interface theory [ 8 ] .
Example 3 . ( Compatibility of signatures ) Let us build the composition of the signature SShop with the following signature for Store :
SStore = f hChkStore ; OKi 7! fhGetOffer ; OKi ; hOrder ; OKig hChkStore ; FAILi 7! fhGetOffer ; OKi ; hOrder ; OKig g
Both actions require two other actions supported by Supplier to order new items if the stock is below a certain threshold . Signature SStore is well formed . The union SShop [ SStore is also well formed because it supports all actions for its supported methods and no action is supported in both signatures . Therefore the signatures are compatible and their composition is SShop [ SStore .
Substitutivity . To enable top down design , we want to be able to replace a component embedded as part of a larger system ( its environment ) with a new component , while ensuring that the entire system still cooperates properly as before . Intuitively , we need to ensure that the replacement component behaves similarly to the replaced one as far as the environment assumptions and guarantees are concerned . Given two web service signatures S and S 0 , we say S 0 reflnes S ( written S 0 4 S ) if i ) for every a 2 A , if S supports a , then S 0 supports a , ii ) for every a ; a0 2 A , if S supports a , and a requires a0 in S 0 , then a requires a0 in S , and iii ) for all web methods m not supported by S 0 , if S 0 re quires an action hm ; oi , then S requires hm ; oi .
The flrst condition ensures that the reflned web service signature \guarantees" to support every action supported by the abstract one . The other two conditions ensure that the reflned web service signature does not \assume" additional actions to be supported by the environment under situations where it is used exactly as the abstract one would have been used . Given two web service signatures S and S 0 , the question if S 0 4 S can be decided in linear time .
Example 4 . ( Substitutivity of signatures ) Let S 0
Shop be a second web service signature deflned as
S 0 Shop = f hSellItem ; SOLDi 7! hSellItem ; FAILi 7! fhChkAvail ; OKi ; hProcPay ; OKig fhChkAvail ; OKi ; hProcPay ; OKi ; hProcPay ; FAILig hSellItem ; NOTFOUNDi 7! fhChkAvail ; FAILig hChkAvail ; OKi 7! hChkAvail ; FAILi 7! g fhChkStore ; OKig fhChkStore ; FAILig the signature S 0
Compared with SShop , Shop supports an additional action hSellItem ; NOTFOUNDi and requires no action for shipping ( eg , because it implements the shipping It is a reflnement of SShop because functionality itself ) . it i ) supports all actions which SShop supports , ii ) these \reflned" actions require only a subset of the actions which are required by the actions in SShop , iii ) the new action requires only actions which are already required by some action in SShop .
3 . CONSISTENCY INTERFACES
Let B(P ) be the set of expressions over the set of propositions P , using the binary operators u and t , and the propositional constant t . Our language of expressions has some important properties in common with the language of boolean expressions , but there are some essential difierences which we will point out as appropriate . We use the symbols t and u instead of _ and ^ to re(cid:176)ect the similarity , and the difierence .
Given a set of actions A , a consistency interface C is a partial function C : A ! B(A ) . The element ( hm ; oi ; t ) 2 C means that interface C supports a method m , and when m is called , and the caller expects the outcome to be o , the interface C guarantees to fulflll the expectation , since C(hm ; oi ) is deflned . Further , C provides this guarantee making the assumption t , which is always fulfllled , ie , action hm ; oi is supported under no assumptions . Intuitively , this means that the code executed when web method m is called can lead to the outcome o without calling any other web method . The element ( a ; a0 ) 2 C , where a0 = hm0 ; o0i , says that the action a is supported by C , and when a is invoked , C calls m0 in turn , and expects the outcome o0 . The element ( a ; ’1 u ’2 ) 2 C says that action a is supported by C , and leads to the combination of the two sets of conversations , one represented by ’1 and one represented by ’2 . The element ( a ; ’1 t ’2 ) 2 C says that action a is supported by C , but can lead to the set of conversations represented by ’1 , or to the set of conversations represented by ’2 , nondeterministically chosen by the interface . Allowing nondeterminism in interfaces allows us to make them abstract ; ie , the interface can forget about the implementation details of the web service code , and only capture its external behavior in terms of patterns of the web method calls it makes .
Given a consistency interface C , the underlying web service signature of C ( denoted by sig(C ) ) is deflned as follows : for all a 2 A , if C(a ) is deflned , then sig(C)(a ) = fa0 j a0 occurs in C(a)g , and sig(C)(a ) is undeflned otherwise . A consistency interface C is well formed if sig(C ) is well formed .
In the rest of the paper , \consistency interface" stands for \well formed consistency interface" .
The following consistency interface flxes the bug of
CStoreF1 by supporting action hChkStore ; FAILi :
Example 5 . ( Well formed consistency interface ) Let us model the Shop web service as consistency interface :
CShop = f hSellItem ; SOLDi 7! hChkAvail ; OKi u hProcPay ; OKi u hShipItem ; OKi hSellItem ; FAILi 7! hChkAvail ; FAILi t ( hChkAvail ; OKi u ( hProcPay ; FAILi t ( hProcPay ; OKi u hShipItem ; FAILi ) ) ) hChkAvail ; OKi 7! hChkStore ; OKi hChkAvail ; FAILi 7! hChkStore ; FAILi g
For action hSellItem ; SOLDi , all three actions occur together . For action hSellItem ; FAILi , action hChkAvail ; FAILi occurs alone , or action hChkAvail ; OKi occurs together with either action hProcPay ; FAILi or both , actions hProcPay ; OKi and hShipItem ; FAILi . Note that nothing is said about the order of their occurrence . The actions for method ChkAvail result in calls of the method ChkStore in Store ( delegation of service ) .
The underlying signature sig(CShop ) of CShop is SShop from Example 2 , which is a well formed signature , and hence CShop is a well formed consistency interface . 3.1 Compatibility and Composition
Intuitively , given two consistency interfaces , if their mutual behavioral assumptions and guarantees allow them to co operate , we say they are compatible , and we can compose them to a single consistency interface , in which some of their internal details are forgotten and the combined behavioral assumptions and guarantees of interest for the environment are retained .
Given two consistency interfaces C1 and C2 , if the underlying signatures sig(C1 ) and sig(C2 ) are compatible , then C1 and C2 are compatible ( denoted by comp(C1 ; C2) ) , and their composition ( denoted C1 k C2 ) is C1 [ C2 . The composition operation is commutative and associative . Compatibility and composition of consistency interfaces can be computed in linear time .
Example 6 . ( Compatibility of consistency interfaces ) Consider the following consistency interface for Store :
CStoreF1 = f hChkStore ; OKi 7! ft t ( hGetOffer ; RECi u hOrder ; OKi)g g
When action hChkStore ; OKi is invoked , Store does nothing , or gets ofiers and orders more items ( if the stock is below threshold ) . Note that nondeterminism allows the stock to be abstracted away .
Let us try to compose the Shop and Store interfaces . Are they compatible ? No , because their union Cc is not a well formed interface ; because Cc supports an action hChkStore ; OKi and thus supports method ChkStore , but requires an action hChkStore ; FAILi that is not supported . Intuitively , this means that Shop and Store do not agree on their mutual guarantees and assumptions , and therefore cannot work with each other .
CStore = f hChkStore ; OKi 7! ft t ( hGetOffer ; OKi u hOrder ; OKi)g hChkStore ; FAILi 7! fhGetOffer ; OKi u hOrder ; OKig g
The action hChkStore ; OKi is the same as in CStoreF , and for action hChkStore ; FAILi it orders new items . The consistency interfaces CShop and CStore are compatible , and can be composed to CShop k CStore . 3.2 Specifications
The notion of well formedness removes a general class of errors in consistency interfaces . However , depending on the particular application in which a service will be used , additional properties would be required of it . We identify a class of safety properties that seem the most useful in practice and propose a property speciflcation language and a veriflcation scheme as follows .
In the context of consistency interfaces , a conversation is a set of actions that are exhibited together . Sets of conversations are concisely represented using expressions ’ 2 B(A ) . Intuitively , the expression t represents the empty conversation . The expression a ( where a is a supported action ) represents the set of possible conversations exhibited when action a is invoked . If a is not supported , then the expression a represents the set consisting of only the conversation fag . Thus , we postpone judgement about the behavior exhibited by an action a until enough information is available about the actions a requires . Intuitively , this is why our formalism allows systems to be developed and analyzed incrementally ; as long as some environment exists in which the ( open ) system under development can operate correctly , it will be considered to be correct . The expression ’1 t ’2 represents a nondeterministic choice between ’1 and ’2 , and hence represents the set consisting of all conversations represented by ’1 or ’2 . The expression ’1 u ’2 represents the combination of the two sets of conversations , ie , the actions of each pair of conversations , one each from ’1 and ’2 , can be exhibited together in a conversation of ’1 u ’2 .
The set of conversations represented by an expression from B(A ) is deflned by the function [ [: ] ] : B(A ) ! 22A , which is inductively deflned as the least solution of the following system of equations :
= ffgg = ffag [ y j y 2 [ [C(a)]]g = ffagg
[ [t ] ] [ [a ] ] [ [a ] ] [ [’1 t ’2 ] ] = [ [’1 ] ] [ [ [’2 ] ] [ [’1 u ’2 ] ] = fx [ y j x 2 [ [’1] ] ; y 2 [ [’2]]g if a 2 dom(C ) if :a 2 dom(C ) where a 2 A and ’1 ; ’2 2 B(A ) .
Note that according to the above deflnition , the operators t and u are commutative and associative , and distribute over each other , thus acting like the boolean _ and ^ operators respectively . However , while t is idempotent ( like _ ) , u is not ( unlike ^ ) . The following example illustrates the idea concretely .
Example 7 . ( Idempotence ) The expression ’ t ’ represents choice between two completely equivalent alternatives , so t must be idempotent . Now consider the expression ’ = ( a t b ) u ( a t b ) . It represents two duplicate invocations of ( a t b ) , which make independent choices and hence ’ exhibits a richer set of conversations than a single invocation of ( a t b ) . Formally , [ [(a t b ) u ( a t b) ] ] = ffag ; fa ; bg ; fbgg 6= ffag ; fbgg = [ [a t b] ] .
A speciflcation ˆ for a consistency interface is a formula a 6ˆ S where a 2 A and S ( cid:181 ) A . Intuitively , a speciflcation represents the property that the invocation of action a must not lead to a conversation in which the actions in set S are all exhibited together . Formally , a speciflcation ˆ = a 6ˆ S is satisfled by a consistency interface C ( denoted C j= ˆ ) if S * y for all y 2 [ [C(a)] ] . The speciflcation satisfaction problem for consistency interfaces is in co NP .
Given two compatible
C1 and C2 , and a speciflcation ˆ , then the following holds : ( C1 k C2 ) j= ˆ ) ( C1 j= ˆ ^ C2 j= ˆ ) . The converse is not true . consistency interfaces
Example 8 . ( Speciflcation for consistency interfaces ) Consider the interface Cc = CShop k CStore and the following speciflcation ˆ : hSellItem ; FAILi 6ˆ fhChkStore ; FAILi ; hProcPay ; OKig
The speciflcation requires that the client must not be charged for an item which is not available at the store . To check whether Cc satisfles ˆ , we have to compute [ [Cc(hSellItem ; FAILi)] ] , ie ,
[ [hChkAvail ; FAILi t ( hChkAvail ; OKi u ( hProcPay ; FAILi t ( hProcPay ; OKi u hShipItem ; FAILi)))] ] ; which is the following set ( of sets ) :
'fhChkAvail ; FAILi ; hChkStore ; FAILi ; fhChkAvail ; OKi ; hChkStore ; OKi ; fhChkAvail ; OKi ; hChkStore ; OKi ; hGetOffer ; OKi ; hOrder ; OKi ; hGetOffer ; OKi ; hOrder ; OKig ; hProcPay ; FAILig ; fhChkAvail ; OKi ; hChkStore ; OKi ; fhChkAvail ; OKi ; hChkStore ; OKi ; hGetOffer ; OKi ; hOrder ; OKi ; hProcPay ; OKi ; hShipItem ; FAILig hProcPay ; OKi ; hShipItem ; FAILig hProcPay ; FAILig ;
“
We observe that there is no y in [ [Cc(hSellItem ; FAILi) ] ] such that fhChkStore ; FAILi ; hProcPay ; OKig ( cid:181 ) y , and therefore ( CShop k CStore ) j= ˆ .
Example 9 . ( Non recursive conversation ) Consider now the following interface for the Shop web service :
C0 Shop = f hSellItem ; SOLDi 7! hSellItem ; FAILi 7! hChkAvail ; OKi u hProcPay ; OKi hChkAvail ; FAILi t ( hChkAvail ; OKi u hProcPay ; FAILi ) hSellItem ; NOTFOUNDi 7! hChkAvail ; FAILi hChkAvail ; OKi 7! hChkAvail ; FAILi 7! g hChkStore ; OKi hChkStore ; FAILi
Let us compose C0
Shop with the following version of Store :
CStoreF2 = f hChkStore ; OKi 7! t t ( hGetOffer ; OKi u hOrder ; OKi ) hChkStore ; FAILi 7! hSellItem ; NOTFOUNDi u hGetOffer ; OKi u hOrder ; OKi g
Whenever method ChkStore reports that there are no more items available ( by action hChkStore ; FAILi ) , the Store interface notifles the Shop interface that there are no more items available . We can check whether the conversations of these two web services contain a recursive invocation of hChkStore ; FAILi by checking the following speciflcation on the composed interface :
ˆR = hChkStore ; FAILi 6ˆ fhChkStore ; FAILig
The property does not hold because hChkStore ; FAILi invokes hSellItem ; NOTFOUNDi which invokes hChkAvail ; FAILi , and this action invokes hChkStore ; FAILi again . 3.3 Substitutivity
While implementing a web service application , a developer often wants to use an ofi the shelf service P 0 to implement some desired functionality for which she has an abstract place holder P in her overall design . In such situations , it is required to decide if P 0 fulfllls the behavioral requirements specifled in P , to avoid errors in the overall design . Intuitively , reflnement captures the notion of one service being substitutable in place of another .
Given two consistency interfaces C and C 0 , we say C0 re flnes C ( written C0 4 C ) if i ) sig(C0 ) 4 sig(C ) , and ii ) for every a 2 A , if C supports a , then for all conversations y 2 [ [C0(a)] ] , there exists a conversation x 2 [ [C(a) ] ] such that y ( cid:181 ) x .
The deflnition above allows the reflnement C 0 to drop conversations , or actions from a conversation , for actions supported by C ; C0 is also allowed to support additional actions that C does not , but it is not allowed to require additional actions ; it can implement actions a not supported by C only by requiring actions b already required by C , and that too , only as long as it does not introduce a new conversation y in C0 for an action c supported by C such that y is not a fragment ( subset ) of a conversation x of c in C itself .
Theorem 1 . ( Substitutivity of consistency interfaces ) Let C1 , C0 1 , and C2 be three consistency interfaces such that comp(C1 ; C2 ) and comp(C0 1 ; C2 ) . Let ˆ = a 6ˆ S be a speciflcation such that a is supported by either C1 or C2 . If ( C1 k C2 ) j= ˆ and C0
1 4 C1 , then ( C0
1 k C2 ) j= ˆ .
The above theorem allows a developer to substitute a service C0 in place of an abstract place holder C in a design , if C0 reflnes C . Thus , our framework allows compositional reflnement : separate parts of a design can be independently reflned , say by independent development teams in a parallelized development environment , or even by separate companies that do not want to disclose any information about their code , without having to worry about global consistency issues . Once interfaces are decided at the top level , they can be handed ofi to separate development teams to be implemented in a more concrete form . As long as the design produced by each team is a reflnement of the interface it had been handed to start with , the design of the entire application is guaranteed to be correct . Formally , for consistency interfaces C1 , C0 1 ; C2 ) and C0 1 k C2 ) 4 ( C1 k C2 ) . The reflnementchecking problem for consistency interfaces is in NP .
1 , and C2 , if comp(C1 ; C2 ) and comp(C0
1 4 C1 , then ( C0
Shop is a reflnement of
Example 10 . ( Substitutivity of consistency interfaces ) The interface C0 Shop ( from Example 9 ) is a reflnement of interface CShop ( from Example 5 ) , because i ) sig(C 0 Shop ) = S 0 sig(CShop ) = SShop , and ii ) actions supported in C0 Shop require less actions than those supported in CShop ( C0 Shop does not require the actions for shipping ) and C0 Shop supports an additional action hSellItem ; NOTFOUNDi , which requires only actions already used by CShop . Applying Theorem 1 we conclude that if we replace interface CShop by its reflnement C0 Shop in the composition with the Store interface CStore , the new composition is a reflnement of the old composition , and the speciflcation ˆ from Example 8 is satisfled by the new composition :
( C0
Shop k CStore ) 4 ( CShop k CStore ) and ( C0
Shop k CStore ) j= ˆ .
4 . PROTOCOL INTERFACES
Consistency interfaces and the associated speciflcation formalism are used to reason about sets of actions . Though it is su–cient to catch a large set of web service errors and represent many properties of interest , there is often a need for a richer model of web service behavior that allows reasoning about evolution of behavior over time . In addition to reasoning about sequences of actions , it is important to be able to model thread creation , parallel executions of multiple threads , and joining threads after a parallel call . We introduce the formalism of protocol interfaces which is a rich model for representing web service behavior .
The set of terms over a set of actions A is deflned by the following grammar ( a ; b 2 A ) : term : : a j a t b j a u b j a ¢ b
A protocol automaton is a tuple F = ( Q ; ? ; – ) , where Q is a set of control locations , ? 2 Q is the return location , and – : ( Q n f?g ) ! ( terms £ Q ) is the switch function of the protocol automaton , which assigns to each location difierent from ? a term and a successor location . The execution halts when location ? is reached . A protocol interface P is a pair ( D ; F ) , where D : A ! 2Q is a partial function that assigns to an action a set of locations , and F is a protocol automaton . The semantics of a protocol interface is presented informally as follows . A formal semantics will be presented in Section 42 Intuitively , the execution of an action a starts in one of the locations in D(a ) . A switch of the automaton –(q ) = ( term ; q0 ) means that , if the automaton is in location q , it recursively invokes term , and remembers the successor location q0 as the return location , where control returns when the recursive invocation of term terminates . If the automaton reaches location ? , it returns control to the return location ; a return for the very flrst invocation of action a leads to termination of execution . The term a = hm ; oi represents a call to web method m with expected outcome o . The term a t b represents a nondeterministic choice between a and b . The term a u b represents spawning two threads for a and b in parallel , while the parent thread waits for both to flnish . The term a ¢ b represents spawning two threads for a and b in parallel , while the parent thread waits for whichever child flnishes flrst . Note that all three of t , u , and ¢ are commutative , and t is idempotent while u and ¢ are not .
A location q is well formed if there exists a terminating execution of F starting in location q . An action a is well formed if at least one of the locations in D(a ) is well formed . To formally deflne the notion of well formedness : Q ! ft ; fg , which is of locations , we use a function wf inductively deflned as follows : wf ( ? ) = t . wf ( q ) = W wf ( qa ) ^ wf ( q0 ) , if –(q ) = ( a ; q0 ) . qa2D(a ) wf ( q ) =
W qa2D(a);qb2D(b )
( wf ( qa ) ^ wf ( qb ) ) ^ wf ( q0 ) , if –(q ) = ( a u b ; q0 ) . wf ( q ) =
W qa2D(a);qb2D(b )
( wf ( qa ) _ wf ( qb ) ) ^ wf ( q0 ) , if –(q ) = ( a – b ; q0 ) ; – 2 ft ; ¢g .
The function wf can be computed using a least flxed point computation ( starting from the function that maps all locations to f ) that converges in time O(n2 ¢ k2 ) , where n = jQj is the number of locations of the protocol automaton and k = maxa(jD(a)j ) is the maximal nondeterministicbranching factor of the interface .
Given a protocol interface P = ( D ; F ) , the underlying web service signature of P ( denoted sig(P ) ) is the partial function S : A ! 2A such that S(a ) = Sq2D(a ) sigl ( q ) if D(a ) is deflned , and S(a ) is undeflned otherwise . The function : Q ! 2A assigns a set of actions to every location sigl q 2 Q of the protocol interface , and is inductively deflned as follows : sigl ( q ) = g(term ) [ sigl ( q0 ) for –(q ) = ( term ; q0 ) with q 6= ? , and sigl ( ? ) = ; . The function g : terms ! 2A is inductively deflned as g(a ) = a , g(a – b ) = fa ; bg with – 2 ft ; u ; ¢g , with a ; b 2 A . A protocol interface P is wellformed , if sig(P ) is well formed and all actions supported by P are well formed . In the rest of the paper , \protocol interface" stands for \well formed protocol interface" .
Example 11 . ( Well formed protocol interface ) Let us model the Shop web service as a protocol interface . For simplicity , protocol interfaces are deflned concisely here by giving the switch function – of the automaton as a sequence of triples q : ( term ; q0 ) , and the partial function D is indicated by writing an action in front of every location it is mapped to .
PShop = f hSellItem ; SOLDi 7! q0 : ( hChkAvail ; OKi ; q1 ) hSellItem ; FAILi 7! q2 : ( hChkAvail ; FAILi t q1 : ( hProcPay ; OKi ; ? ) hSellStep1 ; FAILi ; ? ) hSellStep1 ; FAILi 7! q3 : ( hChkAvail ; OKi ; q4 ) q4 : ( hProcPay ; FAILi t hSellStep2 ; FAILi ; ? ) hSellStep2 ; FAILi 7! q5 : ( hProcPay ; OKi ; q6 ) hChkAvail ; OKi 7! hChkAvail ; FAILi 7! q8 : ( hChkStore ; FAILi ; ? ) g q6 : ( hShipItem ; FAILi ; ? ) q7 : ( hChkStore ; OKi ; ? )
Compare this protocol interface with the consistency interface CShop ; they have a relationship and we will formalize the idea in Section 44
The protocol interface models action hSellItem ; SOLDi the three actions occur in the given sequence in a conversation . When the action hSellItem ; FAILi is invoked , Shop nondeterministically can check the availability of the item ( using ChkAvail ) with the expectation that for of failure , or can invoke SellStep1 with the expectation of failure . In the latter case , ChkAvail is invoked with expectation of success , and then either the payment processing web method ( ProcPay ) or the Sellstep2 web method is invoked , in both cases with expectation of failure . The invocation of hSellStep2 ; FAILi leads to a successful invocation of the payment processing web method , and then a failed attempt to ship the item sold ( using ShipItem ) .
The protocol interface PShop is well formed , because its underlying signature is well formed and all its actions are well formed .
Example 12 . ( Concurrency and nondeterministic actions ) The following interface is the protocol interface for the Store web service :
PStore = f hChkStore ; OKi 7! ? hChkStore ; OKi 7! q10 hChkStore ; FAILi 7! q10 : ( hSupp1:GetOffer ; RECi u hSupp2:GetOffer ; RECi ; q11 ) q11 : ( hSupp1:Order ; OKi t hSupp2:Order ; OKi ; ? ) g
Let us flrst consider action hChkStore ; FAILi . The interface models for this action that two difierent supplier web services are simultaneously asked to make an ofier . This example shows how the protocol interface expresses not only sequence , but also concurrency . After both ofiers are received , the automaton switches to location q11 , where the Store orders the missing item from one of the two suppliers . After this action , the automaton switches to the return location ? , and the conversation induced by action hChkStore ; FAILi terminates .
The invocation of action hChkStore ; OKi either immediately returns , or orders new items , when the stock is below a certain threshold . This is modeled by assigning two difierent locations to the same action . Note that for ordering new items the implementation of hChkStore ; FAILi is shared .
4.1 Compatibility and Composition
Intuitively , as for consistency interfaces , given two protocol interfaces , if their behavior allows them to co operate , we say they are compatible , and we are able to compose them , forgetting their internal distinctions and allowing ourselves to focus instead on their behavioral contract with their environment .
Given two protocol interfaces P1 = ( D1 ; F1 ) and P2 = ( D2 ; F2 ) , if the underlying signatures sig(P1 ) and sig(P2 ) are compatible , and Q1 \ Q2 = f?g , and Pc = ( Dc ; Fc ) is a protocol interface , where Dc = D1 [ D2 , Fc = ( Q1 [ Q2 ; ? ; –1 [ –2 ) , where Qi and –i are the set of locations and the switch function of the automaton Fi for i 2 f1 ; 2g , then P1 and P2 are compatible ( denoted comp(P1 ; P2) ) , and their composition ( denoted by P1 k P2 ) is Pc . The composition operation is commutative and associative . Compatibility and composition of protocol interfaces can be computed in linear time .
A protocol interface P is closed if its underlying web service signature sig(P ) supports all actions it requires , formally , 8a 2 A : a 2 RP ) a 2 dom(sig(P) ) , where RP = fa j 9a0 2 A : a 2 sig(P)(a0)g is the set of actions required by P . An interface that is not closed is called open . Given an open protocol interface P , an environment for P is a protocol interface EP that is compatible with P and supports all actions that are required but not supported by P . Note that the composition ( P k EP ) is closed , and EP is not unique . Intuitively , each EP represents a design context in which P can be used .
Example 13 . ( Compatibility of protocol interfaces ) The two protocol interfaces PShop and PStore are compatible , because their underlying signatures are compatible , their protocol automata have no location in common except ? , and all their actions are well formed . Thus their composition PShop k PStore is a protocol interface .
4.2 Specifications
We use a speciflcation language which is capable of expressing temporal safety constraints to represent protocol properties . In the context of protocol interfaces , a conversation is a set of sequences of objects A , where each A is a set of actions ; intuitively , it is a directed acyclic graph of actions that are exhibited in sequence or in parallel . Sets of conversations are represented by protocol automata , which concisely represent multi threaded systems with an unbounded number of threads .
A speciflcation ˆ for a protocol interface is a formula a 6ˆ ’ where a 2 A , and ’ is a temporal formula of the form ( :C ) U B ( \not C until B" ) , with C ; B ( cid:181 ) A . Intuitively , a speciflcation a 6ˆ ( :C ) U B means that the invocation of action a must not lead to a conversation in which an action from the set B occurs before any action from the set C has occurred . The expressions ’ can be extended to allow right associative nesting of U operators , as well as boolean combinations of U formulas . We omit such extensions here for simplicity of presentation .
A speciflcation ˆ for a protocol interface P is interpreted over traces generated by the underlying transition relation of P , which is deflned as follows .
Underlying transition relation . Given a flnite set of symbols L , a ( binary ) tree t over L is a partial function t : B⁄ ! L , where B⁄ denotes the set of flnite words over B = f0 ; 1g , and the domain dom(t ) = fp 2 B⁄ j 9(p ; l ) 2 tg is preflx closed . Each element from dom(t ) represents a node of tree t , and each node p is named with the symbol t(p ) . The root is represented by the empty word ‰ . The set of child nodes of node p in tree t is denoted by ch(t ; p ) = fp0 j 9b 2 B : p0 = p ¢ b ^ p0 2 dom(t)g , where ¢ is the concatenation operator . The set of leaf nodes of a tree t is leaf ( t ) = fp 2 dom(t ) j ch(t ; p ) = ;g . The set of all trees over a flnite set L is denoted T ( L ) .
Given a protocol interface P = ( D ; F ) , the underlying transition relation of P is a labeled transition relation !P ( cid:181 ) T ( Q¢ )£2A[fretg £T ( Q¢ ) , where the states are trees over the tree symbols Q¢ = Q£f¢ ; –g , where Q is the set of locations of protocol automaton F , and the transitions between states are labeled with sets of elements from A[fretg . A! t0 for ( t ; A ; t0 ) 2 !P . In the rules below , if acWe write t tion c is supported by P , qc is an element of D(c ) , otherwise qc is ? . The relation !P is deflned as follows :
† Call : t fag ! t0 if there exists a node p such that p 2 leaf ( t ) , t(p ) = q– , and –(q ) = ( a ; q0 ) is a switch of F , and t0 = ( t n f(p ; q–)g ) [ f(p ; q0– ) ; ( p ¢ 0 ; qa–)g .
† Fork : t fa;bg ! t0 if there exists a node p such that p 2 leaf ( t ) , t(p ) = q– , and –(q ) = ( a u b ; q0 ) is a switch of F , and t0 = ( t n f(p ; q–)g ) [ f(p ; q0– ) ; ( p ¢ 0 ; qa– ) ; ( p ¢ 1 ; qb–)g .
† Choice : t fcg ! t0 if there exists a node p such that p 2 leaf ( t ) , t(p ) = q– , and –(q ) = ( a t b ; q0 ) is a switch of F , and t0 = ( t n f(p ; q–)g ) [ f(p ; q0– ) ; ( p ¢ 0 ; qc–)g , where c 2 fa ; bg .
† Fork Choice : t fa;bg ! t0 if there exists a node p such that p 2 leaf ( t ) , t(p ) = q– , and –(q ) = ( a ¢ b ; q 0 ) is a switch of F , and t0 = ( t n f(p ; q–)g ) [ f(p ; q0¢ ) ; ( p ¢ 0 ; qa– ) ; ( p ¢ 1 ; qb–)g .
† Return : t fretg ! t0 if there exists a node p ¢ b , where b 2 B , such that p ¢ b 2 leaf ( t ) , t(p ¢ b ) = ?– , t(p ) = q– , and t0 = t n f(p ¢ b ; ?–)g .
† Return & Remove Sibling Tree : t fretg ! t0 if there exists a node p ¢ b , b 2 B such that p ¢ b 2 leaf ( t ) , t(p ¢ b ) = ?– , t(p ) = q¢ , and t0 = ( t n f(p ¢ p0 ; q0 ? ) j p0 2 B⁄ ^ q0 ? 2 Q¢g ) [ f(p ; q–)g .
Intuitively , we have a pushdown system whose state is a tree , not a stack ( tree with branching out degree 1 ) . The primitives Call , Choice , and Return contribute to pushdown behavior , and the primitives Fork and Fork Choice lead to branching in the pushdown state . The leaves of the tree represent parallel threads of control . A node p of the tree is labeled with an element of Q¢ , the label representing the \return location" where control should reach when all the children of node p are removed from the tree . For a Call of a supported action , the current location is popped as a leaf from the tree , the successor location is flrst pushed , and then one of the locations corresponding to the called action ( nondeterministically chosen ) is pushed as child of the successor location . Choice behaves similarly except that it produces the successor tree for any of the two actions . In case of a Fork and a Fork Choice , the current location is popped , the successor location is pushed , and a branch point is created in the state , two locations corresponding to the two parallel actions are pushed as children of the successor location . In case of Return , a leaf labeled with the return location ? is popped . If the parent of the return location is the successor of a fork choice term , the whole sibling subtree is also removed . In other words , a node with two children resulting from a fork can only be popped if both children were popped before , but a node with two children resulting from a fork choice is popped if one of the children was popped . To remember this fact in the tree symbols , every control location is paired with a ( cid:176)ag from f¢ ; –g . Note that invocations of unsupported actions are assumed to immediately return . A run of a transition relation is an alternating sequence of trees and sets of actions t0 ; A1 ; t1 ; A2 ; t2 ; : : : , with 8i 2 Ai! ti . A trace is the projection of a run f1 ; : : : ng : ti¡1 to its action sets , eg , for the run t0 ; A1 ; t1 ; A2 ; t2 ; : : : , the corresponding trace is A1 ; A2 ; : : : ; for a location q , a q run is a run t0 ; A1 ; t1 ; : : : with t0 = f(‰ ; q–)g , ie , a run starting from location q ; a q trace is a trace corresponding to a q run . Speciflcation checking . A location q satisfles a temporal formula ( :C ) U B ( written q j= ( :C ) U B ) if there exists a q trace A1 ; A2 ; : : : such that there exists a j such that Aj \ B 6= ; , and for all i < j , we have Ai \ C = ; . A closed protocol interface P = ( D ; F ) satisfles a speciflcation ˆ = a 6ˆ ’ ( written P j= ˆ ) if for all q 2 D(a ) , we have q 6j= ’ .
Although we deflned the semantics of q j= ’ in terms of traces of the underlying transition relation , to check satisflability in practice we do not compute the transition relation because it may be inflnite . Instead , we deflne a set of proof rules ( cf . Figure 2 ) and give a polynomial time algorithm ( cf . Algorithm 1 ) . Using the proof rules in Figure 2 we inductively decide judgements ¡ = q j= ’ where ’ is a temporal formula of the form ’U = ( :C ) U B , or ’2 = 2(:C ) . All leaves of the proof result from the proof rules \Return 2" and \Reached U 0" . If a judgement is true , there exists a short proof of linear size , and its existence can be decided in polynomial time . We explain some of the proof rules below . The rule \Return 2" at the top of Figure 2 asserts that the location ? satisfles the property 2(:C ) ie , no ? trace should contain an element from C ; which is true , since the ? trace is empty . The \Call 2" rule says that if the invocation of action a does not ( recursively ) lead to an element from C , and a itself is not in C , and furthermore , the successor location q0 , where control returns after execution of a , does not lead to an element from C , then the location q , at which a is called , never leads to an element of C . The rule \Choice 2" for the operator t is similar to \Call 2" , except that one of the nondeterministically chosen actions from the term invoked must fulflll the requirements in the antecedent . The remaining rules similarly enforce the semantics of a recursive system with nondeterministic choice , process spawning and joining , and a pushdown tree store .
Proposition 1 . ( Correctness of speciflcation checking ) For a given closed protocol interface P and a speciflcation ˆ = a 6ˆ ( :C ) U B , procedure CheckSpec(P ; a ; B ; C ) in Algorithm 1 stops with answer Yes if P satisfles ˆ , and No otherwise .
Algorithm 1 CheckSpec(P ; a ; B ; C ) Input : Closed protocol interface P = ( D ; F ) ,
Action sets B ; C ( cid:181 ) A , and action a 2 A
Output : Yes if P satisfles a 6ˆ ( :C ) U B , No otherwise Variables : Set of judgements S , boolean done 1 : done := f 2 : while ( : done ) do 3 : 4 : 5 : 6 : done := t for each location q of automaton F do
// Try to prove q j= 2(:C ) . if all premises of a rule for q j= 2(:C ) are in S then
7 : 8 : 9 : 10 :
11 : 12 :
13 : 14 :
S := S [ fq j= 2(:C)g done := f
// Try to prove q j= ( :C ) U B . if all premises of a rule for q j= ( :C ) U B are in S then
S := S [ fq j= ( :C ) U Bg done := f end if ( q j= ( :C ) U B ) 2 S for some q 2 D(a ) then return No end
15 : return Yes
? j= 2(:C ) qa j= 2(:C ) a 62 C q0 j= 2(:C ) q j= 2(:C )
–(q ) = ( a ; q0 ) ; qa 2 D(a ) qc j= 2(:C ) c 62 C q0 j= 2(:C ) q j= 2(:C )
–(q ) = ( a t b ; q0 ) ; c 2 fa ; bg ; qc 2 D(c ) qa j= 2(:C ) a 62 C qb j= 2(:C ) q j= 2(:C ) b 62 C q0 j= 2(:C )
–(q ) = ( a u b ; q0 ) ; qa 2 D(a ) ; qb 2 D(b )
( Return 2 )
( Call 2 )
( Choice 2 )
( Fork 2 ) qc j= 2(:C ) a 62 C b 62 C q0 j= 2(:C ) q j= 2(:C )
–(q ) = ( a ¢ b ; q0 ) ; c 2 fa ; bg ; qc 2 D(c )
( Fork Choice 2 ) c 2 B q j= ( :C ) U B
–(q ) = ( c ; q0 ) _ ( –(q ) = ( a – b ; q0 ) ^ c 2 fa ; bg ) ; qc 2 D(c ) ; – 2 ft ; u ; ¢g c j= ( :C ) U B c 62 C q j= ( :C ) U B
–(q ) = ( c ; q0 ) _ ( –(q ) = ( a – b ; q0 ) ^ c 2 fa ; bg ) ; qc 2 D(c ) ; – 2 ft ; u ; ¢g qa j= 2(:C ) a 62 C q0 j= ( :C ) U B q j= ( :C ) U B
–(q ) = ( a ; q0 ) ; qa 2 D(a ) qc j= 2(:C ) c 62 C q0 j= ( :C ) U B q j= ( :C ) U B
–(q ) = ( a t b ; q0 ) ; c 2 fa ; bg ; qc 2 D(c ) qa j= 2(:C ) a 62 C qb j= 2(:C ) b 62 C q0 j= ( :C ) U B q j= ( :C ) U B
–(q ) = ( a u b ; q0 ) ; qa 2 D(a ) ; qb 2 D(b )
( Reached U 0 )
( Reached U + )
( Call U )
( Choice U )
( Fork U ) qc j= 2(:C ) a 62 C b 62 C q0 j= ( :C ) U B q j= ( :C ) U B
–(q ) = ( a ¢ b ; q0 ) ; c 2 fa ; bg ; qc 2 D(c )
( Fork Choice U )
Figure 2 : Proof rules for speciflcation checking
The algorithm computes the least flxed point of the set of provable judgements wrt the proof rules by starting with the empty set of judgements , and trying to prove every stillunproven judgement until no new judgements can be proved . For every location q , it iterates through the all rules that can be used to prove the two judgements q j= ( :C ) U B and q j= 2(:C ) . If all antecedents of a rule are already proven , the rule is \triggered" , and the consequent is considered proven . This corresponds to a leaves to root traversal of the proof for each judgement , where a proof for a judgement ¡ is seen as a tree with ¡ as root , instances of the proof rules as internal nodes , and judgements axiomatically known to be true , as leaves . Since there are only flnitely many proof rules for each location , flnitely many locations , and flnitely many judgements , and the algorithm proves at least one new judgement in each iteration till the flxed point is reached , the procedure must terminate . For each judgement ¡ for which a proof exists , a shortest proof p(¡ ) exists . By induction over the length of p(¡ ) , we conclude that every ¡ for which a proof exists , is eventually proved by our algorithm , and vice versa .
Proposition 2 . ( Complexity of speciflcation checking ) Given a closed protocol interface P = ( D ; F ) , and given a speciflcation ˆ = a 6ˆ ( :C ) U B , the question if P satisfles ˆ can be decided in O(n2 ¢ k2 ) time , where n is the number of locations of F , and k = maxa2A jD(a)j is the maximal nondeterministic branching factor of P .
The set operations insertion and membership checking can be done in O(1 ) time , using , for example , a direct access array of ( cid:176)ags , since the number of judgements is bounded . A term in a switch can have the form a u b ; hence the algorithm , in the worst case , has to check O(k2 ) proof rules for a location ( lines 6 and 10 ) . Line 13 takes O(k ) time . Therefore , lines 5 to 14 altogether are in O(k2 ) time . The loop over locations ( line 4 ) always makes n iterations . The flxpoint iteration ( line 2 ) is executed at most 2n times since we have only 2n judgements . Note that for the special case when C is empty , the problem reduces to reachability of a state where an action from B is invoked , which can be decided in linear time .
Example 14 . ( Speciflcation for protocol interfaces ) The Shop web service is not allowed to process payments if the item to be sold is not available . Therefore , we need to check that in PShop the payment is never processed before the availability of the item is checked ; this property is expressed in the following speciflcation ˆ : hSellItem ; FAILi 6ˆ :fhChkStore ; OKig U fhProcPay ; OKig
This property is satisfled if none of the conversations of PShop has the following characteristic : it starts with a sequence of actions which are all difierent from hChkStore ; OKi , and eventually an action hProcPay ; OKi occurs . Note that this particular speciflcation is \stronger" than the corresponding speciflcation we discussed for consistency interfaces : it forbids not only the conversations that fail checking of availability before payment , but also those that do not check for availability at all ; and also the desired sequence is enforced . Observe that the composition Pc = PShop k PStore , along with a minimal environment for Pc that does not require any actions , satisfles the speciflcation ˆ .
Properties like ˆ in general cannot be verifled using consistency interfaces , because consistency interfaces do not keep track on the order of actions in conversations . However , a subset of the protocol speciflcations can be checked even using consistency interfaces using a relationship between consistency and protocol interfaces ( intuitively \conservative extension" ) that will be formalized in Section 44 4.3 Substitutivity
As in the case of consistency interfaces , we want to enable the substitution of a protocol interface in a design comprising a set of web services , with the assurance that the change will not allow violation by the combined system of any speciflcation that it satisfled before the substitution . Our notion of reflnement for protocol interfaces is based on simulation of labeled transition systems . We flrst deflne the notions labeled transition system and simulation . Then we describe how to build a labeled transition system from the underlying transition relation of the protocol interface , and deflne reflnement of two protocol interfaces based on their labeled transition systems .
A labeled transition system ( LTS ) T S is a tuple ( S ; Si ; L ; ! ) , where S the set of states , Si ( cid:181 ) S is the set of initial states , L is the set of labels , and ! ( cid:181 ) S £ L £ S is the transition relation . An LTS T S 0 = ( S0 ; S0 i ; L ; !0 ) is simulated by an LTS T S = ( S ; Si ; L ; ! ) if there exists a relation ( cid:181 ) S0 £ S such that :
† for every s1 2 S , s0
1 2 S0 , if s0
2 , there exists a transition s1
1 s1 , then for every l! s2 , transition s0 1 such that s0 2 s2 , and l! s0
† for every s0 2 S0 i , there exists s 2 Si such that s0 s .
Given a protocol interface P = ( D ; F ) and an action a supported by P , the underlying transition system obtained by invoking a on P ( denoted uts(P ; a ) ) is the LTS T S = ( T ( Q¢ ) ; ff‰ 7! q–g j q 2 D(a)g ; 2A[fretg ; !P ) , where T ( Q¢ ) is the set of trees over the set of labels Q¢ , and Q¢ = Q £ f¢ ; –g , where Q is the set of locations in F , and !P is the underlying transition relation of P deflned in Section 42 Intuitively , it is an LTS with a set of states comprising the set of binary trees with nodes labeled with elements from Q¢ , the set of initial states comprising trees with a root labeled with an element of D(a ) , and the transition relation !P .
Given interfaces we say P 0 reflnes P ( written P 0 4 P ) , if protocol two
P and
P 0 ,
† sig(P 0 ) 4 sig(P ) , and
† for every action a 2 A , if P supports a , then the LTS T S 0 = uts(P 0 ; a ) is simulated by the LTS T S = uts(P ; a ) .
Note that for all protocol interfaces P and P 0 , we have P 0 4 P if and only if ( P 0 k E 0 P ) , where E 0 P is the minimal environment of P and P 0 , which supports each action required but not supported by P and P 0 with an implementation that returns immediately on invocation .
P ) 4 ( P k E 0
Proposition 3 . ( Compositionality of reflnement ) 1 , and P2 be three protocol interfaces such that 1 k
1 4 P1 , then ( P 0
Let P1 , P 0 comp(P1 ; P2 ) and comp(P 0 P2 ) 4 ( P1 k P2 ) .
1 ; P2 ) .
If P 0
From this proposition it follows that a component based system , after reflnement of one component , still satisfles all speciflcations that it satisfled before reflnement .
Theorem 2 . ( Substitutivity of protocol interfaces ) Let P1 , P 0 1 , and P2 be three protocol interfaces such that comp(P1 ; P2 ) and comp(P 0 1 k P2 ) are both closed . Let ˆ = a 6ˆ ( :C ) U B be a speciflcation such that a is supported by P1 . Then , if ( P1 k P2 ) j= ˆ and P 0
1 ; P2 ) ; and ( P1 k P2 ) and ( P 0
1 4 P1 , then ( P 0
1 k P2 ) j= ˆ .
Note that given protocol interfaces P = ( D ; F ) and P 0 = ( D0 ; F 0 ) , deciding the question if P 0 4 P requires , according to the deflnition of reflnement above , checking whether the corresponding underlying transition systems are in simulation . However , the underlying transition systems may be inflnite state systems : there can be an inflnite number of trees representing the conflguration of the parallel and sequential action invocations in the multi threaded system . Our formalism of protocol automata and the underlying transition relation enables visibility of recursion and control returns [ 1 ] , therefore , the problem can be solved e–ciently as follows . We deflne a local simulation relation on locations : ¢ ( cid:181 ) Q0 £ Q , where Q ; Q0 are the sets of locations of F and F 0 , as follows : ( q0 ; q ) 2 ¢ if the LTS pair T S 0 = ( T ( Q0¢ ) ; ff‰ 7! q0–gg ; 2A[fretg ; !P 0 ) and T S = ( T ( Q¢ ) ; ff‰ 7! q–gg ; 2A[fretg ; !P ) are such that T S 0 T S . Note that we can compute the relation ¢ using a greatest flxed point computation starting from the set of all pairs f(q0 ; q ) j q0 location of F 0 ; q location of Fg and removing pairs ( q0 ; q ) when the one step simulation locally fails , ie , q has no switches to match a term that q0 can invoke ; until a flxed point is reached and for every action a supported by P , for every location q0 2 D0(a ) there is a location q 2 D(a ) such that the pair ( q0 ; q ) is in the flxed point set , and we conclude simulation holds ; or there exists at least one action a supported by P such that all the pairs f(q0 ; q ) j q0 2 D0(a ) ; q 2 D(a)g are eventually removed from the set of pairs , at which point we conclude that simulation fails at some point on invocation of action a . Note that the other condition for reflnement involves checking reflnement on the underlying signatures sig(P ) and sig(P 0 ) , which takes linear time .
Proposition 4 . ( Complexity of reflnement checking ) Given protocol interfaces P = ( D ; F ) and P 0 = ( D0 ; F 0 ) , the question if P 0 4 P can be decided in O(c¢(jAj+ c ) ) time , where A is the set of actions , c = n¢ n0 ¢ k ¢ k0 , where n and n0 are the numbers of locations in F and F 0 respectively , k = maxa2A(jD(a)j ) and k0 = maxa2A(jD0(a)j ) .
Example 15 . ( Substitutivity of protocol interfaces ) Consider the protocol interface PShop and the following protocol interface P 0
Shop :
P 0 Shop = f hSellItem ; SOLDi 7! hSellItem ; FAILi 7! q20 : ( hChkAvail ; OKi ; q21 ) q21 : ( hProcPay ; OKi ; ? ) q22 : ( hChkAvail ; FAILi t hSellStep1 ; FAILi ; ? ) hSellStep2 ; FAILi 7! hSellStep1 ; FAILi 7! q23 : ( hChkAvail ; OKi ; q24 ) q24 : ( hProcPay ; FAILi ; ? ) q25 : ( hProcPay ; OKi ; q26 ) q26 : ( hShipItem ; FAILi ; ? ) hSellItem ; NOTFOUNDi 7! q27 : ( hChkAvail ; FAILi ; ? ) hChkAvail ; OKi 7! hChkAvail ; FAILi 7! g q28 : ( hChkStore ; OKi ; ? ) q29 : ( hChkStore ; FAILi ; ? ) interface P 0
Shop reflnes interface PShop beThe protocol cause the reflned version \implements" the abstraction : it adds guarantees ( it supports hSellItem ; NOTFOUNDi ) , and removes some nondeterministic choice in the behavior ( in hSellStep1 ; FAILi ) . Note that the abstraction nondeterministically generates some traces that cannot be matched by the reflnement . 4.4 Consistency and protocol interfaces
We have presented in Sections 3 and 4 two difierent theories for modeling web service interfaces , with difierent definitions for composition and reflnement . In the following discussion we show that the two theories are consistent with each other , and that the protocol theory is a conservative extension of the consistency theory .
Given a protocol interface P = ( D ; F ) , the underlying consistency interface of P ( denoted uci(P ) ) is the partial function C : A ! B(A ) such that C(a ) = Fq2D(a ) uce(q ) if D(a ) is deflned , and C(a ) is undeflned otherwise . The function uce : Q ! B(A ) assigns an expression to every location q 2 Q of the protocol interface , and is inductively deflned as follows : uce(q ) = f ( term ) u uce(q0 ) for –(q ) = ( term ; q0 ) with q 6= ? , and uce( ? ) = t . The function f : terms ! B(A ) is inductively deflned as f ( a ) = a , f ( a t b ) = a t b , and f ( a – b ) = a u b with – 2 fu ; ¢g , and a ; b 2 A . Note that sig(uci(P ) ) = sig(P ) , as expected , and hence for two protocol interfaces P1 and P2 , comp(P1 ; P2 ) ) comp(uci(P1 ) ; uci(P2) ) , but the converse is not true . Given a protocol speciflcation ˆp = a 6ˆ ( :C ) U B , the set of underlying consistency speciflcations of ˆp is deflned as ucs(ˆp ) = fa 6ˆ fbg j b 2 Bg .
Theorem 3 . ( Conservative extension ) The theory of protocol interfaces is a conservative extension of the theory of consistency interfaces . In particular :
1 . Given two compatible protocol interfaces P1 and P2 such that P1 k P2 is closed , and a protocol speciflcation ˆp , if uci(P1 ) k uci(P2 ) j= ˆc for every ˆc 2 ucs(ˆp ) , then P1 k P2 j= ˆp . The converse is not true .
2 . Given protocol interfaces P and P 0 , if P 0 4 P , then uci(P 0 ) 4 uci(P ) . The converse is not true .
Example 16 . ( Conservative
Consider the two compatible protocol interfaces PShop and PStore from the previous examples in this section , and the following speciflcation ˆp : extension ) hSellItem ; SOLDi 6ˆ :fg U fhProcPay ; FAILig
This speciflcation requires that a conversation starting with hSellItem ; SOLDi must not reach the action hProcPay ; FAILi , no matter what other actions occur on the way to it . If we apply the deflnition of underlying consistency interface to the protocol interfaces PShop and PStore , we get the underlying consistency interfaces uci(PShop ) and uci(PStore ) ( which are similar to , but not identical to the examples in Section 3 ) .
The set of underlying consistency speciflcations for ˆp is a singleton , it contains the following speciflcation ˆc = ucs(ˆp ) : hSellItem ; SOLDi 6ˆ fhProcPay ; FAILig
Theorem 3 states in its flrst part that if the composition uci(PShop ) k uci(PStore ) satisfles all of the underlying consistency speciflcations | which is true in our case | then the composition PShop k PStore satisfles the protocol speciflcation ˆp . This particular ˆp is a reachability speciflcation , but in general given a protocol speciflcation that rules out a sequence of actions , the conjunction of the underlying consistency speciflcations rules out all possible orders of the actions from the forbidden sequence . Then , for a protocol speciflcation ˆp , the conjunction V ucs(ˆp ) of the underlying consistency speciflcations is \stronger" than ˆp , which forbids a conversation only if the actions occur in one particular order . Thus , the ability to reason about sequences gives the designer the ability to much more precisely express what kinds of behavior are undesired .
Example 17 . ( Conservative extension of reflne ment ) Consider the protocol interfaces PShop and P 0 Shop from the previous examples . We already know that P 0 Shop reflnes PShop . Theorem 3 states in its second part that in this case the underlying consistency interfaces fulflll the reflnement relation as well . The underlying consistency interfaces of PShop and P 0 Shop ) , respectively . The reflnement relation uci(P 0 Shop ) 4 uci(PShop ) holds . Note that the underlying consistency interfaces are very similar , but not identical to the examples in Section 3 .
Shop are uci(PShop ) and uci(P 0
5 . RELATED WORK
The fleld of modeling web services and their interaction protocols has received considerable attention in recent years . We will brie(cid:176)y mention some of the related work .
A variety of formalisms have been proposed for e business conversation models [ 17 ] , models for control ( cid:176)ow [ 24 , 16 ] , and to model dynamic contracts between services [ 6 ] . A high level programming language for web service implementation , XL [ 10 ] , supports constructs like nondeterministic choice and parallel execution . BPEL1 , together with WS C2 and WS T3 , have emerged as the technology for specifying 1http://wwwibmcom/developerworks/library/ws bpel/ 2http://xmlcoverpagesorg/WS Coordination200309pdf 3http://xmlcoverpagesorg/WS Transaction2002pdf interaction protocols between web services . They are built on top of the XML based messaging protocol SOAP4 and the interface description language WSDL5 .
Veriflcation of BPEL descriptions using flnite state model extraction and the NuSMV model checker has been proposed [ 21 ] . Temporal logics for compositional reasoning about web service interfaces have been proposed [ 22 ] . Fu , Bultan , and Su studied conversations which occur in compositions of web services [ 4 , 12 ] , and analyzed interactions of composed web services by modeling them as conversations [ 13 , 14 ] . An implementation supporting a guarded automaton language and using the SPIN model checker is available in WSAT [ 15 ] . A similar approach was chosen in [ 19 ] , translating BPEL descriptions of web services into Promela , and using the SPIN model checker to analyze web service ( cid:176)ow . Unanticipated behaviors were detected in the WS AT6 protocol using a temporal speciflcation language and model checking [ 18 ] . Process interactions have been verifled using flnite state representations for web service composition [ 11 ] .
A DAML S7 based semantics has been proposed for web services [ 20 ] . First order logic is used to express speciflcations , and web service descriptions are represented as Petri nets for simulation , veriflcation , and composition . A CCSbased formalism to represent and analyze WSCI descriptions has been proposed [ 3 ] , and the issues of compatibility [ 23 ] and substitutivity are discussed .
The protocol interface formalism proposed in this paper supports programming and modeling language constructs like spawning threads , nondeterministic choice , sequencing , recursion , join operations , callbacks , etc . , which are supported by web service programming or modeling frameworks like the .NET framework , or WSCI8 . However , while Turingcomplete programming environments or modeling languages sufier from the undecidability of non trivial properties , temporal speciflcations and reflnement of our interfaces can be algorithmically checked .
Acknowledgement . We thank Nir Piterman for helpful discussions about algorithms for checking properties of pushdown systems .
6 . REFERENCES [ 1 ] R . Alur and P . Madhusudan . Visibly pushdown languages . Proc . STOC , pp . 202{211 . ACM , 2004 .
[ 2 ] S . Anderson , M . Chapman , M . Goodner , P . Kackinaw , and R . Rekasius . Supply chain management use case model . Working group interim report , Web Services Interoperability Organization , 2002 .
[ 3 ] A . Brogi , C . Canal , E . Pimentel , and A . Vallecillo .
Formalizing web service choreographies . Proc . WS FM . Elsevier , 2004 .
[ 4 ] T . Bultan , X . Fu , R . Hull , and J . Su . Conversation speciflcation : a new approach to design and analysis of e service composition . Proc . WWW , pp . 403{410 . ACM , 2003 .
4http://wwww3org/TR/soap12/ 5http://wwww3org/TR/wsdl 6http://www 106ibmcom/developerworks/library/ws atomtran/ 7http://wwwdamlorg/services/ 8http://wwww3corg/TR/wsci/
[ 5 ] A . Chakrabarti , L . de Alfaro , T . Henzinger , and
M . Stoelinga . Resource interfaces . Proc . EMSOFT , LNCS 2855 , pp . 117{133 . Springer , 2003 .
[ 6 ] H . Davulcu , M . Kifer , and I . V . Ramakrishnan .
CTR S : a logic for specifying contracts in semantic web services . Proc . WWW , pp . 144{153 . ACM , 2004 .
[ 7 ] L . de Alfaro and T . Henzinger . Interface automata .
Proc . FSE , pp . 109{120 . ACM , 2001 .
[ 8 ] L . de Alfaro and T . Henzinger . Interface theories for component based design . Proc . EMSOFT , LNCS 2211 , pp . 148{165 . Springer , 2001 .
[ 9 ] L . de Alfaro , T . Henzinger , and M . Stoelinga . Timed interfaces . Proc . EMSOFT , LNCS 2491 , pp . 108{122 . Springer , 2002 .
[ 10 ] D . Florescu , A . Gr˜unhagen , and D . Kossmann . XL : an
XML programming language for web service speciflcation and composition . Proc . WWW , pp . 65{76 . ACM , 2002 .
[ 11 ] H . Foster , S . Uchitel , J . Magee , and J . Kramer .
Compatibility veriflcation for web service choreography . Proc . ICWS , pp . 738{741 . IEEE , 2004 . [ 12 ] X . Fu , T . Bultan , and J . Su . Conversation protocols :
A formalism for speciflcation and veriflcation of reactive electronic services . Proc . CIAA , LNCS 2759 , pp . 188{200 . Springer , 2003 .
[ 13 ] X . Fu , T . Bultan , and J . Su . Analysis of interacting
BPEL web services . Proc . WWW , pp . 621{630 . ACM , 2004 .
[ 14 ] X . Fu , T . Bultan , and J . Su . Realizability of conversation protocols with message contents . Proc . ICWS , pp . 96{103 . IEEE , 2004 .
[ 15 ] X . Fu , T . Bultan , and J . Su . WSAT : A tool for formal analysis of web services . Proc . CAV , LNCS 3114 , pp . 510{514 . Springer , 2004 .
[ 16 ] R . Hamadi and B . Benatallah . A Petri net based model for web service composition . Proc . ADC , pp . 191{200 . Australian Computer Society , 2003 .
[ 17 ] J . E . Hanson , P . Nandi , and D . W . Levine .
Conversation enabled web services for agents and e business . Proc . IC , pp . 791{796 . CSREA , 2002 .
[ 18 ] J . E . Johnson , D . E . Langworthy , L . Lamport , and
F . H . Vogt . Formal speciflcation of a web services protocol . Proc . WS FM . Elsevier , 2004 .
[ 19 ] S . Nakajima . Model checking of safety and security aspects in web service ( cid:176)ows . Proc . ICWE , LNCS 3140 , pp . 488{501 . Springer , 2004 .
[ 20 ] S . Narayanan and S . A . McIlraith . Simulation , veriflcation and automated composition of web services . Proc . WWW , pp . 77{88 . ACM , 2002 .
[ 21 ] M . Pistore , M . Roveri , and P . Busetta .
Requirements driven veriflcation of web services . Proc . WS FM . Elsevier , 2004 .
[ 22 ] M . Solanki , A . Cau , and H . Zedan . Augmenting semantic web service descriptions with compositional speciflcation . Proc . WWW , pp . 544{552 . ACM , 2004 .
[ 23 ] X . Yi and K . Kochut . A CP nets based design and veriflcation framework for web services composition . Proc . ICWS , pp . 756{760 . IEEE , 2004 .
[ 24 ] J . Zhang , J Y Chung , C . K . Chang , and S . Kim . WS Net : A Petri net based speciflcation model for web services . Proc . ICWS , pp . 420{427 . IEEE , 2004 .
