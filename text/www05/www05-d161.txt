Constructing Extensible XQuery Mappings
Gang Qian
Yisheng Dong
Dept . of Computer Science and Engineering Southeast University , Nanjing 210096 , China
Dept . of Computer Science and Engineering Southeast University , Nanjing 210096 , China qiangang@seueducn
ABSTRACT Constructing and maintaining semantic mappings are necessary but troublesome in data sharing systems . While most current work focuses on seeking automated techniques to solve this problem , this paper proposes a combination model for constructing extensible mappings between XML schemas . In our model , complex global mappings are constructed by first defining simple atomic mappings for each target schema element , and then combining them using a few basic operators . At the same time , we provide automated support for constructing such combined mappings .
Categories and Subject Descriptors H23 [ Database Management ] : Languages – Query languages ; H25 [ Database Management ] : Heterogeneous Databases .
General Terms Management , Languages
Keywords XQuery , Mapping , Extensibility , Automated support .
1 . INTRODUCTION Schema mapping is one of the underlying components of data sharing systems . As is known , constructing and maintaining such mappings are labor intensive and error prone processes . We limit our attention to the XML model and the mappings expressed in XQuery ( called XQuery mapping ) , though our discussion is also applicable to other data models .
While recent research on schema matching [ 4 ] , mapping discovery [ 2 , 3 ] and mapping adaptation [ 5 ] has made exciting progress towards semi automating these processes , the mapping self is still represented as naive expressions , eg , XQuery clauses in our context , which is troublesome for the user ( administrator ) to deal with . For example , in dynamic environment like the Web , as schemas evolve , the mappings may need to be frequently modified and maintained manually . Additionally , as complicated large schemas become prevalent on the Web , it may be more feasible to start with some simple local mappings , and then glue them together to formulate complex ones . Hence we believe that a suitable mapping model would be able to alleviate the burden on the user , for cases out of the capabilities of the above techniques . In fact , this is usual in practice .
We propose a combination model for constructing extensible XQuery mappings between XML schemas . In our model , a global
Copyright is held by the author/owner(s ) . WWW 2005 , May 10 14 , 2005 , Chiba , Japan . ACM 1 59593 051 5/05/0005 . ysdong@seueducn mapping is composed of a set of simple atomic mappings , which are combined by a few of basic operators . With these operators ( eg , Nest , Join or Merge ) , two mappings ( say M1 and M2 ) are connected to a combined one , say M1 , 2 . Here extensibility means that the resulting mapping M1 , 2 can be combined again with others , possibly using another combination operator , and it is also possible to reset the operator in M1 , 2 , or recover M1 and M2 from it . Consequently , the complex global schema mappings can be incrementally constructed , starting with the simple ones , and continuously applying the combination operators . To maintain them , it only needs to adjust the corresponding parts , eg , the atomic mappings affected by schema evolving , while other parts are reused . At the same time , based on the previous works on schema matching and mapping discovery , we present automated support for constructing such combined mappings .
2 . MAPPING COMBINATION Atomic mapping has the following general form , where SP is a simple path with no branching predicates , and SP1( ) denotes that SP1 must start at a schema root , while SPk($vk 1 ) indicates that in the FOR clause SPk is relative to variable $vk 1 . for $v1 in SP1( ) , …… , $vn in SPn($vn 1 ) where φ($v1 , …… , $vi ) return ( ) | SPn+1($vj ) | <e></e> We refer to $vi as the F variable of the atomic mapping , and $vn as its primary F variable ( PFV ) . In the above formulation , the optional WHERE clause defines a filter φ , and the RETURN clause indicates that the atomic mapping may be empty , copy , or construct type , which respectively returns empty sequence , copies of XML fragment or new constructed elements , eg , instances of e . Samples of atomic mappings are given below .
Mbook( ) : for $n in doc( “ S1 ” )//novel Mtitle : for $t in doc( “ S1 ” )//novel/title return <book></book> return $t
Compared to global mapping , atomic mapping is easier to be formulated , since each atomic mapping is defined separately , and the context of the target schema element is ignored . Then , with the combination operators given below , the separately defined atomic mappings are connected and a combined one is obtained , where the source elements are semantically related ( by connection condition ) , and the returned instances are structurally nested .
Let M1 and M2 be atomic mappings , and M1 be construct type . Figure 1 shows the combination rules of the Nest , Join and Merge operators , which respectively connect M1 and M2 , and generate the combined mapping M1 , 2 . Here exp corresponds to the return expression of M2 , and ψ is an expression wrt the F variables of M1 and M2 , which represents the connection condition of relating the atomic mappings . Semantically , the Nest operator captures the outer join relationship between M1 and M2 . For each binding tuple
1116 for $v1 , 1 in SP1 , 1( ) , …… , $v1 , n in SP1 , n($v1 , n 1 ) where φ1 return <e> for $v2 , 1 in SP2 , 1( ) , …… , $v2 , m in SP2 , m($v2 , m 1 ) where φ2 and ψ return exp </e> for $v1 , 1 in SP1 , 1( ) , …… , $v1 , n in SP1 , n($v1 , n 1 ) let $v:= for $v2 , 1 in SP2 , 1( ) , …… , $v2 , m in SP2 , m($v2 , m 1 ) where φ2 and ψ return exp where φ1 and σ return <e>{$v}</e> for $v1 , 1 in SP1 , 1( ) , …… , $v1 , n in SP1 , n($v1 , n 1 ) for $v2 , 1 in SP2 , 1( ) , …… , $v2 , m in SP2 , m($v2 , m 1 ) where φ1 and φ2 and ψ return <e> exp </e>
Figure 1 . The Nest , Join and Merge operators of M1 , the resulting combined mapping M1 , 2 will returns a new instance of e , whether ψ holds or not . In the combination rule of the Join operator , σ is an expression wrt the variable $v . For example , σ may be count($v)>0 . In this case , the Join operator represents a full join relationship between M1 and M2 . Lastly , the Merge operator has an analogy with the product relationship .
Note that for the Nest and the Join operator , the PFV of M1 forms the PFV of M1 , 2 , while for the Merge operator , the PFVs of M1 , 2 are the union of the ones of M1 and M2 . Recursively , the combined mapping M1 , 2 may be combined with other mappings ( atomic or combined ) . We omit the details from the paper and simply give the following example for illustration . for return <book> n1 in doc( “ S1 ” )//novel , $t in $n1/title in doc( “ S1 ” )//novel $
$n for where $n=$n1 return $t for $a in doc( “ S1 ” )//authors/author where $n/aid=$a/id return <author></author> </book>
The above combined mapping is generated by applying twice the Nest operator , first combining Mbook( ) and Mtitle with the connection condition $n=$n1 , second combining the resulting mapping of the first step with Mauthor( ) , another atomic mapping as highlighted above .
3 . CONSTRUCTION Based on the works on schema matching and mapping discovery , we also provide automated support for constructing the combined mapping . Let e(e1 , … , en ) be a target schema element e nesting ei n ) . Our task is to generate the combined mapping for ( 1 e(e1 , … , en ) , which is reduced to build the atomic mappings Me and Mei , choose the combination operator of and discover the conditions of connecting Me and Mei .
≤ ≤ i
Atomic mapping may be built in terms of the results of schema matching , which produces semantic correspondences ( matches ) between elements of schemas . For example , the atomic mapping Mbook( ) in Section 2 may be derived from the match between the elements book and novel . For our mapping model , we need not to require that the produced matches should be desired , since the combined mapping is extensible and maintainable .
The combination operator may be determined by the cardinality constraints of ei . For example , if ei is optional and multiple , the Nest operator may be applicable ; if ei is mandatory and unique , then the Merge operator may be applicable . Generally , the feasible operators are determined also by factors such as the F variables of Mei , and the connection condition ψ .
Connection condition ψ can be heuristically discovered from the semantic relationships between the source schema elements . As presented in [ 2 , 3 , 5 ] , such relationships are captured by the structural , user and logical associations , which respectively describe a set of associated schema elements . Let a be the source schema element specifying the PFV of Me , and ai be the element specifying the PFV of Mei . If a and ai are in a structural association , then ψ may be formulated in terms of the common path of the elements a and ai . Otherwise , if they are in a user association , then ψ may be formulated with the path assigned by the user . Lastly , if they are neither in a structural nor in a user , but in a logical association , then ψ may be formulated in terms of the referential path between the schema elements a and ai . For example , the condition , $n/aid=$a/id , of connecting Mbook( ) and Mauthor( ) is derived from the logical relationship between the elements novel and author ( see Section 2 ) . Note that the discovered conditions may be multiple , and the user is expected to make right decision in the process .
4 . RELATED WORK Schemas and semantic relationships between schema elements are mainly focused on by current work on schema matching [ 4 ] and mapping discovery [ 2 , 3 ] , and which mappings are affected by schema evolution is the interest of mapping adaptation [ 5 ] . In contrast , our work gives more attention to mapping self and its constitution . We consider mappings as first class of citizens , and provide combination operators to connect them . The same idea is also proposed in [ 1 ] to solve the problem of management of meta data . Yet the subjects there are matches between schemas . What we dealt with in this paper are mappings , which are semantically richer and have more complex formulation .
5 . CONCLUSION In this paper , we have presented the combination model for constructing extensible mappings between XML schemas . From the simple atomic mappings , a complex global mapping is easy to be constructed step by step by applying the combination operators . Additionally , the constructed combined mappings are maintainable and adapt well to dynamic environment like the Web .
6 . REFERENCES [ 1 ] P . A . Bernstein . Applying Model Management to Classical
Meta Data Problems . In Proc . of CIDR , Pages 209 220 , 2003 .
[ 2 ] R . Miller , L . Haas , and M . Hernández . Schema Mapping as
Query Discovery . In Proc . of VLDB , Pages 77–88 , 2000 . [ 3 ] L . Popa , Y . Velegrakis , R Miller , M . A . Hernandez , and R . Fagin . Translating Web Data . In Proc . of VLDB , Pages 598– 609 , 2002 .
[ 4 ] E . Rahm and PA Bernstein . A survey of approaches to automatic schema matching . The VLDB Journal , 10(4 ) : 334– 350 , 2001 .
[ 5 ] Y . Velegrakis , R . J . Miller , and L . Popa . Preserving mapping consistency under schema changes . The VLDB Journal , 13(3 ) : 274 293 , 2004
1117
