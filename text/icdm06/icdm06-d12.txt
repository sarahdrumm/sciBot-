Geometrically Inspired Itemset Mining
School of Information Technologies , University of Sydney , Australia
Florian Verhein , Sanjay Chawla {fverhein,chawla}@itusydeduau
Abstract
In our geometric view , an itemset is a vector ( itemvector ) in the space of transactions . Linear and potentially non linear transformations can be applied to the itemvectors before mining patterns . Aggregation functions and interestingness measures can be applied to the transformed vectors and pushed inside the mining process . We show that interesting itemset mining can be carried out by instantiating four abstract functions : a transformation ( g ) , an algebraic aggregation operator ( ◦ ) and measures ( f and F ) . For Frequent Itemset Mining ( FIM ) , g and F are identity transformations , ◦ is intersection and f is the cardinality . Based on this geometric view we present a novel algorithm that uses space linear in the number of 1 itemsets to mine all interesting itemsets in a single pass over the data , with no candidate generation . It scales ( roughly ) linearly in running time with the number of interesting itemsets . FIM experiments show that it outperforms FPGrowth on realistic datasets above a small support threshold ( 0.29 % and 1.2 % in our experiments ) 1 .
1 Introduction
Traditional Association Rule Mining ( ARM ) considers a set of transactions T containing items I . Each transaction t ∈ T is a subset of the items , t ⊆ I . The most time consuming task of ARM is Frequent ⊆ I Itemset Mining ( FIM ) , whereby all itemsets I that occur in a sufficient number of transactions are ) ≥ minSup , where generated . Specifically , if σ(I ⊆ t}| is the number of transactions σ(I ( known as the support of I containing I
) = |{t : I
) .
For item enumeration type algorithms , each trans
1This research was partially funded by the Australian Research action has generally been recorded as a row in the dataset . These algorithms make two or more passes , reading it one transaction at a time . We consider the data in its transposed format : Each row , x{i} , ( corresponding to an item i ∈ I ) contains the set of transaction identifiers ( tids ) of the transactions containing i . Specifically , x{i} = {t.tid : t ∈ T ∧ i ∈ t} . We call x{i} an itemvector because it represents an item in the space spanned by the transactions2 . An example is provided in Figure 1(a ) . ⊆ I as an We can also represent an itemset I ⊆ t} . Figure itemvector : xI = {t.tid : t ∈ T ∧ I 1(b ) shows all itemsets that have support greater than one , represented as vectors in transaction space . For example , consider x{4} = {t2 , t3} located at g and x{2} = {t1 , t2 , t3} located at f . x{2,4} can be obtained using x{2,4} = x{2} ∩ x{4} = {t2 , t3} , and so ) = |xI | = is located at g . It should be clear that σ(I | ∩i∈I x{i}| .
There are a three important things to note from the above : ( 1 ) We can represent an item by a vector ( we used a set representation to encode its location in transaction space , but we could have equally well used an alternate representation in some other space ) . ( 2 ) We can create itemvectors that represent itemsets by performing a simple operation on the itemvectors ( in the case above , set intersection ) . ( 3 ) We can evaluate a measure using a function on the itemvector ( in the above case , we used set size and the support measure ) . These fundamental operations are all that are required for a mining algorithm . In Section 3 we generalise them to function g(· ) , operator ◦ and function f(· ) respectively . We add an additional family of functions F ( · ) for more complicated measures .
So far we have considered itemvectors as binary . There is no reason for this restriction . Provided that we have functions f(· ) and F ( · ) and an operator 2For simplicity we will use transactions and their tids inter
Council ( ARC ) Discovery Grant , Project ID : DP055900 changeably
( a ) Transposing a dataset of three transactions ( tid ∈ {t1 , t2 , t3} ) containing items I = {1 , 2 , 3 , 4 , 5} .
( b ) Itemsets with support greater than 1 in transaction space .
Figure 1 . Running itemvector example
◦ that obey the requirements set out in Section 3 , we can map the original itemvector into some other space via g(· ) . This has potential for dimensionality and noise reduction or sketch algorithms . Suppose it is possible to perform Singular Value Decomposition ( SVD ) or Random Projections [ 1 ] to reduce the noise and dimensionality ( number of transactions ) before mining itemsets . This has previously been impossible since the transformation creates real valued vectors , and hence cannot be mined using exiting algorithms . Using our framework , all that is required are suitable ◦ , f(· ) and F ( · ) . We can also use measures other than support . Any anti monotonic ( or prefix or weakly anti monotonic ) measure that fits into our framework can be used .
We briefly illustrate some of the ideas used in our algorithm using Figure 1(a ) . We simply wish to convey the importance of the transpose view to our technique , and introduce some of the challenges we solved . Too keep things simple , we use the instantiation of g(· ) , ◦ , f(· ) and F ( · ) required for traditional FIM . Our algorithm scans the transposed dataset row by row . Suppose we scan it bottom up3 so we first read x{5} = {t1 , t3} . Assume minSup = 1 . We can immediately say that σ({5} ) = 2 ≥ minSup and so itemset {5} is frequent . We then read the next row , x{4} = {t2 , t3} , and find that {4} is frequent . Since we now have both x{5} and x{4} , we can create x{4,5} = x{4} ∩ x{5} = {t3} . We have now checked all possible itemsets containing items 4 and 5 . To progress , we read x{3} = {t2} and find that {3} is frequent . We can also check more itemsets : x{3,5} = x{3} ∩ x{5} = ∅ and x{3,4} = x{3} ∩ x{4} = {t2} so {3 , 4} is frequent . Since {3 , 5} is not frequent , neither is {3 , 4 , 5} by the anti monotonic property of support [ 2 ] . We next read x{2} and continue the pro cess . It should be clear from the above that ( 1 ) a single pass over the dataset is sufficient to mine all frequent itemsets , ( 2 ) having processed any n itemvectors corresponding to items in J = {1 , , n} , we can generate all itemsets L ⊆ J and ( 3 ) having the dataset in transpose format and using the itemvector concept allows this to work .
Each itemvector could take up significant space , we may need many of them , and operations on them could be expensive . We generate at least as many itemvectors as there are frequent itemsets4 . Since the number of itemsets is at worst 2|I| − 1 , clearly it is not feasible to keep all these in memory , nor do we need to . On the other hand , we do not want to recompute them as this is expensive . If there are n items we could use n itemvectors of space and create all itemsets , but we must recompute most itemvectors multiple times , so the time is not linear in the number of frequent itemsets – it will be exponential . For example , suppose we have created x{1,2,3} . When we later need x{1,2,3,4} , we do not want to have to recalculate it as x{1} ∩ x{2} ∩ x{3} ∩ x{4} . Instead , we would like to use the previously calculated x{1,2,3} : x{1,2,3,4} = x{1,2,3} ∩ x{4} being one option . The challenge is to use as little space as necessary , while avoiding re computations .
+(l/2 ) itemvectors of space , where n
We present an algorithm that uses time roughly linear in the number of interesting itemsets and at ≤ n worst n is the number of interesting 1 itemsets and l is the size of the largest interesting itemset . This worst case scenario is only reached with extremely low support , and most practical situations require only a small . Based on these facts and the geometfraction of n ric inspiration provided by the itemvectors , we call it Geometrically inspired Linear Itemset Mining In the
3This is just so the ordering of items in the data structure of our
4It is ‘at least’ because some itemsets are not frequent , but we algorithm is increasing . only know this once we have calculated its itemvector .
Transpose , or GLIMIT .
It is widely recognised that FP Growth type algorithms are the fastest know algorithms . We show experimentally that GLIMIT outperforms FP Growth [ 5 ] when the support is above a small threshold .
GLIMIT is more than “ just another FIM/ARM algorithm ” and support is just one of many possible interestingness measures it can use .
We make the following contributions : • We show interesting consequences of viewing transaction data as itemvectors in transactionspace . We develop a theoretical framework for operating on itemvectors . This abstraction allows a new class of algorithm to be developed , gives great flexibility in the measures used , inspires new geometric based interestingness measures and opens up the potential for useful transformations ( such as preprocessing ) on the data that were previously impossible . • We present GLIMIT , a new , efficient and fast class of algorithm that uses our framework to mine interesting itemsets in one pass without candidate generation . It uses linear space and ( roughly ) time linear in the number of interesting itemsets . It significantly departs from existing algorithms . Experiments show it beats FPGrowth above small support thresholds when used for FIM .
In Section 2 we put our framework and GLIMIT in context of previous work . Section 3 presents our itemvector framework . Section 4 gives the the two data structures that can be used by GLIMIT . In Section 5 we first give the main facts exploited by GLIMIT and follow up with a comprehensive example . We prove the space complexity and give the pseudo code . Section 6 contains our experiments . We conclude in Section 7 .
2 Previous Work
Many itemset mining algorithms have been proposed since association rules were introduced [ 2 ] . Recent advances can be found in [ 3 ] and [ 4 ] . Most algorithms can be broadly classified into two groups , the item enumeration ( such as [ 2 , 5 , 9 ] ) and the row enumeration ( such as [ 7 , 12 ] ) techniques . Broadly speaking , item enumeration algorithms are most effective for datasets where |T| >> |I| , while row enumeration algorithms are effective for datasets where |T| << |I| , such as for microarray data [ 7 ] .
Item enumeration algorithms mine subsets of an . Only those itemsets for before mining I itemset I which all subsets are frequent are generated – making use of the anti monotonic property of support . Apriori like algorithms [ 2 ] do this in a breadth first manner and use a candidate generation step . They use multiple passes , at most equal to the length of the longest frequent itemset . Our algorithm does not perform candidate generation , and generates association rules in a depth first fashion using a single pass over the transposed dataset .
FP Growth type algorithms [ 5 , 9 ] generates a compressed summary of the dataset using two passes in a highly cross referenced tree , the FP tree , before mining itemsets by traversing the tree . Like our algorithm it does not perform candidate generation and mines the itemsets in a depth first manner while still . mining all subsets of an itemset I It is very fast at reading from the FP tree , but the downside is that the FP tree can become very large and is expensive to generate , so this investment does not always pay off . Our algorithm uses only as much space as is required . before mining I
Row enumeration techniques effectively intersect before mintransactions and generate supersets of I . Although it is much more difficult for these aling I gorithms to make use of the anti monotonic property for pruning , they exploit the fact that searching the row space in data with |T| << |I| becomes cheaper than searching the itemset space . GLIMIT is similar to row enumeration algorithms since both search using the transpose of the dataset . However , where row enumeration intersects transactions ( rows ) , we effectively intersect itemvectors ( columns ) . But this similarity is tenuous at best . Furthermore , existing algorithms use the transpose for counting convenience rather than for any insight into the data , as we do in our itemvector framework . Since GLIMIT searches through the itemset space , it is classified as an item enumeration technique and is suited to the same types of data . However , it scans the original data column wise ( by scanning the transpose rowwise ) , while all other item enumeration techniques scan it row wise . The transpose has never , to our best knowledge , been used in an item enumeration algorithm . In summary , we think it is about as similar to other item enumeration techniques as FP Growth is to Apriori .
Efforts to create a framework for support exist . Steinbach et al . [ 11 ] present one such generalisation , but their goal is to extend support to cover continuous data . This is very different to transforming the original ( non continuous ) data into a real vector space ( which is one of our motivations ) . Their work is geared toward existing item enumeration algorithms and so their “ pattern evaluation vector ” summarises transactions ( that is , rows ) . Our framework operates on columns of the original data matrix . Furthermore , rather than generalising the support measures so as to cover more types of datasets , we generalise the operations on itemvector and the transformations on the same dataset that can be used to enable a wide range of measures , not just support .
To our best knowledge , Ratio Rules are the closest attempt at combining SVD ( or similar techniques such as Principal Component Analysis ) and rule mining . Korn et al . [ 6 ] consider transaction data where items have continuous values associated with them , such as price . A transaction is considered a point in the space spanned by the items . By performing SVD on such datasets , they observe that the axes ( orthogonal basis vectors ) produced define ratios between single items . We consider items ( and itemsets ) in transaction space ( not the other way around ) so when we talk of performing SVD , the new axes are linear combinations of transactions – not items . Hence I is unchanged . Secondly , we talk about mining itemsets , not just ratios between single items . Finally , SVD is just one possible instantiation of g(· ) .
By considering items as vectors in transaction space , we can interpret itemsets geometrically , which we do not believe has been considered previously . As well as inspiring our algorithm , this geometric view has the potential to lead to very useful preprocessing techniques , such as dimensionality reduction of the transactions space . Since GLIMIT uses only this framework , it will enable us to use such techniques – which are impossible using existing FIM algorithms .
3 Theoretical Itemvector Framework
In Section 1 we used the example of frequent itemset mining ( FIM ) to introduce our ideas . But our work is much more general than this – the instantiations of g(· ) , ◦ and f(· ) are trivial for FIM . The functions and operator we formally describe in this section define the form of interestingness measures and dataset transformations that are supported by our algorithm . Not only can many existing measures be mapped to this framework , but we hope the geometric interpretation will inspire new ones .
Recall that xI is the set of transaction identifiers ⊆ I . of the transactions containing the itemset I Call X the space spanned by all possible xI . Specifically , X = P({t.tid : t ∈ T} ) .
Definition 1 g : X → Y is a transformation on the original itemvector to a different representation yI = g(xI ) in a new space Y . Even though g(· ) is a transformation , it ’s output still ‘represents’ the itemvector . To avoid too many terms , we also refer to yI as an itemvector . Definition 2 ◦ is an operator on the transformed itemvectors so that yI ∪I ” = yI ◦ yI ” = yI ” ◦ yI . That is , ◦ is a commutative operator for combining itemvectors to create itemvectors representing larger itemsets . We do not require that yI = yI ◦ yI 5 . Definition 3 f : Y → R k is a set of k measures on itemsets , evaluated on transformed itemvectors . We write mI = f(yI ) . k is fixed . Definition 4 interestingness : P(I ) → R is an interestingness measure ( order ) on all itemsets .
Suppose we have a measure of interestingness of an itemset that depends only on that itemset ( eg : support ) . We can represent this as follows , where = {i1 , , iq} and k = 1 : I interestingness(I
) = f(g(x{i1} ) ◦ ◦ g(x{iq} ) ) ( 1 ) So the challenge is , given an interestingness measure , find suitable and useful g,◦ and f so that the above holds . For support , we know we can use ◦ = ∩ , f = | · | and g as the identity function . We now return to our motivation . First assume that g(· ) trivially maps xI to a binary vector . Using x{1} = {t1 , t2} and x{5} = {t1 , t3} from Figure 1(a ) we have y{1} = g(x{1} ) = 110 and y{5} = g(x{5} ) = 101 . It should be clear that we can use bitwise AN D as ◦ and f = sum( ) , the number of set bits . But notice that sum(y{1} AN D y{2} ) = sum(y{1} . ∗ y{2} ) = y{1} · y{2} , the dot product ( .∗ is the element wise product6 ) . That is , the dot product of two itemvectors is the support of the the 2itemset . What makes this interesting is that this holds for any rotation about the origin . Suppose we have an arbitrary 3 × 3 matrix R defining a rotation about the origin . This means we can define g(x ) = RxT because the dot product is preserved by R ( hence g(·) ) . For example , σ({1 , 5} ) = y{1} · y{5} = ( RxT{1} ) · ( RxT{5} ) . So we can perform an arbitrary rotation of our itemvectors before mining 2 itemsets . Of course this is much more expensive than bitwise AN D , so why would we want to do this ? Consider
5Equivalently , ◦ may have the restriction that I ∩ I ” = ∅ . 6(a . ∗ b)[i ] = a[i ] ∗ b[i ] for all i , where [ ] indexes the vectors .
Singular Value Decomposition . If normalisation is skipped , it becomes a rotation about the origin , projecting the original data onto a new set of basis vectors pointing in the direction of greatest variance ( incidentally , the covariance matrix calculated in SVD also defines the support of all 2 itemsets7 ) . If we additionally use it for dimensionality reduction , it has the property that it roughly preserves the dot product . This means we should be able to use SVD for dimensionality reduction and or noise reduction prior to mining frequent 2 itemsets without introducing too much error . The drawback is that the dot product applies only to two vectors . That is , we cannot use it for larger itemsets because the ‘generalised dot product’ satisfies sum(RxT{1}.∗ RxT{2}.∗ .∗ RxT{q} ) = sum(x{1}.∗ x{2}.∗ .∗ x{q} ) only for q = 2 . However , this does not mean that there are not other useful ◦ , f(· ) , F ( · ) and interestingness measures that satisfy Equation 1 and use g(· ) = SV D , some that perhaps will be motivated by this observation . Note that the transpose operation is crucial in applying dimensionality or noise reduction because it keeps the items intact . If we did not transpose the data , the itemspace would be reduced , and the results would be in terms of linear combinations of the original It also makes items , which cannot be interpreted . more sense to reduce noise in the transactions . We could also choose g(· ) as a set compression function or use approximate techniques , such as sketches , to give estimates rather than exact values of support or other measures . However , we think new geometrically inspired measures will be the most promising . For example , angles between itemvectors are linked to the correlation between itemsets . Of course , we can also translate existing measures into our framework . family of functions F ( · ) and give an example . k×|P(I )| → R is a measure on Definition 5 F : R that supports any composition of meaan itemset I sures ( provided by f(· ) ) on any number of subsets ) of I |P(I )| where mI
To complete our framework we now define the
1 , mI2 , , mIi ∈ P(I ) .
. We write MI = F ( mI
) and all I
= f(yI i i
We can now support more complicated interestingness functions that require more than a simple ( k = 1 ) measure on one itemset : interestingness(I
) = F ( mI
1 , mI
2 , , mI
|P(I )|
) ( 2 )
7That is , CM [ i , j ] = σ({i , j} ) . i i are evaluated by f(· ) as before . That where the mIis , MI = F ( · ) is evaluated over measures mIi ⊆ I . If F ( · ) does not depend on an where all I mIi , we leave it out of the notation . In that sense we call F ( · ) trivial if MI = F ( mI ) . In this case the function of F ( · ) can be performed by f(· ) alone , as was the case in the examples we considered before introducing F ( · ) . = {1 , , q} Example 1 The minP I of an itemset I )/σ({i})} . This meais minP I(I sure is anti monotonic and gives high value to itemsets where each member predicts the itemset with high probability . It is used in part for spatial colocation mining [ 10 ] . Using the data in Figure 1(a ) , minP I({1 , 2 , 3} ) = min{1/2 , 1/3 , 1/1} = 1/3 . In terms of our framework g(· ) is the identity function , ◦ = ∩ , f = | · | so that mI = σ(I ) and MI = F ( mI , m{1} , , m{q} ) = mini{mI /m{i})} .
) = mini{σ(I
Our algorithm uses only the framework described above for computations on itemvectors . It also provides the arguments for the operators and functions very efficiently so it is flexible and fast . Because GLIMIT generates all subsets of an itemset I’ before , an anti monotonic propit generates the itemset I erty enables it to prune the search space . Therefore , to avoid exhaustive searches , our algorithm requires8 that the function F ( · ) be anti monotonic9 in the underlying itemsets over which it operate ( in conjunction with ◦ , g(· ) and f(·)10 ) . Definition 6 F ( · ) is anti monotonic if MI ≥ MI ” ⇐⇒ I ⊆ I ” , where MI = F ( · ) is evaluated as per Definition 5 . In the spirit this restriction , an itemset I is considered interesting if MI ≥ minM easure , a threshold . We call such itemsets F itemsets .
4 Data Structures
In this section we outline two data structures that our algorithm ( optionally ) generates and uses .
We use the PrefixTree to efficiently store and = build frequent itemsets . We represent an itemset I {i1 , , ik} as a sequence ffli1 , , ik by choosing a global ordering of the items ( in this case i1 < < ik ) , and store the sequence in the tree . An example of a PrefixTree storing all subsets of {1 , 2 , 3 , 4}
8If there are few items then this constraint is not needed . 9Actually , prefix anti monotonic[8 ] is necessary , which is a weaker constraint . With some modification , weakly antimonotonic F ( · ) can also be supported
10Note that f ( · ) does not have to be anti monotonic . is shown in Figure 2(a ) . Since each node represents a sequence ( ordered itemset ) we can use the terms prefix node , itemset and sequence interchangeably . The prefix tree is built of PrefixNodes . Each PrefixNode is a tuple ( parent , depth , m , M , item ) where parent points to the parent of the node ( so n.parent represents the prefix of n ) , depth is its depth of the node and therefore the length of the itemset at that node , m ( M ) is the measure(s ) of the itemset evaluated by f(· ) ( F ( · ) ) and item is the last item in the sequence represented by the node . is the empty item so that { } ∪ α = α where α is an itemset . The sequence ( in reverse ) represented by any node can be recovered by traversing toward the root . To make the link with our itemvector framework clear , suppose the itemset represented at a Pre = {i1 , i2 , , ik} . Then p.m = mI = fixNode p is I f(g(x{i1})◦g(x{i2})◦◦g(x{ik} ) ) and p.M = F ( · ) where F is potentially a function of the m ’s of PrefixNodes corresponding to subsets of I
.
The tree has the property that if s is in the Prefix s by the antiTree , then so are all subsequences s monotonic property of F ( · ) . Hence we save a lot of space because the tree never duplicates prefixes . In fact , it contains exactly one node per F itemset .
The PrefixTree is designed for efficient storage , and not for lookup purposes . This is why there are no references to child nodes . To facilitate the generation of association rules , a set of all nodes that have no children is maintained . We call this the fringe .
The fringe is useful for because ( 1 ) it contains all maximal itemsets11 , and ( 2 ) it can be used to efficiently generate all association rules : Lemma 1 Let s = ffli1 , , ik = αβγ be the sequence corresponding to a prefix node n where α , β = ∅ . All association rules can be generated by creating all rules α ⇒ β and β ⇒ α for each fringe node . or β
⇒ α
⇒ β
Proof : ( Sketch ) We don’t generate all possible association rules that can be generated from itemset {i1 , , ik} by considering only n . Specifically , we where α miss ( 1 ) any rules α is not a prefix of s , and ( 2 ) any such rules where . However , by the there is a gap between α construction of the tree there exists another node n = fflα ( since corresponding to the sequence s , β s ) . If n is not in the fringe , then by definition s = ∅ and for some γ s ” where s ” = fflα s ⇒ β n ” ( the node for s ” ) is in the fringe . Hence α 11A maximal itemset is a F itemset for which no superset is in and β
, β
, γ teresting ( has measure above threshold minM easure ) .
⇒ α and β will be generated from node(s ) other than n . Finally , the longest sequences are guaranteed to be in the fringe , hence all rules will be generated by induction .
We use a SequenceMap to index the nodes in the PrefixTree so we can retrieve them for the following purposes : ( 1 ) to check all subsequences of a potential itemset for pruning ( we automatically check two subsets without using the sequence map12 ) , ( 2 ) to find the measures ( m , M ) for β in Lemma 1 when generating association rules13 , and ( 3 ) to find the the ms when we evaluate a nontrivial F ( · ) .
First we introduce an abstract type – Sequence – which represents a sequence of items . Equality testing and hash code calculation is done using the most efficient iteration direction . PrefixNode can be considered a Sequence14 and reverse iteration is the most efficient . By performing equality comparisons in reverse sequence order , we can map any Sequence to a PrefixNode by using a hash table that stores the PrefixNode both as the key and the value . Hence we can search using any Sequence implementation ( including a list of items ) , and the hash table maps Sequences to the PrefixNodes that represents them . The space required is only that of the hash table ’s bucket array , so it is very space efficient .
Finally , we can avoid the use of both the PrefixTree and SequenceMap without alteration to GLIMIT if ( 1 ) we output frequent itemsets when they are mined , ( 2 ) do not care if not all subsets are checked before we calculate a new itemvector , and ( 3 ) have a trivial F ( · ) .
5 Algorithm
In this section we outline the main principles we use in GLIMIT and follow up with an illustrative example . We prove space complexity bounds before giving the algorithm in pseudo code .
We exploit the following facts in order to use min imum space while avoiding any re computations :
1 . We can construct all itemvectors yI by incrementally applying the rule yI ∪{i} = yI ◦ y{i} . That is , we only ever ◦ itemvectors corresponding to single items to the end of an itemvector . This means that given a PrefixNode p that is
12Fact 3 in Section 5 13Since β is not a prefix of s , its measures are not stored along the path of PrefixNodes corresponding to s . So to get its measures we need to find its PrefixNode – by looking up β in the SequenceMap .
14It is can be considered as a reversed , singly linked list . not the root , we only ever need to keep a single itemvector in memory for any child of p at a time . If p is the root , we will need to keep its children ’s itemvectors in memory ( the y{i} ) . if siblings fflia , ib , , ii , ij
2 . It also means we use least space if we perform a depth first search . Then for any depth ( p.depth ) , we will at most have only one itemvector in memory at a time . 3 . We only ever check a new sequence by ‘joining’ siblings . That is , we check fflia , ib , , ii , ij , ik only and fflia , ib , , ii , ik , k > j are in the prefix tree . Hence , we only try to expand nodes which have one or more siblings below it . 4 . Suppose the items are I = {i1 , i2 , , in} . If we have read in k itemvectors y{ij} j ∈ {n , n − 1 , , n − k − 1} , then we can have completed all nodes corresponding to all subsets of {in−k−1 , , in} . So if we use the depth first procedure , when a PrefixNode p is created all PrefixNodes corresponding to subsets of p ’s itemset will already have been generated . As well as being most space efficient , this is required to evaluate nontrivial F ( · ) and for more thorough ( than Fact 3 ) pruning using the antimonotonic requirement . This is what we call the ‘bottom up’ order of building the Prefix Tree .
5 . When a PrefixNode p with p.depth > 1 ( or p.item is the top most item ) cannot have any children ( because it has no siblings by Fact 3 ) , its itemvector will no longer be needed .
6 . When a topmost sibling ( the topmost child of a node ) is created ( or we find its itemset is not frequent and hence don’t need to create it ) , the itemvector corresponding to its parent p can be deleted . That is , we have just created the topmost ( last ) immediate child of p . This applies only when p.depth > 1 or when p.item is the top most item15 . This is because we only ever need y{ia,ib,,ii,ij} until we generate y{ia,ib,,ii,ij ,ik} = y{ia,ib,,ii,ij} ◦ y{ik} where ia < ib < , , < ii < ij < ik ( eg : b − a and a may both greater then 1 , etc ) and {ia , ib , , ii , iq} : j < q < k is not Indeed , we can write the result of frequent . y{ia,ib,,ij} ◦ y{ik} directly into the itemvector holding y{ia,ib,,ij} Conversely , while there is still a child to create ( or test ) we cannot delete p ’s corresponding itemvector .
15By Fact 1 we cannot apply this to nodes with p.depth = 1 ( unless it is the topmost node ) as they correspond to single items and are still needed .
7 . When we create a PrefixNode p on the topmost branch ( eg : when all itemsets are frequent , p will correspond to ffli1 , i2 , , ik for any k ≥ 1 ) , we can delete the itemvector corresponding to the single item p.item ( eg : ik ) . Fact 6 will always apply in this case too ( eg : we can also delete ik−1 if k > 1 ) . The reason behind this is that by using the bottom up method ( and the fact our itemsets are ordered ) , we know that if we have y{i1,,ik} we can only ever ◦ a y{ij} with j > k onto the end . illustrate some of these facts .
We now present an example of our algorithm to Suppose we have the items {1 , 2 , 3 , 4} and the minM easure ( we will use minSup ) threshold is such that all itemsets are interesting ( frequent ) . Figure 2 shows the target prefix tree and the steps in mining it . This example serves to show how we manage the memory while avoiding any re computations . For now , consider the frontier list in the figure as a list of PrefixNodes that have not been completed . It should be clear that we use a bottom up and depth first procedure to mine the itemsets , as motivated by Facts 2 and 4 . We complete all subtrees before moving to the next item . In ( d ) we calculate y{3,4} = y{3} ◦ y{4} as per Fact 1 . Note we are also making use of Fact 3 – {3} and {4} are siblings . Once we have created the node for {3 , 4} in ( d ) , we can delete y{3,4}by Fact 5 . It has no possible children because of the ordering of the sequences . The same holds for {2 , 4} in ( f ) . In ( g ) , the node for {2 , 3} is the topmost sibling ( child ) . Hence we can apply Fact 6 in ( h ) . Note that by Fact 1 we calculate y{2,3,4} as y{2,3,4} = y{2,3} ◦ y{4} . Note also that because we need the itemvectors of the single items in memory we have not been able to use Fact 7 yet . Similarly , Fact 6 is also applied in ( l ) , ( m ) , ( o ) and ( p ) . However , note that in ( m ) , ( o ) and ( p ) we also use Fact 7 to delete y{2} , y{3} , and y{4} . In ( l ) we deleted y{1} for two reasons : Fact 6 and 7 ( it is a special case in Fact 6 ) . Finally , to better illustrate Fact 3 , suppose {2 , 4} is not frequent . This means that {2 , 3} will have no siblings anymore , so we do not even need to consider {2 , 3 , 4} by Fact 3 . We know already that the time complexity is roughly linear in the number of frequent itemsets , because we avoid re computations of itemvectors . So the question now is , what is the maximum number of itemvectors that we have in memory at any time ? There are two main factors that influence this . First , we need to keep the itemvectors for individual items in memory until we we have completed the node for the top most item ( Fact 1 and 7 ) . Hence , the ‘higher’
Figure 2 . Building the PrefixTree ( mining itemsets ) Example . Nodes are labeled with their item value . Shaded nodes have their corresponding itemvector in memory . Dotted nodes have not been mined yet . Solid lines are the parts of the tree that have been created .
( a ) Complete PrefixTree
( b ) Step 1
( c ) Step 2
( d ) Step 3
( e ) Step 4
( f ) Step 5
( g ) Step 6
( h ) Step 7
( i ) Step 8
( j ) Step 9
( k ) Step 10
( l ) Step 11
( m ) Step 12
( n ) Step 13
( o ) Step 14
( p ) Step 15 nodes , we know from the above that its upper bound is ( l/2 ) . We have sketched the proof of : ≤ n Lemma 2 Let n be the number of items , and n be the number of frequent items . Let l ≤ n be the + ( l/2 ) − largest itemset . GLIMIT uses at most n 1 itemvectors of space . Furthermore , |f rontier| ≤ ( l/2 ) . As an aside , note we could perform the transpose operation in memory before mining while still remaining within the worst case space complexity . However , on average and for practical levels of minM easure ( eg : minSup ) , this would require more memory .
The algorithm is a depth first traversal through the PrefixTree . Any search can be implemented either recursively or using the frontier method , whereby a list ( priority queue ) of states ( each containing a node that has yet to be completely expanded ) is maintained . The general construct is to retrieve the first state , evaluate it for the search criteria , expand it ( create some child nodes ) , and add states corresponding to the child nodes to the frontier . Using different criteria and frontier orderings leads to different search techniques . Our frontier contains any nodes that have not yet been completed , wrapped in State objects . Algorithm 1 describes17 the additional types we use ( such as State ) and shows the initialisation and the main loop – which calls step(· ) . It also describes the check(· ) and calculateF ( · ) methods , used by step(· ) .
6 Experiments
We evaluated our algorithm on two publicly available datasets from the FIMI repository18 – T10I4D100K and T40I10D100K . These datasets have 100 , 000 transactions and a realistic skewed histogram of items . They have 870 and 942 items respectively . To apply GLIMIT we first transpose the dataset as a preprocessing step19 .
We compared GLIMIT to a publicly available implementation of FP Growth and Apriori . We used the algorithms from ARtool20 as it is written in
17The pseudo code in our algorithms is java like and we assume a garbage collector which simplifies it . Indentation defines blocks and we ignore type casts .
18http://fimicshelsinkifi/data/ 19This is cheap , especially for sparse matrices – precisely what the datasets in question typically are . Our data was transposed in 8 and 15 seconds respectively using a naive Java implementation , and without using sparse techniques .
20http://wwwcsumbedu/ laur/ARtool/ . It was not used via the supplied GUI . The underlying classes were invoked directly .
Figure 3 . Maximum number of itemvectors . Two cases : n even or odd . up in the tree we are , the more this contributes . Secondly , we need to keep itemvectors in memory until we complete their respective nodes . That is , check all their children ( Fact 6 ) or if they can’t have children ( Fact 5 ) . Now , the further we are up in the tree , or any subtree for that matter , without completing the node , the longer the sequence of incomplete nodes is and hence the the more itemvectors we need to keep . Considering both these factors leads to the situation in Figure 3 – that is , we are up to the top item and the topmost path from that item so that no node along the path is completed . If we have n items , the worst case itemvector usage is just the number of coloured nodes in Figure 3 . There are n itemvectors y{i} : i ∈ {1 , , n} corresponding to the single items ( children of the root ) . There are a further ( n/2 ) itemvectors along the path from node {1} ( inclusive ) to the last coloured node ( these are the uncompleted nodes)16 . Therefore the total space required is just n + ( n/2 ) − 1 , where the −1 is so that we do not double count the itemvector for {1} .
This is for the worst case when all itemsets are ≤ n frequent . Clearly , a closer bound is if we let n be the number of frequent items . Hence , we need space linear in the number of frequent items . The multiplicative constant ( 1.5 ) is low , and in practice ( with non pathological support thresholds ) , we use far fewer than n itemvectors . If we know that the longest frequent itemset has size l , then we can ad + ( l/2 ) − 1 . Furditionally bound the space by n thermore , since the frontier contains all uncompleted 16When n is even , the last node is {1 , 3 , 5 , , n−3 , n−1} and when n is odd it is {1 , 3 , 5 , , n − 2 , n} . The cardinality of both these sets , equal to the number of nodes along the path , is n/2 . Note that in the even case , the next step to that shown will use the same memory ( the itemvector for node {1 , 3 , 5 , , n − 3 , n − 1} is no longer needed once we create {1 , 3 , 5 , , n − 3 , n − 1 , n} by Fact 6 , and we write y{1,3,5,,n−3,n−1,n} directly into y{1,3,5,,n−3,n−1} as we compute it so both need never be in memory at the same time ) .
Algorithm 1 Data types , initialisation , main loop and methods . Input : ( 1 ) Dataset ( inputF ile ) in transpose format ( may have g(· ) already applied ) . ( 2 ) f ( · ) , ◦ , F ( · ) and minM easure . Output : Completed P ref ixT ree ( pref ixT ree ) and SequenceM ap ( map ) containing all F itemsets .
P air : ( Itemvector y{i} , Item item ) /*y{i} is the itemvector for item and corresponds to y{i} in Fact 1 . We keep reusing them through buf f er:*/ State : ( P ref ixN ode node , Itemvector yI , Iterator itemvectors , boolean top , P air newP air , List buf f er ) /*yI is the itemvector corresponding to node ( and yI in Fact 1 ) . buf f er is used to create the Iterators ( such as itemvectors ) for the States created to hold the children of node . We need buf f er to make use of Fact 3 . itemvectors provides the y{i} to join with yI and newP air helps us do this.*/
/*Initialisation : initialise pref ixT ree with its root . Initialise map and f rontier as empty . Create initial state:*/ Iterator itemvectors = new AnnotatedItemvetorIterator(inputF ile ) ; /*Iterator is over P air objects*/ /*Reads input one row at a time and annotates the itemvector with the item it corresponds to . could also apply g(·)*/ f rontier.add(new State(pref ixT ree.getRoot( ) , null , itemvectors , f alse , null , new LinkedList()) ) ; /*Main Loop*/ while ( !f rontier.isEmpty( ) ) step(f rontier.getF irst() ) ;
/*Perform one expansion . state.node is the parent of the new P ref ixN ode ( newN ode ) that we create if newN ode.M ≥ minM easure . localT op is true iff we are processing the top sibling of any subtree . nextT op becomes newN ode.top and is set so that top is true only for a node that is along the topmost branch of the prefix tree.*/ void step(State state ) if ( state.newP air fi= null ) /*see end of method ♣*/ state.buf f eradd(statenewP air ) ; state.newP air = null ; /*so we don’t add it again*/ P air p = stateitemvectorsnext( ) ; boolean localT op =!stateitemvectorshasN ext( ) ; if ( localT op ) /*Remove state from f rontier ( and hence delete state.yI ) as we are creating*/ localF rontier.removeF irst( ) ; /* the top child of node in this step . Fact 6*/ = { })*/
Itemvector yI ∪{i} = null ; double m[ ] , M ; boolean nextT op ; /*top in the next State we create.*/ if ( statenodeisRoot( ) ) /*we are dealing with itemsets of length 1 ( so I m = f ( p.y{i} ) ; M = calculateF ( null,{p.item} , m ) ; yI ∪{i} = p.y{i} ; state.top = localT op ; nextT op = localT op ; /*initialise tops.*/ else nextT op = localT op && state.top ; if ( check(state.node , p.item ) ) /*make use of anti monotonic pruning property*/ if ( localT op && ( statenodegetDepth( ) > 1|| state.top ) ) /*Fact 6 or 7*/
/*No longer need state.yI as this is the last child we can create under * state.node ( and it is not a single item other than perhaps the topmost)*/ yI ∪{i} = state.yI ; yI ∪{i}◦ = p.y{i} ; /*can write result directly into yI ∪{i}*/ else yI ∪{i} = state.yI ◦ p.y{i} ; /*need to use additional memory for the child ( yI ∪{i}).*/ m = f ( yI ∪{i} ) ; M = calculateF ( statenode,{pitem} , m ) ; else M = −∞ /*don’t need to calculate , we know M < minM easure*/ if ( M ≥ minM easure ) /*Found an interesting itemset – create newN ode for it.*/
P ref ixN ode newN ode = pref ixT ree.createChildU nder(state.node ) ; newN ode.item = p.item ; newN ode.m = m ; newN ode.M = M ; sequenceM ap.put(newN ode ) ; if ( state.buf f er.size( ) > 0 ) /*there is potential to expand newN ode . Fact 5*/
State newState = new State(newN ode , yI ∪{i} , state.buf f er.iterator( ) , nextT op , new LinkedList() ) ; /*add to front of frontier ( ie : in front of state if it ’s still present ) so depth first search . Fact 2.*/ f rontier.addF ront(newState ) ; state.newP air = p ; /*if state.node is not complete , we * will add p to state.buf f er after newState has been completed . See ♣*/
/*Let α be the itemset corresponding to node . α ∪ {item} is the itemset represented by a child p of node so that p.item = item . m would be pm This method calculates p.M by using map to look up the P ref ixN odes corresponding to the K required subsets of α ∪ {item} to get their values , m1 , , mK . Then it returns F ( m1 , , mK ).*/ double calculateF(P ref ixN ode node , Item item , double m[ ] ) /*details depend on F ( ·)*/ /*Check whether the itemset α ∪ {item} could be interesting by exploiting the anti monotonic property of F ( · ) : use map to check whether subsets of α ∪ {item} ( except α and ( α − node.item ) ∪ {item} by Fact 3 ) exist.*/ boolean check(P ref ixN ode node , Item item ) /*details omitted*/ as the number of frequent items . The analogous graph for T40I10D100K is shown in Figure 4(b ) – we did not run Apriori as it is too slow . These graphs clearly show that when the support threshold is below a small value ( about 0.29 % and 1.2 % for the respective datasets ) , FP Growth is superior to GLIMIT . However , above this threshold GLIMIT outperforms FP Growth significantly . Figure 5(a ) shows this more explicitly by presenting the runtime ratios for T40I10D100K . FP Growth takes at worst 19 times as long as GLIMIT . We think it is clear that GLIMIT is superior above the threshold . Furthermore , this threshold is very small and practical applications usually mine with much larger thresholds than this .
GLIMIT scales roughly linearly in the number of frequent itemsets . Figure 5(b ) demonstrates this experimentally by showing the average time to mine a single frequent itemset . The value for GLIMIT is quite stable , rising slowly toward the end ( as there we still need to check itemsets , but very few of these turn out to be frequent ) . FP Growth on the other hand , clearly does not scale linearly . The reason behind these differences is that FP Growth first builds an FP tree . This effectively stores the entire Dataset ( minus infrequent single items ) in memory . The FPtree is also highly cross referenced so that searches are fast . The downside is that this takes significant time and a lot of space . This pays off extremely well when the support threshold is very low , as the frequent itemsets can read from the tree very quickly . However , when minSup is larger , much of the time and space is wasted . GLIMIT uses time and space as needed , so it does not waste as many resources , making it fast . The downside is that the operations on bit vectors ( in our experiments , of length 100 , 000 ) can be time consuming when compared to the search on the FP tree , which is why GLIMIT cannot keep up when minSup is very small . Figure 5(c ) shows the maximum and average24 number of itemvectors our algorithm uses as a percentage of the number of items . At worst , this can be interpreted as the percentage of the dataset in memory . Although the worst case space is 1.5 times the number of items , n ( Lemma 2 ) , the figure clearly shows this is never reached in our experiments . Our maximum was approximately 082n By the time it gets close to 1.5n , minSup would be so small that the runtime would be unfeasibly large anyhow . Furthermore , the space longer than 30 minutes for minSup ≤ 0.1 %
24over the calls to step(· ) .
( a ) Runtime and frequent itemsets . T10I4D100K . Inset shows detail for low support .
( b ) Runtime and frequent itemsets . T40I10D100K .
Figure 4 . Results
Java , like our implementation , and it has been available for some time . In this section we really only want to show that GLIMIT is quite fast and efficient when compared to existing algorithms on the traditional FIM problem . Our contribution is the itemvector framework that allows operations that previously could not be considered , and a flexible and new class of algorithm that uses this framework to efficiently mine data cast into different and useful spaces . The fact that it is also fast when applied to traditional FIM is secondary . To represent itemvectors for traditional FIM , we used bit vectors21 so that each bit is set if the corresponding transaction contains the item(set ) . Therefore g creates the bit vector , ◦ = AN D , f(· ) = sum(· ) and F ( m ) = m .
Figure 4(a ) shows the runtime22 of FP Growth , GLIMIT and Apriori23 on T10I4D100K , as well
21We used the Colt ( http://dsdlblgov/˜hoschek/colt/ ) BitVector implementation .
22Pentium 4 , 2.4GHz with 1GB RAM running WindowsXP Pro . 23Apriori was not run for extremely low support as it takes
( a ) Runtime ratios . T10I4D100K .
( b ) Average time taken per frequent itemset shown on two scales . T10I4D100K .
( c ) Number of Itemvectors needed and maximum frontier size . T10I4D100K .
Figure 5 . Results required drops quite quickly as minSup is increased ( and hence the number of frequent items decreases ) . Figure 5(c ) also shows that the maximum frontier size is very small .
Finally , we reiterate that we can avoid using the prefix tree and sequence map , so the only space required are the itemvectors and the f rontier . That is , the space required is truly linear .
7 Conclusion and Future Work
We showed interesting consequences of viewing transaction data as itemvectors in transactionspace , and developed a framework for operating on itemvectors . This abstraction gives great flexibility in the measures used and opens up the potential for useful transformations on the data . Our future work will focus on finding useful geometric measures and transformations for itemset mining . One problem is to find a way to use SVD prior to mining for itemsets larger than 2 . We also presented GLIMIT , a novel algorithm that uses our framework and significantly departs from existing algorithms . GLIMIT mines itemsets in one pass without candidate generation , in linear space and time linear in the number of interesting itemsets . Experiments showed that it beats FP Growth above small support thresholds . Most importantly , it allows the use of transformations on the data that were previously impossible .
References
[ 1 ] D . Achlioptas . Database friendly random projections . In Symposium on Principles of Database Systems , 2001 .
[ 2 ] R . Agrawal and R . Srikant . Fast algorithms for mining association rules . In Proceedings of 20th Interna tional Conference on Very Large Data Bases VLDB , pages 487–499 . Morgan Kaufmann , 1994 .
[ 3 ] Workshop on frequent itemset mining implementa tions 2003 . http://fimicshelsinkifi/fimi03
[ 4 ] Workshop on frequent itemset mining implementa tions 2004 . http://fimicshelsinkifi/fimi04
[ 5 ] J . Han , J . Pei , and Y . Yin . Mining frequent patterns without candidate generation . In 2000 ACM SIGMOD Intl . Conference on Management of Data , pages 1–12 . ACM Press , May 2000 .
[ 6 ] F . Korn , A . Labrinidis , Y . Kotidis , and C . Faloutsos . Quantifiable data mining using ratio rules . VLDB Journal : Very Large Data Bases , 8(3–4):254–266 , 2000 .
[ 7 ] F . Pan , G . Cong , A . Tung , J . Yang , and M . Zaki . Carpenter : Finding closed patterns in long biological datasets . In Proceedings of the Ninth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining . Morgan Kaufmann , 2003 .
[ 8 ] J . Pei , J . Han , and L . Lakshmanan . Pushing convertible constraints in frequent itemset mining . Data Mining and Knowledge Discovery : An International Journal , 8:227–252 , May 2004 .
[ 9 ] J . Pei , J . Han , and R . Mao . CLOSET : An efficient algorithm for mining frequent closed itemsets . In ACM SIGMOD Workshop on Research Issues in Data Mining and Knowledge Discovery , pages 21–30 , 2000 .
[ 10 ] S . Shekhar and Y . Huang . Discovering spatial colocation patterns : A summary of results . Lecture Notes in Computer Science , 2121:236+ , 2001 .
[ 11 ] M . Steinbach , P N Tan , H . Xiong , and V . Kumar . Generalizing the notion of support . In The Tenth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining KDD’04 , 2004 .
[ 12 ] J . Wang and G . Karypis . Harmony : Efficiently mining the best rules for classification . In SIAM International Conference on Data Mining , pages 205–215 , 2005 .
