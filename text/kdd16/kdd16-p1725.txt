A Real Linear and Parallel Multiple Longest Common
Subsequences ( MLCS ) Algorithm
Yanni Li
School of Software
Xidian University , China yannili@mailxidianeducn
Hui Li
School of Cyber Engineering
Xidian University , China hli@xidianeducn
Tihua Duan
Information Center
Shanghai Finance University ,
China duantihua@163.com
Sheng Wang
Faculty of Engineering ,
Environment and Computing
Coventry University , UK
Zhi Wang
School of Computer Science and
Yang Cheng
School of Software shengwang@conventryacuk xd_zhiwang@163.com
Technology
Xidian University
Xidian University , China xd_chengyang@163.com
ABSTRACT Information in various applications is often expressed as character sequences over a finite alphabet ( eg , DNA or protein sequences ) . In Big Data era , the lengths and sizes of these sequences are growing explosively , leading to grand challenges for the classical NP hard problem , namely searching for the Multiple Longest Common Subsequences ( MLCS ) from multiple sequences . In this paper , we first unveil the fact that the state of the art MLCS algorithms are unable to be applied to long and large scale sequences alignments . To overcome their defects and tackle the longer and largescale or even big sequences alignments , based on the proposed novel problem solving model and various strategies , eg , parallel topological sorting , optimal calculating , reuse of intermediate results , subsection calculation and serialization , etc . , we present a novel parallel MLCS algorithm . Exhaustive experiments on the datasets of both synthetic and real world biological sequences demonstrate that both the time and space of the proposed algorithm are only linear in the number of dominants from aligned sequences , and the proposed algorithm significantly outperforms the state ofthe art MLCS algorithms , being applicable to longer and large scale sequences alignments .
Keywords Multiple Longest Common Subsequences ( MLCS ) ; Non redundant Common Subsequence Graph ( NCSG ) ; Topological Sorting ; Subsection Calculation and Serialization
1 .
INTRODUCTION
Information in various applications often can be abstracted as character sequences over a finite alphabet Σ , eg , DNA or protein sequences in biology . Searching for the Multiple
KDD ’16 , August 13 17 , 2016 , San Francisco , CA , USA cfl 2016 ACM . ISBN 978 1 4503 4232 2/16/08 . . . $15.00 DOI : http://dxdoiorg/101145/29396722939842
Longest Common Subsequences from a group of sequences ( MLCS ) over a finite alphabet Σ is a classical NP hard problem [ 13 ] and has found many important applications in many areas , eg , bioinformatics , computational genomics , pattern recognition , data mining , etc . For example , in bioinformatics , sequence is the most basic mathematical model , which can describe the primary structure of the nucleic acid and protein molecules . Searching for their LCS s/MLCS s is an important way to identify the sequence similarity , which can be utilized in gene discovery , the construction of an evolutionary tree , the evidence of the species’ common origin [ 20 ] , etc . With the successful implementation of the Human Genome Project , the lengths , sizes of biological [ 4 , 8 ] or other types of sequences are growing explosively and exponentially [ 16 ] . Mining the MLCS s from these sequences is becoming a more and more important research topic and facing severe challenges .
In the past forty years , in order to efficiently tackle the LCS/MLCS problem , various types of LCS/MLCS algorithms [ 2 , 3 , 6 , 7 , 11 , 12 , 14 , 15 , 16 , 17 , 19 ] and tools ( eg , SAMtools1 , BLAST2 , Clustal Omega3 , etc . ) have been proposed , which can be divided into two categories : classical dynamic programming and dominant point based algorithms . It has been demonstrated that the dominantpoint based LCS/MLCS algorithms have an overwhelming advantage over classical dynamic programming ones due to their great reduction in the size of search space by orders of magnitude [ 16 ] . In particular , FAST LCS [ 2 ] and QuickDPPAR [ 16 ] are the most efficient parallel MLCS algorithms among dominant point based algorithms . However , it will be shown in this paper with both theoretical and empirical study that these algorithms suffer severely from many unnecessary and redundant storage , computation , comparison and deletion of multi dimensional dominants . Therefore , this kind of algorithms is essentially inapplicable to long and large scale sequences alignments . Moreover , both of the two types of algorithms are in fact not linear . To overcome this problem , we present a new problem solving graphical model and propose a real linear and parallel algorithm for multiple
1
2
3 http://wwwhtsliborg/ http://blastncbinlmnihgov/Blastcgi http://wwwebiacuk/Tools/msa/clustalo/
1725 longest common subsequences mining , equipped with several carefully designed strategies . Our main contributions are as follows :
• We propose a novel problem solving model , namely Non redundant Common Subsequence Graph , NCSG , and introduce both a forward and a backward parallel topological sorting strategies on the NCSG , individually leading to efficiently eliminating existing leading dominant point based MLCS algorithm’ defects and finding all MLCS s of the aligned sequences at once with a very low cost of time and space .
• With the introduction of series of well designed strategies , eg , optimal computing , subsection calculation and serialization , reuse of intermediate results and multiple concurrent execution , we present an efficient parallel MLCS algorithm , which is essentially appropriate to longer and large scale sequences alignments . Theoretical study of the time and space complexities for the proposed parallel MLCS algorithm indicates that the proposed algorithm is only linear in the number of dominants from the aligned sequences .
• We validate the proposed parallel MLCS algorithm on DNA and amino acid sample sequences from real biological datasets and random synthetic sequences , and make comparisons in time and space performance between the proposed algorithm and the existing stateof the art dominant point based algorithms . Theoretical study and experimental results justify that our algorithm not only greatly outperforms state of the art competitors , but also is practical for longer and largescale or even big sequences alignments .
The rest of this paper is organized as follows . Section 2 first gives a formal definition of the MLCS problem , and then briefly reviews the related work on classic dynamic programming and dominant point based algorithms in introducing some necessary preliminaries , and finally reveals some inherent limitations of the leading dominant pointbased algorithms . To overcome the limitations , Section 3 discusses the proposed novel problem solving model NCSG and two topological sorting strategies on the NCSG . Section 4 first elaborates upon several well designed strategies tackling longer and large scale sequences alignments , and then gives our novel efficient parallel MLCS algorithm , followed by a detailed study of the time and space complexities . Comprehensive experiments are conducted in Section 5 . Finally , Section 6 concludes this work .
2 . PRELIMINARIES AND RELATED WORK
In this part , we first present series of preliminaries used in our model and then discuss some related works .
2.1 Definitions of LCS/MLCS Problems
A subsequence of a given sequence over a finite alphabet Σ can be obtained by deleting zero or more ( not necessarily consecutive ) characters from the sequence . Let X = x1x2xn and Y = y1y2ym be two sequences with lengths n and m , respectively , over a finite alphabet Σ , ie , xi , yj ∈ Σ , and the Longest Common Subsequence ( LCS ) problem is to find out all the longest common subsequences of X and Y . Similarly , the Multiple Longest Common Subsequence ( MLCS ) problem is to find out all the longest common subsequences of d ( d ≥ 3 ) sequences with equal length n or unequal length . Obviously , the LCS is a special case of MLCS .
Note that , given d sequences over a finite alphabet Σ , there exists more than one MLCS s in general . For example , given three sequences , S1 = GT ACT AGC , S2 = ACT GT CAG and S3 = T CAGT GCA over Σ = {A , C , G , T } , there are 4 MLCS s with length 4 , namelyM LCS1 = GT CA , M LCS2 = AT GC , M LCS3 = CT GC and M LCS4 = T CAG . 2.2 Preliminaries and Related Algorithms
Based on the methods adopted , existing LCS/MLCS algorithms can be divided into two categories : classical dynamic programming and dominant point based algorithms . Depending on whether they are parallelized , the algorithms can also be divided into two types : serial and parallel ones . 1 ) Classical Dynamic Programming Algorithms : These algorithms are based on dynamic programming [ 14 , 15 ] . In the simplest case , given two sequences X = x1x2xn and Y = y1y2ym with lengths n and m , respectively , over a finite alphabet Σ , where X[i ] = xi , Y [ j ] = yj , xi , yj ∈ Σ , 1 ≤ i ≤ n and 1 ≤ j ≤ m , a dynamic programming algorithm iteratively constructs an ( n + 1 ) ∗ ( m + 1 ) score matrix L , in which L[i , j ] is the length of an LCS between two prefixes X ′ = x1x2xi and Y ′ = y1y2yj of X and Y , calculated as follows :
 
L[i , j ] =
0 L[i − 1 , j − 1 ] + 1 max(L[i − 1 , j ] , L[i , j − 1 ] ) if i or j = 0 if X[i ] = Y [ j ] if X[i ] 6= Y [ j ] .
( 1 )
Once the score matrix L is calculated , all the LCS s can be obtained by tracing back from the end element L[n , m ] to the starting element L[0 , 0 ] . Both the time and space complexities of this algorithm are O(mn ) . In general , given d sequences S1 , S2 , , Sd with arbitrary equal or unequal lengths , n1 , . . . , nd , the matrix L can be naturally extended to d dimensions for the MLCS problem , in which the element L[i1 , i2 , , id ] can be calculated by Eq 2 in a similar manner to Eq 1 , the time and space complexities are therefore both O(Qd i=1 ni ) .
 
L[i1 , . . . , id ] =
0 L[i1 − 1 , . . . , id − 1 ] + 1 max( ¯L ) if ∃ij = 0 , 1 ≤ j ≤ d if S1[i1 ] = . . . = Sd[id ] otherwise .
( 2 ) where ¯L = {L[i1 − 1 , i2 , . . . , id ] , L[i1 , i2 − 1 , . . . , id ] , . . . , L[i1 , i2 , . . . , id−1 , id − 1]} .
Fig 1 illustrates the score matrix L of two sequences S1 = ACT AGCT A and S2 = T CAGGT AT over the alphabet Σ = {A , C , G , T } and the process of extracting an LCS =CAGT A from L .
To further reduce time and space complexities , various improved dynamic programming LCS/MLCS algorithms [ 1 , 3 , 6 ] have been proposed . For example , Hirschberg [ 3 ] presented a new LCS algorithm based on the divide and conquer approach , which reduces the space complexity to O(m + n ) ; however , its time complexity remains to be O(mn ) . Masek and Paterson [ 14 ] put forward an improved dynamic programming LCS algorithm for two sequences with length n using a fast computing method of edit distance , whose worst time complexity is O(n2/ log n ) . Unfortunately , most of the aforementioned algorithms only address the LCS problem but not MLCS and have high time and space complexities . 2 ) Dominant point based Algorithms : In order to clearly illustrate the dominant point based LCS/MLCS algorithms , we first introduce the following definitions .
1726 i
0
1
2
3
4
5
6
7
8 i
0
1 2 3 4 5 6 7 8 j
S 1 A C T A G C T A j
S 1 A C T A G C T A
0 S 2 0
1 T
0
0
0
0
0
0
0 Ś 1
0
1
0
1
0
1
0 Ś 1
1
1 ś 2
0
1
2
2 C 0 3 A 0 Ś 1 1 4 G 0
1
5 G 0
6 T
0
7 A 0
8 T
0
1
1
1
1
1
1
1
1 ś 2
2
2 Ŝ
1
1
2 Ŝ 3
2
3
3
3
3
3
3
3
1 ś 2
2 Ŝ 3
3 ŝ 4 4 Ş
3
2
3
3
3
4
5
0 S 2 0
0 0 0 0 0 0 0 0
1 T
0
0 0 Ś
0 Ś
2 C 0 3 A 0 Ś 4 G 0
ś
Ŝ
ś
Ŝ
5 G 0
6 T
0
7 A 0
8 T
0
ś
Ŝ
ŝ
Ş
( a ) The score matrix L of sequences S1 and S2 .
( b ) An LCS = CAGT A extracted from L .
Figure 1 : The score matrix L of S1 = ACT AGCT A and S2 = T CAGGT AT over a finite alphabet Σ = {A , C , G , T } and LCS ( CAGT A ) extracted from L . The regions of the same entry values are bounded by thick contours ; the corner points of the contours are dominant points ( circled ) and the greyed points are matched points .
Definition 1 : For a sequences set T = {S1 , S2 , , Si , , Sd} over a finite alphabet Σ , and |Si| = n.4 Let Si[pi](Si[pi ] ∈ Σ ) be the pi th ( pi ∈ {1 , 2 , , n} ) character in Si . The point p = ( p1 , p2 , , pd ) is called a matched point of T , if and only if S1[p1 ] = S2[p2 ] = = Si[pi ] = = Sd[pd ] = σ(σ ∈ Σ ) .
Definition 2 : For two matched points , p = ( p1 , p2 , , pd ) and q = ( q1 , q2 , , qd ) , of T , we say that p = q if and only If ∀i , pi < qi , we say that p if pi = qi for i = 1 , 2 , , d . strongly dominates q , denoted as p ≺ q , where p is referred to as a dominating point ( dominant for short ) and q as a dominated point or successor of p . Further , if there is no matched point r = ( r1 , r2 , , rd ) for T such that p ≺ r ≺ q , we say that q is an immediate successor of p and p is an immediate predecessor of q .
Definition 3 : A matched point p = ( p1 , p2 , , pd ) is called the k th dominant ( the k level dominant for short ) , if the score matrix L[p1 , p2 , , pd ] = k ( see Eq 2 ) . The set of all the k th dominants is denoted as Dk , and the set of all dominants of T is denoted as D .
Fig 1 shows that a dominant must be a matched point , but not vice versa , and the size of the dominant set D is smaller than that of the matched points , which have been proved by [ 2 , 7 , 16 ] .
Comparing with dynamic programming LCS/MLCS algorithms , the dominant point based LCS/MLCS algorithms only need to calculate the dominants instead of all the elements in the score matrix L . The algorithms consist of two procedures as follows .
( 1 ) Constructing MLCS DAG . First of all , introduce two dummy points , source point ( 0 , 0 , , 0 ) and sink point ( ∞ , ∞ , , ∞ ) , where the sink point is defined as the immediate successor of those points without an immediate successor . Afterwards , let k = 0 , and D0 = {(0 , 0 , , 0)} . Next , with a forward iteration procedure ( 0 → k ) , the ( k + 1) th dominants Dk+1 are computed based on the k th dominants Dk , and this procedure is denoted as Dk → Dk+1 , where 0 ≤ k ≤ |MLCS| − 1 ( |MLCS | denotes the length of MLCS s of T ) . As a result , a directed acyclic graph consisting of all the MLCS s of T ( MLCS DAG , for short ) is constructed level by level in the following two steps :
4
In fact , the algorithms apply to general case where the length of Si may not be the same . The only reason we fix |Si| = n here is to facilitate the following discussions .
Step 1 : Based on Dk , all the immediate successors of each dominant from Dk are calculated , denoted as Dk+1 init .
Step 2 : There exist massive repeated dominants and dominated points in Dk+1 init , both collectively called redundant points for short . Since the redundant points do not contribute to the MLCS s , the operation Minimal ( Dk+1 init ) ( Minimal ( ) for short ) of eliminating them should be conducted in order to save time and space . In general , the operation Minimal ( ) is performed by comparing between the dominants and redundant points in Dk+1 init one dimension after another , resulting in the baseline Dk+1 over Dk+1 init .
( 2 ) Computing MLCSs . All the MLCS s of T are then found by tracing back through the constructed MLCS DAG from the last dominant set to D0 iteratively . An instance of this kind of algorithms is shown in Example 1 and Fig 2 .
As the size of the dominants set D is far smaller than that of the matrix L , ie , |D| ≪ |L| , both theoretical analysis and experimental results have shown that the dominant pointbased LCS/MLCS algorithms are overwhelmingly faster than classical dynamic programming algorithms [ 16 ] .
Hunt et al . [ 7 ] first proposed a dominant point based LCS algorithm with time complexity O((r + n ) log n ) , where r is the number of all dominants of two sequences with length n . Afterwards , a variety of dominant point based LCS/MLCS algorithms have been presented [ 1 , 6 ] . To further improve the efficiency , some parallel dominant pointbased LCS [ 12 , 19 ] and MLCS algorithms [ 2 , 10 , 16 ] were proposed . Korkin [ 10 ] first proposed a parallel MLCS algorithm with time complexity O(|Σ||D| ) . Chen et al . [ 2 ] presented an efficient parallel MLCS algorithm over the alphabet Σ = {A , C , G , T } , FAST LCS , with series of pruning rules . Wang et al . [ 16 ] developed an efficient parallel MLCS algorithm Quick DPPAR , claiming that the proposed algorithm has reached a near linear speedup with respect to its serial version Quick DP . It is worth mentioning that [ 11 , 17 ] made attempts to develop efficient parallel algorithms on GPUs for the LCS problem and on cloud platform for the MLCS problem , respectively . Regretfully , [ 17 ] is not suitable for the general MLCS problem , as a large amount of synchronous cost [ 11 ] remains to be solved . For large scale MLCS problems in practice , Yang et al . [ 18 ] presented a new progressive algorithm Pro MLCS with its efficient parallelization , which can find an approximate solution quickly . Parallel dominant point based MLCS algorithms are currently a better solution for the MLCS problem . However , as we will show in next subsection , such algorithms are facing serious challenges with the explosive expansion in the lengths and sizes of sequences from varieties of applications .
2.3 Limitations of the Leading MLCS Algo rithms
We first give an example to illustrate the limitations of the leading dominant point based MLCS algorithms , and then make a further study .
Example 1 : Given sequences S1 = T GACGAT C , S2 = AT GCT CAG and S3 = CT AGT ACG over the alphabet Σ = {A , C , G , T } , construct their MLCS DAGs and find out all the MLCS s of S1 , S2 and S3 by the general dominantpoint based algorithms .
Based on the dominant point based MLCS algorithm , the constructed MLCS DAG of S1 , S2 and S3 is shown in Fig 2 . The construction process is as follows . First of all , let k = 0 , D0 = {(0 , 0 , 0)} ( 0 level dominant ) . By Definition 2 , all the
1727 N
N
N
N
N
OHYHO
OHYHO
OHYHO
OHYHO
OHYHO
N
OHYHO
$
&
*
7
$
&
*
7
$
&
*
7
$
&
*
7
*
$
&
7
&
&
*
$
&
*
7
&
*
ɞ ɞ ɞ
Figure 2 : The constructed MLCS DAG of S1 , S2 and S3 over Σ = {A , C , G , T } by the dominant point based algorithms , the blue ( red ) points denote repeated ( dominated ) points , which would be deleted after the operation Minimal ( ) , and a dashed arrow indicates an added edge after deleting a point . All the MLCS s ( marked by red arrows ) can be obtained by tracing back from the sink point ( ∞ , ∞ , ∞ ) to the source point ( 0 , 0 , 0 ) on the MLCS DAG . immediate successors D1 init = {(3 , 1 , 3 ) , ( 4 , 4 , 1 ) , ( 2 , 3 , 4 ) , ( 1 , 2 , 2)} corresponding to the characters {A , C , G , T} from D0 are calculated . The operation Minimal ( ) is then performed so as to eliminate the redundant point ( 2 , 3 , 4 ) ( a dominated point of the point ( 1 , 2 , 2) ) , leading to the end of procedure D0 → D1 ( 1 level dominants D1 = {(3 , 1 , 3 ) , ( 4 , 4 , 1 ) , ( 1 , 2 , 2)} ) . Repeating the same procedure as above Dk → Dk+1 , D2 , D3 , D4 , and D5 of 2 level to 5 level dominants can be obtained in turn , where D2 = {(4 , 4 , 7 ) , ( 5 , 3 , 4 ) , ( 7 , 2 , 5 ) , ( 6 , 7 , 3 ) , ( 7 , 5 , 2 ) , ( 3 , 7 , 3 ) , ( 2 , 3 , 4)} , D3 = {(5 , 8 , 8 ) , ( 6 , 7 , 6 ) , ( 8 , 4 , 7 ) , ( 7 , 5 , 5 ) , ( 5 , 8 , 4 ) , ( 3 , 7 , 6 ) , ( 4 , 4 , 7)} and D4 = {(8 , 6 , 7 ) , ( 5 , 8 , 8)} , respectively . Since D5 init = ∅ , let D5 = {(∞ , ∞ , ∞)} and end the construction of MLCS DAG . Finally , based on the MLCS DAG , all the MLCS s of S1 , S2 and S3 corresponding to the character sequences of points on the longest paths ( marked by red arrows ) over the MLCS DAG(M LCS1 = AGT C , M LCS2 = T GT C , M LCS3 = T GAG and M LCS4 = T GCG with length 4 ) can be obtained by tracing back from the sink point ( ∞ , ∞ , ∞ ) to the source point ( 0 , 0 , 0 ) .
Fig 2 clearly shows that there are numerous redundant points in the MLCS DAG , and that many points , eg , ( 2 , 3 , 4 ) , ( 4 , 4 , 7 ) and ( 5 , 8 , 8 ) , have been recalculated and compared with other points many times . Moreover , there exist many points in the MLCS DAG , which are useless to the MLCS s of sequences S1 , S2 and S3 .
To further show the limitations of the dominant pointbased MLCS algorithms , we conducted a statistical study with various types of the redundant points of the MLCSDAG from sequences with various lengths and sizes of alphabet over the real world and synthetic datasets utilized in Section 5 , from which we draw the following conclusions : 1 ) In each iteration , procedure Dk → Dk+1 generates a great number of redundant points , leading to an excessive computational time in the operation Minimal ( ) .
The statistical data show that in Dk+1 init , there exist two types of a significant number of redundant points ( denoted as Nredu ) , ie , repeated points ( denoted as Nrepeat ) and dominated points/successors ( denoted as Nsuc ) . Let
N = |Dk+1 init | , the average ratio of the redundant points Nredu to N reaches 59 % , and the ratio can be up to 79 % . These redundant points will result in an excessive computational time in the operation Minimal ( ) . Moreover , tremendous comparisons in d dimensions among N points are inevitable besides the massive amount of redundant points in the operation Minimal ( ) of the process Dk → Dk+1 . For d sequences with length n ( d ≥ 3 ) , it is proved that the time for the comparisons among N d dimensional points dimension by dimension in a brute force manner is O(dN 2 ) [ 5 , 9 ] . Even if the divide and conquer strategy is adopted , O(dN logd−2 n ) comparisons are still needed [ 16 ] .
2 ) The constructed MLCS DAG contains a large number of useless points not contributing to any MLCS s , called noncritical points .
The statistical data shows that the ratio of |K| ( the total number of the key points that contribute to the MLCS s in the MLCS DAG ) to |D| ( the total number of the points in MLCS DAG ) ranges from only 1 : 10 to 1 : 100 , 000 . Moreover , the larger the d , n and |Σ| , the smaller the ratio of |K|/|D| is . The massive non critical points in the MLCSDAG introduce another serious space problem of storing the MLCS DAG in RAM and time problem when tracing back to find its MLCS s on the MLCS DAG .
Above all , since Minimal ( ) is the key operation in the process Dk → Dk+1 of the general dominant point based MLCS algorithms , and by the above argument , it is clear that the time complexity of the dominant point based MLCS algorithms are nonlinearly related to d and |D| . In addition , the length of MLCS , |MLCS| is proportional to the aligned sequences length n , and |Dk| tends to grow explosively in the range 1 ≤ k ≤ |MLCS|/2 . Therefore , both the above analysis and our comprehensive experimental results ( see Section 5 ) show that the leading dominant point based MLCS algorithms are not applicable to long and largescale sequences alignments .
3 . A NOVEL PROBLEM SOLVING MODEL
AND MINING MLCS STRATEGY
3.1 A Novel Problem Solving Model : NCSG
As mentioned above , all the MLCS s of aligned sequences set T are constructed by their relevant dominants . For the dominants set D from T , since the immediate predecessorsuccessor relationships between the dominants in D constitute a partial order set , we can represent the relationships by a directed acyclic graph G = ( D , ) . Similar to the construction of MLCS DAG , two dummy d dimensional points ( 0 , 0 , , 0 ) ( the source point ) and ( ∞ , ∞ , , ∞ ) ( the sink point ) are introduced into D , with all the other dominants in D being the successors of ( 0 , 0 , , 0 ) and the predecessors of ( ∞ , ∞ , , ∞ ) . The construction of G is as follows . 1 ) From the dummy source point ( 0 , 0 , , 0 ) , calculate all of its immediate successors and connect them with directed edges from the source point to the immediate successors . 2 ) From these calculated immediate successors , compute all their immediate successors . If the immediate successor found is already in G , only add a directed edge to it ; otherwise , add it to G and connect it by a directed edge . If a successor has no immediate successors , connect it with the sink point by a directed edge . 3 ) Repeat above procedure 2 ) until all points in G have computed their immediate successors . Notably , such G is in fact an MLCS DAG but with
1728
$
&
*
7
$
&
*
7
$
&
*
7
$
*
$
7
&
ɞ ɞ ɞ
Figure 3 : The constructed NCSG of S1 , S2 and S3 over the alphabet Σ = {A , C , G , T } , where the optimal subgraph Sub NCSG4 of the NCSG ( marked red ) is constructed from the optimal dominant ( 1 , 2 , 2 ) . the following properties : no repeated dominants and comparison of dominants in the dimension by dimension manner on constructing G . Due to that , finding an MLCS can now be regarded as identifying the longest path over G from the source point to the sink point , and vice versa . Since G has no repeated dominants , and any path of G corresponds to a common subsequence of T , we refer to it as Non redundant Common Subsequence Graph , abbreviated as NCSG in the following . The constructed NCSG of the above sequences S1 , S2 and S3 is shown in Fig 3 .
3.2 A Strategy to Mine MLCSs : Forward/ Back ward Topological Sorting on NCSG
Given a constructed NCSG , we need to design an efficient and effective strategy to extract all MLCS s from it . To this end , let ’s start by reviewing the following concepts from the graph theory .
Definition 4 : For a directed acyclic graph G = hV , i , topological sorting is to find an overall order of the vertices V in G from the partial order [ 5 , 9 ] .
Definition 5 : The topological sorting algorithm [ 9 ] is to complete the topological sorting over the vertices V in G from the partial order . To this end , it iteratively performs the following two steps until all the vertices V in G have been traversed and processed : 1 ) output the vertices with in degree 0 ; 2 ) delete the edges connecting to the vertices .
We found that the topological sorting over the vertices V in G from the partial order is only associated with the cardinality of the in degree of vertices , but not related to the dimensions of vertices . We do not need to perform the comparison of the dominants dimension by dimension to sort and layer them as in the construction of MLCS DAG for leading dominant point based MLCS algorithms . Inspired by this observation , we present a novel efficient method to sort and layer all the dominants of the NCSG , ie , sorting and layering all of the dominants of the NCSG from the 0 level dominant set D0 to the k level dominant set Dk level by level with the topological sorting algorithm ( called a forward topological sorting algorithm , denoted as Algorithm ForwardTopSort ) , 1 ≤ k ≤ |MLCS| − 1 . An example of sorting and layering all the dominants on the NCSG of the sequences S1 , S2 and S3 is shown in Fig 4 .
Moreover , based on the sorted and layered NCSG shown in Fig 4 , how do we find all MLCS s at once with a very low cost of time and space without multiple backtracking
OHYHO→ OHYHO→ OHYHO→ OHYHO→ OHYHO→ OHYHO
$
&
7
*
$
7
*
$
7
7
&
$
$
*
&
7
*
Ğ Ğ Ğ
Figure 4 : Sorting and layering all the dominants on NCSG of S1 , S2 and S3 by ForwardTopSort , in which all the longest paths are marked by red arrows .
OHYHO→ OHYHO→ OHYHO→ OHYHO→ OHYHO→ OHYHO
$$$$
****
7777
****
7777
$$$$
&&&&
7777
****
ĞĞĞĞ ĞĞĞĞ ĞĞĞĞ
OHYHO ← OHYHO ← OHYHO ← OHYHO ← OHYHO ← OHYHO
Figure 5 : With BackwardTopSort to the sorted and layered NCSG of S1 , S2 and S3 shown in Fig 4 , the optimized NCSG can be obtained , in which any path corresponds to an MLCS of the sequences . processes as in the leading dominant point based MLCS algorithm ? By investigating the sorted and layered NCSG , we find that the sum of the numbers of the forward levels ( from {(0 , 0 , , 0)} to {(∞ , ∞ , , ∞)} ) and the backward levels ( from {(∞ , ∞ , , ∞)} to {(0 , 0 , , 0)} ) of those dominants ( called key points ) residing in the longest paths corresponding to the MLCSs is exactly equal to |M LCS| + 1 ; however non critical points would not meet the property ( see Fig 5)5 . Based on the observation , we replace the in degree with the out degree and layer the NCSG by the topological sorting algorithm from the point {(∞ , ∞ , , ∞)} to {(0 , 0 , , 0)} ( called a backward topological sorting algorithm , denoted as Algorithm BackwardTopSort ) . Thanks to that , all the noncritical points in the NCSG are now identified and can be easily removed . Fig 5 ( called the optimized NCSG ) demonstrates the result with BackwardTopSort to Fig 4 . In particular , the NCSG shown in Fig 5 contains only those key points , that is , each path in the optimized NCSG corresponds to an MLCS of S1 , S2 and S3 .
In summary , based on our novel problem solving model NCSG and the MLCS s mining strategy , Algorithms ForwardTopSort and BackwardTopSort , we can overcome the defects of the leading dominant point based MLCS more efficiently and effectively , which is verified by our extensive experiments . However , unfortunately , the theoretical and experimental results also show that the proposed model and the strategy are impractical to big sequences ( eg , the genome sequences with length 103 − 1011 ) alignments , which motivates us to explore more efficient method . In the next section , we shall present a parallel solution towards this end .
4 . A PARALLEL ALGORITHM RLP_MLCS 4.1 Strategies against the Challenges
For the convenience of discussion , we first introduce following key concepts , and give a part of our statistical study in Table 1 over synthetic and real world biological sequences datasets ( see Section 5 ) .
5
It can be easily proved , we select not to show the detailed proof here due to the limit of space .
1729 Table 1 : The total number of dominants of aligned sequences with various lengths and alphabet sizes
|Si|
N1
|Σ| = 4 N2
N1/N2( % )
|Si|
N1
|Σ| = 20 N2
N1/N2( % )
748
24642
1131 36028
2022260 18338817 86256948
25 50 2159886 100 19546754 140 180 91655681 220 210103979 221208508 260 300603814 313783560 300 446319986 463079501 320 554032873 566657853
66 68 93 93 94 94 95 96 97
46
4714
101 7150
50 100 316244 180 3188919 260 17940691 340 72256797 420 500 164981091 172150132 580 373671085 388190591 620 554532996 566558951
262594 2840112 16523403 68350594
45 65 83 89 92 94 95 96 97
Definition 6 : Given a NCSG , a dominant is called the optimal dominant from the NCSG , if and only if the dominant belongs to 1 level dominants ( ∈ D1 ) and has minimal coordinates values compared with the other 1 level dominants . if a subgraph Sub NCSGi of the NCSG is constructed starting from optimal dominant i , the Sub NCSGi is called the optimal subgraph of the NCSG .
For example , by Definition 6 , dominant ( 1 , 2 , 2 ) ( the fourth dominant from 1 level dominants D1 ) shown in Fig 3 is an optimal dominant , from which the constructed subgraph ( marked red ) of the NCSG is an optimal subgraph denoted as Sub NCSG4 .
The most fundamental challenges to longer and large scale sequences alignments for MLCS algorithms are their unbearable huge time and insufficient space for calculating and storing the massive dominants of the NCSG . The statistical data shown in Table 1(N1 denotes the total number of the dominants from the optimal subgraph of the NCSG , and N2 is the total number of the dominants from the NCSG ) bring out the following facts : 1 ) With the increase in the length of sequences , the number of dominants from the NCSG gets an exponential explosive growth ; 2 ) Most of the dominants come from the optimal subgraph Sub NCSGi , eg , Table 1 shows that the ratio of N1/N2 is as high as 97 % . From the above facts , we present the following strategies so as to tackle the challenges . Notably , in line with other parallel algorithms towards big data , our model is based on the intuition that the results of parallel algorithms should be compatible in divide and conquer style and support combinative .
Strategy 1 : Successor Table , ST . One of the fundamental needs in constructing NCSG is to search all the immediate successors for each dominant efficiently due to the massive number of dominants in the NCSG . To achieve that , according to the searching strategy from [ 2 ] , the successor tables {ST1 , ST2 , , STd} of the aligned sequences set T = {S1 , S2 , , Sd} should be built first , ie , given a sequence Sl = x1 , x2 , , xn from T over a finite alphabet Σ = {σ1 , σ2 , , σk} , its successor table STl is a twodimensional array , where STl[i , j ] denotes the element of the i th row and the j th column in STl , defined as below :
STl[i , j ] = min{m|xm = σi , m ≥ max{1 , j} , i ∈ [ 1 , |Σ| ] , j ∈ [ 0 , n]}
( 3 )
Obviously , STl[i , j ] is in fact the minimal subscript position m of the sequence Sl after position j according to σi when xm = σi , see an example in Fig 6 .
It has been proved in [ 2 ] that all the immediate successors of a d dimensional dominant p = ( p1 , p2 , , pd ) can be obtained efficiently in O(d|Σ| ) based on the successor tables . For example , for the dominant ( 2 , 3 , 4 ) of the sequences S1 , S2 and S3 , we can couple the corresponding lines 1 4 of the second , third and forth columns from the successor ta
^ϭ
$$$$
&&&&
****
7777
7777
****
$$$$
&&&&
****
$$$$
7777
&&&&
;ĂͿ dŚĞ ^ƵĐĐĞƐƐŽƌ dĂďůĞ ^dϭ
^Ϯ
$$$$
&&&&
****
7777
$$$$
7777
****
&&&&
7777
&&&&
$$$$
****
^ϯ
$$$$
&&&&
****
7777
&&&&
7777
$$$$
****
7777
$$$$
&&&&
****
;ďͿ dŚĞ ^ƵĐĐĞƐƐŽƌ dĂďůĞ ^dϮ
;ĐͿ dŚĞ ^ƵĐĐĞƐƐŽƌ dĂďůĞ ^dϯ
Figure 6 : The constructed successor tables ST1 , ST2 and ST3 corresponding to the sequences S1 , S2 and S3 , where the notation “ − ” indicates ∅ . bles ST1 , ST2 and ST3 to obtain all its immediate successors ( 3 , 7 , 6 ) , ( 4 , 4 , 7 ) , ( 5 , 8 , 8 ) and ( 7 , 5 , 5 ) corresponding to the characters A , C , G , and T , respectively , while there is no immediate successor for the dominant ( 6 , 7 , 3 ) due to the coupling results ( , ( , 8 , 4 ) and ( 7 , mediate successor according to Eq 3 .
, 5 ) , which indicates none of them is an im
, 6 ) , ( 8 ,
, 7 ) ,
Strategy 2 : DM(Index , Point ) . During the construction and processing of NCSG , we have to access the coordinates based on the corresponding index , and vice versa , respectively . Hence , we present a bidirectional hash table DM(Index , Point ) , wherein the Point represents a d dimensional coordinates of a dominant and Index is a serial number corresponding to the dominant . As a result , we can compressingly store all the dominants of the NCSG with serial numbers instead of their d dimensional coordinates . The dominants shown in Fig 7 stored in DM are as follows :
DM ={h0 , ( 0 , 0 , 0)i , h1 , ( 3 , 1 , 3)i , h2 , ( 4 , 4 , 1)i , h3 , ( 2 , 3 , 4)i , h4,(1 , 2 , 2)i , h5,(3 , 7 , 3)i , h6,(4 , 4 , 7)i , h7,(7 , 5 , 5)i , h8,(5 , 8 , 4)i , h9 , ( 5 , 8 , 8)i , h10 , ( 3 , 7 , 6)i , h11 , ( 8 , 6 , 7)i , h12 , ( ∞ , ∞ , ∞)i , h13 , ( 5 , 3 , 4)i , h14 , ( 7 , 2 , 5)i , h15 , ( 6 , 7 , 6)i , h16 , ( 8 , 4 , 7)i , h17 , ( 6 , 7 , 3)i , h18 , ( 7 , 5 , 2)i , } .
Strategy 3 : The Optimal Calculation and Reuse of Intermediate Results . Our extensive experiments and analysis reveal the fact that the optimal subgraph Sub NCSGi of NCSG not only contains most of the dominants of the NCSG ( 45% 97 % , average 88 % , see Table 1 ) , but also contributes to most of the MLCS s ( 75% 100 % , average 85% ) . For example , the optimal dominant ( 1 , 2 , 2 ) shown in Fig 3 contributes to three MLCS s of the sequences S1 , S2 and S3 , which is 3 out of 4 MLCSs , accounting for 75 % . Moreover , as a dominant may locate in different paths of the NCSG , the number of levels of a dominant located in the longest paths ( corresponding to MLCSs’ paths ) of NCSG must be greater than that in the non longest paths . For example , the dominants ( 4 , 4 , 7 ) and ( 5 , 8 , 8 ) shown in Fig 7 simultaneously locate in the non longest path ( (0 , 0 , 0 ) → ( 3 , 1 , 3 ) → ( 4 , 4 , 7 ) → ( 5 , 8 , 8 ) → ( ∞ , ∞ , , ∞ ) , denoted as path 1 ) and in the longest path ( (0 , 0 , 0 ) → ( 1 , 2 , 2 ) → ( 2 , 3 , 4 ) → ( 4 , 4 , 7 ) → ( 5 , 8 , 8 ) → ( ∞ , ∞ , , ∞ ) , denoted as path 2 ) . It is clear that the numbers of levels of the dominants ( 4 , 4 , 7 ) and ( 5 , 8 , 8 ) resided in path 1 ( being 2 and 3 , respectively ) are smaller than the numbers of levels they reside in path 2 , namely 3 and 4 , respectively . With the above observations , in order to save time and space of constructing NCSG of aligned sequences , we construct the NCSG in the following manner : 1 ) let D0={0 , 0 , , 0} and perform the procedure D0 → D1 ; 2 ) calculate the optimal dominant i from D1 ; 3 ) construct the optimal subgraph Sub NCSGi , the step called
1730 7
*
7
7
$
&
*
7
*
$
7
&
7
$
&
&
*
Figure 7 : With Strategy 3 , we can construct the NCSG of S1 , S2 and S3 quickly , the red arrows indicate the longest paths of the NCSG , the dash lines mean reuse of the intermediate results available ( the levels information from the optimized subgraph SubNCSG4 ) and red nodes are key points of Sub NCSG4 . optimal calculating ; 4 ) sort and layer the Sub NCSGi by Algorithm ForwardTopSort ; 5 ) identify and remove all of the non critical dominants on the Sub NCSGi by Algorithm BackwardTopSort resulting in an optimized Sub NCSGi , ie , all dominants are key points in the optimized Sub NCSGi ; 6 ) construct another subgraph of Sub NCSGj using the levels information of the dominants from the optimal subgraph Sub NCSGi , which have already been computed in previous steps , thus this step is called reuse of intermediate results . Since the NCSG of T is equal to the sum of the above subgraphs , with Strategy 3 , we can construct the NCSG of T quickly and effectively . For convenient of further discussion , the above steps 1) 6 ) in Strategy 3 are denoted as Function OptCalReusing1 ( ) , while the above steps 1) 4 ) and 6 ) in Strategy 3 ( not including step 5 ) ) are denoted as Function OptCalReusing2 ( ) . An example of using Strategy 3 to construct the NCSG of the sequences S1 , S2 and S3 is shown in Fig 7 .
Example 2 : With Strategy 3 , construct the NCSG of S1 , S2 and S3 and find out all of the MLCS s of the sequences . From Fig 7 , we can easily see that dominant 4 corresponding to dominant ( 1 , 2 , 2 ) ( see the contents of DM ) is an optimal dominant . Hence , with step 3 ) of Strategy 3 , we can construct the optimal subgraph Sub NCSG4 from the optimal dominant 4 . And then with steps 4 ) and 5 ) of Strategy 3 , we can get all the MLCS s of Sub NCSG4 . Next , with step 6 ) of Strategy 3 , we can easily construct other non optimal subgraphs Sub NCSG1 , Sub NCSG2 and Sub NCSG3 from the non optimal dominants 1 , 2 and 3 in turn and quickly find a new MLCS ( the path 1 → 13 → 7 → 11 → 12 ) . From above procedures and Fig 7 , we can easily see that the amount of calculations of constructing non optimal subgraphs ( Sub NCSG1 , Sub NCSG2 and Sub NCSG3 ) from the non optimal dominants 1 , 2 and 3 and searching for all of their MLCS s is very small due to the reuse of intermediate results available , the levels information of key points of optimized subgraph Sub NCSG4 .
Strategy 4 : Subsection Calculation and Serialization . As discussed above , for longer aligned sequences ( n ≥ 103 ) , the challenge is that their MLCS DAG is too large to be stored and calculated in RAM at all ( see Table 1 ) , resulting in leading dominant point based MLCS algorithms’ failure in this
( 0 , 0 )
A
( 3 , 1 )
C
( 4 , 3 )
G
( 2 , 4 )
T
( 1 , 2 )
( 0 , 0 )
A
( 3 , 1 )
T
( 1 , 2 )
C
( 4 , 3 )
G
( 2 , 4 )
G
( 5 , 4 )
C
( 4 , 6 )
( 0 , 0 )
A
( 3 , 1 )
T
( 1 , 2 )
C
( 4 , 3 )
G
( 2 , 4 )
G
( 5 , 4 )
C
( 4 , 6 )
T
( 7 , 2 )
A
( 3 , 7 )
C
( 4 , 3 )
G
( 2 , 4 )
T
( 7 , 5 )
( a )
( b )
( c )
A
( 6 , 7 )
C
( 4 , 6 )
G
( 5 , 4 )
G
( 5 , 8 )
C
( 8 , 6 )
A
( 3 , 7 )
C
( 4 , 6 )
G
( 5 , 8 )
T
( 7 , 2 )
A
( 3 , 7 )
C
( 4 , 6 )
T
( 7 , 5 )
T
( 7 , 2 )
T
( 7 , 5 )
G
( 6 , 7 )
T
( 8 , 6 )
T
( 8 , 3 )
G
( 5 , 8 )
G
( 6 , 7 )
T
( 8 , 6 )
T
( 8 , 3 )
( ∞ , ∞ )
( ∞ , ∞ )
Figure 8 : The sketch of searching for all the MLCS s of S4 and S5 with Strategy 4 . ( (a ) The left side of dashed line is the first subsection Sub NCSGs1 as well as its construction process ; ( b ) The left side of dashed line is serialized Sub NCSGs1 and the right side is the second subsection Sub NCSGs2 as well as its construction process ; ( c ) The concatenation of Sub NCSGs1 and SubNCSGs2 and all the MLCS s with red arrows . ) case . Therefore , we must devise a new subsection calculation method to deal with the case . And yet , we cannot use general subsection method to obtain all the MLCS s of the longer sequences in the case because the MLCS s of the sequences are certainly not equal to the connection of the MLCS s of their sub sequences in most cases . For example , we split the sequences S4 = T GACGAT C and S5 = AT CGT CAG into two subsections S41 = T GAC and S51 = AT CG with S42 = GAT C and S52 = T CAG in their subscripts 4 , and all of the MLCS s of the sequences S4 and S5 is not equal to the connection of the MLCS s of the splitted subsections S41 and S51 with S42 and S52 as some dominants from the sequences S4 and S5 are lost in such splitting manner . Hence , how to split these longer sequences to accurately obtain their MLCS s is a non trivial problem , which motivates us to develop a new subsection calculation method to tackle it . We found that as long as all of the dominants are not lost from aligned sequences and the immediate predecessorsuccessor relationships among dominants are preserved in the splitting position , we can solve the non trivial problem efficiently and effectively with our proposed subsection calculation and serialization methods , which are explained with Example 3 and Fig 8 .
Example 3 : With Strategy 4 , find out all of the MLCS s of the sequences S4 = T GACGAT C and S5 = AT CGT CAG . For the sake of generality , suppose we split the sequences S4 and S5 into two subsections in their subscripts 6 on the premise of no loss of dominants of the two sequences . To this end , we first split the dominants those all their coordinates are less than or equal to 6 in the NCSG of the
1731 sequences to the first subsection , otherwise to the second subsection . Therefore , call function OptCalReusing2 ( ) ( not function OptCalReusing1 ( ) , as no dominant is lost from the first subsection ) , we can construct the first subsection subgraph of the NCSG , denoted as Sub NCSGs1 ( Fig 8(a) ) , and then serialize the constructed Sub NCSGs1 ( left part shown in Fig 8(b ) ) to the disk . Next , we continue constructing the second subsection subgraph Sub NCSGs2 by calling function OptCalReusing1 ( ) ( right part shown in Fig 8(b) ) . To find all of the MLCS s of the sequences S4 and S5 , we first backward sort the Sub NCSGs2 by Algorithm BackwardSortTop . Secondly , we deserialize the Sub NCSGs1 and perform SubNCSGs1 = Sub NCSGs1 ∪ Sub NCSGs2 shown in Fig 8(c ) , and then continue backward sorting the Sub NCSGs1 by Algorithm BackwardSortTop , after which all of the MLCS s of the sequences S4 and S5 are obtained ( denoted as red arrows shown in Fig 8(c) ) .
Remark : As discussed in Strategy 4 , for the longer sequences , their NCSG will be too large to be stored and calculated in memory resulting in the leading dominant pointbased MLCS algorithms’ failure . To tackle the challenges , we propose Strategy 4 by splitting the NCSG of the sequences into subsections . Experimental results justify that the memory overflow for large NCSG has been well avoided by Strategy 4 as expected . More interestingly , the efficiency is also improved due to the strategy . For instance , given |Σ| = 20 with length 300 of 5 aligned sequences , the running time of our algorithm is 3.449s , 1.969s , 1.807s and 0.846s , respectively , if the number of the splitting subsections for the aligned sequences is 2 , 3 , 4 and 5 , respectively . Such an interesting phenomenon results from the following facts . Firstly , with algorithm ForwardSortTop for an arbitrary subsection , many useless edges will be eliminated ( see Fig 4 ) . eg , with algorithm ForwardSortTop , the edges ( 0 , 0 , 0 ) → ( 2 , 3 , 4 ) , ( 4 , 4 , 1 ) → ( 8 , 6 , 7 ) etc . , shown in Fig 3 , have been deleted ) , which saves much time in BackwardSortTop performed afterwards . Secondly , as the number of subsections increases , not only the number of deleted edges increases but also the effect of concurrent execution amplifies , both of which lead to a significant decrease in running time . Notably , although the increase in the number of subsections may lead to additional serialization and deserialization operations , the running time of these operations is in fact negligible comparing to that of ForwardSortTop and BackwardSortTop for the massive dominants , which has been saved due to Strategy 4 . Strategy 5 : The Multiple Concurrent Execution . Since the optimal subgraph NCSGi of the aligned sequences always contributes to most of the MLCSs , ranging from 75 % to 100 % , we can concurrently construct the non optimal subgraph NCSGj of the non optimal dominants with the reuse of intermediate results of the optimal subgraph NCSGi available ( called multiple concurrent execution ) so as to further improve the efficiency of the proposed algorithm .
4.2 A Novel Parallel MLCS Algorithm
For large scale and big sequences alignments , based on the above strategies , we present a novel efficient parallel MLCS algorithm RLP MLCS , which is shown in Algorithm 1 . Notably , on one hand , all the primary procedures of our algorithm , the construction of NCSG of aligned sequences , a forward and a backward topological sorting to the NCSG , are run in parallel . On the other hand , the parallel efficiency of our algorithm with Strategies 4 and 5 is further enhanced
Algorithm 1 RLP MLCS({S1 , S2 , , Sd} , Σ , StepLength ) 1 : Build Successor Tables {ST1 , ST2 , , STd} of sequences set T =
Construct NCSG of the T with OptCalReusing1 ( ) in parallel Output all the MLCS s of the T
/∗ |Si| = n ∗/
{S1 , S2 , , Sd} in parallel 2 : if StepLength > n then : 3 : 4 : 5 : end if 6 : return 7 : Split the sequences into N subsections in StepLength 8 : for i ← 1 to N 1 do : 9 :
Construct the subgraph Sub NCSGsi of the T with OptCalReusing2 ( )6and Strategy 5 Serialize Sub NCSGsi to the disk
10 : 11 : end for 12 : Construct the subgraph Sub NCSGsN of the T with OptCal
Reusing2 ( ) and Strategy 5
13 : Backward sort Sub NCSGsN with Algorithm BackwardSortTop in parallel to obtain its optimized Sub NCSGsN
14 : for i ← N − 1 to 1 do : 15 : 16 : 17 :
Deserialize Sub NCSGsi Sub NCSGsi ← Sub NCSGsi ∪ the optimized NCSGsi+1 Backward sort Sub NCSGsi by Algorithm BackwardSortTop in parallel to get its optimized Sub NCSGsi
18 : end for 19 : Output all of the MLCS s of the T 20 : return and enlarged . To the best of our knowledge , we are the first to present a parallel MLCS algorithm in this manner . For lack of space , we give the framework of our algorithm .
4.3 Analysis of Time and Space Complexities The time complexity of our algorithm in every stage is given first , followed by the total time complexity .
For each sequence Sl of T over alphabet Σ with length n , O(|Σ|n ) time is required for constructing its successor table STl by Eq 3 . Therefore , the time complexity of serially constructing d sequences is O(d|Σ|n ) . The main operations of serially constructing the NCSG consist of establishing the predecessor successor relationship among dominants and computing the in degree of each point of the NCSG . Therefore , the time complexity of serially constructing the NCSG should be O(|E| ) , where |E| is the number of edges in the NCSG . Given the points set V of the NCSG , since both forward and backward topological sorting need to traverse every point in V , both the forward and backward topological sorting take the time O(|V | ) .
As a result , the total serial time complexity of RLP MLCS is O(d|Σ|n ) + O(|E| ) + 2O(|V | ) . Since theoretical analysis and experimental results show that O(d|Σ|n ) ≪ O(|E| ) + 2O(|V | ) , thus , O(d|Σ|n + |E| + |V | ) ≈ O(|E| + |V | ) . Moreover , with O(|E| ) being of the same order as that of O(|V | ) and |E| is at most several times of |V | , the time complexO(|V | ) + Tcom , where Tcom is the ity of RLP MLCS is communication overhead of the parallel execution algorithm RLP MLCS and Np is the number of threads . From the above discussion , we can see that the time complexity of RLP MLCS is linear in |V | . It is important to note that |V | should be replaced with |K| + |Vsi| with subsection calculation of our proposed algorithm , where |K| is the total number of the key points on the NCSG , and |Vsi| is the total number of the dominants on a subsection subgraph Sub
1 Np
6
D1 in Step 2 ) are the dominants with the minimal coordinates in each subsection , such as the left most dominants on the right part of dashed line shown in Fig 8(a ) ; in Step 4 ) after the forward sorting , we need to update the number of levels for dominants by adding those of their immediate predecessors .
1732 NCSGsi of the aligned sequences ( as the above discussion , we can see that |K| + |Vsi| ≪ |V | ) .
Similarly , the storage space of successor tables is O(d|Σ|n ) , the storage space of the NCSG is O(d|V | + |E| ) , and the space complexity of RLP MLCS is O(d|Σ|n + d|V | + |E| ) ≈ O(|V | + |E| ) = O(|V | ) ( given d aligned sequences , d is a constant ) . Similar to the analysis in time complexity , with subsection calculation , the space complexity of RLP MLCS should be O(|K| + |Vsi| ) .
Notably , the state of the art dominant point based MLCS algorithms , FAST MLCS [ 2 ] with effective pruning techniques and Quick DPPAR [ 16 ] with a fast divide and conquer technique in the calculation of the dominants , were claimed to be efficient . However , both the algorithms FAST MLCS and Quick DPPAR do not eliminate the inherent defects of the general dominant point based MLCS algorithms ( see Section 3 ) . The claimed linear time complexity O(|MLCS| ) without considering the time of computing dominants is not reasonable for FAST MLCS , while the time complexity of Quick DPPAR , 1/Np(1 + α(n))O(n|Σ|d + |D||Σ|d(logd−2 n + logd−2|Σ|) ) , where limn→∞ α(n ) = 0 , is obviously non linear , as |D| is the number of the vertices of MLCS DAG which is much larger than |V | of NCSG . Thus the complexities of time and space for our proposed algorithm are much lower than those of FAST MLCS and Quick DPPAR .
5 . EXPERIMENTAL RESULTS
In experiments , all the algorithms ( FAST LCS , QuickDPPAR and the proposed RLP MLCS ) were run on Inspur Corporation K1 800 high performance key host ( Intel Xeon E7 8870 , 4 chip , 4 cores/chip , 2 threads/core , 2.80 GHz and 1TB RAM ) in the High Performance Computing Center of Xidian University , written in Java with JDK 1.7 and tested on the benchmark datasets provided by real biological sequences datasets ncbi7 and dip8 , as well as a set of synthetic sequences randomly drawn from alphabets of the DNA and amino acid , wherein ten groups of real biological sequences and synthetic sequences are randomly selected from the datasets , respectively , and each group consists of 5 or d sequences . We tested the algorithms 10 times on the above 20 groups of benchmark datasets . Notably , the result MLCS s are consistent over all the algorithms as long as the algorithms finish without exception9 . Therefore , we focus on the comparison in efficiency and report the average running times over 10 runs in milliseconds ( ms ) .
Firstly , we test the performance of our parallel algorithm
RLP MLCS and compare it with the state of the art dominantpoint based parallel FAST LCS [ 2 ] and Quick DPPAR [ 16 ] algorithms ( these algorithms were reported to have been implemented in corresponding literature and run on the same hardware platform ) . Due to space limit , only parts of the experimental results are shown in Table 2 and Table 3 , respectively , where ‘+’ stands for the memory overflow such that the algorithm fails in the corresponding case .
Table 2 shows that the time performance of the proposed parallel RLP MLCS algorithm is superior to that of the other two competitors , reaching up to 2−3 orders of magnitude faster for long sequences . For example , the running time of our algorithm RLP MLCS shown in Table 2 is in aver
7
8
9 http://wwwncbinlmnihgov/nuccore/110645304?report=fasta http://dipdoe mbiuclaedu/dip/Downloadcgi As shown in Table 2 and 3 , in many cases , FAST LCS , Quick
DPPAR will run out of memory .
Table 2 : The running times of FAST LCS ( A1 ) , Quick DPPAR ( A2 ) and RLP MLCS ( A3 ) for 5 sequences with various lengths on 32 threads and step length 100 .
|Si|
50 75 100 140 180 220 300 400 500 1000 1500 2000 2500 3000 3500 4000 4500
|Σ| = 4
A1(ms ) A2(ms )
A3(ms )
353 1640 11107 121450 1335962
241 1323 8018 92936
1205232
+ + + + + + + + + + + +
+ + + + + + + + + + + +
56 143 328 1109 10480 23097 52560 85071 167848 629676 1038030 5218596 9126758 13703431 18158274 22083068 27080701
|Si|
50 100 140 180 220 260 300 340 400 600 800 1000 2000 3000 4000 5000 6000
|Σ| = 20
A1(ms ) A2(ms ) A3(ms )
46
1047 6749 28875 97021 355323 984187 3739639
37 682 2137 17886 59604 296465 865325 2567178
+ + + + + + + + +
+ + + + + + + + +
23 98 239 547 1769 2839 3796 9987 19844 73792 107890 214610 571363 703337 931582 1008042 1138462
1 |Si| : length of sequences
Table 3 : The running times of FAST LCS ( A1 ) , Quick DPPAR ( A2 ) and RLP MLCS ( A3 ) for d sequences with lengths 100 and 250 , on 32 threads with step lengths 100 and 250 , respectively . d
3 4 5 6 7 8 9 10 50 100 200 400 600 800 1000
|Si| = 100 and |Σ| = 4
A1(ms ) A2(ms ) A3(ms )
237 1818 32394 985023
196 2631 30211 653235
+ + + + + + + + + + +
+ + + + + + + + + + +
87 198 338 3620 10927 31532 54676 103598 189629 62526 17275 13560 11532 9645 8092 d
3 4 5 6 7 8 9 10 50 100 200 400 600 800 1000
1 |Si| : length of sequences 2 d : number of sequences
|Si| = 250 and |Σ| = 20
A1(ms ) A2(ms ) A3(ms )
2042 28745 879434 9573349
1526 21241 624429 7451484
+ + + + + + + + + + +
+ + + + + + + + + + +
237 953 2753 19688 69440 187688 420122 861038 17925 5536 2132 1074 537 398 286 age 58 times / 47 times shorter than that of the algorithm FAST LCS ( ranging from 6 − 127 times / 4 − 115 times ) , and 113 times / 84 times shorter than that of the algorithm Quick DPPAR ( ranging from 2 − 374 times / 2 − 257 times ) in different |Σ| individually . Moreover , with the increasing length of aligned sequences , the advantage of RLP MLCS in time performance is even more obvious compared with algorithms FAST LCS and Quick DPPAR . Obviously , Table 2 shows that our algorithm RLP MLCS is not only vastly superior to the algorithms FAST LCS and Quick DPPAR , but also is more practical to longer sequences alignments .
As discussed above , thanks to the well designed strategies adopted in RLP MLCS , we have eliminated redundant dominants , got rid of dimension by dimension comparisons of dominants , and saved much storage space compared with the state of the art competitors . Table 3 reveals that these advantages of our algorithm RLP MLCS get more obvious as the number of sequences alignments is increased , eg , for the different |Σ| , when testing on 6 sequences with the lengths of 100 ( resp . , 250 ) individually , the running time of RLP MLCS has already been up to 272 ( resp . , 486 ) times better than that of FAST MLCS and 180 ( resp . , 378 ) times better than that of Quick DPPAR . It is a remarkable fact that FAST MLCS and Quick DPPAR cannot work due to memory overflow when the number of aligned sequences is larger than 6 . In comparison , our proposed algorithm RLP MLCS can also run correctly and efficiently even though the number of aligned sequences reaches 1000 . More
1733 over , with the increasing number of aligned sequences , the number of dominants firstly increases and then usually decreases . Thus , the experimental results of our algorithm RLP MLCS shown in Table 3 is reasonable , and the algorithm is very suitable for large scale sequences alignments . In addition , we further evaluated the speedup of our algorithm RLP MLCS by varying the number of threads . Due to space limit , we briefly describe the high level results . The results show that our algorithm RLP MLCS achieves a nearly linear speedup , and that the larger d , n , and |Σ| , the better speedup is .
In a word , the time and space performances of RLP MLCS are not only very superior to the state of the art FAST LCS and Quick DPPAR , but also more practical to longer and large scale or even big sequences alignments .
6 . CONCLUSION
In order to overcome the disadvantages of the leading dominant point based MLCS algorithms and tackle the challenges of longer and large scale aligned sequences , we first present a novel general problem solving model NCSG and series of new strategies , eg , the parallel topological sorting , optimal calculating , reuse of intermediate results , subsection calculation , etc . Based on that , we present a novel real linear and parallel MLCS algorithm RLP MLCS . In addition to the external communication overhead Tcom of parallel execution with Np threads , theoretical study show that the time and space complexities of the proposed algorithm are only linear to and even smaller than the number O(|V | ) + of the dominants from aligned sequences , ie , Tcom and O(|V | ) , respectively . In particular , with subsection calculation of our algorithm , |V | should be replaced by |K| + |Vsi| , where |K| is the total number of the key points on the NCSG , |Vsi| is the total number of the dominants on a subsection subgraph Sub NCSGsi , and |K| + |Vsi| ≪ |V | . Finally , our algorithm is evaluated by comprehensive experiments on datasets of both random synthetic and real biological sequences . The results show that the proposed problem solving model NCSG and the strategies are efficient and effective , and that the proposed algorithm RLP MLCS not only greatly outperforms the leading stateof the art dominant point based parallel MLCS algorithms available , but also is practical for longer and large scale sequences alignments .
1 Np
As part of our future work , we will further improve the efficiency of the proposed algorithm RLP MLCS and explore applications in big sequence analysis .
ACKNOWLEDGMENTS This work was supported by the National Natural Science Foundation of China ( No.61472296 , 61472297 and 61202179 ) and National High Technology Research and Development Program ( 863 Program ) ( Grant No . 2015AA016007 ) .
7 . REFERENCES [ 1 ] A . Apostolico , S . Browne , and C . Guerra . Fast linear space computations of longest common subsequences . Theoretical Computer Science , 92(1):3–17 , 1992 .
[ 2 ] Y . Chen , A . Wan , and W . Liu . A fast parallel algorithm for finding the longest common sequence of multiple biosequences . BMC Bioinformatics , 7(Suppl 4):S4 , 2006 .
[ 3 ] D . S . Hirschberg . A linear space algorithm for computing maximal common subsequences . Communications of the ACM , 18(6):341–343 , 1975 .
[ 4 ] I . L . Hofacker , M . A . Huynen , P . F . Stadler , and P . E .
Stolorz . Knowledge discovery in RNA sequence families of HIV using scalable computers . In KDD , pages 20–25 , 1996 .
[ 5 ] E . Horowitz and S . Sahni . Fundamentals of data structures . Pitman , 1983 .
[ 6 ] W . Hsu and M . Du . Computing a longest common subsequence for a set of strings . BIT Numerical Mathematics , 24(1):45–59 , 1984 .
[ 7 ] J . W . Hunt and T . G . Szymanski . A fast algorithm for computing longest common subsequences . Communications of the ACM , 20(5):350–353 , 1977 .
[ 8 ] G . Ifrim and C . Wiuf . Bounded coordinate descent for biological sequence classification in high dimensional predictor space . In KDD , pages 708–716 , 2011 .
[ 9 ] D . E . Knuth . The Art of Computer Programming , Volume I : Fundamental Algorithms , 2nd Edition . Addison Wesley , 1973 .
[ 10 ] D . Korkin . A new dominant point based parallel algorithm for multiple longest common subsequence problem . Technical report , TR01 148 , Univ . of New Brunswick , 2001 .
[ 11 ] Y . Li , Y . Wang , and L . Bao . Facc : a novel finite automaton based on cloud computing for the multiple longest common subsequences search . Mathematical Problems in Engineering , 2012 , 2012 .
[ 12 ] M . Lu and H . Lin . Parallel algorithms for the longest common subsequence problem . IEEE Transactions on Parallel and Distributed Systems , 5(8):835–848 , 1994 .
[ 13 ] D . Maier . The complexity of some problems on subsequences and supersequences . Journal of the ACM ( JACM ) , 25(2):322–336 , Apr . 1978 .
[ 14 ] W . J . Masek and M . S . Paterson . A faster algorithm computing string edit distances . Journal of Computer and System Sciences , 20(1):18–31 , 1980 .
[ 15 ] D . Sankoff . Matching sequences under deletion/insertion constraints . Proceedings of the National Academy of Sciences , 69(1):4–6 , 1972 .
[ 16 ] Q . Wang , D . Korkin , and Y . Shang . A fast multiple longest common subsequence ( MLCS ) algorithm . Knowledge and Data Engineering , IEEE Transactions on , 23(3):321–334 , 2011 .
[ 17 ] J . Yang , Y . Xu , and Y . Shang . An efficient parallel algorithm for longest common subsequence problem on GPUs . In Proceedings of the World Congress on Engineering , volume 1 , pages 499–504 , 2010 .
[ 18 ] J . Yang , Y . Xu , G . Sun , and Y . Shang . A new progressive algorithm for a multiple longest common subsequences problem and its efficient parallelization . IEEE Transactions on Parallel and Distributed Systems , 24(5):862–870 , 2013 .
[ 19 ] T . K . Yap , O . Frieder , and R . L . Martino . Parallel computation in biological sequence analysis . IEEE Transactions on Parallel and Distributed Systems , 9(3):283–294 , 1998 .
[ 20 ] M . Zvelebil and J . Baum . Understanding bioinformatics . Garland Science , 2007 .
1734
