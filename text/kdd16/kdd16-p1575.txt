SQUISH : Near Optimal Compression for Archival of
Relational Datasets
University of Illinois at Urbana Champaign
University of Illinois at Urbana Champaign
Aditya Parameswaran
Urbana , Illinois adityagp@illinois.com
Yihan Gao
Urbana , Illinois ygao34@illinois.com
ABSTRACT Relational datasets are being generated at an alarmingly rapid rate across organizations and industries . Compressing these datasets could significantly reduce storage and archival costs . Traditional compression algorithms , eg , gzip , are suboptimal for compressing relational datasets since they ignore the table structure and relationships between attributes .
We study compression algorithms that leverage the relational structure to compress datasets to a much greater extent . We develop SQUISH , a system that uses a combination of Bayesian Networks and Arithmetic Coding to capture multiple kinds of dependencies among attributes and achieve near entropy compression rate . SQUISH also supports user defined attributes : users can instantiate new data types by simply implementing five functions for a new class interface . We prove the asymptotic optimality of our compression algorithm and conduct experiments to show the effectiveness of our system : SQUISH achieves a reduction of over 50 % in storage size relative to systems developed in prior work on a variety of real datasets .
1 .
INTRODUCTION
From social media interactions , commercial transactions , to scientific observations and the internet of things , relational datasets are being generated at an alarming rate . With these datasets , that are either costly or impossible to regenerate , there is a need for periodic archival , for a variety of purposes , including long term analysis or machine learning , historical or legal factors , or public or private access over a network . Thus , despite the declining costs of storage , compression of relational datasets is still important , and will stay important in the coming future .
One may wonder if compression of datasets is a solved problem . Indeed , there has been a variety of robust algorithms like LempelZiv [ 21 ] , WAH [ 20 ] , and CTW [ 17 ] developed and used widely for data compression . However , these algorithms do not exploit the relational structure of the datasets : attributes are often correlated or dependent on each other , and identifying and exploiting such correlations can lead to significant reductions in storage . In fact , there are many types of dependencies between attributes in a relational dataset . For example , attributes could be functionally dependent on other attributes [ 3 ] , or the dataset could consist of several clusters of tuples , such that all the tuples within each cluster are similar to each other [ 8 ] . The skewness of numerical attributes is another important source of redundancy that is overlooked by algorithms like Lempel Ziv [ 21 ] : by designing encoding schemes based on the distribution of attributes , we can achieve much better compression rate than storing the attributes using binary/float number format .
There has been some limited work on compression of relational datasets , all in the recent past [ 3 , 6 , 8 , 12 ] . In contrast with this line of prior work , SQUISH uses a combination of Bayesian Networks coupled with Arithmetic Coding [ 19 ] . Arithmetic Coding is a coding scheme designed for sequence of characters . It requires an order among characters and probability distributions of characters conditioned on all preceding ones . Incidentally , Bayesian Networks fulfill both requirements : the acyclic property of Bayesian Network provides us an order ( ie , the topological order ) , and the conditional probability distributions are also specified in the model . Therefore , Bayesian Networks and Arithmetic Coding are a perfect fit for relational dataset compression .
However , there are several challenges in using Bayesian Networks and Arithmetic Coding for compression . First , we need to identify a new objective function for learning a Bayesian Network , since conventional objectives like Bayesian Information Criterion [ 15 ] are not designed to minimize the size of the compressed dataset . Another challenge is to design a mechanism to support attributes with an infinite range ( eg , numerical and string attributes ) , since Arithmetic Coding assumes a finite alphabet for symbols , and therefore cannot be applied to those attributes . To be applicable to the wide variety of real world datasets , it is essential to be able to handle numbers and strings .
We deal with these challenges in developing SQUISH . As we show in this paper , the compression rate of SQUISH is near optimal for all datasets that can be efficiently described using a Bayesian Network . This theoretical optimality reflects in our experiments as well : SQUISH achieves a reduction in storage on real datasets of over 50 % compared to the nearest competitor . The reason behind this significant improvement is that most prior papers use suboptimal techniques for compression .
In addition to being more effective at compression of relational datasets than prior work , SQUISH is also more powerful . To demonstrate that , we identify the following desiderata for a relational dataset compression system : • Attribute Correlations ( AC ) . A relational dataset compression • Lossless and Lossy Compression ( LC ) . A relational dataset compression system must be general enough to admit a user specified error tolerance , and be able to generate a compressed dataset system must be able to capture correlations across attributes .
1575 in a lossy fashion , while respecting the error tolerance , further saving on storage . • Numerical Attributes ( NA ) . In addition to string and categorical attributes , a relational dataset compression system must be able to capture numerical attributes , that are especially common in scientific datasets . • User defined Attributes ( UDA ) . A relational dataset compression system must be able to admit new types of attributes that do not fit into either string , numerical , or categorical types . In contrast to prior work [ 3 , 6 , 8 , 12]—see Table 1—our system , SQUISH , can capture all of these desiderata . To support UDA ( User Defined Attributes ) , SQUISH surfaces a new class interface , called the SQUID ( short for SQUISH Interface for Data types ) : users can instantiate new data types by simply implementing the required five functions . This interface is remarkably powerful , especially for datasets in specialized domains . For example , a new data type corresponding to genome sequence data can be implemented by a user using a few hundred lines of code . By encoding domain knowledge into the data type definition , we can achieve a significant higher compression rate than using “ universal ” compression algorithms like Lempel Ziv [ 21 ] .
System SQUISH
Spartan [ 3 ]
ItCompress [ 8 ]
Davies and Moore [ 6 ] Raman and Swart [ 12 ]
AC NA LC UDA Y Y Y Y N
Y Y Y N N
Y Y Y N N
Y N N N N
Table 1 : Features of Our System contrasted with Prior Work
The rest of this paper is organized as follows . In Section 2 , we formally define the problem of relational dataset compression , and briefly explain the concepts of Arithmetic Coding . In Section 3 we discuss Bayesian Network learning and related issues , while details about Arithmetic Coding are discussed in Section 4 . In Section 5 , we prove the asymptotic optimality of the compression algorithm . In Section 6 , we conduct experiments to compare SQUISH with prior systems and evaluate its running time and parameter sensitivity . We describe related work in Section 7 . All our proofs can be found in our technical report [ 7 ] , along with a brief review of Bayesian Networks and illustrative examples of our compression algorithm .
The source code of SQUISH is available on GitHub : https://gith ub.com/Preparation Publication BD2K/db_compress
2 . PRELIMINARIES In this section , we define our problem more formally , and provide some background on Arithmetic Coding . 2.1 Problem Definition
We follow the same problem definition proposed by Babu et al . [ 3 ] . Suppose our dataset consists of a single relational table T , with n rows and m columns ( our techniques extend to multirelational case as well ) . Each row of the table is referred to as a tuple and each column of the table is referred to as an attribute . We assume that each attribute has an associated domain that is known to us . For instance , this information could be described when the table schema is specified .
The goal is to design a compression algorithm A and a decompression algorithm B , such that A takes T as input and outputs a compressed file C(T ) , and B takes the compressed file C(T ) as input and outputs T as the approximate reconstruction of T . The i| ≤ i , where ti and t goal is to minimize the file size of C(T ) while ensuring that the recovered T is close enough to T . The closeness constraint of T to T is defined as follows : For each numerical attribute i , for each tuple t and the recovered tuple t , |ti−t i are the values of attribute i of tuple t and t respectively , and i is error threshold parameter provided by the user . For non numerical attributes , the recovered attribute value must be exactly the same as the original one : ti = t i . Note that this definition subsumes lossless compression as a special case with i = 0 . 2.2 Arithmetic Coding
Arithmetic coding [ 19 , 11 ] is a state of the art adaptive compression algorithm for a sequence of dependent characters . Arithmetic coding assumes as a given a conditional probability distribution model for any character , conditioned on all preceding characters . If the sequence of characters are indeed generated from the probabilistic model , then arithmetic coding can achieve a near entropy compression rate [ 11 ] . Formally , arithmetic coding is defined by a finite ordered alphabet A , and a probabilistic model for a sequence of characters that specifies the probability distribution of each character Xk conditioned on all precedent characters X1 , . . . , Xk−1 . Let {an} be any string of length n . To compute the encoded string for {an} , we first compute a probability interval for each character ak :
[ lk , rk ] =[p(Xk < ak|X1 = a1 , . . . , Xk−1 = ak−1 ) , p(Xk ≤ ak|X1 = a1 , . . . , Xk−1 = ak−1 ) ]
We define the product of two probability interval as :
[ l1 , r1 ] ◦ [ l2 , r2 ] = [ l1 + ( r1 − l1)l2 , l1 + ( r1 − l1)r2 ]
The probability interval for string {an} is the product of proba bility intervals of all the characters in the string :
[ l , r ] = [ l1 , r1 ] ◦ [ l2 , r2 ] ◦ . . . ◦ [ ln , rn ]
Let k be the smallest integer such that there exists a non negative integer 0 ≤ M < 2k satisfying : l ≤ 2
−kM , r ≥ 2
−k(M + 1 )
Then the k bit binary representation of M is the encoded bit string of {an} .
An example to illustrate how arithmetic coding works can be found in Figure 1 . The three tables at the right hand side specify the probability distribution of the string a1a2a3 . The blocks at the left hand show the associated probability intervals for the strings : for example , “ aba ” corresponds to [ 0.12 , 0.204 ] = [ 0 , 0.4 ] ◦ [ 0.3 , 1 ] ◦ [ 0 , 03 ] As we can see , the intuition of arithmetic aoding is to map each possible string {an} to disjoint probability intervals . By using these probability intervals to construct encoded strings , we can make sure that no code word is a prefix of another code word . Notice that the length of the product of probability intervals is exactly the product of their lengths . Therefore , the length of each probability interval is exactly the same as the probability of the corresponding string Pr({an} ) . Using this result , the length of encoded string can be bounded as follows : len(binary_code({an} ) ) ≤ − log2 Pr({an} ) + 2
3 . STRUCTURE LEARNING
The overall workflow of SQUISH is illustrated in Figure 2 . SQUISH uses a combination of Bayesian networks and arithmetic coding for
1576 Figure 1 : Arithmetic Coding Example negative log likelihood , BIC [ 15] ) . These algorithms usually have two separate components [ 9 ] : • A combinatorial optimization component that searches for a • A score evaluation component that evaluates the objective func graph with optimal structure . tion given a graph structure . The two components above are independent in many algorithms . In that case , we can modify an existing Bayesian network learning algorithm by changing the score evaluation component , while still using the same combinatorial optimization component . In other words , for any objective function , as long as we can efficiently evaluate it based on a fixed graph structure , we can modify existing Bayesian network learning algorithms to optimize it .
In this section , we derive a new objective function for learning a Bayesian network that minimizes the size of compressed dataset . We show that the new objective function can be evaluated efficiently given the structure graph . Therefore existing Bayesian Network learning algorithms can be used to optimize it . Suppose our dataset D consists of n tuples , and each tuple ti contains m attributes ai1 , ai2 , . . . , aim . Let B be a Bayesian network that describes a joint probability distribution over the attributes . Clearly , B contains m nodes , each corresponding to an attribute . The total description length of D using B is S(D|B ) = S(B ) + S(Tuples|B ) , where S(B ) is the size of description file of B , and S(Tuples|B ) is the total length of encoded binary strings of tuples using arithmetic coding . For the model description length S(B ) , we i=1 S(Mi ) , where m is the number of attributes in our dataset , and M1 , . . . ,Mm are the models for each attribute in B . The expression S(Tuples|B ) is just the sum of the S(ti|B)s ( the lengthes of the encoded binary string for each ti ) . We have the following decomposition of S(ti|B ) : have S(B ) = m
S(ti|B ) ≈ − m − m j=1 j=1 log2 Pr(aij|parent(aij),Mj ) num(aij ) log2 j + const where parent(aij ) is the set of parent attributes of aij in B , num(a ) is the indicator function of whether a is a numerical attribute or not , and j is the maximum tolerable error for attribute aij . We will justify this decomposition in Section 3.3 , after we introduce the encoding scheme for numerical attributes . Therefore , the total description length S(D|B ) can be decom posed as follows :
S(D|B ) ≈ m
[ S(Mj ) − m ti∈DB j=1
− n( j=1 num(aj ) log2 j + const ) log2 Pr(aij|parent(aij),Mj ) ]
Figure 2 : Workflow of the Compression and Decompression Algorithm compression . The workflow of the compression algorithm is the following :
1 . Learn a Bayesian network structure from the dataset , which captures the dependencies between attributes in the structure graph , and models the conditional probability distribution of each attribute conditioned on all the parent attributes .
2 . Apply arithmetic coding to compress the dataset , using the
Bayesian network as probabilistic models .
3 . Concatenate the model description file ( describing the Bayesian network model ) and compressed dataset file .
In this section , we focus on the first step of this workflow . We focus on the remaining steps ( along with decompression ) in Section 4 .
Although the problem of Bayesian network learning has been extensively studied in literature [ 9 ] , conventional objectives like Bayesian Information Criterion ( BIC ) [ 15 ] are suboptimal for the purpose of compressing datasets . In Section 3.1 , we derive the correct objective function for learning a Bayesian network that minimizes the size of the compressed dataset and explain how to modify existing Bayesian network learning algorithms to optimize this objective function .
The general idea about how to apply arithmetic coding on a Bayesian network is straightforward : since the graph encoding the structure of a Bayesian Network is acyclic , we can use any topological order of attributes and treat the attribute values as the sequence of symbols in arithmetic coding . However , arithmetic coding does not naturally apply to non categorical attributes . In Section 3.2 , we introduce SQUID , the mechanism for supporting non categorical and arbitrary user defined attribute types in SQUISH . SQUID is the interface for every attribute type in SQUISH , and example SQUIDs for categorical , numerical and string attributes are demonstrated in Section 3.3 to illustrate the wide applicability of this interface . We describe the SQUID API in Section 34 3.1 Learning a Bayesian Network : The Basics Many Bayesian network learning algorithms search for the optimal Bayesian network by minimizing some objective function ( eg ,
1577 Note that the term in the second line does not depend on either B or Mi . Therefore we only need to optimize the first summation . We denote each term in the first summation on the right hand side as objj : objj = S(Mj ) − ti∈DB log Pr(aij|parent(aij),Mj )
For each objj , if the network structure ( ie , parent(aij ) ) is fixed , then objj only depends on Mj . In that case , optimizing S(D|B ) is equivalent to optimizing each objj individually . In other words , if we fix the Bayesian network structure in advance , then the parameters of each model can be learned separately . Optimizing objj on Mj is exactly the same as maximizing likelihood . For many models , a closed form solution for identifying maximum likelihood parameters exists . In such cases , the optimal Mj can be quickly determined and the objective function S(D|B ) can be computed efficiently . Structure Learning In general , searching for the optimal Bayesian network structure is NP hard [ 9 ] . In SQUISH , we implemented a simple greedy algorithm for this task . The algorithm starts with an empty seed set , and repeatedly finds new attributes with the lowest objj , and adds these new attributes to the seed set . The pseudo code can be found in our technical report [ 7 ] .
The greedy algorithm has a worst case time complexity of O(m4n ) where m is the number of columns and n is the number of tuples in the dataset . For large datasets , even this simple greedy algorithm is not fast enough . However , note that the objective values objj are only used to compare different models . So we do not require exact values for them , and some rough estimation would be sufficient . Therefore , we can use only a subset of data for the structure learning to improve efficiency . 3.2 Supporting Complex Attributes Encoding and Decoding Complex Attributes Before applying arithmetic coding on a Bayesian network to compress the dataset as we stated earlier , there are two issues that we need to address first :
• Arithmetic Coding requires a finite alphabet for each symbol . However , it is natural for attributes in a dataset to have infinite range ( eg , numerical attributes , strings ) .
• In order to support user defined data types , we need to allow the user to specify a probability distribution over an unknown data type .
To address these difficulties , we introduce the concept of SQUID , short for SQUISH Interface for Data types . A SQUID is a ( possibly infinite ) decision tree [ 18 ] with non negative probabilities associated with edges in the tree , such that for every node v , the probabilities of all the edges connecting v and v ’s children sum to one .
Figure 3 : SQUID Example
Figure 3 shows an example infinite SQUID for a positive numerical attribute X . As we can see , each edge is associated with a decision rule and a non negative probability . For each non leaf node v2k−1 , the decision rules on the edges between v2k−1 and its children v2k and v2k+1 are x ≤ k and x > k respectively . Note that these two decision rules do not overlap with each other and covers all the possibilities . The probabilities associated with these two rules sum to 1 , which is required in SQUID . This SQUID describes the following probability distribution over X : Pr(X ∈ ( k − 1 , k ] ) = 0.9k−1 × 0.1
In Section 4 , we will show that we can encode or decode an attribute using Arithmetic Coding if the probability distribution of this attribute can be represented by a SQUID .
As shown in Figure 3 , a SQUID naturally controls the maximum tolerable error in a lossy compression setting . Each leaf node v corresponds to a subset Av of attribute values such that for every a ∈ Av , if we start from the root and traverse down according to the decision rules , we will eventually reach v . As an example , in Figure 3 , for each leaf node v2k we have Av2k = ( k − 1 , k ] . Let av be the representative attribute value of a leaf node v , then the maximum possible recovery error for v is : v = sup a∈Av distance(a , av )
Let Ti be the SQUID corresponding to the ith attribute . As long as for every v ∈ Ti , v is less than or equal to the maximum tolerable error i , we can satisfy the closeness constraint ( defined in Section 21 ) Using User defined Attributes as Predictors
To allow user defined attributes to be used as predictors for other attributes , we introduce the concept of attribute interpreters , which translate attributes into either categorical or numerical values . In this way , these attributes can be used as predictors for other attributes .
The attribute interpreters can also be used to capture the essential features of an attribute . For example , a numerical attribute could have a categorical interpreter that better captures the internal meaning of the attribute . This process is similar to the feature extraction procedure in many data mining applications , and may improve compression rate . 3.3 Example SQUIDs
In SQUISH , we have implemented models for three primitive data types . We intended these models to both illustrate how SQUIDs can be used to define probability distributions , and also to cover most of the basic data types , so the system can be used directly by casual users without writing any code . We implemented models for the following types of attributes : • Categorical attributes with finite range . • Numerical attributes , either integer or float number . • String attributes Categorical Attributes
The distribution over a categorical attributes can be represented using a trivial one depth SQUID . Numerical Attributes
For a numerical attribute , we construct the SQUID using the idea of bisection . Each node v is marked with an upper bound vr and a lower bound vl , so that every attribute value in range ( vl , vr ] will pass by v on its path from the root to the corresponding leaf node . Each node has two children and a bisecting point vm , such that the two children have ranges ( vl , vm ] and ( vm , vr ] respectively . The
1578 branching process stops when the range of the interval is less than 2 , where is the maximum tolerable error . Figure 4 shows an example SQUID for numerical attributes .
Figure 4 : SQUID for numerical attributes
Since each node represents a continuous interval , we can compute its probability using the cumulative distribution function . The branching probability of each node is :
( Pr(left branch ) , Pr(right branch ) ) Pr(vl < X ≤ vm ) Pr(vl < X ≤ vr )
Pr(vm < X ≤ vr ) Pr(vl < X ≤ vr )
,
=(
)
Clearly , the average number of bits that is needed to encode a numerical attribute depends on both the probability distribution of the attribute and the maximum tolerable error . The following theorem gives us a lower bound on the average number of bits that is necessary for encoding a numerical attribute ( the proof can be found in our technical report [ 7] ) :
THEOREM 1 . Let X ∈ X ⊆ R be a numerical random variable with continuous support X and probability density function f ( X ) . Let g : X → {0 , 1}∗ be any uniquely decodable encoding function , and h : {0 , 1}∗ → X be any decoding function . If there exists a function ρ : X → R+ such that : ∀x , y ∈ X ,|x−y| < 2 ⇒ |f ( x)−f ( y)| ≤ ρ(x)f ( x)|x−y| ( 1 ) and g , h satisfies the closeness constraint :
∀x ∈ X ,|h(g(x ) ) − x| ≤
Then
EX [ len(g(X) ) ] ≥EX [ − log2 f ( X)]−
EX [ log2(2 ρ(X ) + 1 ) ] − log2 − 2 Furthermore , if g is the bisecting code described above , then
EX [ len(g(X) ) ] ≤EX [ − log2 f ( X ) ] − log2 l+ where l = minv(vr − vl ) is the minimum length of probability
EX [ max(log2 ρ(X ) + log2 l , 0 ) ] + 4 intervals in the tree .
Equation ( 1 ) is a mild assumption that holds for many common probability distributions , including uniform distribution , Gaussian distribution , and Laplace distribution [ 2 ] .
To understand the intuition behind the results in Theorem 1 . Let us consider a Gaussian distribution as an example :
In this case , f ( x|µ , σ ) =
− ( x−µ)2 2σ2 e
√ 1 2π
σ
ρ(x ) =
|x − µ| + 2
σ2
Substituting into the first expression , we have : EX [ len(g(X) ) ] ≥ log2 σ − log2 + log2
√
2 ( |X − µ| + 2 )
EX [ log2(
σ2
2π − 3 2
−
+ 1 ) ]
10 σ ) , the last Note that when is small compared to σ ( eg , < 1 term is approximately zero . Therefore , the number of bits needed to compress X is approximately log2
σ
.
Now consider the second result ,
EX [ len(g(X) ) ] ≤ log2 σ − log2
EX [ max(log2
√ l + log2 2π + 2 l(|X − µ| + 2 )
σ2
7 2
+
, 0 ) ]
Let l = 2 , and when < 1 10 σ , the last term is approximately zero . Comparing the two results , we can see that the bisecting scheme achieves near optimal compression rate .
Theorem 1 can be used to justify the decomposition in Section 31 Recall that we used the following expression as an approximation of len(g(X) ) : len(g(X ) ) ≈ − log2 f ( X ) − log2 + const
Compared to either the upper bound or lower bound in Theorem 1 , the only term we omitted is the term related to ρ(X ) . As we have seen in the Gaussian case , this term is approximately zero when 10 where σ is the standard deviation parameter . The is smaller than σ same conclusion is also true for the Laplace distribution [ 2 ] and the uniform distribution . String Attributes
The SQUID for string attributes can be viewed as having two steps :
1 . determine the length of the string
2 . determine the characters of the string
The length of a string can be viewed as an integer , so we can use exactly the same bisecting rules as for numerical attributes . After that , we use n more steps to determine each character of the string , where n is the string ’s length . The probability distribution of each character can be specified by conventional probabilistic models like the k gram model . 3.4 SQUID API
In SQUISH , SQUID is defined as an abstract class [ 1 ] . There are five functions that are required to be implemented in order to define a new data type using SQUID . These five functions allow the system to interactively explore the SQUID class : initially , the current node pointer is set to the root of SQUID ; each function will either acquire information about the current node , or move the current node pointer to one of its children . Table 2 lists the five functions together with their high level description .
We also develop another abstract class called SQUIDMODEL . A SQUIDMODEL first reads in all the tuples in the dataset , then generates a SQUID instance and an estimation of the objective value objj derived in Section 3.1 : log Pr(aij|parent(aij),Mj ) objj = S(Mj ) − ti∈DB
There are two reasons behind this design : • For a parametric SQUID , the parameters need to be learned using the dataset at hand .
• The Bayesian network learning algorithm requires an estimation of the objective value . Although it is possible to compute the objective value by actually compressing the attributes , in many cases it is much more efficient to approximate it directly .
1579 Function
IsEnd
Table 2 : Functions need to be implemented for SQUID Template
Description
Return whether the current node is a leaf node .
GenerateBranch
Return the number of branches and the probability distribution associated with them .
GetBranch
ChooseBranch
GetResult
Given an attribute value , return which branch does the value belong to .
Set the current node to another node at next level according to the given branch index . If the current node is a leaf node , return the representative attribute value of this node .
SQUIDMODEL requires six functions to be implemented . These functions allow the SQUIDMODEL to iterate over the dataset and generate SQUID instances . The specification of these functions and the psuedo code of their interactions with SQUID can be found in our technical report [ 7 ] .
A SQUIDMODEL instance is initialized with the target attribute and the set of predictor attributes . After that , the model instance will read over all tuples in the dataset and need to decide the optimal choice of parameters . The model also needs to return an estimate of the objective value objj , which will be used in the Bayesian network structure learning algorithm to compare models . Finally , SQUIDMODEL should be able to generate SQUID instances based on parent attribute values .
4 . COMPRESSION AND DECOMPRESSION In this section , we discuss how we can use arithmetic coding correctly for compression and decompression given a Bayesian Network . In Section 4.1 , we discuss implementation details that ensure the correctness of arithmetic coding using finite precision float numbers . In Section 4.2 we describe the decompression algorithm . 4.1 Compression
We use the same notation as in Section 3.1 : a tuple t contains m attributes , and without loss of generality we assume that they follow the topological order of the Bayesian network : t = {a1 , . . . , am} , parent(aj ) ⊆ {a1 , . . . , aj−1}
We first compute a probability interval for each branch in a SQUID .
For each SQUID T , we define PIT as a mapping from branches of T to probability intervals . The definition is similar to the one in Section 2.2 : let v be any non leaf node in T , suppose v has k children u1 , . . . , uk , and the edge between v and ui is associated with probability pi , then PIT ( v → ui ) is defined as :
PI(v → ui ) = [ j<i j≤i
Algorithm 1 shows the pseudo code of the precision aware compression algorithm . We leverage two tricks to deal with the finite precision problem : the classic early bits emission trick [ 10 ] is described in Section 411 ; the new deterministic approximation trick is described in Section 412
Algorithm 1 Encoding Algorithm function ARITHMETICCODING([l1 , r1 ] , . . . , [ ln , rn ] ) code ← ∅ It ← [ 0 , 1 ] for i = 1 to n do
It ← It ff [ li , ri ] while ∃k = 0 or 1 , It ⊆ [ k
2 , k+1 code ← code + k It ← [ 2It.l − k , 2It.r − k ]
2 ] do end while end for Find smallest k such that
∃M , [ 2−kM , 2−k(M + 1 ) ] ⊆ It return code + M end function
411 Early Bits Emission Without loss of generality , suppose
[ L , R ] = [ l1 , r1 ] ◦ [ l2 , r2 ] ◦ . . . ◦ [ ln , rn ]
Define [ Li , Ri ] as the product of first i probability intervals :
[ Li , Ri ] = [ l1 , r1 ] ◦ [ l2 , r2 ] ◦ . . . ◦ [ li , ri ]
If there exist positive integer ki and non negative integer Mi such that
−ki Mi ≤ Li < Ri ≤ 2
−ki ( Mi + 1 )
2
Then the first ki bits of the code string of t must be the binary representation of Mi . Define i , R i ] = [ 2ki Li − Mi , 2ki Ri − Mi ]
[ L pj , pj ]
Then it can be verified that
Now we can compute the probability interval of t . Let Tj be the SQUID for aj conditioned on its parent attributes . Denote the leaf node in Tj that aj corresponds to as vj . Suppose the path from the root of Tj to vj is uj1 → uj2 → . . . → ujkj → vj . Then , the probability interval of tuple t is :
[ L , R ] =PIT1 ( u11 → u12 ) ◦ . . . ◦ PIT1 ( u1k1 → v1)◦
PIT2 ( u21 → u22 ) ◦ . . . ◦ PIT2 ( u2k2 → v2 ) ◦ . . .◦ PITm ( um1 → um2 ) ◦ . . . ◦ PITm ( umkm → vm ) where ◦ is the probability interval multiplication operator defined in Section 22 The code string of tuple t corresponds to the largest subinterval of [ L , R ] of the form [ 2−kM , 2−k(M +1 ) ] as described in Section 22
In practice , we cannot directly compute the final probability interval of a tuple : there could be hundreds of probability intervals in the product , so the result can easily exceed the precision limit of a floating point number . binary_code([L , R ] ) = binary_code(Mi)+ binary_code([L i ] ◦ [ li+1 , ri+1 ] . . . ◦ [ ln , rn ] ) i , R
Therefore , we can immediately output the first ki bits of the code string . After that , we compute the product : i , R i ] ◦ [ li+1 , ri+1 ] . . . ◦ [ ln , rn ]
[ L
We can recursively use the same early bit emitting scheme for this product . In this way , we can greatly reduce the likelihood of precision overflow . 412 Deterministic Approximation For probability intervals containing 0.5 , we cannot emit any bits early . In rare cases , such a probability interval would exceed the precision limit , and the correctness of our algorithm would be compromised .
To address this problem , we introduce the deterministic approximation trick . Recall that the correctness of arithmetic coding relies
1580 on the non overlapping property of the probability intervals . Therefore , we do not need to compute probability intervals with perfect accuracy : the correctness is guaranteed as long as we ensure these probability intervals do not overlap with each other .
Formally , let t1 , t2 be two different tuples , and suppose their probability intervals are :
PI(t1 ) = [ l1 , r1 ] = [ l11 , r11 ] ◦ [ l12 , r12 ] ◦ . . . ◦ [ l1n1 , r1n1 ] PI(t2 ) = [ l2 , r2 ] = [ l21 , r21 ] ◦ [ l22 , r22 ] ◦ . . . ◦ [ l2n2 , r2n2 ] The deterministic approximation trick is to replace ◦ operator with a deterministic operator ff that approximates ◦ and has the following properties :
• For any two probability intervals [ a , b ] and [ c , d ] :
[ a , b ] ff [ c , d ] ⊆ [ a , b ] ◦ [ c , d ]
• For any two probability intervals [ a , b ] and [ c , d ] with b−a ≥ and d − c ≥ . Let [ l , r ] = [ a , b ] ff [ c , d ] , then :
∃k , M , 2
−kM ≤ l < r ≤ 2
−k(M + 1 ) , 2k(r − l ) ≥
In other words , the product computed by ff operator is always a subset of the product computed by ◦ operator , and ff operator always ensures that the product probability interval has length greater than or equal to after emitting bits . The first property guarantees the non overlapping property still holds , and the second property prevents potential precision overflow . As we will see in Section 4.2 , these two properties are sufficient to guarantee the correctness of arithmetic coding . 4.2 Decompression
When decompressing , SQUISH first reads in the dataset schema and all of the model information , and stores them in the main memory . After that , it scans over the compressed dataset , extracts and decodes the binary code strings to recover the original tuples .
Algorithm 2 Decoding Algorithm function DECODER.INITIALIZATION
Ib ← [ 0 , 1 ] It ← [ 0 , 1 ] end function function DECODER.GETNEXTBRANCH(branches ) while not ∃br ∈ branches , Ib ⊆ It ff PI(br ) do
Read in the next bit x Ib ← Ib ◦ [ x 2 , x+1 2 ] end while if Ib ⊆ It ff PI(br ) , br ∈ branches then
It ← It ff PI(br ) while ∃k = 0 or 1 , It ⊆ [ k
2 , k+1 It ← [ 2It.l − k , 2It.r − k ] Ib ← [ 2Ib.r − k , 2Ib.r − k ]
2 ] do end while return br end if end function
Algorithm 2 describes the procedure to decide the next branch . The decoder maintains two probability intervals Ib and It . Ib is the probability interval corresponding to all the bits that the algorithm has read in so far . It is the probability interval corresponding to all decoded attributes . At each step , the algorithm computes the product of It and the probability interval for every possible attribute value , and then checks whether Ib is contained by one of those probability intervals . If so , we can decide the next branch , and update It accordingly . If not , we continue reading in the next bit and update Ib . m
By calling Algorithm 2 repeatedly , we can gradually decode the whole tuple . The full decoding procedure with an illustrative example can be found in our technical report [ 7 ] .
Notice that Algorithm 2 mirrors Algorithm 1 in the way it computes probability interval products . This design is to ensure that the encoding and decoding algorithm always apply the same deterministic approximation that we described in Section 412 The following theorem states the correctness of the algorithm ( the proof can be found in our technical report [ 7] ) :
THEOREM 2 . Let [ l1 , r1 ] , . . . , [ ln , rn ] be probability intervals with ri − li ≥ where is the small constant defined in Section 412 Let s be the output of Algorithm 1 on these probability intervals . Then Algorithm 2 can always determine the correct branch from alternatives using s as input :
PI(Decoder.GetNextBranch(branchi ) ) = [ li , ri ]
5 . DISCUSSION : OPTIMALITY
We can prove that SQUISH achieves asymptotic near optimal compression rate for lossless compression if the dataset only contains categorical attributes and can be described efficiently using a Bayesian network ( the proof can be found in [ 7] ) :
THEOREM 3 . Let a1 , a2 , . . . , am be categorical attributes with joint probability distribution P ( a1 , . . . , am ) that decomposes as
P ( a1 , . . . , am ) =
P ( ai|parenti ) such that i=1 parenti ⊆ {a1 , . . . , ai−1} , card(parenti ) ≤ c
Suppose the dataset D contains n tuples that are iid samples from P . Let M = maxi card(ai ) be the maximum cardinality of attribute range . Then SQUISH can compress D using less than H(D ) + 4n + 32mM c+1 bits on average , where H(D ) is the entropy [ 5 ] of the dataset D .
Thus , when n is large , the difference between the size of the compressed dataset using our system and the entropy1 of D is at most 5n , that is only 5 bits per tuple . This indicates that SQUISH is asymptotically near optimal for this setting . When the dataset D contains numerical attributes , the entropy H(D ) is not defined , and the techniques we used to prove Theorem 3 no longer apply . However , in light of Theorem 1 , it is likely that SQUISH still achieves asymptotic near optimal compression .
6 . EXPERIMENTS
In this section , we evaluate the performance of SQUISH against the state of the art semantic compression algorithms SPARTAN [ 3 ] and ItCompress [ 8 ] ( see Table 1 ) . For reference we also include the performance of gzip [ 21 ] , a well known syntactic compression algorithm .
We use the following four publicly available datasets : • Corel ( http://kddicsuciedu/databases/CorelFeatures ) is a 20 MB dataset containing 68,040 tuples with 32 numerical color histogram attributes .
• Forest Cover ( http://kddicsuciedu/databases/covertype ) is a 75 MB dataset containing 581,000 tuples with 10 numerical and 44 categorical attributes .
1By Shannon ’s source coding theorem [ 5 ] , there is no algorithm that can achieve compression rate higher than entropy .
1581 • Census ( http://thedatawebrmcensusgov/ftp/cps_ftphtml ) is a 610MB dataset containing 676,000 tuples with 36 numerical and 332 categorical attributes .
• Genomes ( ftp://ftp1000genomesebiacuk ) is a 18.2GB dataset containing 1,832,506 tuples with about 10 numerical and 2500 categorical attributes.2
The first three datasets have been used in previous papers [ 3 , 8 ] , and the compression ratio achieved by SPARTAN , ItCompress and gzip on these datasets have been reported in Jagadish et al . ’s work [ 8 ] . We did not reproduce these numbers and only used their reported performance numbers for comparison . For the Census dataset , the previous papers only used a subset of the attributes in the experiments ( 7 categorical attributes and 7 numerical attributes ) . Since we are unaware of the selection criteria of the attributes , we are unable to compare with their algorithms , and we will only report the comparison with gzip .
For the Corel and Forest Cover datasets , we set the error tolerance as a percentage ( 1 % by default ) of the width of the range for numerical attributes as in previous work . For the Census dataset , we set all error tolerance to 0 ( ie the compression is lossless ) . For the Genomes dataset , we set the error tolerance for integer attributes to 0 and float number attributes to 10−8 .
In all experiments , we only used the first 2000 tuples in the structure learning algorithm to improve efficiency . All available tuples are used in other parts of the algorithm . 6.1 Compression Rate Comparison
Figure 5 shows the comparison of compression rate on the Corel and Forest Cover datasets . In these figures , X axis is the error tolerance for numerical attributes ( % of the width of range ) , and Y axis is the compression ratio , defined as follows : compression ratio = data size with compression data size without compression
As we can see from the figures , SQUISH significantly outperforms the other algorithms . When the error tolerance threshold is small ( 0.5% ) , SQUISH achieves about 50 % reduction in compression ratio on the Forest Cover dataset and 75 % reduction on the Corel dataset , compared to the nearest competitor ItCompress ( gzip ) , which applies gzip algorithm on top of the result of ItCompress . The benefit of not using gzip as a post processing step is that we can still permit tuple level access without decompressing a larger unit .
The remarkable superiority of our system in the Corel dataset reflects the advantage of SQUISH in compressing numerical attributes . Numerical attribute compression is known to be a hard problem [ 14 ] and none of the previous systems have effectively addressed it . In contrast , our encoding scheme can leverage the skewness of the distribution and achieve near optimal performance .
Figure 6 shows the comparison of compression rate on the Census and Genomes datasets . Note that in these two datasets , we set the error tolerance threshold to be extremely small , so that the compression is essentially lossless . As we can see , even in the lossless compression scenario , our algorithm still outperforms gzip significantly . Compared to gzip , SQUISH achieves 48 % reduction in compression ratio in Census dataset and 56 % reduction in Genomes dataset . 6.2 Compression Breakdown
2In this dataset , many attributes are optional and these numbers indicate the average number of attributes that appear in each tuple .
( a ) Forest Cover
( b ) Corel
Figure 5 : Error Threshold vs Compression Ratio
Figure 6 : Compression Ratio Comparison
As we have seen in the last section , SQUISH achieved superior compression ratio in all four datasets . In this section , we use detailed case studies to illustrate the reason behind the significant improvement over previous papers . 621 Categorical Attributes In this section , we study the source of the compression in SQUISH for categorical attributes . We will use three different treatments for the categorical attributes and see how much compression is achieved for each of these treatments :
• Domain Code : We replace the categorical attribute values with short binary code strings . Each code string has length ( cid:100)log2 N , where N is the total number of possible categorical values for the attribute . • Column : We ignore the correlations between categorical attributes and treat all the categorical attributes as independent . • Full : We use both the correlations between attributes and the skewness of attribute values in our compression algorithm .
We will use the Genomes and Census dataset here since they consist of mostly categorical attributes . We keep the compression algorithm for numerical attributes unchanged in all treatments . Figure 7 shows the compression ratio of the three treatments :
1582 Figure 7 : Compression Ratio Comparison
As we can see , the compression ratio of the basic domain coding scheme can be improved up to 70 % if we take into account the skewness of the distribution in attribute values . Furthermore , the correlation between attributes is another opportunity for compression , which improved the compression ratio by 50 % in both datasets .
An interesting observation is that the Column treatment achieves comparable compression ratio as gzip in both datasets , which suggests that gzip is in general capable of capturing the skewness of distribution for categorical attributes , but unable to capture the correlation between attributes . 622 Numerical Attributes We now study the source of the compression in SQUISH for numerical attributes . We use the following five treatments for the numerical attributes :
• IEEE Float : We use the IEEE Single Precision Floating Point standard to store all attributes .
• Discrete : Since all attributes in the dataset have value between 0 and 1 , we use integer i to represent a float number in 107 ] , and then store each integer using its 24 bit range [ binary representation . • Column : We ignore the correlation between numerical at
107 , i+1 i tributes and treat all attributes as independent .
• Full : We use both the correlations between attributes and dis tribution information about attribute values .
• Lossy : The same as the Full treatment , but we set the error tolerance at 10−4 instead .
We use the Corel dataset here since it contains only numerical attributes . The error tolerance in all treatments except the last are set to be 10−7 to make sure the comparison is fair ( IEEE single format has precision about 10−7 ) . All the numerical attributes in this dataset are in range [ 0 , 1 ] , with a distribution peaked at 0 . Figure 8 shows the compression ratio of the five treatments .
Figure 8 : Compression Ratio Comparison
As we can see , storing numerical attributes as float numbers instead of strings gives us about 55 % compression . However , the compression rate can be improved by another 50 % if we recognize distributional properties ( ie , range and skewness ) . Utilizing the correlation between attributes in the Corel dataset only slightly improved the compression ratio by 3 % . Finally , we see that the benefit of lossy compression is significant : even though we only reduced the precision from 10−7 to 10−4 , the compression ratio has already been improved by 50 % . 6.3 Running Time
Table 3 lists the running time of the five components in SQUISH . All experiments are performed on a computer with eight3 3.4GHz Intel Xeon processors . For the Genomes dataset , which contains 2500 attributes—an extremely large number—we constructed the Bayesian Network manually . Note that none of the previous papers have been applied on a dataset with the magnitude of the Genomes dataset ( both in number of tuples and number of attributes ) . Table 3 : Running Time of Different Components
Forest Cov .
Genomes
Corel 2.5 sec 15 sec 6 sec 2 sec 7.5 sec
Census 20 min 100 min 6 min 40 sec 6 min
5.5 sec 140 sec 48 sec 7 sec 53 sec
Struct . Learning Param . Tuning Compression Writing to File Decompression As we can see from Table 3 , our compression algorithm scales reasonably : even with the largest dataset Genomes , the compression can still be finished within hours . Recall that since our algorithm is designed for archival not online query processing , and our goal is therefore to minimize storage as much as possible , a few hours for large datasets is adequate .
N/A 40 min 50 min 7 min 50 min
The running time of the parameter tuning component can be greatly reduced if we use only a subset of tuples ( as we did for structure learning ) . The only potential bottleneck is structure learning , which scales badly with respect to the number of attributes ( O(m4) ) . To handle datasets of this scale , another approach is to partition the dataset column wise , and apply the compression algorithm on each partition separately . We plan to investigate this in future work .
We remark that , unlike gzip [ 21 ] , SQUISH allows random access of tuples without decompressing the whole dataset . Therefore , if users only need to access a few tuples in the dataset , then they will only need to decode those tuples , which would require far less time than decoding the whole dataset . 6.4 Sensitivity to Bayesian Network Learning We now investigate the sensitivity of the performance of our algorithm with respect to the Bayesian network learning . We use the Census dataset here since the correlation between attributes in this dataset is stronger than other datasets , so the quality of the Bayesian network can be directly reflected in the compression ratio .
Since our structure learning algorithm only uses a subset of the training data , one might question whether the selection of tuples in the structure learning component would affect the compression ratio . To test this , we run the algorithm for five times , and randomly choose the tuples participating in the structure learning . Table 4 shows the compression ratio of the five runs . As we can see , the variation between runs are insignificant , suggesting that our compression algorithm is robust .
Table 4 : Sensitivity of the Structure Learning
No . of Exp . Comp . Ratio
1
2
3
4
5
0.0460
0.0472
0.0471
0.0468
0.0476
We also study the sensitivity of our algorithm with respect to the number of tuples used for structure learning . Table 5 shows the compression ratio when we use 1000 , 2000 and 5000 tuples in the structure learning algorithm respectively . As we can see , the 3The implementation is single threaded , so only one processor is used .
1583 compression ratio improves gradually as we use more tuples for structure learning .
Number of Tuples
Table 5 : Sensitivity to Number of Tuples 5000 0.0427
2000 0.0460
1000 0.0474
Comp . Ratio
7 . RELATED WORK
Although compression of datasets is a classical research topic in the database research community [ 14 ] , the idea of exploiting attribute correlations ( aka semantic compression ) is relatively new . Babu et al . [ 3 ] used functional dependencies among attributes to avoid storing them explicitly . Jagadish et al . [ 8 ] used a clustering algorithm for tuples . Their compression scheme stores , for each cluster of tuples , a representative tuple and the differences between the representative tuple and other tuples in the cluster . These two types of dependencies are special cases of the more general Bayesian network style dependencies used in this paper .
The idea of applying arithmetic coding on Bayesian networks was first proposed by Davies and Moore [ 6 ] . However , their work only supports categorical attributes ( a simple case ) . Further , the authors did not justify their approach by either theoretically or experimentally comparing their algorithm with other semantic compression algorithms . Lastly , they used conventional BIC [ 15 ] score for learning a Bayesian Network , which is suboptimal , and their technique does not apply to the lossy setting .
The compression algorithm developed by Raman and Swart [ 12 ] used Huffman Coding to compress attributes . Therefore , their work can only be applied to categorical attributes and can not fully utilize attribute correlation ( the authors only mentioned that they can exploit attribute correlations by encoding multiple attributes at once ) . The major contribution of Raman ’s work [ 12 ] is that they formalized the old idea of compressing ordered sequences by storing the difference between adjacent elements , which has been used in search engines to compress inverted indexes [ 4 ] and also in column oriented database systems [ 16 ] .
Bayesian networks are well known general purpose probabilistic models to characterize dependencies between random variables . For reference , the textbook written by Koller and Friedman [ 9 ] covers many recent developments . Arithmetic coding was first introduced by Rissanen [ 13 ] and further developed by Witten et al . [ 19 ] . An introductory paper written by Langdon Jr . [ 10 ] covers most of the basic concepts of Arithmetic Coding , including the early bit emission trick . The deterministic approximation trick is original . Compared to the overflow prevention mechanism in Witten et al . ’s work [ 19 ] , the deterministic approximation trick is simpler and easier to implement .
8 . CONCLUSION
In this paper , we propose SQUISH , an extensible system for compressing relational datasets . SQUISH exploits both correlations between attributes and skewness of numerical attributes , and thereby achieves better compression rates than prior work . We also develop SQUID , an interface for supporting user defined attributes in SQUISH . Users can use SQUID to define new data types by simply implementing a handful of functions . We develop new encoding schemes for numerical attributes using SQUID , and prove its optimality . We also discuss mechanisms for ensuring the correctness of Arithmetic Coding in finite precision systems . We prove the asymptotic optimality of SQUISH on any dataset that can be efficiently described using a Bayesian Network . Experiment results on two real datasets indicate that SQUISH significantly outperforms prior work , achieving more than 50 % reduction in storage .
Acknowledgement We thank the anonymous reviewers for their valuable feedback . We acknowledge support from grant IIS 1513407 awarded by the National Science Foundation , grant 1U54GM114838 awarded by NIGMS and 3U54EB020406 02S1 awarded by NIBIB through funds provided by the trans NIH Big Data to Knowledge ( BD2K ) initiative ( wwwbd2knihgov ) , the Siebel Energy Institute , and the Faculty Research Award provided by Google . The content is solely the responsibility of the authors and does not necessarily represent the official views of the funding agencies and organizations .
9 . REFERENCES [ 1 ] C++ abstract class reference . http://encppreferencecom/w/cpp/language/abstract_class
[ 2 ] M . Abramowitz and I . A . Stegun . Handbook of mathematical functions : with formulas , graphs , and mathematical tables . Number 55 . Courier Corporation , 1964 .
[ 3 ] S . Babu , M . Garofalakis , and R . Rastogi . Spartan : A model based semantic compression system for massive data tables . In ACM SIGMOD Record , volume 30 , pages 283–294 . ACM , 2001 .
[ 4 ] R . Baeza Yates , B . Ribeiro Neto , et al . Modern information retrieval , volume 463 . ACM press New York , 1999 .
[ 5 ] T . M . Cover and J . A . Thomas . Elements of information theory . John
Wiley & Sons , 2006 .
[ 6 ] S . Davies and A . Moore . Bayesian networks for lossless dataset compression . In Proceedings of the fifth ACM SIGKDD international conference on Knowledge discovery and data mining , pages 387–391 . ACM , 1999 .
[ 7 ] Y . Gao and A . Parameswaran . Squish : Near optimal compression for archival of relational datasets . http://arxivorg/abs/160204256 [ 8 ] H . Jagadish , R . T . Ng , B . C . Ooi , and A . Tung . Itcompress : An iterative semantic compression algorithm . In Proceedings of the 20th International Conference on Data Engineering , pages 646–657 . IEEE , 2004 .
[ 9 ] D . Koller and N . Friedman . Probabilistic graphical models : principles and techniques . MIT press , 2009 .
[ 10 ] G . G . Langdon Jr . An introduction to arithmetic coding . IBM Journal of Research and Development , 28(2):135–149 , 1984 .
[ 11 ] D . J . MacKay . Information theory , inference , and learning algorithms , volume 7 . Cambridge university press , 2003 .
[ 12 ] V . Raman and G . Swart . How to wring a table dry : Entropy compression of relations and querying of compressed relations . In Proceedings of the 32nd international conference on Very large data bases , pages 858–869 . VLDB Endowment , 2006 .
[ 13 ] J . Rissanen . Generalized kraft inequality and arithmetic coding . IBM
Journal of research and development , 20(3):198–203 , 1976 .
[ 14 ] M . A . Roth and S . J . Van Horn . Database compression . ACM Sigmod
Record , 22(3):31–39 , 1993 .
[ 15 ] G . Schwarz et al . Estimating the dimension of a model . The annals of statistics , 6(2):461–464 , 1978 .
[ 16 ] M . Stonebraker , D . J . Abadi , A . Batkin , X . Chen , M . Cherniack ,
M . Ferreira , E . Lau , A . Lin , S . Madden , E . O’Neil , et al . C store : a column oriented dbms . In Proceedings of the 31st international conference on Very large data bases , pages 553–564 . VLDB Endowment , 2005 .
[ 17 ] F . M . Willems , Y . M . Shtarkov , and T . J . Tjalkens . The context tree weighting method : basic properties . Information Theory , IEEE Transactions on , 41(3):653–664 , 1995 .
[ 18 ] I . H . Witten and E . Frank . Data Mining : Practical machine learning tools and techniques . Morgan Kaufmann , 2005 .
[ 19 ] I . H . Witten , R . M . Neal , and J . G . Cleary . Arithmetic coding for data compression . Communications of the ACM , 30(6):520–540 , 1987 .
[ 20 ] K . Wu , A . Shoshani , and E . Otoo . Word aligned bitmap compression method , data structure , and apparatus , Dec . 14 2004 . US Patent 6,831,575 .
[ 21 ] J . Ziv and A . Lempel . A universal algorithm for sequential data compression . IEEE Transactions on information theory , 23(3):337–343 , 1977 .
1584
