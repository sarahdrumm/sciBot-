Query Suggestion by Constructing Term Transition Graphs
Yang Song , Dengyong Zhou , Li wei He
Microsoft Research , One Microsoft Way ,
Redmond , WA 98052 , USA
{yangsong , denzho , lhe}@microsoft.com
ABSTRACT Query suggestion is an interactive approach for search engines to better understand users information need . In this paper , we propose a novel query suggestion framework which leverages user re query feedbacks from search engine logs . Specifically , we mined user query reformulation activities where the user only modifies part of the query by ( 1 ) adding terms after the query , ( 2 ) deleting terms within the query , or ( 3 ) modifying terms to new terms . We build a termtransition graph based on the mined data . Two models are proposed which address topic level and term level query suggestions , respectively . In the first topic based unsupervised Pagerank model , we perform random walk on each of the topic based term transition graph and calculate the Pagerank for each term within a topic . Given a new query , we suggest relevant queries based on its topic distribution and term transition probability within each topic . Our second model resembles the supervised learning to rank ( LTR ) framework , in which term modifications are treated as documents so that each query reformulation is treated as a training instance . A rich set of features are constructed for each ( query , document ) pair from Pagerank , Wikipedia , Ngram , ODP and so on . This supervised model is capable of suggesting new queries on a term level which addresses the limitation of previous methods . Experiments are conducted on a large data set from a commercial search engine . By comparing the with state of the art query suggestion methods [ 4 , 2 ] , our proposals exhibit significant performance increase for all categories of queries .
Categories and Subject Descriptors H33 [ Information Storage and Retrieval ] : Information Search and Retrieval Search process
General Terms Algorithms , Experimentation
Keywords query suggestion , page rank , learning to rank
1 .
INTRODUCTION
While more and more sophisticated algorithms have been applied to web search engines to increase user search experiences , it is still admittedly difficult for search engines to fully understand user ’s search intent in many scenarios . Consequently , many researches have been focused on interaction with users to find out what the users really want [ 12 , 13 ] . Among all , query suggestion [ 5 , 23 ] has established as one of the most promising interactive techniques as we have witnessed its wide usage in most commercial web search engines . Generally speaking , query suggestion techniques aim at recommending a list of relevant queries to user ’s input , by mining correlated queries from previous knowledge , eg , search engine logs . Indeed , the quality of query suggestion can be affected by many factors . For example , depending on the underlying algorithms , query suggestion techniques can be categorized into graph based models ( eg , random walk on click graphs)[16 , 7 ] and probabilistic models ( eg , language models)[24 , 11 ] . Moreover , depending on the length of suggested queries , we can further divide existing query suggestion techniques into query expansion [ 17 , 6 ] , query reduction [ 12 ] and query reformulation [ 24 , 8 ] .
Among all existing techniques , random walk based models [ 16 , 7 , 23 ] have exhibited their superiority over others on both efficiency and effectiveness . Due to its simplicity and mathematically proven fast convergence , random walkbased query suggestion models are capable of scaling up to large data sets for commercial search engines . Essentially , most models in this category construct a bipartite graph of queries and clicked URLs by assuming the goodness of clicked URLs . Queries are treated relevant to each other if they share common clicks . While both theoretically sound and empirically usable , this approach appears to have a drawback that needs attention . To be specific , random walk models only focus on query and clicks but ignore the rich information which is embedded in the entire user session . For example , considering four user activities in a session : {q1 , U RL1 , q2 , U RL2} . The user clicked U RL1 after issuing q1 . Not satisfied by the result , the user immediately reformulates the query to q2 and clicked U RL2 . Apparently , U RL1 is not as a good click as U RL2 , which is unfortunately treated equally in random walk models .
In this paper , we try to address two fundamental questions in query suggestion research . ( 1 ) How to extract highquality user clicks in the user session and use the clicks prop erly ? Since the quality of the clicks directly affects the recommendation performance of models which leverage clicks as signals , it is critical to accurately infer user intent by examining the entire user search session . ( 2 ) Given a specific query , which query suggestion method should be used ? eg , can query reduction method be applied to short queries ? Is query expansion always better than query reformulation ? In our opinion , answers to these questions are non trivial . And in practice , it usually depends on each individual queries as well as the user intent at that moment .
To briefly answer these questions , we first derive highquality user clicks by extracting specific user activity patterns which conveys implicit user preferences . Secondly , instead of using the clicks directly , we construct a termtransition graph model from the data . We use random walk as a guideline to find user preferences within each topic and choose the best suggestion method according to our model . To be concrete , we propose a framework that combines the strength of graph based models and probabilistic models . Our model naturally unifies the advantages of query expansion , reduction and reformulation techniques while successfully avoids their relative shortcomings . More specifically , we make the following contributions in this paper :
• From the search engine session logs , we mine a large amount of user preference data . We consider the following tuple {q1 , q2 , u} where a user abandoned a query q1 and immediately reformulated it into q2 then made a click on URL u , during the same session . These activities strongly indicate a user ’s preference on query q2 over q1 , which often differs by only a few terms .
• We construct a term preference graph from the above data where each node is a term in the query and each directed edge a preference . We then train a topicbiased Pagerank model for each of the query topics by extracting topics from clicked URLs . Given a query , this model guides the decision of ( 1 ) expanding relevant terms to the original query , ( 2 ) removing terms from the original query , or ( 3 ) replacing existing terms with relevant terms . This unsupervised model learns the user preference from the log which does not require any specific user labels .
• We further propose a supervised learning to rank model to interpret user preference at term level . This model leverages a set of rich features , which includes N gram features , external knowledge ( eg , Wikipedia , ODP ) as well as the topic biased Pagerank features learnt in the previous model . No human labeling was conducted . Instead , we automatically infer the training labels from the logs by leveraging a sophisticated probabilistic preference model .
To summarize , our system provides a principled formulation that is capable of addressing both topic and termlevel suggestions . Both of our methods exhibit much better recommendation performance than the state of the art methods [ 16 , 7 ] on a real world large data set mined from a commercial search engine .
2 . RELATED WORK
The complexity of dealing with query suggestion related problems has led to a myriad of proposals of methods in literature . In general , this problem has been addressed by different techniques including query reduction , query expansion , query reformulation and query suggestion using search engine logs [ 22 , 12 , 17 , 4 , 19 ] .
In [ 12 ] , the authors proposed to reduce long queries into shorter ones by removing redundant terms and extract key phrases . Three methods for selecting sub queries were introduced : mutual information , maximum spanning tree and extracting named entities . Results indicated that with user interaction , the precision of retrieval improved . However , this method is only useful for long queries . When applying to short queries , it only exhibits marginal improvement .
Automatic query expansion was first proposed in [ 17 ] , where the authors leveraged term correlations in documents as a metric to recommend similar terms . Similarly , authors in [ 6 ] measured the difference between the distribution of terms in relevant documents and in collections to score similar terms . In general , query expansion techniques were able to introduce useful terms while also bring in unhelpful terms . Differing from the above two approaches , query reformulation replaces the existing terms in the query by more relevant ones . Essentially , it tries to map the query language model into document language model with term replacement . In [ 24 ] , the authors used context distribution to extract term associations from the logs . Given a new query , their method replaced the terms with new terms of higher matching probability in the context . Similarly , using anchor text as the context for reformulation was recently studied [ 8 ] .
The three approaches mentioned above primarily focused on improving retrieval relevance . On the other hand , query suggestion aims at interaction with users to improve search experience by showing relevant queries on the search engine result pages ( SERP ) and allowing users to decide whether to click or not . Among all related techniques for query suggestion , log based random walk methods have shown good results [ 7 , 16 , 9 ] . Most random walk models are performed on query document bipartite graphs . For example , in [ 7 ] , the authors introduced a backward random walk model which alleviates the bias towards documents with more clicks . The model normalizes the correlation matrix on the document clicks rather than query counts , which is why the transition from a document to query is not biased to popular queries . In [ 16 ] , a parameter free random walk model is proposed which addressed the efficiency of random walk . The model constructed a subset of query url nodes in the bipartite graph and performed depth first search for relevant queries . By estimating the transition probabilities between queries using similarity based method , this model was capable of suggesting semantically related queries . In [ 4 ] , the authors proposed a query flow graph that calculates the probability of going from one query to another , by leveraging a set of features . This approach can be treated a special case of random walk on the query URL graph where the URLs are removed but used to calculate the transition probability . Although looks similar to our method , it only considered query level transition while our model deals with much finer granularity by addressing term level transitions .
Recently , the authors in [ 23 ] introduced an optimal way of query suggestion using random walk . The authors addressed two important factors in the paper . First , how to tune the jumping parameter in the random walk model and second , how to optimally combine the clicked and skipped URLs in the log for relevance estimation . The authors proposed to perform two random walks on click graph and skip graph respectively , and optimally combine the results by minimizing the categorization error on the URL correlations , which was estimated using ODP data . Experimental results indicated a significant improvement over previous random walk models .
3 . GET USER PREFERENCE FROM LOG In this section we describe how we acquire a large collection of user preference data from the logs . The primary source of data used in this paper is from logs of a widelydistributed browser toolbar , where a large sample of users opted in for providing their online browsing activities . The logs are anonymized so that no user personal information is recorded . A typical log entry contains the following fields : a unique user identification number generated by a one way hash function , the URL that the user visited , the timestamp of the visit , and the total dwell time on that URL . Since we are interested in the user queries when visiting search engines , we also post processed the data to generate the user queries and the name of the search engine . The logs are organized based on sessions , where each session contains a series of URL visits from a particular user , ordered by the timestamp . If the user becomes inactive for more than 30 minutes , that session ends .
We are particularly interested in spontaneous query refinement behaviors by the users , which can be summarized in a sequence of three activities :
1 . A user enters a query q1 to a search engine .
2 . After examining the search result page , the user did not get the right information , so he/she refines the query to be q2 .
3 . This time the user is satisfied with the results and clicked one of the URLs , therefore ends the search session .
For example , the user first issued “ nyc traffic cameras ” and refined the query by adding one term at the end “ nyc traffic cameras live ” , followed by a click on the satisfied result . This sequence of activities conveys two important pieces of information : first , the user prefers the query q2 to q1 since he performed no click after issuing q1 but then becomes positive about the results after q2 . Second , the user chooses to refine the query rather than clicking the suggested queries by the search engine , which may indicate poor suggestion quality for that particular query .
Although the users may refine the queries in whatever way they want , our statistics have shown that more than 76 % of times users only modify one of the terms in the queries . It has also shown the users are much more likely to revise the last term in the query , which covers more than 80 % of all cases1 . Consequently , we only focus on mining user preferences that fall into these two categories in this paper , although the proposed methods can be easily generalized to handle more complex scenarios .
Formally , given a word vocabulary W = {ǫ , w1 , wn} where ǫ is used to denote the empty string , we define three cases of user query refinements as follows :
1These statistics are drawn from one month search logs from a commercial search engine with over 100 million queries
Type
Modification
Expansion
Deletion
User Activity 1 . q:{single ladies song} 2 . q:{single ladies lyrics} 3 . URL click 1 . q:{sports illustrated} 2 . q:{sports illustrated 2010} 3 . URL click 1 . q:{ebay auction} 2 . q:{ebay} 3 . URL click
Pattern song→lyrics
ǫ→2010 auction → ǫ
Table 1 : Three types of user refinement examples .
• Modification : user modifies the last term of the query : im} , eg , “ single ladies song ”
{wi1 , wim} → {wi1 , w′ → “ single ladies lyrics ” .
• Expansion : user adds one term to the end of the query : {wi1 , wim} → {wi1 , wim , wi(m+1)} , eg , “ sports illustrated ” → “ sports illustrated 2010 ” .
• Deletion : user removes the last term of the query : {wi1 , wi(m−1 ) , wim} → {wi1 , wi(m−1)} , eg , “ ebay auction ” → “ ebay ” .
Table 1 summarizes the three types of refinements used in this paper . Overall , we extracted the aforementioned information from 3 month Toolbar logs between May 2010 and August 2010 . In total , over 4 million user refinement activities were discovered in the log . By aggregating the refinements , a total of 350,000 pairs of refinements were found . Table 2 summarizes the top user refinements in each case .
Next , we show how these implicit user feedbacks can be leveraged for query suggestion in our models .
4 . MODEL 1 : AN UNSUPERVISED APPROACH
Given the pair wise transition between each pair of terms , we represent the transitions between all terms into a directed graph . Since every transition from ti to tj indicates a preference of tj over ti , we assume this is an analogy of webpage inlinks and outlinks , where in general the more inlinks a webpage has , the higher its authority score is . The most famous algorithm for calculating such kind of score is the Pagerank algorithm [ 18 ] , which is widely used in commercial search engines for webpage static rank estimation . In
Modification login→home 2009→2010 facebook→myspace lyrics→video google→yahoo music→songs earth→maps check→access jobs→employment depot→max
Expansion
Deletion
ǫ→free ǫ→2010 ǫ→online the→ǫ search→ǫ mail→ǫ
ǫ→download
2→ǫ
ǫ→lyrics ǫ→video ǫ→login
ǫ→pictures ǫ→games ǫ→reviews facebook→ǫ scam→ǫ best→ǫ cheats→ǫ cheap→ǫ wiki→ǫ
Table 2 : Summary of top user query refined queries in each category . our scenario , we assume that terms exhibit different level of importance in a set of pre defined topics . In what follows , we describe a topic based Pagerank approach which is inspired by [ 10 ] .
The Pagerank is a random walk like algorithm where higher Pagerank is assigned to pages with greater importance . In the Pagerank algorithm , the rank of each page can be estimated iteratively . Specifically , at the t+1 step , the Pagerank is updated as follows :
Rank(t+1 ) = ( 1 − α)M × Rank(t ) + αp ,
( 1 ) where M is a stochastic matrix where Mij = 1/N ( j ) if there is a transition from node j to node i , with N ( j ) being the total number of outlinks of node j . At each step , the random walk has a probability of α ∈ ( 0 , 1 ) that jumps to an arbitrary node . In the original Pagerank algorithm , p = [ 1 N ]N ×1 so that the probability of jumping to any node is the same .
In our topic based Pagerank model , for each topic tj , the jumping vector p is calculated as follows : pji = fl 1
|Uj | 0 if i ∈ Uj otherwise where Uj is the set of terms belonging to topic j . Given t topics , this approach essentially constructs t topic graphs where each graph Gj only contains nodes which is categorized in topic j .
Figure 1 illustrates an example of such graph that contains 9 nodes ( our actual graph is much bigger ) . After Pagerank algorithm converges , each term w is assigned with a vector of scores denoting its Pagerank score in all t topics . email login home online apartment house senate com page
Figure 1 : An illustration of graph construction from the term transition data . Each arrow indicates a user preference , eg , page → home .
4.1 Extracting Topics from Clicks
Recall that in our definition , a query refinement essentially contains three elements : {q1 , q2 , clickurl} . Since getting the topics directly from query is difficult , we propose to infer the topics from the clicked webpage which naturally reflects the query intent . In this paper , we leverage a sophisticated content based classifier that categorizes webpages into ODP categories [ 3 ] . The ODP categories are organized hierarchically where higher level topics are more abstract . For example , wwwmicrosoftcom belongs to “ Computers ” → “ Companies ” category . We leverage the 14 top level categories from ODP and construct 14 topic graphs in our models . Note that it is common for a transition to appear in more than one category according to the URLs clicked . For example , coupon→free happens very often in both Computers and Shopping categories . Table 3 shows the top ranked terms in several categories after running the topic based Pagerank model . 4.2 Query Suggestion
After calculating topic based Pagerank , the next step is to suggest query dependent terms when a new query comes . Given a query qi with m terms {wi1 , , wij , , wim} , we want to suggest a set of related queries by reformulating the query using modification , expansion or deletion methods . Although for training we only consider the modification of the last term in the query , it should be noted that at query suggestion time , our model can be adapted to make modifications for any terms in the query .
Overall , any term can be either modified or deleted from the query . The query itself in the meanwhile can be expanded where the expanded term is considered to be appended at the end . Specifically , for any term wij , the term refinement probability is defined as
P ( wij → w′
P ( wij → w′ ij |Tk)P ( Tk|qi ) , ij|qi ) = Xk w′ ij ∈ W = {ǫ , w1 , wn} , j ∈ 1 , , m .
( 2 )
Here P ( wij → w′ ij |Tk ) is a query dependent score , ie , the most likely transition in topic Tk given wij , which is estimated by controlling the jumping factor in Pagerank : pji = fl 1 if i ∈ Uj
0 otherwise
Meanwhile , P ( Tk|qi ) denotes the topic distribution of the new query . For simplicity , we leverage the pseudo relevance feedback from the search engine [ 21 , 25 ] which assumes that the top returned results are usually relevant . We thus classify the top 10 URLs returned by a search engine into ODP categories and treat it as the topic distribution of qi . Table 5 shows examples of the most possible transitions .
To choose the best candidates among all refinements for all terms in the query , we leverage the Pagerank of the terms to rank the refinements :
P ( q′ i|qi ) = arg max P ( wij)P ( wij → w′ ij|qi ) ,
( 3 ) where q′ w′ i equals to qi except for term j being replaced : wij → ij . In addition , query qi has the following probability to be expanded by adding a new term w′ , according to our model ,
P ( w′|qi ) = Xk
P ( w′|Tk)P ( Tk|qi ) ,
( 4 ) where P ( w′|Tk ) is the static Pagerank of term w′ in topic Tj .
The results from term refinement and query expansion are then combined to suggest new queries based on the descending order of their probabilities . Table 4 shows a concrete example for the query “ stanford university map ” . The final winners are “ stanford university location ” , “ stanford university address ” , “ stanford university ” , “ harvard university map ” and “ yale university map ” . In this case , suggestions from using expansion gets a very low score hence are not suggested , indicate that our model is capable of suggesting queries that are different from a syntactic point of view .
Computers Health download free verizon wireless software iphone email microsoft windows support symptoms hospital treatment pain diet health
Home recipes recipe coupons cooking food baby calculator network surgery doctor dosage easy reviews grilled
Science channel zoo salary coupons weather ohio calculator craigslist toyota jetblue
Shopping walmart parts furniture store buy accessories shoes supplies target clothing
Sports sports espn games results schedule news soccer cup rumors nba
Business jobs bank ashley dmv locations free calculator continental america chase
Table 3 : Top ranked terms in each category by the topic biased Pagerank method . A total of 14 ODP categories are assigned to queries .
Query
Prob(expansion ) stanford university map stanford university map online ( 0.0005 )
Pagerank Score stanford university map download ( 0.0003 ) stanford university map printable ( 0.0001 ) Prob(replacement )
Prob(deletion )
0.04 0.04 0.05 harvard ( 0.03 ) , yale ( 0.02 ) , columbia ( 0.02 ) college ( 0.02 ) , school ( 0.01 ) , institute ( 0.002 ) location ( 0.04 ) , address ( 0.03 ) , history ( 0.005 )
Term stanford university map
Final Suggestions stanford university location stanford university address stanford university harvard university map stanford university map online stanford university map download
Source replacement replacement deletion replacement expansion expansion
0.005 0.01 0.015 Score 0.04 0.03 0.015 0.03
0.0005 0.0003
Table 4 : Examples of query suggestion for “ stanford university map ” . Top : query level expansion probability . Bottom : term level replacement and deletion probabilities for each term in the query . The final suggestion is the highest scored queries from both models . Candidates from expansion are not suggested in this case . target sears costco
Walmart Microsoft
Steelers Weather penguins hurricane pirates panthers wal mart microsoft.com hurricanes walgreens radar zoo news ravens earthquake msn office hp live
Table 5 : Some examples of the most relevant terms given specific terms . Calculated using term specific Pagerank algorithm .
5 . MODEL 2 : A SUPERVISED APPROACH The Pagerank based query suggestion model presents a novel way to efficiently reformulate queries on the topic level . Nevertheless , the model ignores the underlying relationship between the query and the suggested term after it aggregates the term transitions into topics . Indeed , within the same topic the term transition probability still varies from queries . In this section , we propose a query level learningto rank approach which leverages a set of language modeling features to address the limitation of the previous model .
We briefly introduce the idea of learning to rank here . For a better understanding of learning to rank , we refer readers to [ 15 ] . Given a set of queries and URLs as well as labeled relevance score ( usually in 5 scale ) for each query URL pair , learning to rank tries to optimize for the ranking loss for all queries in the training set . Generally , three sets of features are often used during training , ( 1 ) query features ( eg , query frequency ) , ( 2 ) URL features ( eg , the Pagerank score of the URL ) , and ( 3 ) query URL features ( eg , BM25 [ 20] ) . In our model , we mimic these principles and construct three sets of features for each triplet of transition : {q1 , q2 , click} . To be specific , the common part of q1 and q2 are extracted to represent the query part , whereas the refinement is treated similar as the URL role . For example , for the first example shown in Table 1 , “ single ladies ” is the query , while “ song ” and “ lyrics ” are treated as refinements .
5.1 Feature Construction
For each of the query refinement pair , we construct three sets of features as shown in Table 7 .
The query features generally fall into two categories . The first category is related to Wikipedia . We dumped over 8 million Wikipedia articles in English , which contains the Title , Body content and Category information . In total , the corpus contains 7,181,315 titles and 10,170,187 articles . We match the query to the Title , Body and Category to estimate its popularity in the Wikipedia corpus . Secondly , we con struct N gram language modeling features from a publicly available N gram services built from Billions of documents [ 1 ] . The N gram contains four streams : title , body , anchor and query streams , available in unigram , bigram , trigram , N gram with N = 4 , 5 . For each query , each stream returns an N gram probability for the query within that stream .
The term features are quite similar to URL/document features in information retrieval systems . The Pagerank scores of the terms are directly calculated from previous model with different jumping rates from 0.55 to 085 The entropy of the Pagerank score is calculated as −Pi P ( ti ) log P ( ti ) for term ti , which estimates the term ’s specificity across all topics . In addition , a good indicator of term importance is the number of times users expand the original query by adding the term , which is specified as “ # of times derived from EMPTY node ” .
Finally , the query term features consist of Wikipedia , Ngram and several other features . The N gram conditional probability measures P ( term|N gram ) where the N gram equals to all phrases ( N up to 5 ) in the original query . eg , for query “ stanford university map ” and term “ online ” , there are three probability scores : P ( online|stanford university map ) , P ( online|university map ) and P ( online|map ) . Meanwhile , the KL Divergence score measures the closeness of two probability distributions : ODP topic distribution for the query and for the term . Additionally , the inverted query frequency also measures the specificity of the term given a query , defined as log N ( ti)/N ( ti|qj ) , where N ( ti ) is the total number of appearances of term ti and N ( ti|qj ) measures how many times ti is used to modify query qj .
Overall , we constructed 30 features for each training instance . The importance of individual features will be discussed in the experiment section . 5.2 Inferring Training Labels from Log
The next step is to generate ranking labels for each group of query refinements . Instead of asking human judgers to manually label a large set of training data , we infer training labels automatically from implicit user feedbacks in the log . For each of the training instance , we extract its total number of appearances ( impressions ) and total number of user clicks from the log . In literature , it is quite common to use either the total clicks or the click through rate ( defined as clicks/impressions ) to approximate the labels . Nevertheless , these two metrics sometimes conflict with each other ( as shown in the following examples ) . Instead , we use a more principled way to derive rankings . Since in our training tuple {q1 , q2 , clickurl} , we consider both clicks and skips ( impressions clicks ) as good signals , it is important to find a model that takes both numbers into consideration . Specifically , given a refined query q′ for the original query q , we model its probability of click distribution using a function Φ(α , β ) where α corresponds to the total clicks and β is the total skips . In our model , we fit this distribution using a Beta function by following [ 14 ] , ie , Beta(α , β ) . Consequently , to compare two query refinements qi and qj , it has been shown in [ 14 ] that the probability of qj better than qi can be computed as
P ( qj ≻ qi ) = Z 1
0
Betaj(Rj)Φi(Rj)dRj ,
( 5 ) where Ri and Rj corresponds to the ranking of qi and qj respectively , Φi the cumulative distribution function of Ri .
Numerical integration is used to estimate the solution . The rankings of the refined queries are then derived directly from the probabilities which show the pair wise comparison results . Figure 2 shows an example of comparing two cases .
6
4
2
)
X P
(
0 0.3 pdf(19,12 ) cdf(20,25 ) qi qj
Prob(qi>qj)= 0.92
0.4
0.5
0.6
X
0.7
0.8
0.9
1
Figure 2 : An example of compare two query refinements qi:(19 , 12 ) and qj :(20 , 25 ) . Although qi has less clicks than qj ( 19 vs . 20 ) , it has a very high probability ( 0.92 ) of being a better refinement due to its significantly less number of skips ( 12 vs . 25 ) .
More specifically , table 6 shows two examples from our log . Using our model , we show that
P ( stanford admission > stanford map ) = 0.61 P ( stanford map > stanford history ) = 0.08
The query “ stanford admission ” is a clear winner over “ stanford map ” with higher number of clicks and relative less number of skips . On the other hand , “ stanford map ” is ranked lower than “ stanford history ” . According to our method , the former query has more clicks but also significantly more skips that the latter , thus “ map ” should be treated as a less relevant term than “ history ” for the query “ stanford ” .
Query stanford microsoft
Term
# of clicks # of skips rank admission map history employment career office jobs games
1913 568 324 1273 2274 1089 1748 523
1235 438 148 934 1589 222 1733 670
1 4 2 3 2 1 3 4
Table 6 : Two examples of constructing query term training data . Each query consists of a list of terms with their statistics . Labels are assigned according to the probability from eq(5 )
521 Online Query Suggestion
Given a new query q that contains k terms : {t1 , , tk} , we first create a candidate set of queries by removing one terms from the original query . eg , for query with terms {t1 , t2 , t3} , the candidate set contains {t1 , t2} , {t1 , t3} and {t2 , t3} , as well as the query itself . Then for each query in the candidate set , we construct features for all terms available in our training set and calculate its score using our model . The highest scored terms are suggested for the query . In practice , since the potential number of candidate suggestions is quite big ( n suggested terms for each candidate , where n is the number of unique terms in the training data ) , we prefiltered candidates by using ODP categories , where only the
Query Features
Term Features
Query Term Features
Is the query a Wikipedia title ? ∈ {0 , 1}
Is the query a Wikipedia category ? ∈ {0 , 1}
# of times query contains in Wikipedia title ∈ R # of times query contains in Wikipedia body ∈ R
N gram probabilities in the title , body , anchor and query streams ∈ {0 ∼ 1}
Pagerank score of the term
# of inlinks & outlinks entropy of Pagerank score in 16 ODP topics : −Pi P ( ti ) log P ( ti )
# of times derived from EMPTY node All Wikipedia features from query features
N gram conditional probabilities , p(wn|wn−m+1 , , wn−1 ) KL Divergence of query and term probability distributions
Inverted Query Frequency : log N ( ti)/N ( ti|qj )
Table 7 : Some of the features used in the learning to rank method . terms within the same category as the candidate query are considered .
6 . EXPERIMENTS
In this section , we describe the evaluation methods . Our experiments consist of primarily two steps . During the first step , we compare the performance of the two proposed models based on the labels we derived from the log . We also calibrate the parameters of our methods according to the labels . During the second step , we conduct user study and ask judgers to evaluate the query suggestion performance of our proposals as well as several state of the art methods . 6.1 Parameter Tuning
This section describes how to calibrate the parameters in our algorithms . For the Pagerank algorithm , we only need to tune one parameter which is the jumping rate α . Since we use the SVM rank package2 for our learning torank approach , we calibrate the c parameter which specifies the trade off between training error and the margin3 .
For evaluation , we use two well known metrics : normalized discounted cumulative gain ( NDCG ) and zero/one error . NDCG is widely used in information retrieval systems . In our study , we treat the training labels as the golden standard . We use the top 5 suggested queries for evaluation . From the training label , we use a five scale relevance score ( rel ) : Perfect ( 5 ) , Excellent ( 4 ) , Good ( 3 ) , Fair ( 2 ) and Poor ( 1 ) . The Ideal DCG ( IDCG ) is calculated from the training set itself . For the suggestions , if the query is in top 5 of the training data , we assign the score according to its original position or 0 otherwise . The NDCG is calculated as :
N DCG(q ) = Pi(reli)/ log(i + 1 )
IDCG(q )
.
( 6 )
The NDCG of the test set is averaged over all queries .
The zero/one error metric , on the other hand , is a more rigorous metric . It calculates the fraction of perfectly correct rankings between training set and test result . The output is binary for each ranking and averaged over all queries .
Figure 3 depicts the results of two metric according to different jumping rates of Pagerank algorithm . The two horizontal lines correspond to the learning to rank approach
2http://wwwcscornelledu/People/tj/svm light/svm rank.html 3We used linear kernel in our experiments . Due to the data size , all other kernels reported out of memory errors . which is not affected by α . It can be noticed that when ( 1 − α ) increases , Pagerank generally performs better and better . The best NDCG score is achieved at 0.85 for Pagerank with the value of 0.61 , whereas learning to rank achieves 0.82 NDCG — a 25 % better performance . Similarly , Pagerank has the best zero/one loss score of 0.52 , comparing to 0.75 for learning to rank algorithm .
In Figure 4 , we show the results of the Pagerank algorithm across 14 ODP topics . Comparatively , our algorithm achieves the best performance in the business category , a 0.7 NDCG score . The news category , on the other hand , exhibits the worst performance , which has only 0.47 NDCG and 0.35 zero/one loss scores .
Next , we split the training data into different proportions and examine the performance of the learning to rank approach . Figure 5 shows the results of two metrics with training data ranging from 20 % to 90 % . Even with only 20 % of training data , the learning to rank method is capable of achieving 0.63 NDCG score . The highest NDCG score is around 0.82 when most of the data is used for training .
Finally , we performed a 5 fold cross validation to select the optimal parameter c in SVM rank in the range of [ 3 , 3 ] . The performance generally increases when c becomes larger . The optimal performance was found when c equals 28
Figure 6 lists the top weighted features used in learningto rank model . The Wikipedia title feature indicates critical importance which is top ranked . The Pagerank score with 0.85 jumping rate also shows superiority which predicts the term relevance well . 4 of the N gram features made to the top 10 feature list where the uni gram feature ranks the highest among them .
6.2 User Study
After calibrating the parameters for our models , we conducted a user study by comparing our methods to others . Since the user study is unable to cover all queries in our data set , we applied a similar approach as in [ 7 , 23 ] by randomly selecting 450 queries from the search log for judgment .
To compare with state of the art algorithms , we implemented two random walk algorithms which have shown good performance in literature . The first algorithm involves using pseudo relevance feedback [ 23 ] which builds the query url bipartite graph by considering all top URLs returned by a search engine as relevant ( RW Pseudo ) . This algorithm has shown significantly better performance than the traditional random walk method . The second algorithm considered s e r o c S
1
0.9
0.8
0.7
0.6
0.5
0.4
Pagerank NDCG Learning−To−Rank NDCG Pagerank Zero/One Loss Learning−To−Rank Zero/One Loss
0.55
0.6
0.65
0.7 ( 1−α )
0.75
0.8
0.85
Figure 3 : The NDCG & zero/one loss scores affected by the jumping rate α . s e r o c S
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0 arts business computers games health
Pagerank NDCG Pagerank Zero/One Loss society sports home kids&teens news recreation reference science shopping
Top−ODP Categories
Figure 4 : The performance of Pagerank algorithm in all top 14 ODP categories in the training set . is a backward random walk model [ 7](RW Back ) , which addresses the bias towards URLs with more clicks in traditional forward walk models . This model assumes a uniform prior on all URLs by normalizing the graph on URL clicks instead of query counts , which turns out to be much more efficient in retrieval relevant queries and URLs .
To be more convincing , we also compare with a recently developed query flow approach [ 4 ] that represents the transition between queries into directed graphs and learns the edge weight from a set of features . For query suggestion , we use one of their methods which also leveraged random walk that shown better performance than maximum weight and history based methods . Furthermore , we compare with an optimized model of the query flow approach that is de s e r o c S
0.9
0.85
0.8
0.75
0.7
0.65
0.6
0.55
Learning−To−Rank Zero/One Loss Learning−To−Rank NDCG
0.2
0.3
0.4
0.5
0.6
Percentage of Training data
0.7
0.8
0.9
1
Figure 6 : Top ranked features from SVM rank used in learning to rank model . scribed in [ 2 ] , which introduced query recommendation links that improve the quality of the random walk model .
Finally , we implemented a baseline model . This simplified model only takes query frequency into consideration . Specifically , for any query q , this model recommends q′ which appears most frequently after users issued q , and leads to a successful click in the session .
Following [ 7 , 23 ] , we conducted the user study approach as follows . For each sampled query , the four algorithms in comparison independently generate top 5 suggested queries . We then mixed the suggestions by removing the duplicates and randomly sort the remaining , which helps eliminating the positional bias during user study . The suggestions , along with the original query , are given to judgers to evaluation . We asked the judgers to evaluate whether each suggestion is ( 1 ) relevant , ( 2 ) irrelevant or ( 3 ) no opinion ( hard to judge ) . Every query is triple judged by three different judgers and the majority vote is used as the final label . During the user study , we also give the judgers some context by showing the results from search engine besides the queries , for a better understanding of what the query means .
Since the responses from judgers are binary , the NDCG metric used in previous section no longer applies . Instead , we evaluate by using Precision at rank N ( P@N ) and Mean Average Precision ( M AP ) . The precision at rank N for a specific query is defined as the percentage of relevant queries :
P ( N ) =
# rel . queries
N
.
( 7 )
P@N is defined as the aggregated precision for all queries ,
P @N = P P ( N )
# total queries
.
( 8 )
While P@N addresses the precision , M AP takes both precision and recall into consideration . Specifically , for each query qi
AverageP ( qi ) = Pj ( P ( j ) · I(j ) )
# rel . queries
,
M AP =
1
K Xk
AverageP ( qk ) ,
( 9 )
Figure 5 : The performance of learning to rank algorithm given different portion of training data . where P ( j ) is the precision at rank j as defined in eq.(7 ) and I equals 1 when query at j is relevant and 0 otherwise .
Query
Pagerank
Learning to Rank battlefield bad company 2 battlefield bad company 1 battlefield bad company 2 price best exercise for abs dante ’s inferno xbox360 battlefield bad company 2 ringtones battlefield bad company 1 battlefield bad company 2 slots battlefield bad company 2 realms battlefield bad company 2 games battlefield bad company 2 download battlefield bad company 2 walkthrough battlefield bad company 2 games best exercise for abs workout best exercise for abs exercise best exercise for abs lower best exercise for abs exercises best exercise for abs workouts dante ’s inferno xbox360 wiki dante ’s inferno ps3 best exercise for abs home best exercise for abs six best exercise for abs workouts best exercise for abs cardio best exercise for abs diet dante ’s inferno xbox360 wiki dante ’s inferno xbox360 video dante ’s inferno xbox360 cheats dante ’s inferno xbox360 walkthrough dante ’s inferno xbox360 walkthrough dante ’s inferno dante ’s inferno xbox360 cheats dante ’s inferno xbox360 guide
Table 8 : Examples of query suggestions by Pagerank and learning to rank methods . Our methods work best for short and medium queries in most scenarios .
Algorithm
LTR
Pagerank RW Back [ 7 ]
RW Pseudo [ 23 ]
Baseline
Query Flow [ 4 ]
Query Flow Opt [ 2 ]
MAP
0.6709452 0.6483460 0.5805054 0.5789023 0.458293 0.570428 0.583297
P@5
0.6346841 0.600000 0.5480981 0.5408738 0.428911 0.539200 0.543886
P@1
0.668909 0.630982 0.57902 0.573906 0.452865 0.609072 0.570965
Table 9 : Overall scores of the seven algorithms in MAP , P@5 and P@1 . LTR performs the best in all metrics . Query Flow is the second worst for P @5 after the Baseline . Query Flow Opt shows marginal improvement over Query Flow but not significantly .
621 The Results
Table 9 summarizes the overall performance of the four algorithms in terms of MAP , P@5 and P@1 . The learningto rank and Pagerank approaches significantly outperformed random walk methods in all three metrics . Comparatively , LTR improves 2.2 % of MAP , 2.4 % P@5 and 3.8 % P@1 upon the Pagerank algorithm , which shows the usefulness of the Wikipedia and N gram features in addition to the Pagerank features . Note the query flow approach performs better than both random walk models ( but worse than both of ours ) for P @1 , but the performance significantly decreased for precision at 5 . We looked into the data and figured out the reason . Since the query flow method aggregates node at query level , the graph loses the power of distinguishing ambiguous queries with different user intent . Therefore lots of noises are introduced to random walk which also gradually increases with the length of the walk . On the other hand , the optimization framework proposed in [ 2 ] only achieves marginal improvement over the queryflow method . Both query flow approaches are significantly worse than our proposals , which supports the importance of topical level term transition graph .
Figure 7 presents the P@5 scores in different ODP categories . Learning to rank outperforms other approaches in almost all categories except for the business and games cate
Deletion
Modification
Expansion
Pagerank LTR Pagerank LTR Pagerank LTR 0.68 0.66 0.67 0.67
0.56 0.61 0.57 0.58
0.64 0.63 0.63 0.63
S M L
Avg
0.47 0.54 0.47 0.5
0.59 0.57 0.54 0.58
0.62 0.6 0.56 0.6
Table 10 : Comparison of Pagerank and LTR in terms of suggested methods : deletion , modification and expansion . Results are broken down into query lengths . Short : ≤ 2 , medium : [ 3 , 5 ] and long : ≥ 6 . gories . On the other hand , Pagerank exhibits better performance than random walks and query flow graphs in 8 out of 13 categories . In general , the home and kids&teens are the most difficult categories to make query suggestions , while games and computers are relatively easier than others .
Furthermore , we analysis the effectiveness of our algorithms by breaking down the queries into different query lengths as well as the three techniques ( term deletion , modification and expansion ) in terms of P@5 . As shown in Table 10 , long queries are generally the most difficult to make suggestions . While for short and medium queries , the expansion technique indicates better suggestion performance than deletion and modification . The Pagerank algorithm exhibits relatively poor performance for long queries since it is usually harder to accurately infer the topics from long queries , which justifies the superiority of term level suggestion method over the topic level method .
Table 8 shows four randomly selected queries and the suggestions by our algorithms . As it can be seen , most of the suggestions are quite relevant to the query itself yet some of the irrelevant ones are suggested due to the ambiguity of the query itself ( eg , “ eclipse ” in the query “ eclipse 2010 ” ) .
7 . CONCLUSION AND FUTURE WORK
In this paper , we presented a novel query suggestion framework which extracted user preference data from user sessions in search engine logs . We then used the user pat
5 @ P
1
0.8
0.6
0.4
0.2
0
Baseline Query−Flow [ 4 ] Query−Flow−Opt [ 2 ] RW−Pseudo [ 23 ] RW−Back [ 7 ] Pagerank LTR arts business computers games health home Top−ODP Categories kids&teens recreation reference science shopping society sports
Figure 7 : Breakdown of P@5 for 13 ODP categories in the testing set consisting of 450 queries . terns to build two suggestion models . The first model was a topic based Pagerank model where the suggested terms were treated as nodes in directed graphs . Pagerank algorithm was used to calculate the relative importance of each term within a topic . The model suggested new queries to the original query by using one of the three techniques : term deletion , term expansion and term modification . The second model was meant to address the limitation of the topic based model , which constructed features from Wikipedia , N gram , Pagerank and other resources , and performed query level suggestions by training a learning to rank model .
Our models were compared with two state of the art random walk methods and query flow models on randomlysampled queries . A rigorous user study was conducted where all queries are triple judged by human judgers . Experimental results indicated significant improvement on our models . We also broke down the queries into different ODP categories as well as query lengths . It was shown that our models worked the best for short and medium length queries .
There is a rich body of work to be extended . As a preliminary study , our model only considered changing one term from the queries . It would be interesting to see how the performance will increase/decrease by leveraging a more sophisticated user preference extraction model which could consider multi term alteration . In our topic biased Pagerank model , only the first level ODP categories are used to classify queries , while suggesting queries in a lower level of category which further narrows down user intent , might be more relevant than queries on the same topic category .
8 . REFERENCES [ 1 ] Microsoft web n gram services . http://researchmicrosoftcom/enus/collaboration/focus/cs/web ngramaspx
[ 2 ] A . Anagnostopoulos , L . Becchetti , C . Castillo , and
A . Gionis . An optimization framework for query recommendation . In WSDM ’10 , pages 161–170 , 2010 .
[ 3 ] P . N . Bennett and N . Nguyen . Refined experts : improving classification in large taxonomies . In SIGIR ’09 , pages 11–18 , New York , NY , USA , 2009 . ACM .
[ 4 ] P . Boldi , F . Bonchi , C . Castillo , D . Donato , A . Gionis , and S . Vigna . The query flow graph : model and applications . In Procs of CIKM , 2008 .
[ 5 ] H . Cao , D . Jiang , J . Pei , Q . He , Z . Liao , E . Chen , and
H . Li . Context aware query suggestion by mining click through and session data . In KDD ’08 , 2008 .
[ 6 ] K . Collins Thompson and J . Callan . Query expansion using random walk models . In CIKM ’05 , pages 704–711 .
[ 7 ] N . Craswell and M . Szummer . Random walks on the click graph . In SIGIR ’07 , pages 239–246 , 2007 .
[ 8 ] V . Dang and B . W . Croft . Query reformulation using anchor text . In WSDM ’10 , pages 41–50 , 2010 .
[ 9 ] H . Deng , I . King , and M . R . Lyu . Entropy biased models for query representation on the click graph . In SIGIR ’09 , pages 339–346 , 2009 .
[ 10 ] T . H . Haveliwala . Topic sensitive pagerank . In WWW ’02 , pages 517–526 , 2002 .
[ 11 ] R . Jones , B . Rey , O . Madani , and W . Greiner . Generating query substitutions . In WWW ’06 , pages 387–396 , 2006 .
[ 12 ] G . Kumaran and J . Allan . A case for shorter queries , and helping users create them . In Human Language Technologies 2007 , pages 220–227 , April 2007 .
[ 13 ] G . Kumaran and J . Allan . Effective and efficient user interaction for long queries . In SIGIR ’08 , pages 11–18 , New York , NY , USA , 2008 . ACM .
[ 14 ] C . Liu , M . Li , and Y M Wang . Post rank reordering : resolving preference misalignments between search engines and end users . In CIKM ’09 , pages 641–650 , 2009 .
[ 15 ] T Y Liu . Learning to Rank for Information Retrieval .
Now Publisher , 2009 .
[ 16 ] Q . Mei , D . Zhou , and K . Church . Query suggestion using hitting time . In CIKM ’08 , pages 469–478 , 2008 .
[ 17 ] M . Mitra , A . Singhal , and C . Buckley . Improving automatic query expansion . In SIGIR ’98 , pages 206–214 , 1998 . [ 18 ] L . Page , S . Brin , R . Motwani , and T . Winograd . The pagerank citation ranking : Bringing order to the web . Technical Report 1999 66 , Stanford InfoLab , 1999 .
[ 19 ] F . Radlinski and T . Joachims . Query chains : learning to rank from implicit feedback . In KDD ’05 , pages 239–248 . [ 20 ] S . Robertson , S . Walker , S . Jones , M . Hancock Beaulieu , and M . Gatford . Okapi at trec 3 . pages 109–126 , 1996 .
[ 21 ] J . Rocchio . Relevance Feedback in Information Retrieval , pages 313–323 . 1971 .
[ 22 ] F . Silvestri . Mining query logs : Turning search usage data into knowledge . Foundations and Trends in Information Retrieval , 4(1 2):1–174 , 2010 .
[ 23 ] Y . Song and L . He . Optimal rare query suggestion with implicit user feedback . In WWW ’10 , pages 901–910 .
[ 24 ] X . Wang and C . Zhai . Mining term association patterns from search logs for effective query reformulation . In CIKM ’08 , pages 479–488 , 2008 .
[ 25 ] C . Zhai and J . Lafferty . Model based feedback in the language modeling approach to information retrieval . In CIKM ’01 , pages 403–410 . ACM , 2001 .
