Improved Consistent Sampling , Weighted Minhash and L1 Sketching
Google Inc . , 1600 Amphitheatre Pkwy , Mountain View , CA 94043 , sioffe@google.com
Sergey Ioffe
Abstract—We propose a new Consistent Weighted Sampling method , where the probability of drawing identical samples for a pair of inputs is equal to their Jaccard similarity . Our method takes deterministic constant time per non zero weight , improving on the best previous approach which takes expected constant time . The samples can be used as Weighted Minhash for efficient retrieval and compression ( sketching ) under Jaccard or L1 metric . A method is presented for using simple data statistics to reduce the running time of hash computation by two orders of magnitude . We compare our method with the random projection method and show that it has better characteristics for retrieval under L1 . We present a novel method of mapping hashes to short bit strings , apply it to Weighted Minhash , and achieve more accurate distance estimates from sketches than existing methods , as long as the inputs are sufficiently distinct . We show how to choose the optimal number of bits per hash for sketching , and demonstrate experimental results which agree with the theoretical analysis .
Keywords Sampling , Hashing , Sketching , Retrieval ,
Compression , Minhash .
1 . Introduction
As data sets become larger and more high dimensional , it becomes increasingly important to find data representations that allow compact storage and efficient distance computation and retrieval . Among the common methods to achieve this is Locality Sensitive Hashing ( LSH ) [ 1 ] . LSH is a framework for mapping vectors into Hamming space , so that the distances in the Hamming hash space reflect those in the input space : similar vectors map to similar hashes . Many LSH schemes have been proposed , divided between metric driven [ 2 ] , [ 3 ] , [ 4 ] , [ 5 ] , with the goal of approximating a given distance metric , and datadriven [ 6 ] , [ 7 ] , where the hash functions are learned to optimize performance on a task such as classification . In this work , we mostly follow the metric driven approach , assuming that a good distance function is given ( or already learned ) .
By mapping the ( possibly sparse ) floating point vectors to a sketch in the Hamming hash space , we are able to considerably reduce the number of bits occupied by each data point while still being able to compute accurate approximations to the distances among the data . The distance computations become faster not only because the hash representations are more compact but also because the Hamming distances could be computed using bit operations which involve the minimal amount of floating point computation and can benefit from bit counting instructions available on modern processors . Hash representations often allow sublinear time retrieval of near neighbors from large databases ( eg [ 2] ) . In addition , the compact representations and fast distance computations can be used in kernel learning methods such as SVM or Kernel PCA for efficient kernel approximation .
In this work , we concentrate on two target metrics : Weighted Jaccard and ℓ1 . Our main motivation is text and image retrieval , where histograms , either normalized or unnormalized , are often used to represent documents ( tfidf weighted histograms of terms or n grams ) or image statistics ( such as histograms of color or texture ) .
The ℓ1 distance between two vectors S = ( Sk ) and
T = ( Tk ) is defined as kS − Tk1 = Pk |Sk − Tk| . This distance is a natural fit for data such as histograms , and is less sensitive to outliers than the Euclidean distance .
Weighted Jaccard distance between two vectors with non negative entries is defined as 1 − J(S , T ) where J is the Jaccard Similarity
J(S , T ) = Pk min(Sk , Tk ) Pk max(Sk , Tk )
( 1 )
There is a simple relationship between Jaccard similarity and ℓ1 distance . Because min(S , T ) = S+T −|S−T | and max(S , T ) = S+T +|S−T | ( as can be easily verified by considering the cases S ≤ T and S ≥ T ) , we have
2
2
J(S , T ) = kSk1 + kTk1 − kS − Tk1 kSk1 + kTk1 + kS − Tk1
In the case where the data is ℓ1 normalized , the norms kSk1 and kTk1 are fixed and so the Jaccard similarity is a monotonically decreasing function of the ℓ1 distance . If the data is not normalized then knowing J(S , T ) , kSk1 and kTk1 allows one to compute kS − Tk1 – so if compact representations of S and T allow one to approximate J(S , T ) then their ℓ1 distance can also be approximated by augmenting the compact representation of every vector with that vector ’s ℓ1 norm .
2 . Related Work
Jaccard similarity .
Minhash for unweighted sets or binary vectors was introduced by [ 3 ] . They showed that the probability of hash collision is given by ( 1 ) , which for binary data represents the ratio of the size of the intersection to that of the union . Extensions have since been proposed . A method dealing with integer weights is mentioned in [ 5 ] and was extended in [ 8 ] to the case of Sk = Wkαk where Wk is an integer weight and αk is an input independent real valued multiplier that is fixed for each index k . For instance , Wk can be the frequency of the term k in a document , while αk is its inverse document frequency . The time to compute a hash is O(Pk Wk ) .
A scheme described in [ 9 ] and reviewed in [ 5 ] suggests a rejection sampling approach for handling realvalued weights : a sequence of samples ( k , y ) is sampled from an upper bound on all possible vectors , and the first sample satisfying y ≤ Sk is output . This method is not suitable for sparse vectors and widely varying feature weights .
The consistent sampling algorithm of [ 10 ] runs in time per non zero weight , and can expected constant be made quite fast in practice through a number of optimizations . Here , we propose an algorithm that runs in worst case constant time , is simpler to implement , and has the added advantage of requiring a fixed number of random values ( 3 random numbers per index k ) which means that if the possible set of indices is known in advance then all the random values can be generated offline .
For a common case where all the vectors to be hashed have the same ℓ1 norm , Weighted Jaccard Similarity is a monotonic function of ℓ1 distance , therefore our hashing technique can be used in such cases . One of the best known LSH methods for handling ℓ1 distances is based on stable distributions [ 2 ] . As we will show , our method has better performance characteristics for retrieval and sketching under some common conditions .
In section 4.3 , we show how to compress the sketches by using a fixed number of bits per hash . This problem was previously addressed in [ 11 ] , where each Minhash value is mapped to its lowest b bits . Compared to that work , our approach has two advantages . One is that it is more general and applies to any underlying hashing scheme , not just Minhash . The other is that by mapping hashes to b bit representations randomly we end up with much simpler estimators of the distances between inputs , given the Hamming distances between their hash vectors .
3 . Consistent Weighted Sampling
In this paper , we follow [ 10 ] who presented an algorithm for consistent weighted sampling from a weighted set and showed that consistent sampling leads to an LSH scheme where the probability of hash collision is equal to the
Consistent weighted sampling is a sampling process that generates , for any vector S = ( Sk ≥ 0 ) , a sample ( k , y ) : 0 ≤ y ≤ Sk which is uniform and consistent .
Uniformity : The sample should be uniformly sampled from ∪k{k} × [ 0 , Sk ] , ie the probability of selecting k is proportional to Sk , and y is uniformly distributed on [ 0 , Sk ] .
Consistency : If a vector S dominates S′ ( ∀k 0 ≤ k ≤ Sk ) , a sample ( k , y ) is selected for S and satisfies k , then ( k , y ) would be selected for S′ as well .
S′ y ≤ S′
For a uniform and consistent sampling scheme , it is easy to show that the probability of collision is the Jaccard similarity :
Pr[sample(S ) = sample(T ) ] =
J(S , T ) = Pk min(Sk , Tk ) Pk max(Sk , Tk )
( 2 )
To demonstrate this , consider a sample ( k , y ) from the union of S and T , R = ( Rk = max(Sk , Tk) ) . By consistency , if y ≤ min(Sk , Tk ) then ( k , y ) would be selected for both S and T , resulting in a collision . Otherwise , ( k , y ) would be selected for one of S or T ( the former if y ≤ Sk , the latter if y ≤ Tk ) , but not the other , thus no collision . Now using the uniformity , Pr[collision ] = Pr[y ≤ min(Sk , Tk ) ] = J(S , T ) .
In this paper , we will sometimes refer to the consistent weighted samples ( or invertible functions of such samples ) as Weighted Minhash , since they generalize the min wise permutation hashes of [ 3 ] from binary to real weights . In sec . 3.1 , we will show how to extend the binary case ( standard minwise hashing ) to integer weights and then to real weights . The resulting algorithm is presented in sec . 32 We then prove its correctness in sec . 3.3 , and describe important data driven optimizations in sec . 34
31 From Integer to Real Weights
Restricting our problem to integer weights , one sampling scheme [ 5 ] works by drawing independent , identically distributed random numbers ( from some fixed distribution ) vk(j ) for each ( k , j ) : j ∈ {1 , . . . , Sk} , and returning the pair ( k⋆ , j⋆ ) = arg mink,j≤Sk vk(j ) . It is important for consistency that vk(j ) depend only on k and j and not on S . In practice , we achieve this by using ( k , j ) as the seed for the random number generator used to draw the corresponding value . This scheme is uniform because all vk(j ) are iid and so have equal chances of being the minimum . It is also consistent : if ∀k S′ k ≤ Sk then k vk(j ) ≥ mink,j≤Sk vk(j ) , with the equality mink,j≤S ′ achieved if and only if the element ( k⋆ , j⋆ ) achieving the minimum for S on the right hand side also appears on the left hand side , ie if j⋆ ≤ S′ k⋆ . v(x ) Active indices Minimum so far
∆ 2∆ y
S z
Figure 1 . The motivation for the consistent sampling algorithm is that the real weights can be discretized with granularity ∆ , with random variables v(x ) sampled for each x = j∆ , j = 1 . . . S/∆ ( small red diamonds in the figure ) . We look for the minimum of v(x ) , and avoid the need to sample O(1/∆ ) variables by observing [ 10 ] that we need to consider only the active indices where the minimum found so far is reduced ( large blue diamonds ) . Instead of sampling the individual values v(x ) , we directly sample the active indices y and z that bracket the weight S .
Integer weights can be used to approximate real weights , by quantizing each Sk with granularity ∆ . For each index k we compute achieved on [ 0 , S ] . In other words , cdf(z ) = Pr[ min S≤x≤z v(x ) < min 0≤x≤S v(x ) ] yk = arg min x=∆j,j=1⌊Sk/∆⌋ vk(x ) and define ak as the corresponding minimum ( achieved for x = yk ) . Then the sample returned is ( k⋆ , y⋆ ) where k⋆ = arg mink ak and y⋆ = yk⋆ . Clearly , as ∆ → 0 , the integer weights tend to infinity , which makes it impossible to sample all the vk(x ) directly . However , it is easy to see that yk must be one of “ active indices ” , where vk(y ) < minx<y vk(x ) . Fig 1 illustrates this . In [ 10 ] , the active indices are sampled in expected constant time per nonzero weight . Let us study the properties of active indices to find a sampling scheme that is worst case constant time . We will drop the subscript k where unambiguous , and let ∆ → 0 . It is easy to see that v(y ) = minx≤S v(x ) is achieved at the largest active index y satisfying y ≤ S . Let z be the smallest active index greater than S , so that y and z are the active indices bracketing S ( as shown in Fig 1 ) .
Since y = arg minx<S v(x ) and all v(x ) are iid , y is uniformly distributed on the interval [ 0 , S ] . ( We often use the closed and open interval notation interchangeably , since the endpoints have measure zero . ) Therefore , y = u1S where u1 ∼ Uniform(0 , 1 ) .
To obtain the distribution P ( z ) , let us analyze its cumulative probability function cdf(z ) . For z ≥ S , we can see that cdf(z ) is the probability that the interval [ S , z ] contains a value v(x ) which falls below the minimum which is the probability that the smallest v(x ) over 0 ≤ x ≤ z is achieved for x > S . Since all v(x ) are iid , we z = 1 − S/z ( and so P ( z ) = cdf ′(z ) = have cdf(z ) = z−S S/z2 ) . Therefore , we can write z = cdf −1(1 − u2 ) = S , u2 where u2 ∼ Uniform(0 , 1 ) ( and so is 1 − u2 ) . Note that z is independent of y – knowing where the minimum v occurred on [ 0 , S ] tells us nothing about where the first smaller value will be obtained on ( S , ∞ ) .
It follows that r = ln z − ln y = ( ln S − ln u2 ) − ( ln S + ln u1 ) = −(ln u1 + ln u2 ) , where u1 , u2 ∼ Uniform(0 , 1 ) . Significantly , r does not depend on S . To compute the distribution of r , we first note that if t1 = − ln u1 then P ( t1 ) = P ( u1)fififi = e−t1 , and similar for t2 = − ln u2 . Then , r = t1 + t2 is the sum of independent variables with the distribution P ( r ) = R r 0 e−t1 e−(r−t1)dt1 = re−r . This is the definition of the Gamma(2 , 1 ) distribution : dt1 fififi du1
P ( ln z − ln y ) = P ( r ) = re−r defined for r ≥ 0 . Consider a transformation of variables ( y , z ) → ( ln y , r ) . The distribution P ( y , z ) is defined for 0 ≤ y ≤ S ≤ z and , from independence , P ( y , z ) = P ( y)P ( z ) = ( 1/S ) × ( S/z2 ) = z−2 . The distribution P ( ln y , r ) is defined for r ≥ 0 and for ln y such that ln y ≤ ln S and ln z − ln y = r for some z ≥ S ; in other words , ln y ∈ [ ln S − r , ln S ] . From the transformation properties of probability distri= butions , we have P ( ln y , r ) = P ( y , z)fififi
∂(ln y,r)fififi det ∂(y,z ) fififi z−2fififi det ∂(exp(ln y ) , exp(ln y+r ) )
= exp(−r ) . Therefore
∂(ln y,r ) P ( ln y | r ) = P ( ln y,r ) P ( r ) = 1/r which means that , conditioned on r , ln y is uniformly distributed on [ ln S −r , ln S ] . The way in which we sample ln y uniformly from [ ln S − r , ln S ] has a critical effect on the consistency of our sampling scheme . For example , one option is to set ln y = ln S −rb where b ∼ Uniform(0 , 1 ) does not depend on S . This , however , does not produce consistent samples : even a small change in S will cause y to change – while in a consistent scheme we should have a non zero probability of producing identical samples for similar inputs . Instead , we use a uniform β ∼ Uniform(0 , 1 ) to specify the offset of a regular grid with spacing r , and select , as the sample ln y , the unique element of the grid that falls inside the interval ( ln S − r , ln S ] . Specifically , we set ln y = ln S r
+ β − β r ln z = r + ln y
The use of the piecewise constant floor function ensures that y and z are usually unaffected by small changes in S , and give rise to consistent samples ( as we will show below ) .
Next , we turn to the random variable ak = min0≤x≤Sk vk(x ) , which we need to minimize over indices k to produce the consistent sample . Notice that we are free to choose any distribution for the vk(x ) . Because the minimum of a set of exponential variables is itself exponential , we will draw each vk(x ) from the exponential distribution with rate ∆ : P ( v ) = ∆e−∆v , v ≥ 0 . It is easy to show that the minimum a of S/∆ such variables is then exponential with rate S , and the product ǫ1 = aS is exponential with rate 1 : P ( ǫ1 ) = e−ǫ1 .
The value a = min0≤x≤S v(x ) is connected to the next active index z > S , which is where v(z ) drops below a for the first time . The probability of any v falling below a is Pr[v < a ] = 1 − e−∆a ≈ 1 − ( 1 − ∆a ) = ∆a , and it follows that , as ∆ → 0 , the waiting time z − S until encountering a sample below a is exponential , with rate a . Therefore , ǫ2 = ( z − S)a is exponential with rate 1 .
Putting it together , we have , for two independent exponential variables ǫ1 and ǫ2 , a = Sa+(z−S)a = ǫ1+ǫ2 z = c/z where c = ǫ1 + ǫ2 ∼ Gamma(2 , 1 ) : P ( c ) = ce−c . This means that a can be sampled conditioned on z and independent of S . Furthermore , if z is not usually affected by small changes in S then neither is a , giving the promise of consistency – which we will prove in Sec 33 z
• For each k :
– Sample rk , ck ∼ Gamma(2 , 1 ) ( P ( r ) = re−r ) and βk ∼ Uniform(0 , 1 ) .
– Compute tk = ln Sk rk
+ βk yk = exp ( rk(tk − βk ) ) zk = yk exp(rk ) ak = ck/zk
• Find k⋆ = arg mink ak , and return the sample
( k⋆ , yk⋆ ) .
If we do not care about the actual sample but only the collision of samples , then we output the Weighted Minhash ( k⋆ , tk⋆ ) instead ( since the mapping tk → yk does not depend on S ) , which avoids the use of floating point values as hashes . To compute multiple hashes , we simply draw different independent sets of variables rk , βk , ck .
We can avoid most transcendental function computations by working in the log domain . To sample a variable r ∼ Gamma(2 , 1 ) , we can represent it as r = − ln(u1u2 ) where u1 , u2 ∼ Uniform(0 , 1 ) . Alternatively , we can use the efficient Ziggurat method [ 12 ] . We can sample c in the same way , or can instead sample ln c directly , also using Ziggurat . Figure 2 summarizes the algorithm .
33 Proof of Correctness
Below , we will prove that the algorithm does in fact return uniform and consistent samples .
1 ) Uniformity
We shall prove that our sampling scheme produces a uniform sample from {(k , y ) : 0 ≤ y ≤ Sk} .
Dropping k from notation , observe that the random variable y = exp,r,' ln S r + βff − β , where β is uni form , comes from the same distribution as y = exp(ln S − rb ) for uniform b ( in both cases , ln y is uniformly distributed on [ ln S − r , ln S] ) . The distribution P ( y , z , a ) is defined for y ≤ S , z ≥ S and a > 0 , and can be computed using a transformation of variables :
P ( y , z , a ) = P ( r , b , c)fifififi det
∂(r , b , c )
∂(y , z , a)fifififi where r = ln z − ln y , b = ln S−ln y ln z−ln y , c = az . From independence of r , b and c , and computing the Jacobian , we get
32 Consistent Weighted Sampling Algorithm
From the derivations in Sec 3.1 , we obtain a scheme for sampling from a weighted set S = ( Sk ≥ 0 ) .
P ( y , z , a ) = re−rce−c y(ln z − ln y )
= ae−az
Input : Vector S = ( Sk ≥ 0 ) Output : Consistent uniform sample ( k⋆ , y⋆ ) from {(k , y ) : 0 ≤ y ≤ Sk}
Sample independent random variables , independent of the input S for all k do
Sample : rk ∼ Gamma(2 , 1 ) ( ie P ( rk ) = rke−rk , rk ≥ 0 ) ck ∼ Gamma(2 , 1 ) βk ∼ Uniform(0 , 1 ) end for
The remainder depends on the input S for all k such that Sk > 0 do tk ← j ln Sk rk
+ βkk yk ← exp ( rk(tk − βk ) ) ak ← ck/ ( yk exp(rk ) ) end for k⋆ ← arg mink ak y⋆ ← yk⋆ return Consistent sample ( k⋆ , y⋆ ) or Weighted Minhash ( k⋆ , tk⋆ )
Figure 2 . Algorithm for drawing a uniform consistent sample . The resulting ( k⋆ , y⋆ ) ( or , equivalently , ( k⋆ , tk⋆ ) ) can be used as a Weighted Minhash , where the probability of hash collision for inputs S and T equals the Jaccard similarity J(S , T ) . We sample r ∼ Gamma(2 , 1 ) as the sum of two independent exponential variables , or r = − ln u1 − ln u2 where u1 , u2 ∼ Uniform(0 , 1 ) . In practice , we work with the logs ln yk and ln ak , and sample rk and ln ck from their respective distributions using Ziggurat method .
Integration over z yields assumption , y⋆ ≤ S′ k⋆ ≤ Sk⋆ , we have
P ( y , a ) = Z ∞
S
P ( y , z , a)dz = e−Sa = ln S′ k⋆ rk⋆
+ βk⋆ − 1 ≤ ln Sk⋆ rk⋆
+ βk⋆ − 1
< tk⋆ = ln y⋆ rk⋆
+ βk⋆ ≤ ln S′ k⋆ rk⋆
+ βk⋆ .
1 S
( Se−Sa ) = P ( y)P ( a )
We see that ln S′ k⋆ rk⋆
+ βk⋆ − 1 < tk⋆ ≤ ln S′ k⋆ rk⋆
+ βk⋆ which shows that y is uniform on [ 0 , S ] , a is exponential with rate S , and y and a are independent . Now considering all indices k , it is easy to show that , for a set of exponential variables ak with respective rates Sk , the probability that a particular ak⋆ is the smallest is proportional to Sk⋆ :
Pr[ak⋆ = mink ak ] = Sk⋆/(Pk Sk ) . By independence of a and y , the corresponding y⋆ = yk⋆ is uniformly distributed on [ 0 , Sk ] . Therefore , ( k⋆ , y⋆ ) is uniformly sampled from {(k , y ) : 0 ≤ y ≤ Sk} .
2 ) Consistency
Let us fix all of rk , βk and ck . We will show that for two k , if ( k⋆ , y⋆ ) was weighted sets S , S′ such that ∀k Sk ≥ S′ sampled for S and satisfies y⋆ ≤ S′ k , then ( k⋆ , y⋆ ) will also be sampled for S′ . rk⋆ + βk⋆k is the unique integer rk⋆ + βk⋆ . Since , by
Note that tk⋆ = j ln Sk⋆ rk⋆ + βk⋆ − 1 < tk⋆ ≤ ln Sk⋆ such that ln Sk⋆ and so tk⋆ = ln S′ k⋆
+ βk⋆ = t′ k⋆ rk⋆ k⋆ where y′
Therefore yk⋆ = y⋆ = y′ k⋆ is the value sampled for index k⋆ for input S′ . For any given k , notice that ak = cke−rk /yk is a monotonically decreasing function of yk , which in turn is a non decreasing function of Sk . Thus , for all k , a′ k⋆ = yk⋆ ) . It follows that arg mink a′ k = arg mink ak = k⋆ which means that the sample ( k⋆ , y⋆ = yk⋆ ) is output for S′ as well as for S , and so our sampling scheme is consistent . k⋆ = ak⋆ ( since y′ k ≥ ak , while a′
34 Efficient Hash Computation
We can significantly speed up the computation , by computing simple data statistics . Observe that in each sample ( k⋆ , y⋆ ) ( or , equivalently , hash ( k⋆ , t⋆) ) , if we know k⋆ then y⋆ depends only on k⋆ and the corresponding weight
Sk⋆ , but not on any of the other weights . Similarly , if we know that k⋆ ∈ K then we only need to examine a subset of indices {k ∈ K : Sk > 0} to generate the hash . In practice , we have observed that we can find a rather small set K for each hash , such that most of the hashes have k⋆ ∈ K . Different hashes may have different candidate index sets K , with some indices belonging to most candidate sets ( if the corresponding Sk are usually large ) and some belonging to none ( if their Sk are usually zero or very small ) . We count how frequently each index k is chosen by the hash , over a large data set , and for future hash computations consider only the indices for which this frequency is above a threshold . In our experiments , we were able to reduce the number of considered hash/feature pairs by a factor of 200 , while affecting only 0.5 % of the hashes .
An extra advantage of our method compared to that of [ 10 ] is that for each feature and each hash we sample 3 random variables ( r , c and β ) , independently of the input weight . This suggests that these random variables may be generated ahead of time ( perhaps only for those hash / feature pairs which get selected sufficiently frequently ) – eliminating the need to sample those for every input , and further reducing the hash computation time .
4 . Weighted Minhash for Retrieval and Sketching under ℓ1 Metric Below , we show how Weighted Minhash can be used for data in ℓ1 spaces . We will discuss the use of these hashes for near neighbor retrieval and for sketching the data , where the ℓ1 distance between pairs is approximated based on their hashes . We will demonstrate how the hashes can be mapped to a small number of bits to save space , and how the theoretical properties of Weighted Minhash compare with the commonly used random projection method . It should be pointed out that the discussion in this section is not specific to our method , and applies to any consistent weighted sampling scheme .
41 Retrieval under ℓ1 Metric Often , we deal with ℓ1 normalized data , such as histograms — ie , for all S , S1 = 1 . In this case , Weighted Jaccard Similarity is a monotonic function of ℓ1 distance :
J(S , T ) =
2 − kS − Tk1 2 + kS − Tk1
.
This allows Weighted Minhash to be used for efficient retrieval under ℓ1 . The constraint on the norm is the only one that we impose — the non negativity constraint in ( 1 ) can be relaxed by replacing each weight Sk with a pair
Sk → ( Sk+ , Sk− ) = ( max(0 , Sk ) , max(0 , −Sk ) )
( 3 ) which preserves ℓ1 distances and norms .
We compare Weighted Minhash with the stable distribution method of [ 2 ] , which uses a quantized dot product with a vector of Cauchy variates . The crucial quantity affecting the retrieval speed in the ( R , c) approximate nearest neighbor problem [ 1 ] is ρ = ln(1/p1 ) ln(1/p2 ) where p1 is the probability of hash collision for points at distance R > 0 and p2 is the probability for points at distance Rc , with c > 1 the approximation factor . Smaller ρ results in faster retrieval . Both [ 1 ] and [ 2 ] propose hashing schemes that achieve ρ = 1/c . With Weighted Minhash , ρc(R ) depends on R and is defined on R ∈ ( 0 , 2/c ) : ρc(R ) = ln((2+R)/(2−R ) ) ln((2+Rc)/(2−Rc ) ) . Fig 3 shows ρc(R ) for several values of c . We can show that limR→0 ρc(R ) = 1/c and limR→2/c ρc(R ) = 0 . Furthermore , ρc(R ) decreases on ( 0 , 2/c ) for all values of c that we examined . We can see that ρc(R ) < 1/c and so , in the case of ℓ1 normalized data , Weighted Minhash allows for more efficient retrieval than the stable distribution method .
In addition to its suitability for retrieval , Weighted Minhash can also be faster to compute . Indeed , computing a single stable distribution hash requires us to consider every non zero weight Sk 6= 0 in the input vector to compute the dot product . On the other hand , with the preprocessing described in Sec 3.4 , we can consider only a small fraction of the features to compute a given hash — which is a win compared to the dot product with a Cauchy vector , even though our algorithm spends more time on each weight that it actually considers .
42 Weighted Minhash for Sketching Under ℓ1 We often want to represent the data using as few bits as possible , while being able to reconstruct the distances efficiently and accurately . We now present a method for accomplishing this with Weighted Minhash , study the accuracy of the ℓ1 distance estimation for a given number of bits , and compare with several existing methods .
Consider the mapping of a vector S to a sketch containing its ℓ1 norm and H Weighted Minhash values , where each WMHh is an independent sample from the parameterized family H of hash functions : sketch(S ) = ( kSk1 , WMH1(S ) , . . . , WMHH ( S ) ) that PrWMH∈H[WMH(S ) = WMH(T ) ] = Recall J(S , T ) , where the probability is with respect to a random selection of the hash function from H . Since all of WMHh are independent random samples from H , the normalized Hamming similarity
HashSimH ( S , T ) =
1 H
H
Xh=1
δ(WMHh(S ) , WMHh(T ) )
( where δ is Kronecker ’s delta ) is the average of H iid Bernoulli variables . Thus the Hamming similarity has the
1
1
1.1
1
1.5
1
2.0
) 2 p / 1 ( g o l
/
) 1 p / 1 ( g o l
= ρ
0
0
0.2
0.4
0.6
0.8
1.2 Distance R = ku − vk1
1 c = 1.1 c = 1.5 c = 2.0
1.4
1.6
1.8
2
Figure 3 . The value ρ achieved by our method for different approximation factors c and ℓ1 distances R , under the condition kSk1 = kTk1 = 1 . p1 is the probability of hash collision for points at distance R and p2 is the probability for points at distance Rc . Smaller values of ρ result in more efficient retrieval . Previously , ρ = 1/c has been achieved for ℓ1 distances using the stable distribution method , whereas Weighted Minhash achieves ρ = 1/c for distances R ≈ 0 and quickly decreases after that . These graphs show that when the data is ℓ1 normalized ( such as histograms ) , Weighted Minhash provides a more efficient retrieval method than the method of [ 2 ] . expected value of J(S , T ) and variance
43 Generating b bit hashes
σ2 H =
J(S , T)(1 − J(S , T ) )
H
Being able to approximate J(S , T ) = Pk min(Sk,Tk ) Pk max(Sk,Tk ) Indeed , approximate kS − Tk1 . us to allows
Pk min(Sk , Tk ) = Pk(Sk + Tk − |Sk − Tk|)/2 , and similar for Pk max(Sk , Tk ) , so
J(S , T ) = kSk1 + kTk1 − kS − Tk1 kSk1 + kTk1 + kS − Tk1
.
Defining N = kSk1 + kTk1 and d = kS − Tk1 , we have d = N
1 − J 1 + J
Replacing J with HashSimH ( S , T ) yields an estimate ˆd ≈ d .
How accurate is this estimate ? Let us locally approximate the relationship between J and d as being linear . Then ,
Var[ ˆd ] = σ2
∂J2 H × ∂d × ∂J
J(1 − J )
H
∂d−2
=
( 4 )
( 5 )
In the above discussion we ignored the number of bits required to represent each Weighted Minhash WMHh . One possibility is to use one of the standard compression techniques so that the average number of bits per hash is roughly the entropy of the hash . This approach , however , has several disadvantages . One is that the distance computations between hashes become much more expensive , as each hash needs to be decompressed on the fly . More importantly , it may often be advantageous to reduce the number of bits per hash at the cost of some spurious hash collisions , with the benefit of being able to use more hashes . The extra hash collisions , which a compression scheme would work hard to avoid , may not be quite so harmful in reality , since it is unlikely that the spurious collisions of different hashes would be consistent enough to significantly affect the distance estimates . This insight was has been successfully used in the context of hash learning [ 6 ] . Below , we propose a scheme to represent each hash using a given number b of bits – where b trades off between the number of hashes and their accuracy . This problem has also been addressed in [ 11 ] , but the method below applies to any hashing scheme and not just Minhash , and allows simpler analysis and much simpler estimators of distances given the number of hash collisions .
Given a hash value WMHh(S ) , we will randomly to a b bit value . First , we initialize a random map it h s a h r e p s t i
B
2 d / B × ˆd [ r a V
]
0
12 11 10 9 8 7 6 5 4 3 2 1
10
8
6
4
2
0
0
Weighted MinHash Cauchy Projection
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1 d/N = kS − Tk1/(kSk1 + kTk1 )
Comparing Weighted Minhash with Cauchy Random Projections for estimating the distance d = kS − Tk1 . In both cases , each hash is Figure 4 . mapped to a b bit code , and we minimize the variance of the distance estimate given that we are allowed B bits total . For random projections , the minimum variance Var[ ˆd ] ≈ 8.7d2/B is obtained for b = 1 . For Weighted Minhash , we explore different values of b . We normalize out the effects of B and d by plotting Var[ ˆd ] × B/d2 against d/N = kS − Tk1/(kSk1 + kTk1 ) . ( top ) The optimal number of bits b to which each Weighted Minhash value should be mapped to minimize Var[ ˆd ] . For a near duplicate scenario where d < 0.153N , it is better to use random projections , at one bit per projection . Otherwise , Weighted Minhash performs better . ( bottom ) The optimal normalized variance . For Weighted Minhash , we benefit from minimizing the vector norms , eg by centering each dimension at its median . number generator using ( h , WMHh(S ) ) as the seed . Then sample an integer b bit value WMH(b ) uniformly from h {0 . . . 2b − 1} .
Note that if the original hashes are equal then the bbit hashes are too . For different original hashes , on the other hand , the b bit hashes collide with probability 2−b . Therefore ,
Pr[WMH(b ) h ( S ) = WMH(b ) h ( T ) ] = J + ( 1 − J ) × 2−b = J ( b ) and , denoting by HashSim(b ) H b bit hashes , we can approximate
H the Hamming similarity of
J =
J ( b ) − 2−b 1 − 2−b ≈
HashSim(b ) 1 − 2−b
H − 2−b follows :
Var[ ˆd(b ) ] =
J ( b)(1 − J ( b ) )
H
−2
× ∂J ( b ) ∂d
Denoting by B the total number of bits available , we have H = B/b , and
Var[ ˆd(b ) ] = d(N + d)2(N − d(1 − 21−b ) ) b
2N 2(1 − 2−b)B
( 6 )
The distance estimate variance computed in ( 6 ) allows us to reason about the optimal number of bits b to represent each hash , assuming that the pairs of vectors we care about have similar distances d and sums of norms N . As an alternative , we may choose b empirically to obtain the most accurate estimate ˆd for the vector pairs of interest .
44 Weighted Minhash or Random Projections ?
Similar to ( 4 ) , we obtain that the variance of the estimate ˆd(b ) of the distance d = kS − Tk1 depends on H and b as
Let us now consider another commonly used Locality Sensitive Hashing method , based on Stable Distributions
[ 2 ] . Here , each hash is a quantized dot product between the vector S and a vector of independent Cauchy variates . The method has a single parameter r , the quantization granularity . For given S , T and r , let us define u = r kS−Tk1
. Then , the probability of hash collision is p =
2 tan−1 u
π
− ln(1 + u2 )
πu
( 7 )
We can estimate p as the fraction of colliding hashes , and recover d = kS − Tk1 by inverting p(u ) . For H hashes , the variance of the estimate is
Var[ ˆd ] = p(1 − p )
H
× ∂p
∂d−2
( 8 )
To represent the hash in a fixed number b of bits , we can consider several schemes . One is the scheme described above , where each hash is mapped to a random b bit sequence . Alternatively , we propose to minimize spurious collisions by making the regions represented with the same b bits as separated as possible , as follows :
RP(b)(S ) = mod S · c r
+ β , 2b
( 9 ) where c is the vector of Cauchy variates and β is the random offset . Numerical minimization with respect to r and b shows that for a given distance d = kS − Tk1 and available number of bits B the smallest
Var[ ˆdRP ] ≈
8.7d2
B
( 10 ) is achieved by the scheme in ( 9 ) with r ≈ 4.5d and b = 1 — that is , the random projections are quantized , and the quantization bins are alternately assigned to bits 0 and 1 ( for comparison , random assignment of each bin to a single bit yields the estimate variance of 116d2/B ) Note that the in this analysis we are being optimistic , assuming that for each d we can select the corresponding r value , which of course is not true in practice .
In addition to the hashing methods , we can consider storing non quantized Cauchy projections , and estimating the kS − Tk1 as the maximum likelihood estimate of the scale of a Cauchy distribution . Such a method was proposed in [ 13 ] , and yields
Var[ ˆd ] =
2d2 k
+ O(k−2 ) where k is the number of projections . However , even if we can very aggressively compress the projections to 5 bits with no loss in distance estimation accuracy ( so that k = B/5 ) , the resulting variance exceeds that in ( 10 ) .
To compare our sketching method with that given by Cauchy random projections with quantization and remapping to bits , we observe that Var[ ˆd ] scales inversely with B and quadratically with d , with the caveat for our method that N/d remains constant . Therefore , to compare the methods as well as different values of b for Weighted Minhash , in Fig 4 we plot Var[ ˆd]/d2 against d/N .
From the plots we can make several observations . One is that for a fixed d = kS − Tk1 we obtain smaller variance Var[ ˆd ] if d/(kSk1 + kTk1 ) is larger . Therefore , it is advantageous to make the ℓ1 norms of the inputs as small as possible , while preserving distances . We propose to minimize the sum of ℓ1 norms of the training data by determining , for each dimension k , the median weight µk = median{Sk} over the training data . Then , we subtract the medians from the weights and replace each weight with a pair to ensure non negativity :
Sk → ( max(0 , Sk − µk ) , max(0 , µk − Sk ) )
( 11 )
It is easy to see that this transformation preserves the ℓ1 distances , while minimizing the total ℓ1 norm of the data . The second observation from Fig 4 is that Weighted Minhash achieves better variance of the distance estimate than random projections with remapping to 1 bit , as long as the vectors are sufficiently different , ie kS − Tk1 > 0.153 ( kSk1 + kTk1 ) . On the other hand , in the nearduplicate scenario , where d/N < 0.153 , we are better off using random projections . One explanation for this is that the norms of the inputs kSk1 which we store alongside the Weighted Minhashes help us obtain better distance estimates when these distances are of the same order of magnitude as the norms . The norms become less useful , however , if the distances are much smaller – at that point they only amplify the variances .
Finally , we can see that as the distances we are interested in become larger compared to the norms , we benefit from using more bits per hash , and need fewer hashes .
5 . Experimental Results
In our evaluations , we have concentrated on sketching , and analyzed how well the variances of the distance estimate obtained from sketches agree with the theoretical predictions .
Our inputs are image descriptors containing different histograms of color , texture and other image properties , for a total of about 5 × 105 dimensions . The descriptors are somewhat sparse , with about 50000 non zero weights per image . Some of the constituent histograms are normalized and some are not . We preprocessed the descriptors by subtracting from each dimension the median value of that dimension , computed over a separate set of images , ensuring non negativity as in ( 11 ) .
The average norm of a descriptor is kSk1 ≈ 14.2 , and the average distance kS − Tk1 ≈ 199 Looking up these values in Fig 4 , we find that for d/N ≈ 19.9/(2 · 14.2 ) ≈ 0.7 , we should use Weighted Minhash , with 3 bits per hash . We computed the hashes for different values of b , with the budget of 3000 bytes per image ( B = 24000 ) , and found that b = 3 in fact gives the best agreement between the distances and their estimates . Turning now to ( 6 ) , we expect that Var[ ˆd ] ≈ 00556 In our experiment , we obtained almost exactly this value : averaging over many pairs of images , we got E( ˆd − d)2 = 00559
The time required to compute the B/b = 8000 hashes , with about 50000 non zero weights per input , was approximately 7 seconds . Following Sec 3.4 , we selected for each hash the 200 most frequently selected input dimensions ( as evaluated on a separate set of inputs ) . Now each hash looks only at the dimensions among the 200 which have non zero weights ; the sets of dimensions considered by different hashes may or may not overlap . With this optimization , the variance Var[ ˆd ] increases slightly from 0.0559 to 00572 However , the running time is reduced from 7 seconds to 47 milliseconds per image , ie a speedup factor of almost 150 .
6 . Conclusion
We presented a new consistent sampling scheme , which improves on the best existing such scheme by making it worst case constant time per sample per non zero input weight ( compared to expected constant time ) . Another advantage of our method is that all the random variates used for hash computation can be computed offline , independently of the inputs . The time required to compute the samples was reduced by a factor of 150 by analyzing which samples are affected by which input dimensions . The consistent samples can be used as generalization of Minhash to weighted inputs , with the collision probability given by the Jaccard similarity . We exploit the relationship between Jaccard similarity and ℓ1 distance to present a hash based approximate near neighbor retrieval scheme with performance characteristics superior to the previously existing ones . We discussed the use of Weighted Minhash for sketching that allows ℓ1 distance approximation , and studied the accuracy of this approximation for a given sketch size . We showed how to map Weighted Minhash , or any other hash , to a fixed number of bits , and investigated the optimal trade off between the number of hashes and the number of bits per hash . Our experimental results agree well with the theoretical predictions .
References
[ 1 ] P . Indyk and R . Motwani , “ Approximate nearest neighbors : towards removing the curse of dimensionality , ” in STOC ’98 : Proceedings of the thirtieth annual ACM symposium on Theory of computing , New York , NY , USA , 1998 , pp . 604–613 .
[ 2 ] M . Datar , N . Immorlica , P . Indyk , and V . S . Mirrokni , “ Locality sensitive hashing scheme based on p stable distributions , ” in SCG ’04 : Proceedings of the twentieth annual symposium on Computational geometry , New York , NY , USA , 2004 , pp . 253–262 .
[ 3 ] A . Z . Broder , M . Charikar , A . M . Frieze , and M . Mitzenmacher , “ Min wise independent permutations , ” J . Comput . Syst . Sci . , vol . 60 , no . 3 , pp . 630–659 , 2000 .
[ 4 ] A . Andoni and P . Indyk , “ Near optimal hashing algorithms for approximate nearest neighbor in high dimensions , ” in FOCS ’06 : Proceedings of the 47th Annual IEEE Symposium on Foundations of Computer Science , Washington , DC , USA , 2006 , pp . 459–468 .
[ 5 ] M . S . Charikar , “ Similarity estimation techniques from rounding algorithms , ” in STOC ’02 : Proceedings of the thiry fourth annual ACM symposium on Theory of computing , New York , NY , USA , 2002 , pp . 380–388 .
[ 6 ] Y . Weiss , A . Torralba , and R . Fergus , “ Spectral hashing , ” in Proc . Neural Information Processing Systems 2008 , 2008 . [ 7 ] R . Salakhutdinov and G . Hinton , “ Semantic hashing , ” in IRGM 2007 workshop at the SIGIR 2007 conference , 2007 . [ 8 ] O . Chum , J . Philbin , and A . Zisserman , “ Near duplicate image detection : min hash and tf idf weighting , ” in Proceedings of the British Machine Vision Conference , 2008 . [ 9 ] J . Kleinberg and E . Tardos , “ Approximation algorithms for classification problems with pairwise relationships : Metric labeling and markov random fields , ” in FOCS ’99 : Proceedings of the 40th Annual Symposium on Foundations of Computer Science , Washington , DC , USA , 1999 , p . 14 .
[ 10 ] M . Manasse , F . McSherry , and K . Talwar , “ Consistent weighted sampling , ” MSR , Tech . Rep . MSR TR 2010 73 , 2010 .
[ 11 ] P . Li and C . K¨onig , “ b bit minwise hashing , ” in WWW ’10 ,
2010 .
[ 12 ] G . Marsaglia and W . W . Tsang , “ The ziggurat method for generating random variables , ” Journal of Statistical Software , vol . 5 , no . 8 , pp . 1–7 , 2000 .
[ 13 ] P . Li , T . J . Hastie , and K . W . Church , “ Nonlinear estimators and tail bounds for dimension reduction in l1 using cauchy random projections , ” J . Mach . Learn . Res . , vol . 8 , 2007 .
