2010 IEEE International Conference on Data Mining
Detecting Blackhole and Volcano Patterns in Directed Networks
Zhongmou Li1 , Hui Xiong1 , Yanchi Liu1,2 , Aoying Zhou3
1MSIS Department , Rutgers Business School Newark and New Brunswick
Rutgers , the State University of New Jersey , Newark , NJ 07102 , USA
2School of Economics and Management , University of Science and Technology Beijing , Beijing , China mosesli@pegasusrutgersedu , hxiong@rutgers.edu
3Software Engineering Institute , East China Normal University , Shanghai , China liuyanchi@manageustbeducn ayzhou@seiecnueducn
Abstractâ€”In this paper , we formulate a novel problem for finding blackhole and volcano patterns in a large directed graph . Specifically , a blackhole pattern is a group which is made of a set of nodes in a way such that there are only inlinks to this group from the rest nodes in the graph . In contrast , a volcano pattern is a group which only has outlinks to the rest nodes in the graph . Both patterns can be observed in real world . For instance , in a trading network , a blackhole pattern may represent a group of traders who are manipulating the market . In the paper , we first prove that the blackhole mining problem is a dual problem of finding volcanoes . Therefore , we focus on finding the blackhole patterns . Along this line , we design two pruning schemes to guide the blackhole finding process . In the first pruning scheme , we strategically prune the search space based on a set of pattern size independent pruning rules and develop an iBlackhole algorithm . The second pruning scheme follows a divide and conquer strategy to further exploit the pruning results from the first pruning scheme . Indeed , a target directed graphs can be divided into several disconnected subgraphs by the first pruning scheme , and thus the blackhole finding can be conducted in each disconnected subgraph rather than in a large graph . Based on these two pruning schemes , we also develop an iBlackholeDC algorithm . Finally , experimental results on real world data show that the iBlackhole DC algorithm can be several orders of magnitude faster than the iBlackhole algorithm , which has a huge computational advantage over a brute force method .
Keywords blackhole pattern ; volcano pattern ; fraud detec tion ; graph mining ; network model
I . INTRODUCTION
Financial institutions and government agencies , such as US Securities and Exchange Commission ( SEC ) , are facing some daunting challenges in the field of financial fraud detection . The sophistication of criminalsâ€™ tactics makes detecting and preventing fraud difficult , especially as the number of trading accounts and the volume of transactions grow dramatically . Indeed , the trading networks are vulnerable to these fast growing accounts and the volume of transactions . Particularly , criminals know fraud detection systems are not good at correlating user behavior across multiple trading accounts . This weakness opens the door for cross account collaborative fraud , which is difficult to discover , track and resolve because the activities of the fraudsters usually appear to be normal trading activities . For instance , consider a trading network with a large number of nodes and directed edges , a trader or a group of traders can perform trading only within several accounts for the purpose of manipulating the market . This kind of illegal trading activities is widely known as trading ring .
In this paper , we study a special type of trading ring patterns , called blackhole and volcano patterns . Given a directed graph , a blackhole pattern is a group which is made of a set of nodes in a way such that there are only inlinks to this group from the rest nodes in the graph . In contrast , a volcano pattern is a group which only has outlinks to the rest nodes in the graph . To the best of our knowledge , this is the first time to have the concepts of blackhole and volcano patterns in the directed graphs . In fact , both blackhole and volcano patterns can be observed in realworld trading networks . For example , a blackhole pattern can represent a group of traders who are manipulating the market by performing transactions on a specific stock among themselves for a specific time period . In other words , the overall shares of the target stock in their trading accounts can only increase during this time period , while these traders have produced a large volume of transactions on this stock . After the stock price goes up to a certain degree , these traders start selling off their shares to the public . In this stage , these trading accounts form a volcano pattern which only has outlinks to the rest public accounts .
However , the process for finding blackhole and volcano patterns can be computationally prohibited , since this is a combinatorial problem in nature . To address this challenge , we first prove that the blackhole pattern mining problem is a dual problem of finding volcano patterns . Therefore , we can focus on finding the blackhole patterns . Along this line , we design two pruning schemes to guide the blackhole pattern mining process . In the first pruning scheme , we identify a set of pattern size independent pruning rules by studying the structural graph properties of blackhole patterns . These pruning rules can be used for pruning the search space no matter the size of the patterns is . Based on the first pruning scheme , we design an iBlackhole algorithm for finding
1550 4786/10 $26.00 Â© 2010 IEEE DOI 101109/ICDM201037
294 blackhole patterns . In contrast , the second pruning scheme follows a divide and conquer strategy to further exploit the pruning results from the first pruning scheme . Specifically , because a target directed graph have been divided into several disconnected subgraphs by the first pruning scheme , it becomes much more efficient to find blackhole patterns in each disconnected subgraphs rather than in a large graph . Based on these two pruning schemes , we develop an even more effective algorithm , named iBlackhole DC , for mining blackhole patterns in directed graphs . Furthermore , we have provided the proof of the completeness and correctness of both iBlackhole and iBlackhole DC algorithms .
Finally , experimental results on several real world data sets are provided to show the pruning effect of two pruning schemes . As shown in experiments , the iBlackhole algorithm has a huge computational advantage over the brute force approach . Also , the iBlackhole DC algorithm is several orders of magnitude faster than the iBlackhole algorithm . Finally , we show the effectiveness of blackhole patterns for finding some interesting stock movement patterns .
II . PRELIMINARIES
In this section , we introduce some basic concepts and notations that will be used in this paper .
First , consider a directed graph ğº = ( ğ‘‰ , ğ¸ ) [ 1 ] , where ğ‘‰ is the set of all nodes and ğ¸ is the set of all edges . Assume that ğº has no self loop and has no more than one edge from one node to another . A directed edge ğ‘’ in ğº is denoted as ğ‘’ = ( ğ‘¥ , ğ‘¦ ) , where ğ‘¥ and ğ‘¦ are nodes of ğº and an arc is directed from ğ‘¥ to ğ‘¦ . Each edge ğ‘’ has a positive weight , denoted as ğœ”ğ‘’ , associated with this edge . Definition 1 ( in weight / out weight ) : Given a directed graph ğº = ( ğ‘‰ , ğ¸ ) , ğµ is a set of nodes and ğµ âŠ† ğ‘‰ . Let ğ¶ = ğ‘‰ âˆ– ğµ . The in weight of ğµ is defined as : ğ‘’=(ğ‘¥,ğ‘¦)âˆˆğ¸,ğ‘¥âˆˆğ¶,ğ‘¦âˆˆğµ ğœ”ğ‘’ . Also , the definition of ğ‘‘ğ‘–ğ‘›(ğµ ) = ğ‘’=(ğ‘¥,ğ‘¦)âˆˆğ¸,ğ‘¥âˆˆğµ,ğ‘¦âˆˆğ¶ ğœ”ğ‘’ . the out weight of B is : ğ‘‘ğ‘œğ‘¢ğ‘¡(ğµ ) = Figure 1 shows an example of the in weight and outweight of a set of nodes . The number associated with each edge is the weight of that edge . In this figure , the in weight of ğµ is 6+5 = 11 , while the out weight is 3+3+1+2 = 9 .
âˆ‘
âˆ‘
3
1
4
2
2
4
5
1
3
6
B
5
4
2
3
2
3
1
Figure 1 .
Illustration : in weight and out weight .
Next , we give the definition of blackhole and volcano in a directed graph as follows .
295
Definition 2 ( blackhole ) : Given a directed graph ğº = ( ğ‘‰ , ğ¸ ) , we say that a set of nodes ğµ âŠ† ğ‘‰ form a blackhole , if and only if the following two conditions are satisfied : 1 ) âˆ£ğµâˆ£ â‰¥ 2 , and the subgraph ğº(ğµ ) induced by ğµ is weakly connected , and 2 ) ğ‘‘ğ‘–ğ‘›(ğµ ) âˆ’ ğ‘‘ğ‘œğ‘¢ğ‘¡(ğµ ) > ğœƒ , where ğœƒ is a predefined positive threshold and is typically a very large value . Definition 3 ( volcano ) : Given a directed graph ğº = ( ğ‘‰ , ğ¸ ) , we say that a set of nodes ğ‘‰ ğ‘œğ‘™ âŠ† ğ‘‰ form a volcano , if and only if the following two conditions are satisfied : 1 ) âˆ£ğ‘‰ ğ‘œğ‘™âˆ£ â‰¥ 2 , and the subgraph ğº(ğ‘‰ ğ‘œğ‘™ ) induced by ğ‘‰ ğ‘œğ‘™ is weakly connected , and 2 ) ğ‘‘ğ‘œğ‘¢ğ‘¡(ğ‘‰ ğ‘œğ‘™)âˆ’ ğ‘‘ğ‘–ğ‘›(ğ‘‰ ğ‘œğ‘™ ) > ğœƒ , where ğœƒ is a pre defined positive threshold and is typically a very large value .
III . PROBLEM FORMULATION
In this section , we formulate the problems of detecting blackhole and volcano patterns in a directed graph .
A . A General Problem Formulation
Given a directed graph ğº = ( ğ‘‰ , ğ¸ ) , the goal of detecting blackhole patterns in ğº is to find out the blackhole set , denoted as ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ , such that , 1 ) for each element ğµ âˆˆ ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ , ğµ âŠ† ğ‘‰ and ğµ satisfies the definition of blackhole , and 2 ) for any other set of nodes ğ¶ âŠ† ğ‘‰ and ğ¶ âˆ•âˆˆ ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ , C does not satisfy the definition of blackhole . The problem of detecting volcano patterns can be formulated in a similar fashion .
Next , we show that the problem of detecting blackhole patterns is a dual problem of detecting volcano patterns .
Theorem 1 : The problem of finding out the blackhole set in a directed graph is a dual problem of finding out the volcano set in the same directed graph . Proof : Consider a directed graph ğº = ( ğ‘‰ , ğ¸ ) . Let ğºâ€² = ( ğ‘‰ , ğ¸â€² ) be the inverse graph of ğº , where all the nodes in ğºâ€² are the same as in ğº ; while for each edge ğ‘’ = ( ğ‘¥ , ğ‘¦ ) âˆˆ ğ¸ , there is an edge ğ‘’â€² = ( ğ‘¦ , ğ‘¥ ) âˆˆ ğ¸â€² , and the weight associated with ğ‘’â€² are exactly the same as the weight associated with ğ‘’ . Therefore , the in weight of a set of nodes ğµ in ğº are exactly the same as the out weight of ğµ in ğºâ€² , and vice versa . If ğµ is a blackhole in ğº , which means ğ‘‘ğ‘–ğ‘›(ğµ)âˆ’ ğ‘‘ğ‘œğ‘¢ğ‘¡(ğµ ) > ğœƒ in , we have ğ‘‘ğ‘œğ‘¢ğ‘¡(ğµ)âˆ’ğ‘‘ğ‘–ğ‘›(ğµ ) > ğœƒ . Therefore , ğµ ğº , then in ğºâ€² forms a volcano in ğºâ€² . As a result , the problem of finding out the blackhole set in ğº is equivalent to the problem of finding out the volcano set in ğºâ€²
.
Now that we know the problem of detecting the blackhole set in the original directed graph is equivalent to the problem of detecting the volcano set in the inverse graph . Therefore , in the rest of this paper , we can focus on detecting blackhole patterns in a directed graph .
B . A Simplified Problem Formulation
The above general problem of detecting blackhole patterns is very complex . Instead , in this paper , we focus on a more
Black hole 1
B lackhole 2
Figure 2 . An illustration of the simplified blackhole practical version of this problem . Specifically , we exploit two constraints to simplify the general problem as follows . 1 ) The weights associated with all edges are all equal to 1 . This constraint results that the in weight of a node becomes the in degree and the out weight becomes the out degree ; 2 ) Instead of considering the general version of a blackhole , which satisfies ğ‘‘ğ‘–ğ‘›(ğµ ) âˆ’ ğ‘‘ğ‘œğ‘¢ğ‘¡(ğµ ) > ğœƒ , we simplify the ğ‘ğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ definition with ğ‘‘ğ‘œğ‘¢ğ‘¡(ğµ ) = 0 .
Figure 2 shows an example of the simplified blackhole patterns . In this figure , there are two blackhole patterns , which have been highlighted by dashed circles .
IV . ALGORITHM DESIGN
In this section , we introduce the algorithms for detecting blackhole patterns in a directed graph .
A . A Brute Force Approach First , we present a brute force approach for finding blackhole patterns . From the definition , a set of nodes ğµ âŠ† ğ‘‰ is a simplified blackhole , if and only if : 1 ) âˆ£ğµâˆ£ â‰¥ 2 , and the subgraph ğº(ğµ ) induced by ğµ is weakly connected , and 2 ) ğ‘‘ğ‘œğ‘¢ğ‘¡(ğµ ) = 0 . Therefore , the intuition is really simple : all the possible combinations of the nodes in ğº are checked using the exhaustive search method . For each combination ğµ , if the subgraph ğº(ğµ ) induced by ğµ is weakly connected and ğ‘‘ğ‘œğ‘¢ğ‘¡(ğµ ) = 0 , then ğµ is a blackhole in ğº .
In real world scenarios , it is typically computational prohibited to find all blackhole patterns , since the number of combinations of the nodes is exponentially increased as the number of nodes increase . A practical way is to find blackhole patterns which include only limited number of nodes . Here , we introduce a concept of ğ‘› ğ‘›ğ‘œğ‘‘ğ‘’ ğ‘ğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ . Definition 4 ( n node blackhole ) : Given a directed graph ğº = ( ğ‘‰ , ğ¸ ) , we say that a set of nodes ğµ âŠ† ğ‘‰ is an n node blackhole , if and only if the following two conditions are satisfied : 1 ) ğµ is a blackhole in ğº , and 2 ) ğµ âˆˆ ğ‘‰ ( ğ‘› ) , where ğ‘‰ ( ğ‘› ) is the set of all possible subsets containing ğ‘› nodes in V ; that is , âˆ£ğµâˆ£ = ğ‘› .
Figure 3 shows the pseudocode of the brute force algorithm to detect 2 through n node blackhole patterns in a directed graph ğº . Since we have considered all the possible combinations of nodes in ğº from 2 through n , this algorithm is complete . Also , since for each combination of nodes , we have checked whether it satisfies the definition of blackhole , this algorithm is correct .
ALGORITHM BRUTE FORCE(ğº = ( ğ‘‰ , ğ¸ ) , ğ‘› ) Input :
ğº : the directed graph ğ‘‰ : the set of all nodes ğ¸ : the set of all edges ğ‘› : max number of nodes each blackhole may contain
Output :
1 . 2 . 3 . 4 . 5 . 6 . 7 . 8 . 9 . 10 . 11 .
ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ : 2 to n node blackhole set of ğº ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ â† âˆ… for ğ‘– â† 2 to ğ‘› do for each ğµ âˆˆ ğ‘‰ ( ğ‘– ) do if ğº(ğµ ) is weakly connected then ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ â† ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ if ğ‘‘ğ‘œğ‘¢ğ‘¡(ğµ ) == 0 then
âˆª
ğµ end if end if end for end for return ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’
Figure 3 . The brute force algorithm
B . A Scheme of the iBlackhole Algorithm
In general , finding blackhole patterns in a directed graph is a combinatorial problem . Therefore , as the number of nodes ğ‘› increases , the computation time increases exponentially , making the brute force algorithm unrealistic to obtain the result for a large ğ‘› value . To this end , we introduce some pattern size independent pruning rules to reduce the search space . The key idea behind these pruning rules is to find out irrelevant nodes that have no chance to form an n node blackhole as many as possible , and eliminate these nodes from the candidate search list . In this way , the search space can be reduced dramatically . The algorithm developed based on these pruning rules is named as iBlackhole .
ALGORITHM iBlackhole(ğº = ( ğ‘‰ , ğ¸ ) , ğ‘› ) Input :
ğº : the directed graph ğ‘‰ : the set of all nodes ğ¸ : the set of all edges ğ‘› : max number of nodes each blackhole may contain
Output :
1 . 2 . 3 . 4 . 5 . 6 . 7 . 8 . 9 . 10 .
ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ : 2 to n node blackhole set of ğº ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ â† âˆ… for ğ‘– â† 2 to ğ‘› do establish potential list ğ‘ƒğ‘– remove irrelevant nodes from ğ‘ƒğ‘– , get candidate list ğ¶ğ‘– remove irrelevant nodes from ğ¶ğ‘– , get final list ğ¹ğ‘– apply the Brute Force Algorithm on ğ¹ğ‘– to find out i node blackhole pattern set ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ğ‘– ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ â† ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ end for return ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’
ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ğ‘–
âˆª
Figure 4 . A scheme of the iBlackhole algorithm
Figure 4 shows the scheme of the iBlackhole algorithm for detecting 2 through n node blackhole patterns in a
296
P3
P3
P3
S
V
S
V
S
V
( a )
( b )
( c )
Figure 5 .
Illustration : the cascading delete process directed graph ğº . In this algorithm , all blackhole patterns are identified one by one according to their number of nodes . In each step of finding the i node blackhole patterns , a potential list ğ‘ƒğ‘– is first established . Only the nodes in this potential list have possibilities to form an i node blackhole . In other words , nodes that are not in this list have no chance to be in an i node blackhole pattern . Then nodes in ğ‘ƒğ‘– will be examined one after another and irrelevant nodes will be deleted based on some pruning rules . The results of this pruning form a candidate list ğ¶ğ‘– . For each node v in ğ¶ğ‘– , we will check it again and remove irrelevant nodes from ğ¶ğ‘– using some additional pruning rules . Finally , we will have the final search list ğ¹ğ‘– , and then we can apply the brute force algorithm on ğ¹ğ‘– to find out all i node blackhole patterns . More details about this algorithm will be given after we introduce some pruning rules .
C . Pruning Rules
In this section , we introduce pruning rules associated with the potential list , the candidate list , and the final search list . Definition 5 ( directed path ) : Given a directed graph ğº = ( ğ‘‰ , ğ¸ ) , ğ‘£0 , ğ‘£1 , ğ‘£2 , . . . , ğ‘£ğ‘˜ âˆˆ ğ‘‰ , ğ‘’1 , ğ‘’2 , . . . , ğ‘’ğ‘˜ âˆˆ ğ¸ , where ğ‘’ğ‘– = ( ğ‘£ğ‘–âˆ’1 , ğ‘£ğ‘– ) . We say that the sequence of ğ‘£0ğ‘’1ğ‘£1ğ‘’2ğ‘£2 . . . ğ‘’ğ‘˜ğ‘£ğ‘˜ forms a directed path from ğ‘£0 to ğ‘£ğ‘˜ , if ğ‘£ğ‘– âˆ•= ğ‘£ğ‘— for all 0 â‰¤ ğ‘– , ğ‘— â‰¤ ğ‘˜ , ğ‘– âˆ•= ğ‘— . The length of this directed path is ğ‘˜ . Definition 6 ( reachable ) : Given a directed graph ğº = ( ğ‘‰ , ğ¸ ) , ğ‘¢ , ğ‘£ âˆˆ ğ‘‰ . We say that ğ‘£ is reachable from ğ‘¢ if there is a directed path that starts from ğ‘¢ and ends at ğ‘£ . Definition 7 ( predecessor and successor ) : Given a directed graph ğº = ( ğ‘‰ , ğ¸ ) , ğ‘¢ , ğ‘£ âˆˆ ğ‘‰ . If ğ‘£ is reachable from ğ‘¢ , then we say ğ‘¢ is a predecessor of ğ‘£ , and ğ‘£ is a successor of ğ‘¢ . If there is an edge from ğ‘¢ to ğ‘£ , then ğ‘¢ is a direct predecessor of ğ‘£ , and ğ‘£ is a direct successor of ğ‘¢ . Lemma 1 : If a node ğ‘£ âˆˆ ğµ , where ğµ âŠ† ğ‘‰ is a blackhole , then all the direct successors of ğ‘£ are all in ğµ . Proof : This can be proved by contradiction . Assume that there is at least one of ğ‘£â€²ğ‘  direct successors ğ‘  , and ğ‘  âˆ•âˆˆ ğµ , then we have ğ‘‘ğ‘œğ‘¢ğ‘¡(ğµ ) â‰¥ 1 since ğ‘’ = ( ğ‘£ , ğ‘  ) âˆˆ ğ¸ and ğ‘  âˆ•âˆˆ ğµ . This contradicts with the definition of blackhole . Therefore , all direct successors of ğ‘£ should be in ğµ . Based on Lemma 1 , we have the following lemma .
Lemma 2 : In an n node blackhole ğµ , the maximum out degree of any node in ğµ is ğ‘› âˆ’ 1 .
Proof : This can be proved by contradiction . Suppose there is a node ğ‘£ with out degree at least ğ‘› in an n node blackhole ğµ , then ğ‘£ should have at least ğ‘› direct successors , denoted as ğ‘ 1 , ğ‘ 2 , . . . , ğ‘ ğ‘› . According to Lemma 1 , if ğ‘£ âˆˆ ğµ , all of ğ‘ 1 , ğ‘ 2 , . . . , ğ‘ ğ‘› should be in ğµ , which makes the size of this blackhole at least ğ‘› + 1 . Then we find a contradiction here . Therefore , the maximum out degree of any node in an n node blackhole should be no greater than ğ‘› âˆ’ 1 .
According to Lemma 2 , we can derive the following theorem for pruning the potential list ğ‘ƒğ‘– .
Theorem 2 : For the potential list ğ‘ƒğ‘– , only nodes with out degree less than ğ‘– need to be considered . Proof : By Lemma 2 , the maximum out degree of any node in an n node blackhole is ğ‘›âˆ’ 1 . In other words , nodes with out degree greater than ğ‘– âˆ’ 1 have no chance to be in an i node blackhole . Therefore , only nodes with out degree less than ğ‘– needs to be included in the potential list ğ‘ƒğ‘– .
According to Theorem 2 , only the nodes with out degree less than ğ‘– are used to establish the potential list ğ‘ƒğ‘– . After having ğ‘ƒğ‘– , some additional pruning rules can be applied to remove irrelevant nodes from ğ‘ƒğ‘– to get the candidate list ğ¶ğ‘– . Lemma 3 : For each node ğ‘£ âˆˆ ğ‘ƒğ‘– , if there is at least one of ğ‘£â€²ğ‘  direct successors ğ‘  âˆ•âˆˆ ğ‘ƒğ‘– , then ğ‘£ âˆ•âˆˆ ğ¶ğ‘– . Proof : This can be proved by contradiction . Since ğ‘  âˆ•âˆˆ ğ‘ƒğ‘– , this means ğ‘  has no chance to be in an inode blackhole . Assume that finally ğ‘£ belongs to an inode blackhole ğµ . According to Lemma 1 , all ğ‘£â€²ğ‘  direct successors , which include ğ‘  , will also belong to ğµ . Then we have a contradiction here . Therefore , ğ‘£ has no chance to form an i node blackhole , and thus ğ‘£ can be removed from ğ‘ƒğ‘– safely ; that is , ğ‘£ âˆ•âˆˆ ğ¶ğ‘– .
After a node is removed from ğ‘ƒğ‘– , there are some other nodes associated with it can also be removed from ğ‘ƒğ‘– .
Lemma 4 : If a node ğ‘£ is removed from ğ‘ƒğ‘– , then all of its direct predecessors can also be removed from ğ‘ƒğ‘– . Proof : For each of ğ‘£â€²ğ‘  direct predecessors ğ‘ , ğ‘£ is ğ‘â€²ğ‘  direct successor . Since ğ‘£ has been removed from ğ‘ƒğ‘– , then ğ‘£ âˆ•âˆˆ ğ‘ƒğ‘– . According to Lemma 3 , ğ‘ should also be removed from ğ‘ƒğ‘– . Therefore , all ğ‘£â€²ğ‘  direct predecessors can be removed from ğ‘ƒğ‘– .
297
ALGORITHM iBlackhole(ğº = ( ğ‘‰ , ğ¸ ) , ğ‘› ) Input :
ğº : the directed graph ğ‘‰ : the set of all nodes ğ¸ : the set of all edges ğ‘› : max number of nodes each blackhole may contain
ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ : 2 to n node blackhole set of ğº ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ â† âˆ… for ğ‘– â† 2 to ğ‘› do
ğ‘ƒğ‘– â† {ğ‘£âˆ£ğ‘‘ğ‘œğ‘¢ğ‘¡(ğ‘£ ) < ğ‘–} for each ğ‘£ in ğ‘ƒğ‘– do if at least one of ğ‘£â€²ğ‘  directed successors are not in ğ‘ƒğ‘– then remove ğ‘£ from ğ‘ƒğ‘– remove all ğ‘£â€²ğ‘  predecessors from ğ‘ƒğ‘– end if end for ğ¶ğ‘– â† ğ‘ƒğ‘– for each ğ‘£ in ğ¶ğ‘– do if âˆ£ğ‘£+âˆ£ > ğ‘– then remove ğ‘£ from ğ¶ğ‘– remove all ğ‘£â€²ğ‘  predecessors from ğ¶ğ‘– end if if âˆ£ğ‘£+âˆ£ == ğ‘– then
ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ â† ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ remove ğ‘£ from ğ¶ğ‘– remove all ğ‘£â€²ğ‘  predecessors from ğ¶ğ‘–
ğ‘£+
âˆª end if end for ğ¹ğ‘– â† ğ¶ğ‘– for each ğµ âˆˆ ğ¹ğ‘–(ğ‘– ) do if ğº(ğµ ) is weakly connected then ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ â† ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ if ğ‘‘ğ‘œğ‘¢ğ‘¡(ğµ ) == 0 then
âˆª
ğµ end if end if end for end for return ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’
Figure 7 . The iBlackhole algorithm
Output :
1 . 2 . 3 . 4 . 5 . 6 . 7 . 8 . 9 . 10 . 11 . 12 . 13 . 14 . 15 . 16 . 17 . 18 . 19 . 20 . 21 . 22 . 23 . 24 . 25 . 26 . 27 . 28 . 29 . 30 . 31 . 32 .
â€²â€²ğ‘£â€²â€²
By Lemma 4 , when removing a node ğ‘£ from ğ‘ƒğ‘– , all its direct predecessors should also be removed . Then , the newly s . Finally , removed direct predecessors become the new the cascading delete will spread to all ğ‘£â€²ğ‘  predecessors . Figure 5 shows an example of the cascading delete process when removing node ğ‘£ from the potential list ğ‘ƒ3 . The shadow nodes in the figures are nodes removed from ğ‘ƒ3 . In Figure 5(ğ‘ ) , ğ‘  has an out degree of 3 , which makes it exclude from ğ‘ƒ3 at the first place . When nodes in ğ‘ƒ3 are checked one after another , it can be noticed that ğ‘£ has a successor ğ‘  not in ğ‘ƒ3 . Therefore , ğ‘£ is removed from ğ‘ƒ3 . Then all of ğ‘£â€²ğ‘  direct predecessors are all deleted from ğ‘ƒ3 as shown in Figure 5(ğ‘ ) , and this process spreads to all ğ‘£â€²ğ‘  predecessors in Figure 5(ğ‘ ) .
By applying Lemma 3 and Lemma 4 , we prune rules irrelevant nodes from ğ‘ƒğ‘– , and get the candidate list ğ¶ğ‘– . Before going any further , we would like to introduce another concept first . e d v b a c f g h
Figure 6 . An example of the closure of node ğ‘£
Definition 8 ( closure ) : Given a directed graph ğº = ( ğ‘‰ , ğ¸ ) , ğ‘£ âˆˆ ğ‘‰ . The closure of ğ‘£ , denoted as ğ‘£+ , is defined as : ğ‘£+ = {ğ‘  âˆ£ there is a directed path from v to s} âˆª {ğ‘£} . Figure 6 shows an example of the closure of node ğ‘£ . In this figure , ğ‘£+ = {ğ‘£ , ğ‘ , ğ‘ , ğ‘ , â„ , ğ‘”} . Indeed , the closure of a node has an important feature as the following .
Theorem 3 : The closure of a node ğ‘£ is a blackhole . Moreover , it is a subset of any blackhole that contains ğ‘£ . Proof : For the first part of this theorem , by the definition of closure , ğ‘£+ is the set of all nodes reachable from ğ‘£ , together with ğ‘£ . If ğ‘£+ does not form a blackhole , there have to be at least an edge ğ‘’ = ( ğ‘  , ğ‘¡ ) âˆˆ ğº , such that ğ‘  âˆˆ ğ‘£+ and ğ‘¡ âˆ•âˆˆ ğ‘£+ . If ğ‘  = ğ‘£ , then ğ‘¡ is reachable from ğ‘£ , we have ğ‘¡ âˆˆ ğ‘£+ ; If ğ‘  âˆ•= ğ‘£ , since there is a directed path from ğ‘£ to ğ‘  , and ğ‘’ = ( ğ‘  , ğ‘¡ ) , ğ‘¡ can be reached from ğ‘£ . We can also have ğ‘¡ âˆˆ ğ‘£+ . In either condition , we can have a contradiction here . Therefore , ğ‘£+ is a blackhole . For the second part of this theorem , if a blackhole ğµ contains ğ‘£ , by Lemma 1 , all ğ‘£â€²ğ‘  direct successors should all be in ğµ . And then these direct successors become the new â€²â€²ğ‘£â€²â€² s . Eventually , this procedure will be spread to all the ğ‘£â€²ğ‘  successors . The above leads to ğ‘£+ âŠ† ğµ .
The feature of closure ( Theorem 3 ) can be used to derive some pruning rules to remove some irrelevant nodes from ğ¶ğ‘– , and finally lead to the final search list ğ¹ğ‘– .
298
Lemma 5 : For each node ğ‘£ âˆˆ ğ¶ğ‘– , if âˆ£ğ‘£+âˆ£ > ğ‘– , then ğ‘£ and all its predecessors are not in ğ¹ğ‘– .
Proof : By Theorem 3 , ğ‘£+ is a subset of any blackhole which contains ğ‘£ . Suppose ğ‘£ is in an i node blackhole ğµ . Then we have ğ‘£+ âŠ† ğµ . So âˆ£ğµâˆ£ â‰¥ âˆ£ğ‘£+âˆ£ > ğ‘– . We can have a contradiction here . Therefore , ğ‘£ has no chance to form an i node blackhole , and we can remove ğ‘£ from ğ¶ğ‘– safely . Then , the similar cascading delete procedure can be applied , and thus all the ğ‘£â€²ğ‘  predecessors can be deleted from ğ¶ğ‘– . Therefore , ğ‘£ and all its predecessors will not be in ğ¹ğ‘– . Lemma 6 : For each node ğ‘£ âˆˆ ğ¶ğ‘– , if âˆ£ğ‘£+âˆ£ = ğ‘– , then ğ‘£+ can be outputted as an i node blackhole . Also , ğ‘£ and all its predecessors can be removed from ğ¶ğ‘– . Proof : According to Theorem 3 , ğ‘£+ is a blackhole . Since âˆ£ğ‘£+âˆ£ = ğ‘– , ğ‘£+ can be outputted as an i node blackhole . Assume that ğ‘£ will also be in another blackhole ğµ . By
P3 a b s c v d h i j k g e f
( a )
C3 a b s c v d h i j k g e f
( b )
F3 a b s c v d h i j k g e f
( c )
F 3 a b s c v d h i j k g e f
( d )
Figure 8 . An example of the procedure of the iBlackhole Algorithm
Theorem 3 , ğ‘£+ âŠ† ğµ . If âˆ£ğµâˆ£ > ğ‘– , ğµ is not an i node blackhole and cannot be outputted as an i node blackhole ; If âˆ£ğµâˆ£ = ğ‘– , then ğµ is exactly ğ‘£+ , and has already been out putted as an i node blackhole . In either situation , we can remove ğ‘£ from ğ¶ğ‘– . Then the similar cascading delete procedure can be applied , and finally all ğ‘£â€²ğ‘  predecessors will be deleted from ğ¶ğ‘– .
Lemma 5 and Lemma 6 are used as pruning rules to prune the candidate list ğ¶ğ‘– and get the final search list ğ¹ğ‘– . After having ğ¹ğ‘– , we can apply the brute force approach on ğ¹ğ‘– to find out all i node blackhole patterns . In the next subsection , we will give the details of the iBlackhole algorithm .
D . The iBlackhole Algorithm
The iBlackhole algorithm exploits the pruning rules stated from Lemma 1 to Lemma 6 . Figure 7 shows the detailed pseudocode of the iBlackhole algorithm . Specifically , Line 3 establishes the potential list ğ‘ƒğ‘– . Lines 4 11 remove irrelevant nodes from ğ‘ƒğ‘– , and get the candidate list ğ¶ğ‘– . Lines 12 23 remove irrelevant nodes from ğ¶ğ‘– , and get the final search list ğ¹ğ‘– . Lines 24 30 apply the brute force approach on ğ¹ğ‘– to find out all i node blackhole patterns .
Completeness and Correctness . In the iBlackhole algorithm , since only the nodes that have no chance to form an inode blackhole pattern are removed in each iteration ğ‘– ( this is guaranteed by Lemma 1 through Lemma 6 ) . In other words , all the possible combinations of nodes have been checked to produce ğ¹ğ‘– , this algorithm is complete . Also , for each candidate blackhole pattern , since we have checked whether this candidate pattern satisfies the definition of blackhole or not , this algorithm is correct .
Figure 8 shows an example of the procedure of the iBlackhole algorithm when searching the 3 node blackhole patterns . The shadow nodes in the figures are nodes which have been deleted . In Figure 8(ğ‘ ) , ğ‘  has an out degree of 3 , so ğ‘  can be deleted from ğ‘ƒ3 at the first place . In Figure 8(ğ‘ ) , when we check the nodes in ğ‘ƒ3 one after another , we notice that ğ‘£ has a successor ğ‘  not in ğ‘ƒ3 . Therefore , we can remove ğ‘£ from ğ‘ƒ3 . Then , all the direct predecessors of ğ‘£ can be cascaded deleted from ğ‘ƒ3 , and this delete process spreads to all ğ‘£â€²ğ‘  predecessors . Finally , we have the candidate list ğ¶3 = {ğ‘ , ğ‘ , ğ‘ , ğ‘– , ğ‘— , ğ‘˜} . In Figure 8(ğ‘ ) , we find that âˆ£ğ‘–+âˆ£ = 3 . Therefore , we output ğ‘–+ = {ğ‘– , ğ‘— , ğ‘˜} as a 3 node blackhole , and delete ğ‘– from ğ¶3 . Now , we have the final search list ğ¹3 = {ğ‘ , ğ‘ , ğ‘ , ğ‘— , ğ‘˜} . In Figure 8(ğ‘‘ ) , we examine each 3combination of nodes in ğ¹3 , and find out a 3 node blackhole
{ğ‘ , ğ‘ , ğ‘} . Therefore , there are two 3 node blackhole patterns in this example , {ğ‘ , ğ‘ , ğ‘} and {ğ‘– , ğ‘— , ğ‘˜} respectively .
E . The iBlackhole DC Algorithm
While the search space has been reduced dramatically in the iBlackhole algorithm , it is still possible to develop some pruning strategies for the graphs with some special characteristics . Indeed , for a node ğ‘£ âˆˆ ğ‘‰ , ğ‘£ can only form a blackhole pattern with nodes within the same weakly in ğº by the blackhole definition . connected component Therefore , if a directed graph has several weakly connected components , which are not connected to each other , a divide and conquer pruning strategy can be exploited for first identifying these weakly connected components and the blackhole finding method can be conducted in each weakly connected component . This pruning strategy can drastically divide a large exponential growth search space into several much smaller exponential growth search space , and thus reducing a lot of computational cost .
Along this line , we combine the iBlackhole algorithm with this divide and conquer pruning strategy and develop an even more effective algorithm , named iBlackhole DC , for finding blackhole patterns . Figure 9 shows the scheme of this algorithm for finding out 2 through n node blackhole patterns in a directed graph ğº .
ALGORITHM iBlackhole DC(ğº = ( ğ‘‰ , ğ¸ ) , ğ‘› ) Input :
ğº : the directed graph ğ‘‰ : the set of all nodes ğ¸ : the set of all edges ğ‘› : max number of nodes each blackhole may contain
ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ : 2 to n node blackhole set of ğº ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ â† âˆ… for ğ‘– â† 2 to ğ‘› do establish potential list ğ‘ƒğ‘– remove useless nodes from ğ‘ƒğ‘– , get candidate list ğ¶ğ‘– remove useless nodes from ğ¶ğ‘– , get final list ğ¹ğ‘– for each weakly connected component in ğº(ğ¹ğ‘– ) do apply the Brute Force Algorithm to find out i node blackhole pattern set ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ğ‘– ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ â† ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’
ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’ğ‘–
âˆª end for end for return ğµğ‘™ğ‘ğ‘ğ‘˜â„ğ‘œğ‘™ğ‘’
Figure 9 . A scheme of the iBlackhole DC algorithm
Output :
1 . 2 . 3 . 4 . 5 . 6 . 7 . 8 . 9 . 10 . 11 . 12 .
299
The completeness and correctness of the iBlackholeDC algorithm is straightforward . Since the only difference between iBlackhole and iBlackhole DC is the use of the divide and conquer strategy . We know that the iBlackhole algorithm is complete and correct . Also , the divide andconquer strategy only separates the nodes which cannot form blackhole patterns . Therefore , the iBlackhole DC algorithm is also complete and correct .
V . EXPERIMENTAL RESULTS
In this section , we present the experimental results to evaluate the performances of Brute Force , iBlackhole and iBlackhole DC algorithms .
A . The Experimental Setup
Experimental Data . The experiments were conducted on four real world data sets : Wiki , Amazon , Roget , and Stock . Table I shows some basic characteristics of these data sets .
Table I
DATA CHARACTERISTICS
Data set Wiki Wiki500 Wiki1000 Wiki1500 Wiki1500 full Amazon Amazon1000 Amazon500 full Roget Roget full Stock 0.35
# nodes 7,115 500 1,000 1,500 1,500 262,111 1,000 500 1,022 1,022 2,453
# egdes 103,689 3,865 9,741 16,389 16,820
1,234,877
3,952 1,911 5,075 5,127 273
Wiki Data Set . There are 7,115 nodes and 103,689 edges in the Wiki data set [ 2 ] . To make the brute force algorithm runnable , we derived three subgraphs from the original graph , with the number of nodes 500 , 1,000 , and 1,500 respectively . These subgraphs are named as Wiki500 , Wiki1000 , and Wiki1500 separately . In addition , we synthesized a weakly connected directed graph , named as Wiki1500 full , by adding some edges to Wiki1500 data set .
Amazon Data Set . There are 262,111 nodes and 1,234,877 edges in the Amazon data set [ 3 ] . Similar to the Wiki data set , we derived a subgraph Amazon1000 with 1000 nodes , and synthesized a weakly connected directed graph Amazon500 full from the original graph .
Roget Data Set . There are 1,022 nodes and 5,075 edges in the Roget data set [ 4 ] . Also , we synthesized a weakly connected directed graph Roget full from the original graph , by adding some edges to it .
Stock Data Set . This is a data set generated by ourselves . Specifically , we collected daily stock prices from Wharton Research Data Services [ 5 ] of 3,081 instruments in
Figure 10 . An overview of the Dow Jones Index from Jan 08 to Jun 08
, ğ‘ğ‘–2
, . . . , ğ‘ğ‘–ğ‘¡
, . . . , ğ‘ğ‘–124
, . . . , ğ‘ğ‘–125 the US stock market over a period of 125 consecutive trading days from Jan 2 , 2008 to Jun 30 , 2008 . We tried to avoid selecting the period with a strong movement trend in the stock market , since the movements of all instruments during that period tend to have high correlations among each other . As can be seen in Figure 10 , there was no strong trend in the Dow Jones index during the selected period . Then we removed instruments in Dow Jones and S&P 500 indexes from our collection . Those instruments are more representative in the stock market and therefore tend to have high correlations with the other instruments . Since we target on finding out some not so obvious blackhole patterns , we only consider instruments not in Dow Jones and S&P 500 indexes . After that , we constructed the Stock data set as follows . 1 ) Nodes in this data set correspond to instruments . There are 2,453 nodes in this data set ; 2 ) we build a vector ğ‘ƒğ‘– = } for each instrument , where ğ‘ğ‘–ğ‘¡ {ğ‘ğ‘–1 is the closing price of instrument ğ‘– on day ğ‘¡ ; 3 ) we create a Boolean vector ğµğ‘– = {ğ‘ğ‘–1 } based , ğ‘œğ‘¡â„ğ‘’ğ‘Ÿğ‘¤ğ‘–ğ‘ ğ‘’ 0 ; 4 ) For = 1 , ğ‘–ğ‘“ ğ‘ğ‘–ğ‘¡+1 on ğ‘ƒğ‘– , where ğ‘ğ‘–ğ‘¡ ğ‘‹ = {ğ‘¥1 , . . . , ğ‘¥ğ‘¡ , . . . , ğ‘¥ğ‘›} and ğ‘Œ = {ğ‘¦1 , . . . , ğ‘¦ğ‘¡ , . . . , ğ‘¦ğ‘›} , ğœŒğ‘¥ğ‘¦(ğ‘˜ ) is the lagged correlation when ğ‘Œ is delayed by ğ‘˜ . A symmetric situation can be applied to get ğœŒğ‘¦ğ‘¥(ğ‘˜ ) . We compute the lagged correlations ğœŒğ‘–ğ‘—(1 ) and ğœŒğ‘—ğ‘–(1 ) for each pair of instrument ğ‘– and ğ‘— ; 5 ) there is an edge from node ğ‘— to node ğ‘– , if ğœŒğ‘–ğ‘—(1 ) > ğœƒ , where ğœƒ is a pre defined threshold , and vice versa . Since we compute the lagged correlation of 1day delay between two instruments , if there is an edge from node ğ‘— to node ğ‘– , it indicates the movement of instrument ğ‘— followed the movement of instrument ğ‘– on the previous day . Here , we specify ğœƒ as 0.35 to get Stock 0.35 data set . Note that the method we used to construct the Stock data set is similar to the way in [ 6 ] . However , there are some differences . We used the lagged Pearson correlation among instruments , and ended up with a directed graph . While Boginski et al [ 6 ] employed the general Pearson correlation and constructed an undirected graph .
, ğ‘ğ‘–2 , . . . , ğ‘ğ‘–ğ‘¡ â‰¥ ğ‘ğ‘–ğ‘¡
Experimental Platform . All the experiments were performed on a Dell Optiplex 960 Desktop with Intel Core 2 Quad Processor Q9550 and 4 GB of memory running the Windows XP Professional Service Pack 3 operating system .
300 i
) c e s ( e m T g n n n u R i i
) c e s ( e m T g n n n u R i
105
104
103
102
101
100
10âˆ’1
10âˆ’2
2
104
103
102
101
100
10âˆ’1
10âˆ’2
10âˆ’3
10âˆ’4
2
Bruteâˆ’Force iBlackhole iBlackholeâˆ’DC
3
4
5
6
7
Number of Nodes
8
9
10 i
) c e s ( e m T g n n n u R i
105
104
103
102
101
100
10âˆ’1
10âˆ’2
10âˆ’3
2
Bruteâˆ’Force iBlackhole iBlackholeâˆ’DC
3
4
5
6
7
8
9
10
Number of Nodes i
) c e s ( e m T g n n n u R i
105
104
103
102
101
100
10âˆ’1
10âˆ’2
10âˆ’3
2
Bruteâˆ’Force iBlackhole iBlackholeâˆ’DC
3
4
5
6
7
Number of Nodes
8
9
10
( a ) Wiki1000
( b ) Amazon1000
( c ) Roget
Figure 11 . The running time of Brute Force , iBlackhole , and iBlackhole DC algorithms on different data sets
Bruteâˆ’Force iBlackhole iBlackholeâˆ’DC
Bruteâˆ’Force iBlackhole iBlackholeâˆ’DC i
) c e s ( e m T g n n n u R i
105
104
103
102
101
100
10âˆ’1
10âˆ’2
2
3
4
8
9
10
3
4
5
6
7
Number of Nodes
5
6
7
8
9
10
Number of Nodes i
) c e s ( e m T g n n n u R i
106
105
104
103
102
101
100
10âˆ’1
10âˆ’2
2
Bruteâˆ’Force iBlackhole iBlackholeâˆ’DC
3
4
5
6
7
Number of Nodes
8
9
10
( a ) Wiki500
( b ) Wiki1000
( c ) Wiki1500
Figure 12 . The running time of Brute Force , iBlackhole , and iBlackhole DC algorithms for different # nodes
B . An Overall Comparison
In this subsection , we provide an overall comparison of
Brute Force , iBlackhole , and iBlackhole DC algorithms .
First , we compare the performances of three algorithms on different data sets with almost the same number of nodes . In this experiment , we choose data sets Wiki1000 , Amazon1000 , and Roget . Figure 11 shows the running time of these algorithms . As can be seen , both BruteForce and iBlackhole algorithms are runnable within certain number of nodes , while iBlackhole can go a litter bit further than Brute Force . In contrast , the iBlackhole DC algorithm is runnable for finding n node blackhole patterns with a large ğ‘› value .
The running time of three algorithms for detecting blackhole patterns with different number of nodes forms three approximately straight lines in logarithm scale for all three data sets . ( For iBlackhole DC , it is more clear if we only focus on ğ‘› â‰¥ 4 ) . This indicates that the running time for those algorithms follow an exponential increasing time . Also , the slopes of three performance curves for each data set are significantly different . For Brute Force , since we do the exhaust search at the beginning and the number of nodes of the three data sets are almost the same , the slopes in those three subfigures are almost the same . For iBlackhole , as well as iBlackhole DC , they are a little different . The slope of the curve on the Wiki1000 data set is larger than slopes in Amazon1000 and Roget . For both iBlackhole and iBlackhole DC , we prune irrelevant nodes from each data set . However , the pruning effect depends on the graph properties of each data set ( ie the average in degree and out degree plays an important role ) . This makes the running time of iBlackhole and iBlackhole DC algorithms vary for different data sets , but after all , much less than the BruteForce algorithm .
Next , we compare the performances of three algorithms on the same data set with different number of nodes . In this experiment , we choose data sets Wiki500 , Wiki1000 , and Wiki1500 . Figure 12 shows the running time of these three algorithms on those three data sets .
The overall performances of these three algorithms are very similar to the first experiment . However , there are still something interesting here . We can observe that the slopes of the three lines in these three data sets are almost the same . ( For iBlackhole DC , it is more clear if we only focus on ğ‘› â‰¥ 4 ) . Since these three subgraphs are derived from the same network , the inherent graph properties of these data sets are similar . The above might be the reason that similar slopes are observed in the results .
C . iBlackhole vs . iBlackhole DC
In this compare subsection , we the performances of iBlackhole and iBlackhole DC algorithms . We show how significant strategy improves the performance of In this experiment , we choose three synthetical weakly connected directed networks , Amazon500 full , Roget full , and Wiki1500 full . the divide and conquer iBlackhole .
Figure 13 shows the running time of these two algorithms on those three data sets . In the figure , we can see that the performance of iBlackhole DC is several orders of magnitude faster than the performance of iBlackhole , since it drastically divides a large exponential growth search space into several much smaller exponential growth search space , and thus reduces a lot of computational cost .
301 i
) c e s ( e m T g n n n u R i
105
104
103
102
101
100
10âˆ’1
10âˆ’2
10âˆ’3
2
3
4 iBlackhole iBlackholeâˆ’DC
104
102
100
10âˆ’2 i
) c e s ( e m T g n n n u R i
5
6
7
Number of Nodes
8
9
10
2
3
4 iBlackhole iBlackholeâˆ’DC iBlackhole iBlackholeâˆ’DC
104
102
100 i
) c e s ( e m T g n n n u R i
8
9
10
10âˆ’2
2
3
4
5
6
7
Number of Nodes
8
9
10
5
6
7
Number of Nodes
( a ) Amazon500 full Figure 13 . The running time of iBlackhole algorithm and iBlackhole DC algorithm on different data sets
( c ) Wiki1500 full
( b ) Roget full
Figure 14 shows the visualizations of the structures of different data sets before and after applying the first pruning scheme to these data sets while detecting 7 node blackhole patterns . This figure is drawn with Pajek [ 7 ] . From this figure , we can observe that the number of nodes in each data set decreases dramatically after pruning , and each network becomes very sparse . Table II shows some main characteristics of the data sets after pruning . As can be seen , while the original data sets are all weakly connected , we can still get a large number of connected components after pruning . Therefore , the divide and conquer strategy can help dramatically reduce the search space .
CHARACTERISTICS OF DATA SETS AFTER PRUNING
Table II
Data set
Amazon500
Roget
Wiki1500
# nodes
# edges
# connected comp
14 32 252
36 37 209
3 11 43 i g n n u r P e r o f e B i g n n u r P r e Ä A
Pajek
Pajek
Pajek
Amazon500
Pajek
Roget
Pajek
Wiki1500
Pajek
Figure 14 . Structures of different data sets before and after pruning
D . Blackhole Patterns in the Stock Data
Here , we show an application of blackhole patterns for understanding the structural relationship of stock movement .
Figure 15 shows two blackhole patterns identified in the Stock 0.35 data set . Owens Corning ( OC ) is in the left blackhole pattern . The Westmoreland Coal Company ( WLB ) has an outlink to OC . This indicates that the price movement of WLB followed the price movement of OC . By doing some research , we find out Owens Corning is one
302
OC
WLB
CDL
ISIL
A DCT
T KR
TRID
VQ
H P
MTEX
ZRAN
Figure 15 . Two blackhole patterns identified in Stock 0.35 data set of the biggest building material producers in the country . Its products include the manufactured stone products used in the building . In recent years , there is a trend in the industry that companies are developing new innovative building materials by recycling the waste in the energy industry , which are primarily the residual byproducts of coal combustion . As an energy company , WLB owns five coal mines . Therefore , it is understandable that the stock price of the Westmoreland Coal Company has a lag correlation with the stock price of Owens Corning . The other two companies in this pattern are Venoco Inc . ( VQ ) and Helmerich & Payne Inc . ( HP ) . Venoco Inc . is an energy company primarily engaged in the acquisition , exploration , exploitation , and development of oil and natural gas properties , while Helmerich & Payne Inc . is a contract drilling company drilling oil and gas wells for others . Therefore , it is not surprising that the stock price movements of these two companies are lag correlated with the stock price of the Westmoreland Coal Company .
The second blackhole pattern is a star shaped blackhole , which indicates the stock prices for the other six instruments are triggered by Citadel Broadcasting Corp . ( CDL ) . Among these six companies , there are one telecommunication company ( ADCT ) , three IC related companies ( ISIL , TRID , and ZRAN ) , and one highly engineered steel produce company ( TKR ) , which are all related to the Broadcasting Corporation to some extent . The other company is a wellness solution provider , which may be involved in this pattern by chance or for some unknown reasons .
This application is just a simple indication of the use of the blackhole patterns . Indeed , the blackhole patterns can provide an unique view of some structural properties , and help us better understand the interactions among some nodes in the network . However , we should note that this use of blackhole patterns is still preliminary and more comprehensive studies are expected in the future .
VI . RELATED WORK
Related work can be grouped into two categories . The first category includes the work on frequent subgraph mining , which studies how to efficiently find frequent subgraphs in the graph data . For instance , Jiang et al . [ 8 ] proposed a measure for mining globally distributed frequent subgraphs in a single labeled graph . Meanwhile , there are many works in mining frequent subgraphs in multiple labeled graphs [ 9 ] , [ 10 ] , [ 11 ] , [ 12 ] , [ 13 ] , [ 14 ] . The problem of detecting blackhole patterns is different from the above works for two reasons . First , the definition of blackhole patterns is different from the definition of frequent subgraphs . Second , blackhole patterns are identified whether they are frequent or not .
The second category includes the works for detecting community structures in large networks . Communities in a network are groups of nodes within which connections are dense , but between which connections are sparse [ 15 ] . There are a lot of works on how to detect communities in a network . For instance , Newman and Girvan [ 16 ] , [ 17 ] proposed a betweenness based method , Hopcroft [ 18 ] proposed a stable method , and Ghosh [ 19 ] proposed a global influence based method to detect community structures . All these methods detect community structures based on certain definitions and criteria . However , the definition of blackhole patterns is different from the above definitions of communities . Also , once a network has been decided , the number of n node blackhole patterns is determined . In contrast , it is usually difficult to know how many community structures are in the network .
VII . CONCLUDING REMARKS
In this paper , we formulated a problem of finding blackhole and volcano patterns in directed networks . Both blackhole and volcano patterns can be observed in real world scenarios , such as the trading ring for market manipulation . Indeed , it is essentially a combinatorial problem for mining blackhole or volcano patterns . To reduce the complexity of the problem , we first proved that the problem of finding blackhole patterns is a dual problem of finding volcano patterns . Thus , we could be only focused on mining blackhole patterns . To that end , we derived two pruning schemes . The first scheme is based on a set of size independent pruning rules which can help to prune the candidate search space effectively and thus can dramatically reduce the computational cost of blackhole mining . Based on the first pruning scheme , we developed the iBlackhole algorithm for mining blackhole patterns . In addition , the second scheme is to take advantage of an unique graph property ; that is , we could search in each individual subgraphs if the target directed graph contains several disconnected subgraphs . Therefore , by exploiting these two pruning schemes , we developed the iBlackhole DC algorithm for finding blackhole patterns .
Finally , as shown in the experimental results , the pruning effect of both pruning schemes is significant and the iBlackhole DC algorithm is several order of magnitude faster than the iBlackhole algorithm , which outperforms a brute force approach by several orders of magnitude as well .
VIII . ACKNOWLEDGEMENTS
The authors were supported in part by National Science Foundation ( NSF ) via grant number CCF 1018151 , and National Natural Science Foundation of China ( NSFC ) via project number 60925008 .
REFERENCES
[ 1 ] R . Diestel , Graph Theory ( Graduate Texts in Mathematics ) .
Springer , 2006 .
[ 2 ] J . Leskovec , K . Lang , and et al , â€œ Community structure in large networks : Natural cluster sizes and the absence of large well defined clusters , â€ in arXiv:0810.1355 , 2008 .
[ 3 ] J . Leskovec , L . Adamic , and B . Adamic , â€œ The dynamics of viral marketing , â€ ACM TWEB , vol . 1 , 2007 .
[ 4 ] V . Batagelj and A . Mrvar .
Pajek datasets , 2006 . http://vladofmfuni ljsi/pub/networks/data
[ 5 ] Wharton Research Data Services , University of Pennsylvania . https://wrdswhartonupennedu/wrdsauth/memberscgi
[ 6 ] V . Boginski , S . Butenko , and P . M . Pardalos , â€œ Statistical analysis of financial networks , â€ Computational Stat . and Data Analysis , vol . 48 , pp . 431â€“443 , 2005 .
[ 7 ] W . Nooy , A . Mrvar , and V . Batagelj , Exploratory Social Network Analysis with Pajek . Cambridge University Press , 2005 .
[ 8 ] X . Jiang , H . Xiong , C . Wang , and A . H . Tan , â€œ Mining globally distributed frequent subgraphs in a single labeled graph , â€ Data and Knowledge Engineering , vol . 68 , pp . 1034â€“1058 , 2009 .
[ 9 ] X . Yan and J . Han , â€œ gspan : Graph based substructure pattern mining . â€ in IEEE ICDMâ€™02 , 2002 .
[ 10 ] C . Wang , W . Wang , J . Pei , Y . Zhu , and B . Shi , â€œ Scalable mining of large disk based graph databases , â€ in ACM SIGKDDâ€™04 , 2004 .
[ 11 ] J . Huan , W . Wang , and J . Prins , â€œ Efficient mining of frequent subgraphs in the presence of isomorphism , â€ in IEEE ICDMâ€™03 , 2003 .
[ 12 ] J . Wang , W . Hsu , M . Lee , and C . Sheng , â€œ A partition based approach to graph mining , â€ in ICDE 2006 , 2006 , p . 74 .
[ 13 ] M . Kuramochi and G . Karypis , â€œ Finding frequent patterns in a large sparse graph . â€ Data Min . Knowl . Discov . , vol . 11 , no . 3 , pp . 243â€“271 , 2005 .
[ 14 ] D . J . Cook and L . B . Holder , â€œ Substructure discovery using minimum description length and background knowledge . â€ J . Artif . Intell . Res . ( JAIR ) , vol . 1 , pp . 231â€“255 , 1994 .
[ 15 ] M . E . J . Newman , â€œ Detecting community structure in net works , â€ Eur . Phys . J . B , vol . 38 , pp . 321â€“330 , 2004 .
[ 16 ] M . E . J . Newman and M . Girvan , â€œ Finding and evaluating community structure in networks , â€ Phys . Rev . E 69 , vol . 026113 , 2004 .
[ 17 ] M . Girvan and M . E . J . Newman , â€œ Community structure in social and biological networks , â€ in Proc . National Acad . Science , 2002 .
[ 18 ] J . Hopcroft , O . Khan , and et al , â€œ Natural communities in large linked networks , â€ in ACM SIGKDDâ€™03 , 2003 .
[ 19 ] R . Ghosh and K . Lerman , â€œ Community detection using a measure of global influence , â€ in SNA KDDâ€™08 , 2008 .
303
