A Generic Graph based Multidimensional
Recommendation Framework and Its Implementations
School of Computer Science and Engineering , Seoul National University , Seoul , Korea
{liza183 , sglee}@europasnuackr
Sangkeun Lee supervised by Sang goo Lee Intelligent Data Systems Lab for the increasing framework , we propose
ABSTRACT As the volume of information on the Web is explosively growing , recommender systems have become essential tools for helping users to find what they need or prefer . Most existing systems are two dimensional in that they only exploit User and Item dimensions and perform a typical form of recommendation ‘Recommending Item to User’ . Yet , in many applications , the capabilities of dealing with multidimensional information and of adapting to various forms of recommendation requests are very important . In this paper , we take a graph based approach to accomplishing such requirements in recommender systems and present a generic graph based multidimensional recommendation framework . Based on two homogeneous graph based and one heterogeneous graph based multidimensional recommendation methods . We expect our approach will be useful recommendation performance and enabling flexibility of recommender systems so that they can incorporate various user intentions into their recommendation process . We present our research result that we have reached and discuss remaining challenges and future work . Categories and Subject Descriptors H33 [ Information Search and Retrieval ] : Information Search and Retrieval – Information filtering , Retrieval models General Terms Algorithms , Design , Experimentation . Keywords Multidimensional , Recommender systems , Context aware recommender systems , Random walks , Implicit feedback , Usage log , Context awareness . 1 . INTRODUCTION As the information on the Web becomes larger and more diverse , it has become more difficult for users to find what they really want . As a result , recommender systems have become necessary for dealing with such information overload . So far , recommender systems have been widely researched both by industry and academia . Typical recommender systems consider User and Item dimensions in recommendation process and perform a particular form of recommendation that is ‘Recommending Item to User’ . More formally , they consider the recommendation problem as a problem of finding an effective utility function : ( cid:1847)(cid:1857)(cid:3400)(cid:1835)(cid:1857)(cid:1865)(cid:1372 ) ( cid:1847)(cid:1861)(cid:1864)(cid:1861)(cid:1877 ) , which estimates utilities of items for a given user [ 1 ] . improving focused on the performance of
They have
Copyright is held by the International World Wide Web Conference Committee ( IW3C2 ) . Distribution of these papers is limited to classroom use , and personal use by others . WWW 2012 Companion , April 16–20 , 2012 , Lyon , France . ACM 978 1 4503 1230 1/12/04 . on the user ’s focusing contextual information recommendation with respect to various criteria such as accuracy , diversity , serendipity , and etc . [ 2 ] ; but , there have been few realizing Multidimensional researches recommendation ( MDR ) . Recently , the importance of MDR has been emphasized , as it is considered to be very effective for achieving better users’ satisfaction . There are two main goals in MDR [ 3 ] . Firstly , MDR systems aim to more accurately identify user preferences by exploiting additional dimensions ( eg , Location , Time , Season , etc . ) to the User and Item dimensions . For example , when a user requested a recommendation for Vacation , a user ’s preference on a ski resort or a beach may largely depend on Season . Thus , in this case , MDR systems aim to consider Season dimension into recommendation process for more accurate recommendation result . Secondly , MDR systems aim to perform not only ‘Recommending Item to User’ but also other various queries by incorporating multidimensional information . There can be many queries with different user intentions . For example , a user may want to request a recommendation for songs that are often played by the user ’s friends or for songs whose genres are similar with the user ’s favorite genres . Similarly , a user may want to incorporate into recommendation or not depending on situations . MDR systems need an expressive and unambiguous way for users and systems to represent and process various queries . However , achieving MDR is challenging . In many cases , it is not straightforward to extend well known and commonly used existing two dimensional recommendation models ( eg k NN CF , matrix factorization , etc . ) to support MDR . Also , it is not trivial to define a language for representing various user queries with different intentions . Furthermore , because the search space becomes significantly larger when dealing with multidimensional data , the data sparsity issue becomes very critical . We tackle such challenges by taking a graph based approach and propose a generic graph based MDR framework . Then , based on our framework , we introduce three methods that construct and utilize different types of graphs that are Co occurrence Graph , Contextual Bipartite Graph , and Heterogeneous Data Graph . First two methods are based on homogeneous graph model , and the last one is based on heterogeneous graph model . For each method , we demand for a node ranking measure that can reasonably quantify the proximity between a given query and nodes two homogeneous graph based methods , we adapt Personalized PageRank [ 4 ] , which is widely used and known to be an effective node ranking measure . For the heterogeneous graph based method , we define a new node ranking measure , named PathRank by extending Personalized PageRank to take advantage of various types of edges in heterogeneous graph , and we adapt PathRank for our third method . target entities . For represent first that the
WWW 2012 – PhD SymposiumApril 16–20 , 2012 , Lyon , France161 The remainder of this paper is organized as follow . Section 2 presents research background and related work . In section 3 , we present a generic graph based MDR framework and its expected advantages . In section 4 , we introduce our MDR methods based on the proposed framework . In section 5 , we explain the result that we have reached so far . Section 6 concludes our work and discusses future work . 2 . RELATED WORK Traditional recommendation methods are generally classified into two main categories , Content based Filtering ( CBF ) and Collaborative Filtering ( CF ) . For a given user , CBF recommends items that are similar with the ones previously liked by the user . On the other hand , CF utilizes the other users’ item preferences and aggregates them to estimate the given user ’s unknown item preferences . Many variations of CF have been introduced such as user based k NN CF , item based k NN CF , matrix factorization , and etc [ 5 ] . CF approaches have been acknowledged to be practical and popularly used in many real world applications [ 6 ] ; but they do not consider additional information other than User and Item for their recommendation process . Since Adomavicius et al.[7 ] introduced the concept , several studies on MDR have been presented . Reduction based approach [ 3 ] recommends items according to the given user ’s context by only using the users’ prior item preferences that match the current context . It can be straightforwardly applied to many existing algorithms , but the data sparsity problem often becomes more serious due to too much filtering . To resolve the problem , some methods have been introduced such as Disjunction based approach [ 8 ] and Learning to Rank approach [ 9 ] . Yet , all of these methods fix the recommendation form and do not allow users to express their intentions . There have been few approaches that aim to achieve [ 10][11 ] . Such approaches require an ordinary user to learn structured language or usages of operators in order to request a recommendation . Earlier graph based recommender methods have a common point in that they are based on homogeneous graphs . Generally , they take advantage of existing node ranking measures defined on homogeneous graph such as PageRank [ 12 ] , Personalized PageRank [ 4 ] , and HITS [ 13 ] . Fouss et al . [ 14 ] compared several random walk based quantities for measuring relatedness between users and movies on bipartite graph . Gori et al . [ 15 ] presented a random walk based item scoring algorithm , ItemRank , reflecting propagation and attenuation properties . Both approaches only consider User and Item . Lately , some studies have attempted to utilize additional information . Xiang et al . [ 16 ] presented a method that aim to improve accuracy by blending users’ shortterm and long term preferences . Although heterogeneous graph can express real world objects and their relationships much more expressively , heterogeneous graphbased multidimensional recommenders systems and node ranking measures defined on heterogeneous graph are relatively less studied [ 17 ] . ObjectRank [ 18 ] first introduced that considering many types of edges differently could influence node ranking results . It computes revised Personalized PageRank based on differently assigned authority flows to each type of edge . There have been a few studies that consider paths importantly for ranking on heterogeneous graph . PathSim [ 17 ] presents a novel node similarity measure on heterogeneous graph and gives more freedoms to users to express their requirement by defining meta paths . However , because it can be defined only between the same types of objects , it cannot be directly used for our method in that recommendation flexibility of we need to measure relatedness between different types of objects such as User and Item . 3 . PROPOSED APPROACH
Figure 1 : A Generic Graph based Multidimensional
Recommendation Framework and each entity this framework , MDR problem
Figure 1 depicts a generic framework of our general graph based MDR describing inputs and outputs in the overall process of graph based MDR . In is considered as a problem of finding most relevant nodes for a given query that is a set of nodes on graph , where the nodes represent entities . We first transform various data sources ( eg user ratings , item consumption logs , etc . ) into a graph based on data transformation rules . is a set of nodes that represent entities , and is a set of edges that represent relationships between entities . Then , we enrich the created graph by adding nodes and edges based on additional knowledge . For example , when we created User nodes , we could add SimilarTaste edges between them by comparing their preferences on items . A user can express his or her recommendation request as a recommendation query , and it can be represented using various features of graph model such as nodes , paths , and their weights . By adapting a node ranking measure defined on graph , we can that estimates the relatedness define a utility function between given query that is represented as a in graph . After ranking nodes in the graph , we perform a node post processing the recommendation results . In this framework , the step 2 process can be omitted if not needed . Several aspects like data transformation rules , query representations and expressiveness , and node ranking measures can vary depending on implementations of our framework There are three main benefits of adopting graph based approach for MDR . Firstly , because graph data model is suitable to deal with heterogeneous information , we can reasonably represent various real world objects and their relationships as nodes and edges in graph . Secondly , without understanding complicated language , users can describe their recommendation queries using graph features ( eg , nodes , paths , etc ) Lastly , we can benefit from not only direct relationships but also indirect relationships between nodes . This is very helpful for resolving data sparsity problem that is known to be a serious problem when dealing with multidimensional data [ 8 ] . 4 . METHODOLOGY In this section , we introduce three different implementations of our framework . These implementations can be categorized into to generate a top k entity list as the
WWW 2012 – PhD SymposiumApril 16–20 , 2012 , Lyon , France162 graph as follow : dimension , and its values can be considered as its entities . We request for songs that are suitable for the user ‘Matt’ and location
( cid:1868)(cid:4688)(cid:1868)(cid:3435)(cid:1867),(cid:1867)(cid:3439 ) ( cid:3400 ) 1(cid:1864)1 , 0 , differentiate the strategies to create nodes and assign edges in graphs . Co occurrence Graph based Method ( CG ) [ 19 ] : It transforms a two groups that are homogeneous graph based and heterogeneous graph based methods . 4.1 Homogeneous Graph based Method We introduce two methods that are based on homogeneous graphs that have only one edge type . We use a log table ( cid:1838 ) as an input for the both methods . Each attribute in table ( cid:1838 ) can be considered as a denote an entity ( cid:1867)whose dimension is ( cid:1830 ) by ( cid:1867)(cid:1488)(cid:1830 ) . We assume that a recommendation query ( cid:1843 ) is given as ( cid:4668)(cid:1841),(cid:1830)(cid:4669 ) , where ( cid:1841 ) is a set of entities ( cid:4676)(cid:1867 ) ,(cid:1867)(cid:2870),…(cid:1867)(cid:3292)(cid:4677 ) and ( cid:1830 ) is recommendation target dimension ( eg ( cid:1841)(cid:1840)(cid:1833 ) ) . For instance , when ( cid:1841)(cid:4668)‘(cid:1839)(cid:1853)’(cid:1488 ) ( cid:1847)(cid:1831),’(cid:1857)(cid:1867)(cid:1864)’(cid:1488)(cid:1838)(cid:1841)(cid:1829)(cid:1827)(cid:1846)(cid:1835)(cid:1841)(cid:1840)(cid:4669 ) and(cid:1830)(cid:1841)(cid:1840)(cid:1833 ) for a query ( cid:1843)(cid:4668)(cid:1841),(cid:1830)(cid:4669 ) , the query can be interpreted as a recommendation ‘Seoul’ . Both methods transform the log table ( cid:1838 ) into graphs ( cid:1833)(cid:4666)(cid:1848),(cid:1831)(cid:4667 ) , where each node ( cid:1488)(cid:1848 ) corresponds to a set of entities , and weight of each edge ( cid:1857)(cid:1488)(cid:1831 ) represents the strength of relationship between two entities ( cid:1867 ) and ( cid:1867 ) ; however they given log table ( cid:1838 ) into a graph based on co occurrence of entities in the same tuples of ( cid:1838 ) . For every entity ( cid:1867 ) appeared in the log table ( cid:1838 ) , we create a node ( cid:3042 ) that corresponds to the entity . Then , we compute |(cid:1848)|(cid:3400)|(cid:1848)| transition matrix ( cid:1842)(cid:3004)(cid:3008 ) whose element ( cid:1868 ) is the weight of an edge between node and for constructed ( cid:1868)(cid:3435)(cid:1867),(cid:1867)(cid:3439)(cid:3408)0 where ( cid:1868)(cid:3435)(cid:1867),(cid:1867)(cid:3439 ) is the probability of co occurrence of two entities ( cid:1867 ) and ( cid:1867 ) in the tuples of ( cid:1838 ) , and ( cid:1864 ) is the number of dimensions in ( cid:1838 ) ( cid:4666)(cid:1864)(cid:3410)2(cid:4667 ) . Edge ( cid:1857 ) between and exists iff ( cid:1868)(cid:3408)0 . method transforms a given log table ( cid:1838 ) into a bipartite graph based on recommendation factor set ( cid:1832 ) . Each recommendation factor ( cid:1858)(cid:1488)(cid:1832 ) is defined as {(cid:1830)(cid:3033)(cid:3284 ) , ( cid:1875)} . ( cid:1830)(cid:3033)(cid:3284 ) is a set of one or more than one recommendation results , and ( cid:1875 ) is the weight of ( cid:1858 ) , in other method , we first create a node set ( cid:1848)(cid:1848)(cid:1515)…(cid:1515)(cid:1848)(cid:1515)…(cid:1515)(cid:1848)||(cid:1515 ) ( cid:1848 ) . The nodes in ( cid:1848 ) correspond to the entity combination whose dimensions match the dimensions in ( cid:1830)(cid:3033)(cid:3284 ) , and the nodes in ( cid:1848 ) correspond to the entities of target dimension ( cid:1830 ) . Next , we compute a |(cid:1848)|(cid:3400)|(cid:1848)| weighted adjacent matrix ( cid:1839 ) whose element ( cid:1865 ) is the weight of an edge between node and as follow : ,(cid:1861)(cid:1858 ) ( cid:1489)(cid:1848 ) ( cid:1853)(cid:1856 ) ( cid:1488)(cid:1848 ) ( cid:1829)(cid:4666)(cid:1861),(cid:4667 ) ( cid:1865 ) ( cid:4688 ) ( cid:1829)(cid:4666)(cid:1861),(cid:4667 ) ( cid:3400)(cid:1875)(cid:3038 ) ,(cid:1861)(cid:1858 ) ( cid:1488)(cid:1848 ) ,(cid:1489)(cid:1848),(cid:1853)(cid:1856 ) ( cid:1488)(cid:1848)(cid:3038 ) 0 ,(cid:1867)(cid:1860)(cid:1857)(cid:1875)(cid:1861)(cid:1857 ) where ( cid:1829)(cid:4666)(cid:1861),(cid:4667 ) is the co occurrence number of entities ( cid:1867 ) and ( cid:1867 ) in the tuples of ( cid:1838 ) , and ( cid:1875)(cid:3038 ) is the weight of ( cid:1858)(cid:3038 ) that ( cid:1848)(cid:3038 ) corresponds to . ( cid:1842)(cid:3004)(cid:3003)(cid:3008 ) as follow : words , how much this factor will affect the recommendation results . We assume that users can reflect their intentions by changing the recommendation factors . To create a graph for this
Contextual Bipartite Graph based Method ( CBG ) [ 20 ] : This
Now , we normalize the matrix M to achieve the transition matrix
( cid:1868)(cid:3435)(cid:1867),(cid:1867)(cid:3439)0 non target dimensions whose combination will affect
( cid:1865 ) ∑ ( cid:3286)(cid:1488)(cid:3042)(cid:3047)(cid:3039)(cid:3038)(cid:4670)(cid:3284)(cid:4671 )
The final constructed graph G that is represented by the matrix P
For both CG and CBG , we adapt Personalized PageRank to compute utility of each entity for a given query . From the query
,(cid:1861)(cid:1858 ) ( cid:1867)(cid:1864)(cid:1861)(cid:1863)(cid:4670)(cid:4671)(cid:3405)0 ( cid:1865)(cid:3038 ) ( cid:1868)(cid:4688 ) 0,(cid:1867)(cid:1860)(cid:1857)(cid:1875)(cid:1861)(cid:1857 ) is bipartite in that there are no edges between nodes ( cid:1488 ) ( cid:1848 ) ( cid:1853)(cid:1856 ) ( cid:1488)(cid:1848 ) . ( cid:1843)(cid:4668)(cid:1841),(cid:1830)(cid:4669 ) , we compute a vector ( cid:1869)(cid:1318)(cid:3560 ) as : ( cid:1869)(cid:3556)(cid:3420)1,(cid:1861)(cid:1858 ) ( cid:1322)(cid:3284)(cid:1603)(cid:1841 ) 0,(cid:1867)(cid:1860)(cid:1857)(cid:1875)(cid:1861)(cid:1857 ) where ( cid:1322)(cid:3284 ) is a set of entities that each node v(cid:2919 ) ( cid:1488)(cid:1848 ) corresponds to . Next , we achieve a normalized vector ( cid:1869)(cid:1318 ) from ( cid:1869)(cid:1318)(cid:3560 ) such that elements in ( cid:1869)(cid:1318 ) sum up to 1 . With a transition matrix ( cid:1842 ) ( (cid:1842)(cid:3004)(cid:3008 ) or ( cid:1842)(cid:3004)(cid:3003)(cid:3008) ) , we calculate utility vector as ( cid:1318)(cid:1855)(cid:1842)(cid:1318)(cid:3397)(cid:4666)1(cid:1855)(cid:4667)(cid:1869)(cid:1318 ) ( typically , ( cid:1855 ) is set to 085 ) Then , we define a utility function ( cid:4666)(cid:1843),(cid:1867)(cid:4667 ) as follow : ( cid:4666)(cid:1843),(cid:1867)(cid:4667)(cid:3420),(cid:1861)(cid:1858 ) ( cid:1867)(cid:1488)(cid:1830 ) 0,(cid:1867)(cid:1489)(cid:1830 ) Finally , we sort the entities by ( cid:4666)(cid:1843),(cid:1867)(cid:4667 ) in descending order to generate top k entities for the query . By adapting Personalized PageRank , these two methods can reasonably quantify the utility of each entity by fusing authority of each nodes and relatedness to the given query . CG is based on the simple assumption that the more two objects appears in the same tuples in the log table , the more they are related . CBG can be considered as a more sophisticated modification of CG in that it can reflect various recommendation factors depending on user intention . 4.2 Heterogeneous Graph based Method In this section , we introduce a Heterogeneous Data Graph and Path based Method ( HGP ) . Unlike previous two methods , we do not constraint our input as a log table . Instead , we transform various types of data sources ( eg relational data , XML , RDF , OWL ) into a heterogeneous data graph that consists of different types of nodes and edges . In this paper , we assume that we already have constructed the graph and focus more on entity ranking .
For a graph ( cid:1833)(cid:4666)(cid:1848),(cid:1831)(cid:4667 ) , ( cid:1848 ) is a set of nodes ( cid:4668),,…,,…,|(cid:3023)|(cid:4669 ) , and each represents entity ( cid:1867 ) . Each node has one node type ( cid:2308)(cid:3038)(cid:1488)(cid:1846)(cid:3023)(cid:4668)(cid:2308),…,(cid:2308)(cid:3038),…,(cid:2308)|(cid:3271)|(cid:4669 ) , where a node type ( cid:2308)(cid:3038 ) represents a dimension of entities . E is a set of edges , and each edge ( cid:1857)from node to is represented as ( cid:4666),,(cid:3039),(cid:1875)(cid:3032)(cid:3284)(cid:3285)(cid:4667 ) . ( cid:3039 ) and ( cid:1875)(cid:3032)(cid:3284)(cid:3285 ) are the edge ’s type and weight , where ( cid:3039)(cid:1488)(cid:1846)(cid:3006 ) ( cid:4668),…,(cid:3039),…,|(cid:3254)|(cid:4669 ) . represent the heterogeneous graph G as a set of |(cid:1848)|(cid:3400)|(cid:1848)| weighted adjacent matrices ( cid:2414)(cid:4668)(cid:1827)(cid:3047)(cid:3117),…,(cid:1827)(cid:3047)(cid:3287),,(cid:1827)|(cid:3254)|(cid:4669 ) , where each ( cid:1827)(cid:3047)(cid:3287 ) represents the graph ’s edges whose type is ( cid:3039 ) . We can transition matrix set ( cid:2448)(cid:4668)(cid:1842)(cid:3047)(cid:3117),…,(cid:1842)(cid:3047)(cid:3287),,(cid:1842)|(cid:3254)|(cid:4669 ) by ( cid:4657)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:4654)(cid:4666)(cid:1847)(cid:1857)(cid:4667)(cid:3017)(cid:3045)(cid:3032)(cid:3033)(cid:3032)(cid:3045 ) ( cid:4657)(cid:1755)(cid:1755)(cid:1755)(cid:4654)(cid:4666)(cid:1867)(cid:1859)(cid:4667 ) Path 1 : ( cid:4666)(cid:1847)(cid:1857)(cid:4667)(cid:3020)(cid:3040)(cid:3039)(cid:3028)(cid:3045)(cid:3028)(cid:3046)(cid:3047)(cid:3032 ) ( cid:4657)(cid:1755)(cid:1755)(cid:1755)(cid:4654)(cid:4666)(cid:1867)(cid:1859)(cid:4667)(cid:3020)(cid:3040)(cid:3039)(cid:3028)(cid:3045)(cid:3004)(cid:3042)(cid:3047)(cid:3032)(cid:3047)(cid:3046 ) Path 2 : ( cid:4666)(cid:1847)(cid:1857)(cid:4667)(cid:3017)(cid:3045)(cid:3032)(cid:3033)(cid:3032)(cid:3045 ) ( cid:4657)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:4654)(cid:4666)(cid:1867)(cid:1859)(cid:4667 ) derive a normalizing the adjacent matrices . The intuition of HGP is that paths defined on heterogeneous graph can represent various user intentions expressively . For example , we can define several paths as follow :
Although one matrix can represent a homogeneous graph , when we deal with more than one type of edge in heterogeneous graph , we need more than one matrix to represent to the graph . So , we
WWW 2012 – PhD SymposiumApril 16–20 , 2012 , Lyon , France163 Path 3 : ( cid:4666)(cid:1847)(cid:1857)(cid:4667)(cid:3013)(cid:3032)(cid:3046)(cid:3010 )
( cid:4657)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:4654)(cid:4666)(cid:1838)(cid:1867)(cid:1855)(cid:1853)(cid:1861)(cid:1867)(cid:4667)(cid:3035)(cid:3028)(cid:3046)(cid:3022)(cid:3046)(cid:3032)(cid:3045)(cid:3046 )
( cid:4657)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:4654)(cid:4666)(cid:1847)(cid:1857)(cid:4667)(cid:3017)(cid:3045)(cid:3032)(cid:3033)(cid:3032)(cid:3045 )
( cid:4657)(cid:1755)(cid:1755)(cid:1755)(cid:4654)(cid:4666)(cid:1867)(cid:1859)(cid:4667 ) where parentheses include a node type and arrows represent edges in the graph . As we previously mentioned that ranking objects by following different paths could be useful for recommender systems [ 21 ] , each path can be interpreted as a different recommendation procedure . If we follow the defined path 1 on the graph from a User type node , then we will reach the songs that are preferred by the users who have similar taste with the user that the start node represents . In other words , we can consider the path 1 represents collaborative filtering process . Similarly , the path 2 represents a content based filtering process that aims to find items whose contents are similar to the items previously liked by the given user . The path 3 can be understood as a location based recommendation procedure , so we can find the songs that are preferred by the users who live in the same location by following it . As we can see , paths can be used to describe different recommendation procedures . So , we aim to allow users to define paths and use them as part of their query . as we explained in the previous section . As we need to consider paths in node proximity measuring , we define a novel node ranking measure PathRank as follow :
For the HGP , we assume that a query is given as ( cid:1843)(cid:4668)(cid:1841),(cid:1842),(cid:1830)(cid:4669 ) , where ( cid:1842 ) is a set of pairs ( cid:1868),(cid:1875)(cid:3408 ) , ( cid:1868 ) is a path , ( cid:1875 ) is its weight , and ∑ 1 . ( cid:1869)(cid:1318 ) can be computed based on ( cid:1841 ) in the same way ( cid:1875)(cid:3038 ) ( cid:3038)(cid:2880 ) ( cid:1318)(cid:1875)(cid:3047)(cid:3045)(cid:3028)(cid:3046)(cid:1842)(cid:1318)(cid:3397)(cid:1875)(cid:3043)(cid:3028)(cid:3047)(cid:3035)(cid:3435)(cid:1875)(cid:1842)(cid:3043)(cid:3117)(cid:3397)(cid:1875)(cid:2870)(cid:1842)(cid:3043)(cid:3118)(cid:3397)(cid:1710)(cid:3397)(cid:1875)(cid:1842)(cid:3043)(cid:3289)(cid:3439)(cid:1318 ) ( cid:3397)(cid:1875)(cid:3045)(cid:3032)(cid:3046)(cid:3047)(cid:3028)(cid:3045)(cid:3047)(cid:1869)(cid:1318 ) ( cid:1842 ) is the transition matrix when we ignore the edge types and the sum of adjacent matrix A∑ . Each ( cid:1842)(cid:3043)(cid:3284 ) represents a ( cid:3047)(cid:3284)(cid:1488 ) ( cid:1842)(cid:3043)(cid:3028)(cid:3047)(cid:3035 ) ( cid:1842)(cid:3046)(cid:3040)(cid:3039)(cid:3028)(cid:3045)(cid:3028)(cid:3046)(cid:3047)(cid:3032)(cid:3400)(cid:1842)(cid:3043)(cid:3045)(cid:3032)(cid:3033)(cid:3032)(cid:3045 ) . Like Personalized PageRank , PathRank of a node is the stationary probability of random random walk with restart . w(cid:2930)(cid:2928)(cid:2911)(cid:2924)(cid:2929 ) is the weight of following graph ignoring edge types , and w(cid:2928)(cid:2915)(cid:2929)(cid:2930)(cid:2911)(cid:2928)(cid:2930 ) is weight of restarting the walk . path ( cid:1861 ) with a given probability w(cid:2926)(cid:2911)(cid:2930)(cid:2918)(cid:3400)(cid:1875 ) . All these weights are PathRank , we can define the utility function ( cid:4666)(cid:1843),(cid:1867)(cid:4667 ) for HGP as given as probability values . Intuitively , PathRank can be understood as an extension of Personalized PageRank , because it inherits the ability of fusing node authority and query relatedness . But , moreover , it reflects path semantics , thus , the nodes that can be reached by following paths achieve higher scores . By adapting transition matrix for path i , and it can be computed by sequentially multiplying transition matrix of each edges on the path . For example , a transition matrix for the path 1 can be computed as where ( cid:1875)(cid:3047)(cid:3045)(cid:3028)(cid:3046)(cid:3397)(cid:1875)(cid:3043)(cid:3028)(cid:3047)(cid:3035)(cid:3397)(cid:1875)(cid:3045)(cid:3032)(cid:3046)(cid:3047)(cid:3028)(cid:3045)(cid:3047)1
Additionally , during the random walk with restart process , the random walker also jumps to the destination nodes following each consider it as homogeneous , so it can be computed by normalizing walker ’s being at the node after enough number of iterations of
( cid:1827)(cid:3047)(cid:3284 ) in the same way we explained earlier so that we can achieve a topk recommendation results which reflected more flexible forms of MDR requests . 5 . RESULTS In our previous studies , we aimed to formalize the MDR problem and propose solutions by taking graph based approaches . So far , we have implemented CG [ 19 ] and CBG [ 20 ] and performed experiments to validate our methods using several real world datasets gathered from different application domains such as online music streaming services ( eg last.fm [ 22 ] , Bugs Music [ 23] ) , and a mobile application market ( LG Oz Store [ 24] ) . One than intentions the state of art is significantly important to important insight we achieved from the experiments is that our methods can increase recommendation accuracy ( HR@k ) [ 8 ] by exploiting the contextual information in log tables . Particularly , CBG showed better accuracy twodimensional recommendation methods by using time information in logs [ 20 ] . To validate the flexibility of our methods , we have identified many interesting use cases of our methods , such as friend recommendation , context aware recommendation , group recommendation , etc . These promising results convinced us to extend and improve our previous work . By extending the previous work [ 19][20][21 ] , we proposed our new HGP model in the earlier section . We are currently working on implementing a prototype system for a proof of concept and experiments . 6 . CONCLUSIONS AND FUTURE WORK In summary , we first presented a unified framework that can cover general graph based MDR methods . Then , we introduced two homogeneous graph based methods CG and CBG . We also outlined a novel MDR method HGP and a node ranking measure PathRank that are based on paths in heterogeneous graph . Graphbased MDR methods have significant advantages in that they give much more freedom to express their recommendation queries with various intentions . Especially , we insist that exploiting paths in for considering various graphs semantics of user recommendation process . Preliminary experimental results and identified use cases of our methods show the great potential of graph based MDR methods . We expect the further research will lead to better user satisfaction . Still , there are remaining interesting subjects that we are planning to tackle in the future work as follow : Experiments with Respect to Various Criteria : We have compared the recommendation accuracy of our methods with other existing methods . However , recommendation performance can be assessed with respect to , not just accuracy , but also with various other criteria such as serendipity , novelty , and etc [ 25 ] . So , we plan to conduct thorough experiments to evaluate our proposed methods with a wide range of recommendation performance metrics . By taking advantage of flexibility , we can adjust many settings for recommendation in our methods . So , it will be meaningful to look into the how the changes in query node types , paths , and weights affect such recommendation metrics . We expect the experimental results will be a meaningful reference for finding good settings in various applications and enhancing our methods . More Expressive Graph & Path Models : We plan to adapt more expressive graph and path models for our future work . There are many ways to extend the graph and path models , for instance , we can extend each node in heterogeneous graph to have attributes and its values ( eg , a user node can have attributes such as name , age , address , and so on ) Then , this will allow users to define more detailed paths by adding filtering conditions on each step on the paths . For example , a path for a modified collaborative filtering can be defined as :
( cid:4666)(cid:1847)(cid:1831 ) ( cid:4667)(cid:3020)(cid:3040)(cid:3039)(cid:3028)(cid:3045)(cid:3028)(cid:3046)(cid:3047)(cid:3032 ) ( cid:4657)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:1755)(cid:4654)(cid:4666)(cid:1847)(cid:1831)(cid:4667)(cid:3034)(cid:3032)(cid:3031)(cid:3032)(cid:3045)(cid:2880)(cid:4593)(cid:3014)(cid:3028)(cid:3039)(cid:3032)(cid:4593 ) ( cid:4657)(cid:1755)(cid:1755)(cid:1755)(cid:4654)(cid:4666)(cid:1841)(cid:1840)(cid:1833)(cid:4667)(cid:3052)(cid:3032)(cid:3028)(cid:3045)(cid:3016)(cid:3033)(cid:3019)(cid:3032)(cid:3039)(cid:3032)(cid:3028)(cid:3046)(cid:3032)(cid:2880)(cid:2870)(cid:1512)(cid:3034)(cid:3032)(cid:3045)(cid:3032)(cid:2880)(cid:4594)(cid:3011)(cid:3028)(cid:3053)(cid:3053)(cid:4594 ) ( cid:3017)(cid:3045)(cid:3032)(cid:3033)(cid:3032)(cid:3045 )
Other extensions are possible . However , because path definition should be comprehensive and intuitive for users , we will try to balance the expressiveness and complexity and look for most suitable graph and path models . Incremental Graph Update : All of our methods need to perform transforming data sources into graph , and it requires full scan on
WWW 2012 – PhD SymposiumApril 16–20 , 2012 , Lyon , France164 input data . However , when input data is extremely large and often updated , so , re building whole graph is tedious and impractical . Thus , we need to develop a method so that it can synchronize input data and constructed graph . Intuitive and User friendly Interface : Our goal is to build a unified graph based recommender system that allows users to flexibly perform various recommendation requests by easily changing various queries and parameters . To realize such system , we need to design an intuitive and user friendly interface for graph based MDR system . We expect this will give great opportunities to content providers and consumers in that they can test various recommendation requests to empirically find best recommendation results . 7 . ACKNOWLEDGEMENTS This work was supported by the National Research Foundation of Korea(NRF ) grant funded by the Korea government(MEST ) ( No . 20110017480 ) . 8 . REFERENCES [ 1 ] G . Adomavicius and A . Tuzhilin . Toward the next generation of recommender systems : A survey of the state of the art and possible extensions . IEEE Transactions on Knowledge and Data Engineering , Vol . 17(6 ) , pp . 734–749 , 2005 .
[ 2 ] H . Stack . Training and testing of recommender systems on data missing not at random . In KDD '10 : Proceedings of the 16th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining . 2010 .
[ 3 ] G . Adomavicius , R . Sankaranarayanan , S . Sen , and A .
Tuzhilin . Incorporating Contextual Information in Recommender Systems Using a Multidimensional Approach . ACM Trans . Information Systems , vol . 23 , no . 1 , Jan . 2005
[ 4 ] T . Haveliwala , S . Kamvar and G . Jeh . An analytical comparison of approaches to personalizing pagerank . Technical Report . Stanford . 2003 .
[ 5 ] Xiaoyuan Su , Taghi M . Khoshgoftaar . A survey of collaborative filtering techniques . Advances in Artificial Intelligence . Jan . 2009 . http://doiacorg/101155/2009/421425
[ 6 ] M . Deshpande and G . Karypis . Item Based Top N
Recommendation Algorithms . ACM Trans . Information Systems , Vol . 22 , no . 1 , pp . 143 177 , 2004 .
[ 7 ] G . Adomavicius and A . Tuzhilin . Multidimensional
Recommender Systems : A Data Warehousing Approach . Proc . Second Int'l Workshop Electronic Commerce ( WELCOM '01 ) , 2001b .
[ 8 ] D . Lee , S . E . Park , M . Kahng , S . Lee , and S g Lee . Exploiting contextual information from event logs for personalized recommendation . In Computer and Information Science , Studies in Computational Intelligence , pp . 121 139 . Springer . 2010 .
[ 9 ] M . Kahng , S . Lee , and S g Lee . Ranking in context aware recommender systems . In WWW '11 : Proceedings of the 20th International Conference Companion on World Wide Web . 2011 . http://doiacmorg/101145/19631921963226
[ 10 ] G . Adomavicius , A . Tuzhilin , and R . Zheng . REQUEST : A query language for customizing recommendations . Information System Research . Information Systems Research , Vol . 22(1 ) , pp . 99 117 , 2011 .
[ 11 ] G . Koutrika , B . Bercovitz , and H . Garcia Molina . FlexRecs : expressing and combining flexible recommendations . In SIGMOD '09 : Proceedings of the 35th SIGMOD International Conference on Management of Data . 2009 . http://doiacmorg/101145/15598451559923
[ 12 ] S . Kamvar , H . Haveliwala , C . D . Manning , and Gene H . Golub . Extrapolation methods for accelerating PageRank computations . In WWW '03 : Proceedings of the 12th International Conference on World Wide Web . 2003 .
[ 13 ] J . M . Kleinberg . Authoritative sources in a hyperlinked environment . In Proceedings of the 9th Annual ACM SIAM Symposium on Discrete Algorithms ( SODA ) , pp . 668 677 , 1998 .
[ 14 ] F . Fouss , A . Pirotte , J M Renders , and M . Saerens .
Random walk computation of similarities between nodes of a graph with application to collaborative recommendation . IEEE Transactions on Knowledge and Data Engineering , Vol . 19(3 ) , pp . 355 369 , 2007 .
[ 15 ] M . Gori and A . Pucci . ItemRank , A random walk based scoring algorithm for recommender engines , In 20th International Joint Conference on Artificial Intelligences . 2007 .
[ 16 ] L . Xiang , Q . Yuan , S . Zhao , L . Chen , X . Zhang , Q . Yang , and J . Sun . Temporal recommendation on graphs via longand short term preference fusion . In KDD '10 : Proceedings of the 16th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining . 2010 . http://doiacmorg/ 101145/18358041835896
[ 17 ] Y . Sun , J . Han , X . Yan , P . S . Yu , and T . Wu . Pathsim : Meta path based top k similarity search in heterogeneous information networks . In VLDB’ 11 , 2011 .
[ 18 ] A . Balmin , V . Hristidis , and Y . Papakonstantinou .
ObjectRank : authority based keyword search in databases . In VLDB , 2004 .
[ 19 ] Lee , S . , Kahng , M . , and Lee , S . Flexible recommendation using random walks on implicit feedback graph . In Proceedings of ICUIMC . 2011 , 3 3 .
[ 20 ] S . Lee , S . Song , M . Kahng , D . Lee , S. g Lee . Random Walk based Entity Ranking on Graph for Multidimensional Recommendation . Proc . of the 5th ACM Conference on Recommender Systems ( RecSys 2011 ) , Page 93 100 . 2011 .
[ 21 ] M . Kahng , S . Lee , and S. g Lee , Ranking Objects By
Following Paths In Entity Relationship Graphs , Proc . of the 4th PIKM 2011 in conjunction with CIKM 2011 , vol , Page 9 16 .
[ 22 ] Last.fm , http://wwwlastfm/ [ 23 ] Bugs Music , http://wwwbugscom/ [ 24 ] LG U+ Oz Store , http://ozstoreupluscokr/ [ 25 ] N . Kawamae . Serendipitous recommendations via innovators .
In proceedings of the 33rd international ACM SIGIR conference on Research and development in information retrieval ( SIGIR’10 ) , pages 218 225 , 2010 .
WWW 2012 – PhD SymposiumApril 16–20 , 2012 , Lyon , France165
