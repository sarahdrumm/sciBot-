QUBE : a Quick algorithm for Updating BEtweenness centrality
Min Joong Lee
Department of Computer
Science , KAIST
Daejeon , Korea
Jungmin Lee
Science , KAIST
Daejeon , Korea
Jaimie Y . Park
Technology , KAIST
Daejeon , Korea
Department of Computer
Division of Web Science and
291 Daehak ro , Yuseong gu
291 Daehak ro , Yuseong gu
291 Daehak ro , Yuseong gu mjlee@islabkaistackr jungmin@islabkaistackr yjpark@islabkaistackr
Ryan H . Choi
Department of Computer
Science , KAIST
291 Daehak ro , Yuseong gu
Daejeon , Korea rchoi@islabkaistackr
Chin Wan Chung
Division of Web Science and Technology & Department of Computer Science , KAIST 291 Daehak ro , Yuseong gu
Daejeon , Korea chungcw@kaist.edu
ABSTRACT The betweenness centrality of a vertex in a graph is a measure for the participation of the vertex in the shortest paths in the graph . The Betweenness centrality is widely used in network analyses . Especially in a social network , the recursive computation of the betweenness centralities of vertices is performed for the community detection and finding the influential user in the network . Since a social network graph is frequently updated , it is necessary to update the betweenness centrality efficiently . When a graph is changed , the betweenness centralities of all the vertices should be recomputed from scratch using all the vertices in the graph . To the best of our knowledge , this is the first work that proposes an efficient algorithm which handles the update of the betweenness centralities of vertices in a graph . In this paper , we propose a method that efficiently reduces the search space by finding a candidate set of vertices whose betweenness centralities can be updated and computes their betweenness centeralities using candidate vertices only . As the cost of calculating the betweenness centrality mainly depends on the number of vertices to be considered , the proposed algorithm significantly reduces the cost of calculation . The proposed algorithm allows the transformation of an existing algorithm which does not consider the graph update . Experimental results on large real datasets show that the proposed algorithm speeds up the existing algorithm 2 to 2418 times depending on the dataset .
Categories and Subject Descriptors G22 [ Discrete Mathematics ] : Graph Theory—Graph algorithms , Path and circuit problems ; E.1 [ Data ] : Data structures—Graphs and networks
Copyright is held by the International World Wide Web Conference Committee ( IW3C2 ) . Distribution of these papers is limited to classroom use , and personal use by others . WWW 2012 , April 16– 20 , 2012 , Lyon , France . ACM 978 1 4503 1229 5/12/04 .
General Terms Algorithms , Theory
Keywords Betweenness centrality , Update algorithm
1 .
INTRODUCTION
The betweenness centrality is a measure that computes the relative importance of a vertex in a graph , and it is widely used in network analyses such as a social network analysis , biological graph analysis , and road network analysis . For example , in the social network analysis , a vertex with higher centrality can be viewed as a more important vertex than a vertex with lower centrality . The betweenness centrality of a vertex in a graph is a measure for the participation of the vertex in the shortest paths in the graph .
There are many previous works on the betweenness centrality problem . The concept of the betweenness centrality is proposed in [ 1 ] , but the definition proposed in [ 10 ] is more widely used . Recently , many variants of the definition are proposed in [ 6 ] . [ 5 ] improves the computation time of the betweenness centrality based on a modified breadth first search algorithm and the dependency of a vertex , and it is the fastest known algorithm that computes the exact betweenness centralities of all the vertices in a graph . As the computation of shortest paths between all pairs of vertices are time consuming , [ 22 ] proposes another definition of betweenness centrality , which is based on a random walk . In [ 22 ] , each vertex has a probability of visiting its neighbor vertices . Also , [ 7 ] , [ 2 ] and [ 12 ] propose approximation algorithms for computing the betweenness centrality . [ 23 ] and [ 25 ] adopt the betweenness centrality for detecting communities in a social network .
Although many works on calculating the betweenness centrality exist and the betweenness centrality is one of the major measures used in analyzing social network graphs , none of the works for computing the betweenness centrality address the problem of updating betweenness centrality .
WWW 2012 – Session : Community Detection in Social NetworksApril 16–20 , 2012 , Lyon , France351 Applying the previous algorithms to find influential users or detect communities over frequently updated graphs such as a social network graph is inefficient . This is because , calculating the betweenness centralities of all users in the graph involves computing the shortest paths between all pairs of users in the graph . In all previous works , the recomputation for all the vertices is inevitable whenever a new edge is inserted to the graph . This recomputation is clearly timeconsuming . As the number of edges in the social network graph increases over time [ 19 ] , the need for updating the betweenness centrality is evident .
It is difficult to update the betweenness centrality , because even a single edge insertion or a single edge deletion leads to the changes in many shortest paths in the graph . This change causes the updates of the betweenness centralities of many vertices in the graph . It is trivial to see that when an edge ( vi , vj ) is inserted to a graph , the shortest path between vi and vj is changed . Also , the shortest paths that include the original shortest path from vi to vj are changed . . For example , in Figure 1 , let G1 be a graph and G 1 be an updated graph of G1 . When an edge ( v1 , v5 ) is inserted , the shortest path between v1 and v5 is changed . Also , there are more shortest paths that are changed eg , the shortest path between v12 and v5 and the shortest path between v10 and v11 .
However , we observe that there exist vertices whose betweenness centralities do not change even when the graph is updated . In Figure 1(b ) , the betweenness centralities of v1 , v3 , v4 and v5 change , while the betweenness centralities of the other vertices do not change . The betweenness centralities of v2 , v6 , v7 , v8 , v9 , v10 , v11 and v12 do not change , because the source target pairs of original shortest paths that go through v2 , v6 , v7 , v8 , v9 , v10 , v11 or v12 do not change even when G1 is updated . v9 v10 v8 v7 v6 v1 v2 v3 v4 v5 v9 v10 v8 v7 v6 v1 v2 v3 v4 v5 v11 v12 v11 v12
( a ) G1
. ( b ) G 1
Figure 1 : An example of a graph update
Based on the above observation , we proposed a Quick algorithm for Updating BEtweenness centrality ( QUBE ) . The key idea of the proposed algorithm is to perform the betweenness centrality computation on a reduced set of vertices . We first find the set of vertices whose betweenness centralities can be changed and the set(s ) of vertices whose betweenness centralities do not change . In Figure 1(b ) , {v1,v2,v3,v4,v5} is the set of vertices whose betweenness centralities can be changed , and {v6,v7,v8,v9,v10} , {v11} , {v12} are the sets of vertices whose betweenness centralities do not change . The method of finding these sets is explained in Section 4 , and it is easy to see that the latter three sets correspond to connected components after removing the first . set from G 1 .
We compute the betweenness centrality only on the first set of vertices . In the previous works , all pair shortest paths recomputation is necessary to compute the betweenness centrality and the number of shortest paths that need to be 1 would be 12 · 11/2 = 66 . On the other . recomputed on G hand , in our approach , only 5· 4/2 = 10 shortest paths need to be recomputed . Clearly , the smaller the cardinality of the first set , the shorter the amount of time it would take in computing the necessary shortest paths .
In order to recompute the betweenness centrality of a vertex in the reduced set , in addition to the betweenness centrality in the reduced set , the number of shortest paths that satisfy the following conditions needs to be considered .
1 . The shortest path goes through the vertex in the re duced set .
2 . The shortest path ’s source or target or both are not in the reduced set .
The number can be obtained based on the cardinality of the set(s ) of vertices whose betweenness centralities do not change without actually computing the shortest paths . For example , the shortest paths from v12 to v6 always go through vertices in the reduced set . Similarly , the shortest paths from vi ∈ {v12} to vj ∈ {v6 , v7 , v8 , v9 , v10} always go through vertices in the reduced set . Therefore , the number of shortest paths from vi to vj is a product of the cardinalities of the two sets , which is 5 .
The contributions of this paper are as follows .
1 . We propose a method that identifies a set of vertices whose betweenness centralities can be updated and sets of vertices whose betweenness centralities do not change , based on the comprehensive analysis of changes in the betweenness centrality when a graph is updated .
2 . We devise a Betweenness Centrality U pdate T heorem .
The theorem enables an efficient update of betweenness centrality without traversing the entire graph . Based on the proposed theorem , we propose an efficient algorithm for updating betweenness centrality .
3 . We conduct experiments on various synthetic datasets as well as large real datasets . The experimental results show that the incorporation of our algorithm outperforms an existing algorithm , in updating the betweenness centrality . In cases where the size of the reduced set of vertices is 1/10 of the number of vertices in the synthetic graphs , the proposed algorithm speeds up the existing algorithm 577 times on the average . For real datasets , the proposed algorithm speeds up the exist algorithm 2 to 2418 times depending on the dataset .
The rest of the paper is organized as follows . In Section 2 , related works on betweenness centrality are reviewed . In Section 3 , we formally define betweenness centrality and explain basic concepts . In Section 4 , we devise a method which finds the reduced set of vertices whose betweenness centralities can be updated . Section 5 explains how to efficiently update the betweenness centralities of vertices in the reduced set . In Section 6 , we show experimental results , and we conclude the paper in Section 7 .
2 . RELATED WORK
Computation of betweenness centrality has been gaining much importance in social network analyses , and is widely
WWW 2012 – Session : Community Detection in Social NetworksApril 16–20 , 2012 , Lyon , France352 used in many applications . The earliest work to define the measure which quantifies this idea of betweenness centrality is introduced by Anthonisse et al . [ 1 ] and Freeman [ 10 ] . Freeman ’s original method of finding betweenness centrality is based on counting geodesic paths for all pairs of vertices on a graph . Following Freeman ’s work , variations of centrality measures are proposed . Everette et al . [ 17 ] propose a group betweenness measure which can be applied to groups and classes as well as individuals . Freeman et al . [ 11 ] extend Freeman ’s work [ 10 ] to introduce a new measure of centrality based on the concept of network flows , which considers both shortest and certain non shortest paths . Newman [ 22 ] proposes a measure of betweenness centrality based on random walks of any length instead of shortest paths . Brandes [ 6 ] reviews a number of variants of betweenness centrality based on shortest paths including bounded distance betweenness , distance scaled betweenness , edge betweenness , and group betweenness , and discusses algorithms to compute each variant efficiently . As part of the discussion , Brandes points out that the efficient recomputation of betweenness centrality in dynamically changing networks on the algorithmic side is a remaining challenge .
Currently , the fastest known algorithm to compute exact betweenness centralities for all the vertices [ 5 ] requires O(|V ||E| ) and O(|V ||E| +|V |2log|V | ) time on weighted and unweighted graphs , respectively . Traditionally , betweenness centrality was determined by first computing the lengths and number of shortest paths between all pairs , and then summing up pair dependencies of all pairs [ 10 ] . Pair dependency of a pair s , t ∈ V on an intermediary vertex v ∈ V is defined as the ratio of shortest paths between s and t that v lies on to all shortest paths between s and t . Brandes [ 5 ] points out the weakness in this approach arguing it is computing more information than needed . The faster algorithm is presented by Brandes [ 5 ] , based on aggregating path counts from different source vertices in the network .
Although big improvement was made over the very initial betweenness centrality computation algorithm , many researchers argued that the Brandes’ algorithm is still too costly for large graphs . In order to overcome such limitation , researchers propose approximation algorithms to compute the estimated betweenness centrality , claiming that good approximation would be an acceptable alternative to exact score as long as fast computation is possible . Brandes et al . [ 7 ] propose a heuristic estimation method for betweenness centrality computation and conduct experiments with various selection strategies of the source vertices to assess the quality of the estimation . Bader et al . [ 3 ] present a parallel algorithm for computing betweenness centrality , optimized for scale free sparse graphs . They [ 2 ] also suggest an algorithm to compute the betweenness centrality of a single vertex in time faster than computing the betweenness of all vertices . Geisberger et al . [ 12 ] suggest a bisection scaling algorithm for approximating a variant of betweenness centrality . Makarychev [ 21 ] suggests a linear time approximation algorithm to find the ordering of the vertices that maximizes the number of satisfied betweenness constraints .
Betweenness centrality is used in diverse applications across many different disciplines . Betweenness centrality allows an understanding of the extent to which a vertex contributes in the flow of information . It is mainly used in finding the most prominent vertices in complex networks , whether they are individuals in social networks , elements in biological net works , intersections or junctions in transportation networks , physical elements in computer networks , or documents in World Wide Web . For example , Leydesdorff [ 20 ] demonstrates in his research how betweenness centrality is shown to be an indicator of the interdisciplinarity of scientific journals , and del Sol et al . [ 8 ] use the betweenness centrality in identifying the most central residues in protein protein complex structures . Jin et al . [ 15 ] demonstrate an application of parallel betweenness centrality to detect potentially harmful nodes in an electrical grid . The electrical grid is an interconnected network for delivering electricity from suppliers to consumers . Holme [ 13 ] studies the relationship between betweenness centrality and the density of a traffic model , and Lammer et al . [ 18 ] use betweenness centrality in approximating the importance of a road or a junction and investigated the scaling laws associated with urban road networks in Germany . In many applications , the network structures are typically not static . As the network evolves , the network graphs constantly change over time , which implies that there is a strong need for an efficient algorithm to update betweenness centrality .
Betweenness centrality is also used in community detection . Newman et al . [ 23 ] propose a divisive community detection technique which iteratively removes edges with the highest betweenness centrality value from the network . Pinney et al . [ 25 ] suggest an alternative community detection algorithm in which the network decomposition is based on vertex betweenness instead of edge betweenness . Newman et al . [ 23 ] discuss a weakness in the existing algorithms which is a high computation cost associated with iterative recalculation of all pair shortest paths when the edges are removed . As observed in many applications , dynamic nature of many real life networks is a clear evidence that efficiently updating betweenness centrality is an important issue . Yet no literature dealing with the problem of efficiently updating betweenness centrality in a dynamic network environment exists at present .
3 . PRELIMINARY
In this section , we introduce the formal definition of betweenness centrality of a vertex , and explain the basic concept of a minimum cycle basis . Also we briefly introduce the overall process of the proposed algorithm . 3.1 Betweenness Centrality
Betweenness centrality is a measure that computes the relative importance of a vertex in a graph . The formal definition is presented below . A graph is represented by G = ( V , E ) , where V is the set of vertices , and E ⊆ V × V is the set of edges . A path in a graph is represented by a sequence of vertices , ( v1 , , vn ) where vi , vj ∈ V for 1 ≤ i , j ≤ n , i ff= j except possible 1 = n .
Definition 1 ( Betweenness Centrality ) . The betweenness centrality of a vertex vj ∈ G is : . c(vj ) =
( 1 )
σvi,vk ( vj )
σvi,vk i,k where vi , vj , vk ∈ V , i ff= j ff= k , σvi,vk ( vj ) is the number of shortest paths between vi and vk that include vj , and σvi,vk is the number of shortest paths between vi and vk .
WWW 2012 – Session : Community Detection in Social NetworksApril 16–20 , 2012 , Lyon , France353 The betweenness centrality can be computed as follows :
1 . For each pair of vertices ( vs and vt ) , compute the shortest paths between the two vertices .
2 . For each pair of vertices , compute the ratio of the participation of each vertex in the shortest path(s ) . The ratio is the number of shortest paths between vs and vt that go through vj divided by the number of shortest paths between vs and vt .
3 . Accumulate the ratio for all pairs of vertices .
Let us consider updating the betweenness centrality caused by a graph update . Even a simple update , for example inserting an edge to a graph , could change existing shortest paths for many pairs of vertices in the graph . One of the biggest drawbacks in updating the betweenness centrality using the previous algorithms is that the shortest paths for all pairs of vertices are recomputed whenever an update occurs in a graph . 3.2 Minimum Cycle Basis
Definition 2 ( Cycle Basis ) . Let a graph G = ( V , E ) be an undirected graph . A cycle C is a subset of edges such that every vertex of V is incident to an even number of edges in C . Each cycle C can be represented by an edge incidence vector in {0 , 1}|E| where a component is equal to 1 precisely when e ∈ C . A maximal set of linearly independent cycles is called a cycle basis .
Definition 3 ( Minimum Cycle Basis ( MCB) ) . Let a graph G = ( V , E ) be an undirected connected graph with a nonnegative weight we assigned to each edge e ∈ E . Minimum Cycle Basis is a cycle basis C of minimum total weight , fi ie , which minimizes w(C ) = i=1 w(Ci ) , where w(Ci ) = fiv e∈Ci we . c3 v5 c2 c1 v1 v2 v3 v4
Figure 2 : An example of a cycle basis and the minimum cycle basis
The example depicted in Figure 2 has three cycle basis sets {C1 , C2} , {C1 , C3} , and {C2 , C3} . If every edge in the graph has the same weight ( ie , 1 for all edges ) , MCB is {C1 , C2} . The detailed definitions of cycle basis and minimum cycle basis can be found in [ 16 ] . 3.3 Overall Process
The overall flow of the proposed betweenness centrality update algorithm is as follows . First , we identify the set of vertices whose betweenness centralities can be changed , and the set(s ) of vertices whose betweenness centralities do not change . Through the analysis of possible changes in the betweenness centrality that can occur as a result of graph updates , we discovered the characteristics of the sets of vertices in which the changes in the betweenness centralities do and do not occur . Observed pattern is applicable for any type of connected graphs . Theoretical evidence on the generalization is presented in Section 51
Next , we perform the betweenness centrality computation on the identified sets of vertices whose betweenness centralities can be changed . We refer to the computed values as the local betweenness centrality . On top of the local betweenness centrality , we perform additional calculations on the vertices whose shortest paths are not yet considered . Details are presented in Section 5 . Through simple additional calculations , the exact betweenness centrality can be restored without performing an expensive computation on all the vertices on a graph , such as the calculation of all pair shortest paths .
4 . MINIMUM UNION CYCLE
In this section we introduce the concept of the minimum union cycle ( MUC ) upon which our update algorithm is built . As explained in the previous section , a set of vertices whose betweenness centralities can be changed is distinguished from the set(s ) of vertices whose betweenness centralities do not change . Such sets are identified by using MUCs obtained during the preprocessing time . The initial set of MUCs is found and stored during the preprocessing time . As changes occur in a graph , stored MUCs also need to be changed . Changes in MUCs are managed during the runtime . In Sections 4.2 and 4.3 , we explain how to find MUCs and how to update MUCs . 4.1 Definition of MUC
Definition 4 ( Minimum Union Cycle ( MUC) ) . Given a minimum cycle basis C and minimum cycles Ci ∈ C , let VCi be the set of vertices in Ci . Recursively union two VCi s together if they share at least one common vertex . Then each final set of vertices forms a MUC .
Each vertex appears in only one MUC since MUCs are disjoint sets . We denote M U C(v ) as MUC which contains vertex v . Definition 5 ( Connection vertex ) . Vertex v ∈ M U C is a connection vertex , if v is an articulation vertex1 and v has an edge to a vertex w /∈ M U C(v ) .
In Figure 5 , let us assume that an edge ( v3 , v4 ) is inserted . M U C(v3 ) is {v1 , v2 , v3 , v4} , and the connection vertices of M U C(v3 ) are v1 , v2 and v3 .
The deletion of a connection vertex makes the graph disconnected since the connection vertex is also an articulation vertex . We denote a graph that is disconnected from M U C(vi ) as a result of the deletion of a connection vertex vi as a disconnected subgraph Gi . In Figure 5 , G1 , G2 , and G3 are disconnected subgraphs generated from the deletion of connection vertex v1 , v2 , and v3 , respectively . 4.2 Finding MUCs
In this subsection , we present how to generate M U Cs , a set of connection vertices for each M U C and disconnected subgraphs derived from the deletion of connection vertices . 1A vertex a is called an articulation vertex if the deletion of a with its incident edges from G makes the graph disconnected . Equivalently , there must exist two vertices v and w such that every path from v to w goes through an articulation vertex a .
WWW 2012 – Session : Community Detection in Social NetworksApril 16–20 , 2012 , Lyon , France354 Algorithm 1 : FindMUC(C ) input 1 begin 2 3
: C minimum cycle basis
M U CSet := A minimum cycle basis C ; while ∃ ci , cj ∈ M U CSet , where ci and cj share at least one common vertex do
4 5
6 7
8 9 ci := ci union cj ; Remove cj from M U CSet ; for each M U C ∈ M U CSet do
Conn(M U C ) := a set of connection vertices in MUC ; for each connection vertex vi ∈ Conn(M U C ) do Gi := disconnected subgraphs originated from the deletion of a connection vertex vi ;
Algorithm 1 uses a minimum cycle basis C as an input , and it finds a set of MUCs ( M U CSet ) , and a set of connection vertices with corresponding subgraphs .
The calculation of a minimum cycle basis is well studied in the field of graph theory , and many efficient algorithms , such as Horton ’s algorithms [ 14 ] and Kavitha ’s algorithm [ 16 ] , exist . In line 2 , we calculate a minimum cycle basis using an existing algorithm . In line 3 line 5 , the algorithm finds a set of MUCs ( M U CSet ) by unioning the cycles in a minimum cycle basis until the unioned cycles are disjoint from each other . A set of connection vertices for each M U C and disconnected subgraphs derived from the deletion of connection vertices are found in line 7 line 9 .
Note that Algorithm 1 is performed during the preprocessing time . However , the MUC updating algorithm ( Algorithm 2 ) needs to be processed during the runtime . MUC updating algorithm for an insertion and deletion of an edge is presented in the following subsection . 4.3 Updating MUCs b v6 v12 v9 v4 v7 v2 a v3 v5 v1 c v1 v10 v8 c v11 v9 a v11 v10
( a ) Insertion v6 v2 b v4 v7 v8 v3 v5
( b ) Deletion
Figure 3 : An example of updating MUC
We now present our technique on maintaining a set of MUCs , a set of connection vertices for each M U C and disconnected subgraphs derived from the deletion of a connec
Algorithm 2 : UpdateMUC(vi , vj , M U CSet , G ) input
: vi a vertex in inserted/deleted edge vj a vertex in inserted/deleted edge M U CSet a set of MUCs G an original graph
1 begin
// if vi is not contained any MUC , M U C(vi ) returns vi only
2 3 4
5 6 7 8 9
10
11
12 13 14 15
16 17 18
19 20 if Insertion Operation then if M U C(vi ) = M U C(vj ) then
// Do Nothing else
N ewM U C := Let be an empty set ; for each vertices v in ςρ(vi , vj ) in G do N ewM U C := N ewM U C ∪ M U C(v ) ; remove M U C(v ) from M U CSet ; add N ewM U C to M U CSet ; add edge ( vi , vj ) to graph G ; else delete edge ( vi , vj ) from graph G ; if 1 = |P ath(vi , vj )| in G then else remove M U C(vi ) from M U CSet ; if ∃v in all P ath(vi , vj ) then split M U C(v ) into M U Cs ; else
// Do Nothing tion vertex . We explain each case of updating MUCs according to the insertion or deletion of an edge as follow ( Initial MUCs in Figure 3(a ) are {v1 , v2 , v3 , v4 , v5} and {v8 , v9 , v10} . Initial MUCs in Figure 3(b ) are {v1 , v2 , v3 , v4 , v5 , v6 , v7} and {v8 , v9 , v10}. ) :
1 . When an edge is inserted
( a ) No change , if the new edge connects two vertices in one MUC . In Figure 3(a ) , the insertion of edge(a ) does not affect any MUCs ( Line 4 in Algorithm 2 ) .
( b ) A new MUC is created , if vertices in an existing shortest path between two vertices in the new edge are not included in any MUC . In Figure 3(a ) , the insertion of edge(b ) induces a creation of a new MUC consisting of {v6 , v7 , v12} ( Line 6 Line 10 in Algorithm 2 . ςρ(vi , vj ) is the set of vertices in shortest paths between vi and vj ) .
( c ) MUC is merged with the vertices and other MUCs to create a new MUC , if vertices in existing shortest paths between two vertices of the new edge are included in some MUCs . In Figure 3(a ) , the insertion of edge(c ) induces M U C(v10 ) to merge with v11 ( Line 6 Line 10 in Algorithm 2 ) .
2 . When an edge is deleted
( a ) MUC is destroyed , if there exists only one path between two vertices in the deleted edge as a result of the deletion . In Figure 3(b ) , the deletion of edge(a ) causes the destruction of M U C(v10 ) ( Line 14 Line 15 in Algorithm 2 . P ath(vi , vj ) is the set of paths between vi and vj )
WWW 2012 – Session : Community Detection in Social NetworksApril 16–20 , 2012 , Lyon , France355 ( b ) No change , after the deletion , if there still exists more than one path between the two vertices and does not exist a vertex appearing in all the paths between the two vertices . In Figure 3(b ) , the deletion of edge(b ) does not affect any M U Cs ( Line 20 in Algorithm 2 ) .
( c ) An existing MUC is split into MUC(s ) and vertex(s ) , after the deletion , if there still exists more than one path between two vertices and exists a vertex appearing in all paths between the two vertices . In Figure 3(b ) , the deletion of edge(c ) induces the separation of M U C into two M U Cs ( Line 18 in Algorithm 2 ) .
5 . UPDATING BETWEENNESS
CENTRALITY
In this section , we describe how to compute the betweenness centrality values . As mentioned in Section 4 , after an insertion or deletion of the edge e(vi , vj ) , we guarantee that the betweenness centralities of vertices in M U C(vi ) can be changed . Therefore , after we find the reduced set of vertices , which we refer to as MUC , we need to efficiently calculate and update the betweenness centralities of the vertices in the MUC to which the updated vertices belong . From now on , we simply denote such MUC as M U CU .
G’ v4
G v5 v3 v1 v2
G 1 1 0.5 3.5 0 c(v1 ) c(v2 ) c(v3 ) c(v4 ) c(v5 )
G’ 0.5 0.5 0.5 0.5
Figure 4 : An example of the dependency of the betweenness centrality
Recomputing betweenness centralities of the vertices in a graph every time an update occurs is expensive , because in general , the recomputation involves computation of all pair shortest paths in the graph . In the previous section , we proposed a way to find a set of vertices whose betweenness centralities can be changed . This set of vertices is referred to as M U CU . Yet , calculating the betweenness centrality using only the vertices in M U CU is insufficient . In fact , the betweenness centralities calculated using only the vertices in M U CU are always smaller than the betweenness centralities calculated using all the vertices in a graph . This is because , ( 1 ) the shortest paths whose source or target is not in M U CU , and ( 2 ) the shortest paths that pass though M U CU and both the source and the target of the shortest paths are not in M U CU , are not yet considered . For example , Figure 4 shows the betweenness centralities of the . vertices in G , and a subgraph of G , G . The betweenness centralities of vertices calculated using only the vertices in . G are smaller than the values calculated using the vertices in G . This is because , the paths from v5 to each vertex in . G are missing . Based on this idea , we now explain how to restore the exact betweenness centrality by considering the vertices in M U CU only . Let us refer to the betweenness centrality calculated using only the vertices in M U CU as the local betweenness centrality and the betweenness centrality calcu lated using the entire vertices in the graph as the global betweenness centrality . 5.1 Betweenness Centrality Update Theorem Before we introduce our technique , we define some terminologies for a better understanding . cM U C ( vi ) denotes the local betweenness centrality of a vertex vi calculated using the vertices in M U CU only . ci represents a connection vertex . ςρ(vi , vj ) is the set of vertices in the shortest paths between vi and vj , and SP ( vi , vj ) is the set of shortest paths between vi and vj . Therefore , |SP ( vi , vj )| is the number of the shortest paths between vi and vj . For example , in Figure 4 , |SP ( v1 , v5)| = 1 , |SP ( v1 , v2)| = 2 , and ςρ(v1 , v2 ) is {v1 , v2 , v3 , v4} .
Gj represents a disconnected subgraph originated from a deletion of the connection vertex , cj . Gl j represents the lth connected component of Gj . VGj is the set of vertices of Gj . In Figure 5 , G1 , G2 and G3 represent disconnected subgraphs originated from the deletions of connection vertices , v1 , v2 , and v3 , respectively . G1 2 are connected components of G2 . If the dotted edge is inserted , M U CU is {v1 , v2 , v3 , v4} and connection vertices of M U CU to G1 , G2 , and G3 are v1 , v2 , and v3 , respectively .
2 and G2
G1
|VG1
|=5
G3
|VG3
|=6 v3
MUCU v4 v1 v2
G2
|VG2
|=4 v8 v6 v5 v7
1 G2
|VG2
|=31
2 G2
|VG2
|=12
Figure 5 : An example of updating the betweenness centrality ( vertices in G1 and G3 are omitted . ) Lemma 1 . Let vs ∈ VGj , vt ∈ M U CU and cj be a connection vertex which connects M U CU with Gj . Then each vertex in ςρ(cj , vt ) must be included in a ςρ(vs , vt ) . Proof : Since a connection vertex in M U CU is also an articulation vertex , all paths from vs ∈ VGj to vt ∈ M U CU go through a connection vertex cj . Therefore ςρ(vs , vt ) always includes ςρ(cj , vt).2
Lemma 1 allows us to calculate the increase of the betweenness centrality due to the shortest paths whose source or target is not in M U CU ( the shortest paths between the vertices in M U CU and the vertices not in M U CU ) . Such increase of the betweenness centrality for vi is denoted as cbj ( vi ) .
0 otherwise where vs in VGj , vt ∈ M U CU , cj is a connection vertex to Gj .
|VGj
|
|SP ( vs,vt)| if vi in ςρ(cj , vt ) − {vt}
( 2 ) cbj ( vi ) =
⎧⎪⎨ ⎪⎩
WWW 2012 – Session : Community Detection in Social NetworksApril 16–20 , 2012 , Lyon , France356 Lemma 2 . Let vs ∈ VGj , vt ∈ VGk , and cj and ck be con nection vertices which connect M U CU with Gj , and M U CU with Gk , respectively . Then each vertex in ςρ(cj , ck ) must be included in a ςρ(vs , vt ) . Proof : Since cj and ck are articulation vertices , all paths from vs ∈ VGj to vt ∈ VGk go through connection vertices cj and ck . Therefore ςρ(vs , vt ) always includes ςρ(cj , ck).2
Lemma 2 allows us to calculate the increase of the betweenness centrality due to the shortest paths that pass through M U CU and whose source and target are both not in M U CU . Such increase of the betweenness centrality for vi is denoted as ctk j
( vi ) .
⎧⎪⎨ ⎪⎩ ctk j
( vi ) =
|VGj | |·|VGk |SP ( vs,vt)| if vi in ςρ(cj , ck )
( 3 )
0 otherwise where vs ∈ VGj , vt ∈ VGk , cj and ck are connection vertices to Gj and Gk , respectively .
In the case where Gi is disconnected , all shortest paths between the two vertices from different connected components of Gi always pass through vi . For example , in Figure 5 , a shortest path from vs ∈ G1 2 must pass through v2 . Such an increase of the betweenness centrality for vi is denoted as cti ( vi ) and calculated as follows :
2 to vt ∈ G2
⎧⎨ ⎩ cti ( vi ) =
|VGi|2 − fin l=1(|VGl i
|2 ) if Gi is disconnected
0 otherwise
( 4 ) where Gl j is the lth connected component of Gi , n is the number of connected components in Gi , and vi is the connection vertex to Gi .
Theorem 1 . ( Betweenness Centrality Update Theorem ) By Lemma 1 and Lemma 2 , we can compute the betweenness centrality of a vertex vi , c(vi ) .
.
.
. c(vi ) = cM U C ( vi)+
Gj⊂G cbj ( vi)+
Gj ,Gk⊂G,jff=k ctk j
( vi)+
Gi⊂G cti ( vi ) where cbi ( vi ) is from Equation 2 ( Lemma 1 ) and ctk j are from Equation 3 and 4 ( Lemma 2 ) .
( 5 )
( vi ) , cti ( vi )
By Theorem 1 , we can compute the global betweenness centrality using the local betweenness centrality and the number of vertices in each disconnected subgraph Gi without performing all pair shortest paths computation on the all the vertices in a graph .
5.2 Betweenness Centrality Update Algorithm
( QUBE )
Algorithm 3 shows how to update betweenness centrality only using vertices in M U CU that updated vertices belong to . Algorithm 3 uses M U CU as an input and calculates the updated betweenness centrality ( C[vi ] ) as an output . The set of all pair shortest paths in M U CU and the local betweenness centralities of vertices in M U CU are calculated using the existing betweenness centrality algorithms ( Line
Algorithm 3 : QUBE(M U CU ) input
: M U CU Minimum Union Cycle that updated vertices belong to output : C[vi ] Updated Betweenness Centrality Array
1 begin 2 3 4 5 6 7
Let SP be the set of all pair shortest paths in M U CU ; Let C[vi ] be an empty array , vi ∈ M U CU ; SP , C[vi ] ← Betweenness( ) ; for each shortest path <va , . . . , vb> in SP do if va is a connecting vertex then
8
9
10 11
12
13
14 15
|VGa |
Ga := Subgraph connected by a connection vertex va ; for each vi ∈ <va , . . . , vb> {vb} do
C[vi ] := C[vi ] + if vb is also a connecting vertex then
|SP ( va,vb)| ;
Gb := Subgraph connected by a connection vertex vb ; for each vi ∈ < va , . . . , vb > do |VGa|·|VGb | |SP ( va,vb)| ;
C[vi ] := C[vi ] + if Ga is disconnected then
C[va ] := C[va ] + |VGa|2 − .n l=1(|VGl a
|2 )
4)2 . Then for each shortest path between the vertices in M U CU ( Line 5 ) , add the increase of betweenness centrality values due to the shortest paths between the vertices in M U CU and the vertices in other subgraphs ( Line 9 ) , as well as the shortest paths between the vertices in two other subgraphs , which pass through M U CU ( Line 13 ) and the shortest paths between the two vertices from different connected components of a subgraph ( Line 15 ) . Note that it does not require additional costs to obtain SP , the set of all pair shortest paths in M U CU , since all pair shortest paths are already calculated when we compute the local betweenness centrality and can be easily obtained .
Example 1 . Table 5.2 shows the values computed using Equation 2 , Equation 3 , and Equation 4 for the vertices in M U CU depicted in Figure 5 . Due to the space limitation , we do not differentiate a path from vs to vt and a path from vt to vs in this example . Therefore , the actual betweenness centralities are twice as big as the values shown in this example . For vertex v2 , the local betweenness centrality , cM U C ( v2 ) , is 0 . And there are four shortest paths ( v2 v3v1 , v2 v4 v1 , v2 v3 , v2 v4 ) which start from v2 . Therefore , we add ‘|VG1| = 4’ 2 times for the paths v2 v3 and v2 v4 . Since |SP ( v2 , v1)| = 2 , we add ‘|VG1|/2 = 2’ 2 times to v2 ’s betweenness centrality for the paths v2 v3 v1 and v2 v4 v1 . Also , v1 v3 v2 , v1 v4 v2 are shortest paths which include v2 and connect G1 and G2 via v1 and v2 . Therefore , we add a half of the product of the numbers of vertices in G1 and G2 , which is ‘|VG1| · |VG2|/2 = 5 · 4/2’ for each path . The path v2 v3 connects G2 and G3 via v2 and v3 . Similar to the above case , we add ‘|VG2| · |VG3| = 4 · 6’ to v2 ’s betweenness centrality . G2 is a disconnected graph and v2 is a connection vertex to G2 . Therefore , we add the product of the numbers 2 , which is 3 · 1 . Finally , we get 59 of vertices in G1 2Algorithm 3 can use any existing betweenness centrality algorithm . For the implementation of Algorithm 3 , we use the Brandes’ algorithm which is the fastest known algorithm so far . Our implementation is explained in Section 6.1
2 and G2
WWW 2012 – Session : Community Detection in Social NetworksApril 16–20 , 2012 , Lyon , France357 Table 1 : An example of updating the betweenness centrality
SP ( cj , • ) P aths
SP ( c1 , v2 ) v1 v3 v2 v1 v4 v2
SP ( c1 , v3 ) v1 v3 SP ( c1 , v4 ) v1 v4 SP ( c2 , v1 ) v2 v3 v1 v2 v4 v1
SP ( c2 , v3 ) v2 v3 SP ( c2 , v4 ) v2 v4 SP ( c3 , v1 ) v3 v1 SP ( c3 , v2 ) v3 v2 SP ( c3 , v4 ) v3 v4 SP ( c1 , c2 ) v1 v3 v2 v1 v4 v2
SP ( c1 , c3 ) v1 v3 SP ( c2 , c3 ) v2 v3 v2 cM U C ( vi ) cb1 ( vi ) cb2 ( vi ) cb3 ( vi ) ct2 1
( vi )
( vi ) ct3 1 ct3 ( vi ) 2 ct2 ( vi ) c(vi ) Actual value v1 0 5/2 5/2 5 5 v2 0
4/2 4/2 4 4
5·4/2 5·4/2 5·6
65 130
5·4/2 5·4/2 4·6 3·1 59 118 v4 0.5
5/2
4/2
5·4/2 v3 0.5 5/2
4/2
6 6 6 5·4/2 5·6 4·6
87 174
15 30 as the global betweenness centrality which is the same value resulting from the calculation of the betweenness centrality of v2 using all the vertices in the original graph . The betweenness centrality values for the other vertices v1 , v3 and v4 can also be calculated in the same way as the case of v2 .
6 . EXPERIMENTS
We explain how we implement an updatable version of the Brandes’ algorithm using QUBE based on the Brandes’ algorithm in Section 61 We compare this updatable version of the Brandes’ algorithm with the original Brandes’ algorithm and we show how much improvement is achieved with the help of QUBE in Section 62 Recall that all previous betweenness centrality calculation algorithms which do not consider the graph update , such as the Brandes’ algorithm , inevitably require the computation of the betweenness centrality from scratch whenever a graph changes . We conduct experiments on Intel Xeon CPU with 2.53GHz and 20GB main memory .
6.1 Implementation
As we explained in Algorithm 3 , QUBE can be applied to any betweenness centrality calculation algorithm since it reduces the search space by identifying the candidate vertices and restores the global betweenness centrality using the local betweenness centrality . Since the Brandes’ algorithm known to be the fastest algorithm so far for computing the exact betweenness centrality , we implement QUBE based on the Brandes’ algorithm . The Brandes’ algorithm computes onesided pair dependencies of all the vertices in a graph for a given source vertex by solving a single source shortest path problem . The one sided pair dependency of a vertex vt is the number of all shortest paths that go through vt , where the start vertex of the paths is fixed to a specific vertex vs . A detailed description of the Brandes’ algorithm can be found in [ 5 ] .
As we mentioned in Section 5 , in addition to the local betweenness centrality , we need to calculate ( 1 ) the increase of the betweenness centrality ( Equation 2 ) due to the shortest paths whose source or target is a connection vertex , and ( 2 ) the increase of the betweenness centrality ( Equation 3 and Equation 4 ) due to the shortest paths whose source and target are both connection vertices . Since the Brandes’ algorithm does not explicitly calculate the all pair shortest paths , the necessary values for the calculation of ( 1 ) and ( 2 ) are obtained during the computation of the one sided pair dependencies on the Brandes’ algorithm . The detailed implementation of the updatable version of the Brandes’ algorithm using QUBE is shown in Algorithm 4 . The additional increases in the betweenness centrality explained through Equation 2 , Equation 3 , and Equation 4 are computed in ( Line 34 ) , ( Line 23 Line 26 and Line 29 Line 31 ) , and ( Line 38 ) , respectively . The additional lines apart from the original Brandes’ algorithm are underlined .
6.2 Experiment Results
To evaluate the proposed algorithm , we measure the betweenness centrality update time using synthetic datasets and real datasets . We synthetically generate connected , undirected , and unweighted graphs of varying numbers of vertices and edges in order to observe the performance with respect to the graph size and proportions . The proportion is computed as ( |M U CU|/|V |)· 100 , and it indicates the percentage of vertices whose betweenness centralities should be recalculated due to the update of the graph . Therefore , it mainly affects the performance of QUBE . The Erd¨os R´enyi model [ 9 ] , the most widely used random graph model , is used to generate synthetic graphs . Each edge in the graph is generated independently of existing edges , with an equal probability of being generated .
Figure 6 shows the running time for updating the betweenness centrality on synthetic graphs of size 1000 , 3000 , and 5000 , respectively . For each graph , we randomly insert 100 edges and take the average value . QUBE significantly reduces the betweenness centrality update time as the proportion decreases . In Figure 6(c ) , when the proportions are 80 , 40 , and 10 , QUBE enables the original Brandes’ algorithm to perform about 2 , 13 , and 623 times faster , respectively . These results provide a clear evidence that finding M U CU dramatically improves the performance of updating the betweenness centrality . Regardless of the size of a graph , QUBE makes the original Brandes’ algorithm perform much faster .
Besides the update time of the betweenness centrality , we measure the update time of MUCs . Since it is negligible compared to the overall processing time , we do not explicitly present the update time of MUCs .
In order to estimate how QUBE performs in real world graphs , we select various real datasets which are prone to frequent changes . For each real graph , we extract the maximally connected subgraph . In cases of directed real graphs , we convert directed edges into undirected edges . We compare the betweenness centrality update time over 8 different real datasets . The results are shown in Table 2 and Figure 7 . Table 2 shows the speed up achieved by QUBE and the overall statistics of each real dataset . Recall that the proportion is the percentage of vertices in MUC . The low proportion means that there exists a small number of vertices whose betweenness centralities can be changed . Speed
WWW 2012 – Session : Community Detection in Social NetworksApril 16–20 , 2012 , Lyon , France358 ) s m ( e m T i
3500 3000 2500 2000 1500 1000 500 0
QUBE+Brandes Brandes
) s m ( e m T i
100000
80000
60000
40000
20000
0
QUBE+Brandes Brandes
) s m ( e m T i
400000 350000 300000 250000 200000 150000 100000 50000 0
QUBE+Brandes Brandes
10
20
30
40
50
60
70
80
10
20
30
40
50
60
70
80
10
20
30
40
50
60
70
80
Proportion
( a ) |V|=1000
Proportion
( b ) |V|=3000
Proportion
( c ) |V|=5000
Figure 6 : The betweenness centrality update time on the synthetic data
Algorithm 4 : QUBE BRANDES(M U CU ) input
: M U CU Minimum Union Cycle that an updated vertices belong to SGs A set of disconnected subgraphs connected by each connection vertices in M U CU output : C[vi ] Updated Betweenness Centrality Array
1 begin 2 3 4 5 6 for vs ∈ M U CU do
S ← empty stack ; P [ vi ] ← empty list , for all vi ∈ M U CU ; σ[vi ] := 0 , for all vi ∈ M U CU ; σ[vs ] := 1 ; σt[vi ] := 0 for all vi ∈ M U CU ; d[vs ] := 0 ; d[vi ] := 1 , for all vi ∈ M U CU ; d[vs ] := 0 ; Q ← empty queue ; enqueue vs → Q ; while Q not empty do dequeue vi ← Q ; push vi → S ; for each neighbor vn of vi do
7 8 9 10 11 12 13 14 15 16
17 18 19
20 21 22 23
24
25
26
27
28
29
30
31
32 33
34 35
36 37 38 if d[vn ] < 0 then enqueue vn → Q ; d[vn ] := d[vi ] + 1 ; if d[vn ] = d[vi ] + 1 then σ[vn ] := σ[vn ] + σ[vi ] ; append vi → P [ vn ] ; δ[vi ] := 0 , for all vi ∈ M U CU ; while S not empty do pop vn ← S ; if vs , vn are connection vertices and vn = vs then ct := |VGs| · |VGn| ;
σt[vn ] := σt[vn ] + ct ; C[vn ] := C[vn ] + ct ; for vp in P [ vn ] do δ[vp ] := δ[vp ] + if vs is connection vertex then
· ( 1 + δ[vn ] ) ;
σ[vp ] σ[vn ]
σt[vp ] := σt[vp ] + σt[vn ] · σ[vp ] σ[vn ] ; C[vp ] := C[vp ] + σt[vn ] · σ[vp ] σ[vn ] ; if vn = vs then
C[vn ] := C[vn ] + δ[vn ] ; if vs is connection vertex then
C[vn ] := C[vn ] + δ[vn ] · |VGs| ·2 ; for Gi ∈ SGs do if Gi is disconnected then
C[vi ] := C[vi ] + |VGi
|2 − .n l=1(|VGl
|2 ) ; i
Name
Type
Table 2 : The speed up on real data
|V|
|E|
Ownership 4457 Eva[24 ] Erdos02a Collaboration 5534 Erdos972a Collaboration 4680 4680 Social Pgp[4 ] Epab 4253 Web link Contact c Social 11604 65441 Wikivote[19 ] Trust 7066 CAGrQc[19 ] Collaboration 4158
4562 8472 7030 24316 8897
100736 13422
Avg . Prop . 6.41 28.66 30.00 42.14 52.25 62.60 67.73 77.92
Speedup 2418.17 39.57 34.39 13.09 6.67 4.00 3.00 2.06 ahttp://vladofmfuni ljsi/pub/networks/data bhttp://wwwcscornelledu/courses/cs685/2002fa/ chttp://stuffmetafiltercom/infodump/ l
) e a c s g o l
, s m
( e m T i
10000000
1000000
100000
10000
1000
100
10
1
QUBE+Brandes Brandes
Eva 106
256326
Erdos02 12289 486267
Erdos972
Pgp
8640 297100
270419 3538417
Epa 34056 227158
Contact 1150801 4600805
Wikivote 361362 1082843
CAGrQc 101895 210831
Figure 7 : The betweenness centrality update time on real data up in Table 2 shows how fast the updatable version of the Brandes’ algorithm is compared to the original Brandes’ algorithm . Table 2 clearly shows that the performance of the updatable version of the Brandes’ algorithm increases as the proportion decreases . Figure 7 shows the average betweenness centrality update times measured on real graphs . Note that we use a log scale for the y axis in Figure 7 . To represent the precise update time , a table is included in Figure 7 . QUBE makes the original Brandes’ algorithm perform about 2 times faster on ‘CAGrQc’ dataset whose proportion is about 77 and perform about 2418 times faster on ‘Eva’ dataset whose proportion is about 6 . When the proportion is about 30 , QUBE makes the original Brandes’ algorithm perform about 37 times faster and when the proportion is about 70 , QUBE makes the original Brandes’ algorithm perform about 3 times faster .
WWW 2012 – Session : Community Detection in Social NetworksApril 16–20 , 2012 , Lyon , France359 7 . CONCLUSIONS
In this paper , we devise a betweenness centrality update theorem and propose an efficient algorithm ( QUBE ) based on this theorem . QUBE identifies a set of vertices whose betweenness centralities can be changed . QUBE efficiently updates the betweenness centralities based on the betweenness centrality calculated using the vertices in the set only and the number of vertices not in the set . Any existing betweenness centrality algorithm which does not consider the graph update can be changed to an efficient updatable betweenness centrality algorithm with an adoption of QUBE . We implement an updatable version of the Brandes’ algorithm by adopting QUBE . For the synthetic graphs whose proportions are 10 , the Brandes’ algorithm with QUBE is about 557 times faster compared to the original Brandes’ algorithm . For the real graphs whose proportions are about 30 , the Brandes’ algorithm with QUBE performs about 37 times faster than the original Brandes’ algorithm . The performance improvement becomes even larger when the proportion decreases .
8 . ACKNOWLEDGMENTS
We would like to thank anonymous reviewers . This work was supported in part by WCU ( World Class University ) program under the National Research Foundation of Korea funded by the Ministry of Education , Science and Technology of Korea ( No . R31 30007 ) , and in part by the National Research Foundation of Korea grant funded by the Korea government ( MEST ) ( No . 2011 0000377 ) .
9 . REFERENCES [ 1 ] J . Anthonisse and S . M . C . A . A . M . besliskunde . The rush in a directed graph . Technical report , 1971 .
[ 2 ] D . A . Bader , S . Kintali , K . Madduri , and M . Mihail . Approximating betweenness centrality . In Proceedings of the 5th international conference on Algorithms and models for the web graph , WAW’07 , pages 124–137 , Berlin , Heidelberg , 2007 . Springer Verlag .
[ 3 ] D . A . Bader and K . Madduri . Parallel algorithms for evaluating centrality indices in real world networks . In Proceedings of the 2006 International Conference on Parallel Processing , ICPP ’06 , pages 539–550 , Washington , DC , USA , 2006 . IEEE Computer Society .
[ 4 ] M . Bogu˜n´a , R . Pastor Satorras , A . Diaz Guilera , and A . Arenas . Models of social networks based on social distance attachment . Phys . Rev . E , 70(5):056122 , Nov . 2004 .
[ 5 ] U . Brandes . A faster algorithm for betweenness centrality . Journal of Mathematical Sociology , 25(1994):163–177 , 2001 .
[ 6 ] U . Brandes . On variants of shortest path betweenness centrality and their generic computation . Social Networks , 30(2):136–145 , 2008 .
[ 7 ] U . Brandes and C . Pich . Centrality estimation in large networks . International Journal Of Bifurcation And Chaos , 17(7):2303 , 2007 .
[ 8 ] A . del Sol , H . Fujihashi , and P . O’Meara . Topology of small world networks of protein protein complex structures . Bioinformatics , 21(8):1311–1315 , Apr . 2005 .
[ 9 ] P . Erd¨os and A . R´enyi . On random graphs , I .
Publicationes Mathematicae ( Debrecen ) , 6:290–297 , 1959 .
[ 10 ] L . C . Freeman . A set of measures of centrality based on betweenness . Sociometry , 40(1):35–41 , 1977 .
[ 11 ] L . C . Freeman , S . P . Borgatti , and D . R . White .
Centrality in valued graphs : A measure of betweenness based on network flow . Social Networks , 13(2):141 – 154 , 1991 .
[ 12 ] R . Geisberger , P . Sanders , and D . Schultes . Better approximation of betweenness centrality . In J . I . Munro and D . Wagner , editors , ALENEX , pages 90–100 . SIAM , 2008 .
[ 13 ] P . Holme . Congestion and centrality in traffic flow on complex networks . Advances in Complex Systems , 6(2):163–176 , Jan . 2003 .
[ 14 ] J . D . Horton . A polynomial time algorithm to find the shortest cycle basis of a graph . SIAM J . Comput . , 16:358–366 , April 1987 .
[ 15 ] S . Jin , Z . Huang , Y . Chen , D . G . Chavarria Miranda ,
J . Feo , and P . C . Wong . A novel application of parallel betweenness centrality to power grid contingency analysis . In IPDPS , pages 1–7 . IEEE , 2010 .
[ 16 ] T . Kavitha , K . Mehlhorn , D . Michail , and K . E .
Paluch . A faster algorithm for minimum cycle basis of graphs . In ICALP , pages 846–857 , 2004 .
[ 17 ] E . D . Kolaczyk , D . B . Chua , and M . Barth´elemy .
Group betweenness and co betweenness : Inter related notions of coalition centrality . Social Networks , 31(3):190–203 , July 2009 .
[ 18 ] S . Lammer , B . Gehlsen , and D . Helbing . Scaling laws in the spatial structure of urban road networks . Physica A : Statistical Mechanics and its Applications , 363(1):89–95 , Apr . 2006 .
[ 19 ] J . Leskovec , J . Kleinberg , and C . Faloutsos . Graph evolution : Densification and shrinking diameters . ACM Trans . Knowl . Discov . Data , 1(1):2 , 2007 .
[ 20 ] L . Leydesdorff . Betweenness centrality as an indicator of the interdisciplinarity of scientific journals . Journal of the American Society for Information Science and Technology , 58(9):1303–1309 , 2009 .
[ 21 ] Y . Makarychev . Simple linear time approximation algorithm for betweenness . Technical report , 2009 .
[ 22 ] M . E . J . Newman . A measure of betweenness centrality based on random walks . Social Networks , 27(1):39–54 , 2005 .
[ 23 ] M . E . J . Newman and M . Girvan . Finding and evaluating community structure in networks . Physical Review E , 69(2):26113 , 2004 .
[ 24 ] K . Norlen , G . Lucas , M . Gebbie , and J . Chuang . EVA :
Extraction , Visualization and Analysis of the Telecommunications and Media Ownership Network , Aug . 2002 .
[ 25 ] J . W . Pinney and D . R . Westhead . Betweenness based decomposition methods for social and biological networks . In Interdisciplinary Statistics and Bioinformatics , pages 87–90 . Leeds University Press , 2006 .
WWW 2012 – Session : Community Detection in Social NetworksApril 16–20 , 2012 , Lyon , France360
