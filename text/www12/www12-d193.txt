On Directly Mapping Relational Databases to RDF and
OWL
Juan F . Sequeda
University of Texas at Austin jsequeda@csutexasedu
Marcelo Arenas
PUC Chile marenas@ingpuccl
Daniel P . Miranker
University of Texas at Austin miranker@csutexasedu
ABSTRACT
Mapping relational databases to RDF is a fundamental problem for the development of the Semantic Web . We present a solution , inspired by draft methods defined by the W3C where relational databases are directly mapped to RDF and OWL . Given a relational database schema and its integrity constraints , this direct mapping produces an OWL ontology , which , provides the basis for generating RDF instances . The semantics of this mapping is defined using Datalog . Two fundamental properties are information preservation and query preservation . We prove that our mapping satisfies both conditions , even for relational databases that contain null values . We also consider two desirable properties : monotonicity and semantics preservation . We prove that our mapping is monotone and also prove that no monotone mapping , including ours , is semantic preserving . We realize that monotonicity is an obstacle for semantic preservation and thus present a non monotone direct mapping that is semantics preserving .
Categories and Subject Descriptors
H25 [ Heterogeneous Databases ] : Data translation ; H35 [ Online Information Services ] : Web based services
Keywords
Relational Databases , Semantic Web , Direct Mapping , RDB2RDF , SQL , SPARQL , RDF , OWL
INTRODUCTION
1 . In this paper , we study the problem of directly mapping a relational database to an RDF graph with OWL vocabulary . A direct mapping is a default and automatic way of translating a relational database to RDF . One report suggests that Internet accessible databases contained up to 500 times more data compared to the static Web and roughly 70 % of websites are backed by relational databases , making automatic translation of relational database to RDF central to the success of the Semantic Web [ 13 ] .
We build on an existing direct mapping of relational database schema to OWL DL [ 23 ] and the current draft of the W3C Direct Mapping standard [ 5 ] . We study two properties that are fundamental to a direct mapping : information preservation and query preservation . Additionally we study two desirable properties : monotonicity and semantics preservation . To the best of our knowledge , we are presenting the first direct mapping from a relational database
Copyright is held by the International World Wide Web Conference Committee ( IW3C2 ) . Distribution of these papers is limited to classroom use , and personal use by others . WWW 2012 , April 16–20 , 2012 , Lyon , France . ACM 978 1 4503 1229 5/12/04 . to an RDF graph with OWL vocabulary that has been thoroughly studied with respect to these fundamental and desirable properties . Information preservation speaks to the ability of reconstructing the original database from the result of the direct mapping . Query preservation means that every query over a relational database can be translated into an equivalent query over the result of the direct mapping . Monotonicity is a desired property because it assures that a re computation of the entire mapping is not needed after any updates to the database . Finally , a direct mapping is semantics preserving if the satisfaction of a set of integrity constraints are encoded in the mapping result .
Our proposed direct mapping is monotone , information preserving and query preserving even in the general and practical scenario where relational databases contain null values . However , given a database that violates an integrity constraint , our direct mapping generates a consistent RDF graph , hence , it is not semantics preserving .
We analyze why our direct mapping is not semantics preserving and realize that monotonicity is an obstacle . We first show that if we only consider primary keys , we can still have a monotone direct mapping that is semantics preserving . However this result is not sufficient because it dismisses foreign keys . Unfortunately , we prove that no monotone direct mapping is semantics preserving if foreign keys are considered , essentially because the only form of constraint checking in OWL is satisfiability testing . This result has an important implication in real world applications : if you migrate your relational database to the Semantic Web using a monotone direct mapping , be prepared to experience consistency when what one would expect is inconsistency .
Finally , we present a non monotone direct mapping that overcomes the aforementioned limitation . We foresee the existence of monotone direct mappings if OWL is extended with the epistemic operator . Due to lack of space , the paper does not include the proofs of the results . We refer the reader to [ 19 ] for these proofs .
2 . PRELIMINARIES In this section , we define the basic terminology used in the paper .
2.1 Relational databases Assume , a countably infinite domain D and a reserved symbol NULL that is not in D . A schema R is a finite set of relation names , where for each R ∈ R , att(R ) denotes the nonempty finite set of attributes names associated to R . An instance I of R assigns to each relation symbol R ∈ R a finite set RI = {t1 , . . . , tℓ} of tuples , where each tuple tj ( 1 ≤ j ≤ ℓ ) is a function that assigns to each attribute in att(R ) a value from ( D ∪ {NULL} ) . We use notation t.A to refer to the value of a tuple t in an attribute A .
Relational algebra : To define some of the concept studied in this
WWW 2012 – Session : Ontology Representation and Querying : RDF and SPARQLApril 16–20 , 2012 , Lyon , France649 paper , we use relational algebra as a query language for relational databases . Given that we consider relational databases containing null values , we present in detail the syntax and semantics of a version of relational algebra that formalizes the way nulls are treated in practice in database systems . Formally , assume that R is a relational schema . Then a relational algebra expression ϕ over R and its set of attributes att(ϕ ) are recursively defined as follows : 1 . If ϕ = R with R ∈ R , then ϕ is a relational algebra expression over R such that att(ϕ ) = att(R ) .
2 . If ϕ = NULLA , where A is an attribute , then ϕ is a relational algebra expression over R such that att(ϕ ) = {A} .
3 . If ψ is a relational algebra expression over R , A ∈ att(ψ ) , a ∈ D and ϕ is any of the expressions σA=a(ψ ) , σA6=a(ψ ) , σIsNull(A)(ψ ) or σIsNotNull(A)(ψ ) , then ϕ is a relational algebra expression over R such that att(ϕ ) = att(ψ ) .
4 . If ψ is a relational algebra expression over R , U ⊆ att(ψ ) and ϕ = πU ( ψ ) , then ϕ is a relational algebra expression over R such that att(ϕ ) = U .
5 . If ψ is a relational algebra expression over R , A ∈ att(ψ ) , B is an attribute such that B 6∈ att(ψ ) and ϕ = δA→B(ψ ) , then ϕ is a relational algebra expression over R such that att(ϕ ) = ( att(ψ ) r {A} ) ∪ {B} .
6 . If ψ1 , ψ2 are relational algebra expressions over R and ϕ = ( ψ1 ⊲⊳ ψ2 ) , then ϕ is a relational algebra expression over R such that att(ϕ ) = ( att(ψ1 ) ∪ att(ψ2) ) .
7 . If ψ1 , ψ2 are relational algebra expressions over R such that att(ψ1 ) = att(ψ2 ) and ϕ is either ( ψ1 ∪ ψ2 ) or ( ψ1 r ψ2 ) , then ϕ is a relational algebra expression over R such that att(ϕ ) = att(ψ1 ) .
Let R be a relational schema , I an instance of R and ϕ a relational algebra expression over R . The evaluation of ϕ over I , denoted by JϕKI , is defined recursively as follows : 1 . If ϕ = R with R ∈ R , then JϕKI = RI .
2 . If ϕ = NULLA , where A is an attribute , then JϕKI = {t} , where t : {A} → ( D ∪ {NULL} ) is a tuple such that t.A = NULL .
3 . Let ψ be a relational algebra expression over R , A ∈ att(ψ ) If ϕ = σA=a(ψ ) , then JϕKI = {t ∈ JψKI | and a ∈ D . t.A = a} . If ϕ = σA6=a(ψ ) , then JϕKI = {t ∈ JψKI | t.A 6= NULL and t.A 6= a} . If ϕ = σIsNull(A)(ψ ) , then JϕKI = {t ∈ JψKI | t.A = NULL} . If ϕ = σIsNotNull(A)(ψ ) , then JϕKI = {t ∈ JψKI | t.A 6= NULL} .
4 . If ψ is a relational algebra expression over R , U ⊆ att(ψ ) and ϕ = πU ( ψ ) , then JϕKI = {t : U → ( D ∪ {NULL} ) | there exists t′ ∈ JψKI such that for every A ∈ U : t.A = t′A}
5 . If ψ is a relational algebra expression over R , A ∈ att(ψ ) , B is an attribute such that B 6∈ att(ψ ) and ϕ = δA→B(ψ ) , then JϕKI = {t : att(ϕ ) → ( D ∪ {NULL} ) | there exists t′ ∈ JψKI such that t.B = t′.A and for every C ∈ ( att(ϕ)r {B} ) : t.C = t′C}
6 . If ψ1 , ψ2 are relational algebra expressions over R and ϕ = ( ψ1 ⊲⊳ ψ2 ) , then JϕKI = {t : att(ϕ ) → ( D ∪ {NULL} ) | there exist t1 ∈ Jψ1KI and t2 ∈ Jψ2KI such that for every A ∈ ( att(ψ1 ) ∩ att(ψ2) ) : t.A = t1.A = t2.A 6= NULL , for every A ∈ ( att(ψ1 ) r att(ψ2) ) : t.A = t1.A , and for every A ∈ ( att(ψ2 ) r att(ψ1) ) : t.A = t2A}
It is important to notice that the operators left outer join , right outer join and full outer join are all expressible with the previous operators . For more details , we refer the reader to [ 19 ] .
Integrity constraints : We consider two types of integrity constraints : keys and foreign keys . Let R be a relational schema . A key ϕ over R is an expression of the form R[A1 , . . . , Am ] , where R ∈ R and ∅ ( {A1 , . . . , Am} ⊆ att(R ) . Given an instance I of R , I satisfies key ϕ , denoted by I |= ϕ , if : ( 1 ) for every t ∈ RI and k ∈ {1 , . . . , m} , it holds that t.Ak 6= NULL , and ( 2 ) for every t1 , t2 ∈ RI , if t1.Ak = t2.Ak for every k ∈ {1 , . . . , m} , then t1 = t2 . A foreign key over R is an expression of the form R[A1 , . . . , Am ] ⊆FK S[B1 , . . . , Bm ] , where R , S ∈ R , ∅ ( {A1 , . . . , Am} ⊆ att(R ) and ∅ ( {B1 , . . . , Bm} ⊆ att(S ) . Given an instance I of R , I satisfies foreign key ϕ , denoted by I |= ϕ , if I |= S[B1 , . . . , Bm ] and for every tuple t in RI : either ( 1 ) there exists k ∈ {1 , . . . , m} such that t.Ak = NULL , or ( 2 ) there exists a tuple s in SI such that t.Ak = s.Bk for every k ∈ {1 , . . . , m} .
Given a relational schema R , a set Σ of keys and foreign keys is said to be a set of primary keys ( PKs ) and foreign keys ( FKs ) over R if : ( 1 ) for every ϕ ∈ Σ , it holds that ϕ is either a key or a foreign key over R , and ( 2 ) there are no two distinct keys in Σ of the form R[A1 , . . . , Am ] and R[B1 , . . . , Bn ] ( that is , that mention the same relation name R ) . Moreover , an instance I of R satisfies Σ , denoted by I |= Σ , if for every ϕ ∈ Σ , it holds that I |= ϕ .
2.2 RDF and OWL Assume there are pairwise disjoint infinite sets I ( IRIs ) , B ( blank nodes ) and L ( literals ) . A tuple ( s , p , o ) ∈ ( I∪B)× I×(I∪B∪L ) is called an RDF triple , where s is the subject , p is the predicate and o is the object . A finite set of RDF triples is called an RDF graph . Moreover , assume the existence of an infinite set V of variables disjoint from the above sets , and assume that every element in V starts with the symbol ? .
In this paper , we consider RDF graphs with OWL vocabulary [ 1 ] , which is the W3C standard ontology language based on description logics , without datatypes . In particular , we say that an RDF graph G is consistent under OWL semantics if a model of G with respect to the OWL vocabulary exists ( see [ 1 ] for a precise definition of the notion of model and the semantics of OWL ) .
2.3 SPARQL In this paper , we use SPARQL as a query language for RDF graphs . The official syntax of SPARQL [ 17 , 12 ] considers operators OPTIONAL , UNION , FILTER , SELECT , AS and concatenation via a point symbol ( . ) , to construct graph pattern expressions . The syntax of the language also considers { } to group patterns , and some implicit rules of precedence and association . In order to avoid ambiguities in the parsing , we follow the approach proposed in [ 16 ] , and we present the syntax of SPARQL graph patterns in a more traditional algebraic formalism , using operators AND ( . ) , UNION ( UNION ) , OPT ( OPTIONAL ) , MINUS ( MINUS ) , FILTER ( FILTER ) , SELECT ( SELECT ) and AS ( AS ) . More precisely , a SPARQL graph pattern expression is defined recursively as follows .
1 . { } is a graph pattern ( the empty graph pattern ) .
2 . A tuple from ( I ∪ L ∪ V ) × ( I ∪ V ) × ( I ∪ L ∪ V ) is a graph pattern ( a triple pattern ) .
7 . Let ψ1 , ψ2 be relational algebra expressions over R such that att(ψ1 ) = att(ψ2 ) . If ϕ = ( ψ1 ∪ ψ2 ) , then JϕKI = Jψ1KI ∪ Jψ2KI . If ϕ = ( ψ1 r ψ2 ) , then JϕKI = Jψ1KI r Jψ2KI .
3 . If P1 and P2 are graph patterns , then expressions ( P1 AND P2 ) , ( P1 OPT P2 ) , ( P1 UNION P2 ) and ( P1 MINUS P2 ) are graph patterns .
WWW 2012 – Session : Ontology Representation and Querying : RDF and SPARQLApril 16–20 , 2012 , Lyon , France650 4 . If P is a graph pattern and R is a SPARQL built in condition , then the expression ( P FILTER R ) is a graph pattern .
5 . If P is a graph pattern and ?A1 , . . . , ?Am , ?B1 , . . . , ?Bm , ?C1 , . . . , ?Cn is a sequence of pairwise distinct elements from V ( m ≥ 0 and n ≥ 0 ) such that none of the variables ?Bi ( 1 ≤ i ≤ m ) is mentioned in P , then
( SELECT {?A1 AS ?B1 , . . . , ?Am AS ?Bm , ?C1 , . . . , ?Cn} P ) is a graph pattern .
A SPARQL built in condition is constructed using elements of the set ( I ∪ V ) and constants , logical connectives ( ¬ , ∧ , ∨ ) , inequality symbols ( < , ≤ , ≥ , > ) , the equality symbol ( = ) , unary predicates such as bound , isBlank , and isIRI ( see [ 17 , 12 ] for a complete list ) . In this paper , we restrict to the fragment where the built in condition is a Boolean combination of terms constructed by using = and bound , that is : ( 1 ) if ?X , ?Y ∈ V and c ∈ I , then bound(?X ) , ?X = c and ?X =?Y are built in conditions , and ( 2 ) if R1 and R2 are built in conditions , then ( ¬R1 ) , ( R1 ∨ R2 ) and ( R1 ∧ R2 ) are built in conditions .
The version of SPARQL used in this paper includes the following SPARQL 1.1 features : the operator MINUS , the possibility of nesting the SELECT operator and the operator AS [ 12 ] .
The answer of a SPARQL query P over an RDF graph G is a finite set of mappings , where a mapping µ is a partial function from the set V of variables to ( I ∪ L ∪ B ) . We define the semantics of SPARQL as a function J · KG that , given an RDF graph G , takes a graph pattern expression and returns a set of mappings . We refer the reader to [ 19 ] for more detail .
3 . DIRECT MAPPINGS : DEFINITION AND
PROPERTIES
A direct mapping is a default way to translate relational databases into RDF ( without any input from the user on how the relational data should be translated ) . The input of a direct mapping M is a relational schema R , a set Σ of PKs and FKs over R and an instance I of R . The output is an RDF graph with OWL vocabulary . Assume G is the set of all RDF graphs and RC is the set of all triples of the form ( R , Σ , I ) such that R is a relational schema , Σ is a set of PKs and FKs over R and I is an instance of R .
Definition 1 ( Direct mapping ) A direct mapping M is a total function from RC to G .
We now introduce two fundamental properties of direct mappings : information preservation and query preservation ; and two desirable properties of these mappings : monotonicity and semantic preservation . Information preservation is a fundamental property because it guarantees that the mapping does not lose information , which is fundamental in an Extract Transform Load process . Query preservation is also a fundamental property because it guarantees that everything that can be extracted from the relational database by a relational algebra query , can also be extracted from the resulting RDF graph by a SPARQL query . This property is fundamental for workloads that involve translating SPARQL to SQL . Monotonicity is a desirable property because it would avoid recalculating the mapping for the entire database after inserting new data . In addition to practical considerations when translating relational data to RDF graphs , we must deal with the closed world database semantics and open world RDF/OWL semantics . Understanding the expressive power of a mapping and , its ability to properly deal with integrity constraints is important . Thus our choice of examining semantics preservation .
3.1 Fundamental properties Information preservation : A direct mapping is information preserving if it does not lose any information about the relational instance being translated , that is , if there exists a way to recover the original database instance from the RDF graph resulting from the translation process . Formally , assuming that I is the set of all possible relational instances , we have that :
Definition 2 ( Information preservation ) A direct mapping M is information preserving if there is a computable mapping N : G → I such that for every relational schema R , set Σ of PKs and FKs over R , and instance I of R satisfying Σ : N ( M(R , Σ , I ) ) = I .
Recall that a mapping N : G → I is computable if there exists an algorithm that , given G ∈ G , computes N ( G ) .
Query preservation : A direct mapping is query preserving if every query over a relational database can be translated into an equivalent query over the RDF graph resulting from the mapping . That is , query preservation ensures that every relational query can be evaluated using the mapped RDF data .
To formally define query preservation , we focus on relational queries that can be expressed in relational algebra [ 3 ] and RDF queries that can be expressed in SPARQL [ 17 , 16 ] . In Section 2.1 , we introduced a version of relational algebra that formalizes the semantics of null values in practice . In Section 2.3 , we introduce an algebraic version of SPARQL that follows the approach proposed in [ 16 ] . Given the mismatch in the formats of these query languages , we introduce a function tr that converts tuples returned by relational algebra queries into mappings returned by SPARQL . Formally , given a relational schema R , a relation name R ∈ R , an instance I of R and a tuple t ∈ RI , define tr(t ) as the mapping µ such that : ( 1 ) the domain of µ is {?A | A ∈ att(R ) and t.A 6= NULL} , and ( 2 ) µ(?A ) = t.A for every A in the domain of µ .
Example 1 Assume that a relational schema contains a relation name STUDENT and attributes ID , NAME and AGE . Moreover , assume that t is a tuple in this relation such that t.ID = 1 , t.NAME = John and t.AGE = NULL . Then , tr(t ) = µ , where the domain of µ is {?ID , ?NAME} , µ(?ID ) = 1 and µ(?NAME ) = John .
Definition 3 ( Query preservation ) A direct mapping M is query preserving if for every relational schema R , set Σ of PKs and FKs over R and relational algebra query Q over R , there exists a SPARQL query Q⋆ such that for every instance I of R satisfying Σ : tr(JQKI ) = JQ⋆KM(R,Σ,I ) . It is important to notice that information preservation and query preservation are incomparable properties in our setting . On one side , if a direct mapping M is information preserving , this does not guarantee that every relational algebra query Q can be rewritten into an equivalent SPARQL query over the translated data , as M could transform source relational databases in such a way that a more expressive query language is needed to express Q over the generated RDF graphs . On the other side , a mapping M can be query preserving and not information preserving if the information about the schema of the relational database being translated is not stored . For example , we define in Section 4 a direct mapping DM that includes information about these relational schemas . It will become clear in Sections 4 and 5 that if such information is not stored , then DM would be query preserving but not information preserving .
3.2 Desirable properties Monotonicity : Given two database instances I1 and I2 over a relational schema R , instance I1 is said to be contained in instance I2 ,
WWW 2012 – Session : Ontology Representation and Querying : RDF and SPARQLApril 16–20 , 2012 , Lyon , France651 denoted by I1 ⊆ I2 , if for every R ∈ R , it holds that RI1 ⊆ RI2 . A direct mapping M is considered monotone if for any such pair of instances , the result of mapping I2 contains the result of mapping I1 . In other words , if we insert new data to the database , then the elements of the mapping that are already computed are unaltered .
Definition 4 ( Monotonicity ) A direct mapping M is monotone if for every relational schema R , set Σ of PKs and FKs over R , and instances I1 , I2 of R such that I1 ⊆ I2 : M(R , Σ , I1 ) ⊆ M(R , Σ , I2 ) .
Semantics preservation : A direct mapping is semantics preserving if the satisfaction of a set of PKs and FKs by a relational database is encoded in the translation process . More precisely , given a relational schema R , a set Σ of PKs and FKs over R and an instance I of R , a semantics preserving mapping should generate from I a consistent RDF graph if I |= Σ , and it should generate an inconsistent RDF graph otherwise .
Definition 5 ( Semantics preservation ) A direct mapping M is semantics preserving if for every relation schema R , set Σ of PKs and FKs over R and instance I of R : I |= Σ iff M(R , Σ , I ) is consistent under OWL semantics .
4 . THE DIRECT MAPPING DM We introduce a direct mapping DM , that integrates and extends the functionalities of the direct mappings proposed in [ 23 , 5 ] . DM is defined as a set of Datalog rules1 , which are divided in two parts : translate relational schemas and translate relational instances .
In Section 4.1 , we present the predicates that are used to store a relational database , the input of DM . In Section 4.2 , we present predicates that are used to store an ontology and Datalog rules to generate an ontology from the relational schema and the set of PKs and FKs . In Section 4.3 , we present the Datalog rules that generate the OWL vocabulary from the ontology that was derived from the relational schema and a set of PKs and FKs . Finally , we present in Section 4.4 the Datalog rules that generates RDF triples from a relational instance .
DEPT(DID,NAME ) this database consists of
Throughout this section , we use the following running example . Consider a relational database for a university . The schema of tables STUDENT(SID,NAME ) , COURSE(CID,TITLE,CODE ) , and ENROLLED(SID,CID ) . Moreover , we have the following constraints about the schema of the university : SID is the primary key of STUDENT , CID is the primary key of COURSE , DID is the primary key of DEPT , ( SID,CID ) is the primary key of ENROLLED , CODE is a foreign key in COURSE that references attribute DID in DEPT , SID is a foreign key in ENROLLED that references attribute SID in STUDENT , and CID is a foreign key in ENROLLED that references attribute CID in COURSE .
4.1 Storing relational databases Given that the direct mapping DM is specified by a set of Datalog rules , its input ( R , Σ , I ) has to be encoded as a set of relations . We define the predicates that are used to store the triples of the form ( R , Σ , I ) . More precisely , the following predicates are used to store a relational schema R and a set Σ of PKs and FKs over R .
• REL(r ) :
Indicates that r is a relation name in R ; eg REL("STUDENT" ) indicates that STUDENT is a relation name.2
1We refer the reader to [ 3 ] for the syntax and semantics of Datalog . 2As is customary , we use double quotes to delimit strings .
• ATTR(a , r ) : Indicates that a is an attribute in the relation r in
R ; eg ATTR("NAME" , "STUDENT" ) holds .
• PKn(a1 , . . . , an , r ) : Indicates that r[a1 , . . . , an ] is a primary key in Σ ; eg PK1("SID" , "STUDENT" ) holds .
• FKn(a1 , . . . , an , r , b1 , . . . , bn , s ) : r[a1 , . . . , an ] ⊆FK eg FK1("CODE" , "COURSE" , "DID" , "DEPT" ) holds . s[b1 , . . . , bn ]
Indicates that is a foreign key in Σ ;
Moreover , the following predicate is used to store the tuples in an relational instance I of a relational schema R . • VALUE(v , a , t , r ) :
Indicates that v is the value of an attribute a in a tuple with identifier t in a relation r ( that bea tuple t1 of table STUDENT such that longs to R ) ; eg t1.SID = "1" and t1.NAME = NULL is stored by using the facts VALUE("1" , "SID" , "id1" , "STUDENT" ) and VALUE(NULL , "NAME" , "id1" , "STUDENT" ) , assuming that id1 is the identifier of tuple t1 .
4.2 Storing an ontology In order to translate a relational database into an RDF graph with OWL vocabulary , we first extract an ontology from the relational schema and the set of PKs and FKs given as input . In particular , we classify each relation name in the schema as a class or a binary relation ( which is used to represent a many to many relationship between entities in an ER/UML diagram ) , we represent foreign keys as object properties and attributes of relations as data type properties . More specifically , the following predicates are used to store the extracted ontology : • CLASS(c ) : Indicates that c is a class . • OPn(p1 , . . . , pn , d , r ) : Indicates that p1 , . . . , pn ( n ≥ 1 ) form an object property with domain d and range r .
• DTP(p , d ) : Indicates that p is a data type property with domain d .
The above predicates are defined by the Datalog rules described in the following sections .
Identifying binary relations : We define auxiliary predicates that identify binary relations to facilitate identifying classes , object properties and data type properties . Informally , a relation R is a binary relation between two relations S and T if ( 1 ) both S and T are different from R , ( 2 ) R has exactly two attributes A and B , which form a primary key of R , ( 3 ) A is the attribute of a foreign key in R that points to S , ( 4 ) B is the attribute of a foreign key in R that points to T , ( 5 ) A is not the attribute of two distinct foreign keys in R , ( 6 ) B is not the attribute of two distinct foreign keys in R , ( 7 ) A and B are not the attributes of a composite foreign key in R , and ( 8 ) relation R does not have incoming foreign keys . In Datalog this becomes :
BINREL(R , A , B , S , C , T , D ) ←
PK2(A , B , R ) , ¬THREEATTR(R ) , FK1(A , R , C , S ) , R 6= S , FK1(B , R , D , T ) , R 6= T , ¬TWOFK(A , R ) , ¬TWOFK(B , R ) ,
( 1 )
¬ONEFK(A , B , R ) , ¬FKTO(R ) .
In a Datalog rule , negation is represented with the symbol ¬ and upper case letters are used to denote variables . Thus , the previous rule states that the relation R is a binary relation between two relations S and T if the following conditions are satisfied . ( a ) Expression PK2(A , B , R ) in ( 1 ) indicates that attributes A and B form a primary key of R . ( b ) Predicate THREEATTR checks whether a relation has at least three attributes , and it is defined as follows from the base predicate ATTR :
THREEATTR(R ) ← ATTR(X , R ) , ATTR(Y , R ) ,
ATTR(Z , R ) , X 6= Y , X 6= Z , Y 6= Z .
WWW 2012 – Session : Ontology Representation and Querying : RDF and SPARQLApril 16–20 , 2012 , Lyon , France652 Thus , expression ¬THREEATTR(R ) in ( 1 ) indicates that R has at least two attributes . Notice that by combining this expression with PK2(A , B , R ) , we conclude that A , B are exactly the attributes of R . ( c ) Expressions FK1(A , R , C , S ) and FK1(B , R , D , T ) in ( 1 ) indicate that A is the attribute of a foreign key in R that points to S and B is the attribute of a foreign key in R that points to T , respectively . ( d ) Expressions R 6= S and R 6= T in ( 1 ) indicate that both S and T are different from relation R . ( e ) Predicate TWOFK checks whether an attribute of a relation is the attribute of two distinct foreign keys in that relation , and it is defined as follows from the base predicate FK1 :
TWOFK(X , Y ) ← FK1(X , Y , U1 , V1 ) , FK1(X , Y , U2 , V2 ) ,
TWOFK(X , Y ) ← FK1(X , Y , U1 , V1 ) , FK1(X , Y , U2 , V2 ) ,
U1 6= U2
V1 6= V2
Thus , expressions ¬TWOFK(A , R ) and ¬TWOFK(B , R ) in ( 1 ) indicate that attribute A is not the attribute of two distinct foreign keys in R and B is not the attribute of two distinct foreign keys in R , respectively . ( f ) Predicate ONEFK checks whether a pair of attributes of a relation are the attributes of a composite foreign key in that relation :
ONEFK(X , Y , Z ) ← FK2(X , Y , Z , U , V , W ) ONEFK(X , Y , Z ) ← FK2(Y , X , Z , U , V , W )
Thus , expression ¬ONEFK(A , B , R ) in ( 1 ) indicates that attributes A , B of R are not the attributes of a composite foreign key in R . ( g ) Finally , predicate FKTO checks whether a relation with two attributes has incoming foreign keys :
FKTO(X ) ← FK1(U1 , Y , V , X ) FKTO(X ) ← FK2(U1 , U2 , Y , V1 , V2 , X )
Thus , expression ¬FKTO(R ) in ( 1 ) indicates that relation R does not have incoming foreign keys .
For instance , BINREL("ENROLLED" , "SID" , "CID" , "STUDENT" , "SID" , "COURSE" , "CID" ) holds in our example . Note that there is no condition in the rule ( 1 ) that requires S and T to be different , allowing binary relations that have their domain equal to their range . Also note that , for simplicity , we assume in the rule ( 1 ) that a binary relation R consists of only two attributes A and B . However , this rule can be easily extended to deal with binary relations generated from many to many relationships between entities in an ER/UML diagram that have more than two attributes .
Identifying classes : In our context , a class is any relation that is not a binary relation . That is , predicate CLASS is defined by the following Datalog rules :
CLASS(X ) ← REL(X ) , ¬ISBINREL(X )
ISBINREL(X ) ← BINREL(X , A , B , S , C , T , D )
In our example , CLASS("DEPT" ) , CLASS("STUDENT" ) and CLASS("COURSE" ) hold .
Identifying object properties : For every n ≥ 1 , the following rule is used for identifying object properties that are generated from foreign keys : 3
OP2n(X1 , . . . , Xn , Y1 , . . . , Yn , S , T ) ←
FKn(X1 , . . . , Xn , S , Y1 , . . . , Yn , T ) , ¬ISBINREL(S )
3Notice that although we consider an infinite number of rules in the definition of DM , for every concrete relational database we will need only a finite number of these rules .
This rule states that a foreign key represents an object property from the entity containing the foreign key ( domain ) to the referenced entity ( range ) . It should be noticed that this rule excludes the case of binary relations , as there is a special rule for this type of relations ( see rule ( 1) ) . In our example , OP2("CODE" , "DID" , "COURSE" , "DEPT" ) holds as CODE is a foreign key in the table COURSE that references attribute DID in the table DEPT .
Identifying data type properties : Every attribute in a non binary relation is mapped to a data type property :
DTP(A , R ) ← ATTR(A , R ) , ¬ISBINREL(R )
For instance , we have that DTP("NAME" , "STUDENT" ) holds in our example , while DTP("SID" , "ENROLLED" ) does not hold as ENROLLED is a binary relation .
4.3 Translating a relational schema into OWL We now define the rules that translates a relational database schema into an OWL vocabulary .
431 Generating IRIs for classes , object properties and data type properties
We introduce a family of rules that produce IRIs for classes , binary relations , object properties and data type properties identified by the mapping ( which are stored in the predicates CLASS , BINREL , OPn and DTP , respectively ) . Note that the IRIs generated can be later on replaced or mapped to existing IRIs available in the Semantic Web . Assume given a base IRI base for the relational database to be translated ( for example , "http://example.edu/db/" ) , and assume given a family of built in predicates CONCATn ( n ≥ 2 ) such that CONCATn has n+1 arguments and CONCATn(x1 , . . . , xn , y ) holds if y is the concatenation of the strings x1 , . . . , xn . Then by following the approach proposed in [ 5 ] , DM uses the following Datalog rules to produce IRIs for classes and data type properties :
CLASSIRI(R , X ) ← CLASS(R ) , CONCAT2(base , R , X )
DTP_IRI(A , R , X ) ← DTP(A , R ) , CONCAT4(base , R , "#" , A , X ) for instance , http://example.edu/db/STUDENT is For and the STUDENT relation in our example , the IRI IRI http://example.edu/db/STUDENT#NAME is the that for attribute NAME in the STUDENT relation ( recall DTP("NAME" , "STUDENT" ) holds in our example ) . Moreover , DM uses the following family of Datalog rules to generate IRIs for object properties . First , for object properties generated from binary relations , the following rules is used :
OP_IRI1(R , A , B , S , C , T , D , X ) ←
BINREL(R , A , B , S , C , T , D ) , CONCAT10(base , R , "#" , A , "," , B , "," , C , "," , D , X )
Thus , http://example.edu/db/ENROLLED#SID,CID,SID,CID is the IRI for binary relation ENROLLED in our example . Second , for object properties generated from a foreign key consisting of n attributes ( n ≥ 1 ) , the following rule is used :
OP_IRI2n(X1 , . . . , Xn , Y1 , . . . , Yn , S , T , X ) ←
OP2n(X1 , . . . , Xn , Y1 , . . . , Yn , S , T ) , CONCAT4n+4(base , S , "," , T , "#" , X1 , "," , . . . , Xn−1 , "," ,
Xn , "," , Y1 , "," , . . . , Yn−1 , "," , Yn , X ) that holds in our given
"DEPT" )
"DID" , Thus , IRI "COURSE" , http://example.edu/db/COURSE,DEPT#CODE,DID is generated to represented the fact that CODE is a foreign key in the table COURSE that references attribute DID in the table DEPT .
OP2("CODE" , example ,
WWW 2012 – Session : Ontology Representation and Querying : RDF and SPARQLApril 16–20 , 2012 , Lyon , France653 432 Translating relational schemas The following Datalog rules are used to generate the RDF representation of the OWL vocabulary . First , a rule is used to collect all the classes :
TRIPLE(U , "rdf:type" , "owl:Class" ) ←
CLASS(R ) , CLASSIRI(R , U )
Predicate TRIPLE is used to collect all the triples of the RDF graph generated by the direct mapping DM . Second , the following family of rules is used to collect all the object properties ( n ≥ 1 ) :
TRIPLE(U , "rdf:type" , "owl:ObjectProperty" ) ←
OPn(X1 , . . . , Xn , S , T ) , OP_IRIn(X1 , . . . , Xn , S , T , U )
Third , the following rule is used to collect the domains of the object properties ( n ≥ 1 ) :
TRIPLE(U , "rdfs:domain" , W ) ← OPn(X1 , . . . , Xn , S , T ) , OP_IRIn(X1 , . . . , Xn , S , T , U ) , CLASSIRI(S , W )
Fourth , the following rule is used to collect the ranges of the object properties ( n ≥ 1 ) :
TRIPLE(U , "rdfs:range" , W ) ← OPn(X1 , . . . , Xn , S , T ) ,
OP_IRIn(X1 , . . . , Xn , S , T , U ) , CLASSIRI(T , W )
Fifth , the following rule is used to collect all the data type properties :
TRIPLE(U , "rdf:type" , "owl:DatatypeProperty" ) ←
442 Translating relational instances The direct mapping DM generates three types of triples when translating a relational instance : Table triples , reference triples and literal triples [ 5 ] . Following are the Datalog rules for each one of these cases .
For table triples , DM produces for each tuple t in a relation R , a triple indicating that t is of type r . To construct these tuples , DM uses the following auxiliary rules :
TUPLEID(T , R,X ) ←
CLASS(R ) , PKn(A1 , . . . , An , R ) , VALUE(V1 , A1 , T , R ) , . . . , VALUE(Vn , An , T , R ) , ROWIRIn(V1 , . . . , Vn , A1 , . . . , An , T , R , X )
TUPLEID(T , R,X ) ←
CLASS(R ) , ¬HASPKn(R ) , VALUE(V , A , T , R ) , BLANKNODE(T , R , X )
That is , TUPLEID(T , R , X ) generates the identifier X of a tuple T of a relation R , which is an IRI if R has a primary key or a blank node otherwise . Notice that in the preceding rules , predicate HASPKn is used to check whether a table R with n attributes has a primary key ( thus , ¬HASPKn(R ) indicates that R does not have a primary key ) . Predicate HASPKn is defined by the following n rules :
HASPKn(X ) ← PKi(A1 , . . . , Ai , X ) i ∈ {1 , . . . , n}
DTP(A , R ) , DTP_IRI(A , R , U )
The following rule generates the table triples :
Finally , the following rule is used to collect the domains of the data type properties :
TRIPLE(U , "rdfs:domain" , W ) ←
TRIPLE(U , "rdf:type" , W ) ←
VALUE(V , A , T , R ) , TUPLEID(T , R , U ) , CLASSIRI(R , W )
DTP(A , R ) , DTP_IRI(A , R , U ) , CLASSIRI(R , W )
For example , the following is a table triple in our example :
4.4 Translating a database instance into RDF We now define the rules that map a relational database instance into RDF . More specifically , we first introduce a series of rules for generating IRIs , and then we present the Datalog rules that generate RDF .
441 Generating IRIs for tuples We introduce a family of predicates that produce IRIs for the tuples being translated , where we assume a given a base IRI base for the relational database ( for example , "http://exampleedu/db/" ) First , DM uses the following Datalog rule to produce IRIs for the tuples of the relations having a primary key :
ROWIRIn(V1 , V2 , . . . , Vn , A1 , A2 , . . . , An , T , R , X ) ←
TRIPLE("http://example.edu/db/STUDENT#SID=1" ,
"rdf:type" ,
"http://example.edu/db/STUDENT" )
For reference triples , DM generates triples that store the references generated by binary relations and foreign keys . More precisely , the following Datalog rule is used to construct reference triples for object properties that are generated from binary relations :
TRIPLE(U , V , W ) ← BINREL(R , A , B , S , C , T , D ) ,
VALUE(V1 , A , T1 , R ) , VALUE(V1 , C , T2 , S ) , VALUE(V2 , B , T1 , R ) , VALUE(V2 , D , T3 , T ) , TUPLEID(T2 , S , U ) , OP_IRI1(R , A , B , S , C , T , D , V ) , TUPLEID(T3 , T , W )
PKn(A1 , A2 , . . . , An , R ) , VALUE(V1 , A1 , T , R ) , VALUE(V2 , A2 , T , R ) , . . . , VALUE(Vn , An , T , R ) , CONCAT4n+2(base , R , "#" , A1 , "=" , V1 , "," , A2 , "=" , V2 , "," , . . . , "," , An , "=" , Vn , X )
Moreover , the following Datalog rule is used to construct reference triples for object properties that are generated from foreign keys ( n ≥ 1 ) :
TRIPLE(U , V,W ) ← the facts PK1("SID" , "STUDENT" ) and Thus , given that VALUE("1" , "SID" , "id1" , "STUDENT" ) hold in our example , the IRI http://example.edu/db/STUDENT#SID=1 is the identifier for the tuple in table STUDENT with value 1 in the primary key . Moreover , DM uses the following rule to generate blank nodes for the tuples of the relations not having a primary key :
BLANKNODE(T , R , X ) ←
VALUE(V , A , T , R ) , CONCAT3("_:" , R , T , X )
OP2n(A1 , . . . , An , B1 , . . . , Bn , S , T ) , VALUE(V1 , A1 , T1 , S ) , . . . , VALUE(Vn , An , T1 , S ) , VALUE(V1 , B1 , T2 , T ) , . . . , VALUE(Vn , Bn , T2 , T ) , TUPLEID(T1 , S , U ) , TUPLEID(T2 , T , W ) , OP_IRI2n(A1 , . . . , An , B1 , . . . , Bn , S , T , V )
Finally , DM produces for every tuple t in a relation R and for every attribute A of R , a triple storing the value of t in A , which is called a literal triple . The following Datalog rule is used to generate such triples :
WWW 2012 – Session : Ontology Representation and Querying : RDF and SPARQLApril 16–20 , 2012 , Lyon , France654 TRIPLE(U , V , W ) ← DTP(A , R ) , VALUE(W , A , T , R ) ,
W 6= NULL , TUPLEID(T , R , U ) , DTP_IRI(A , R , V )
Notice that in the above rule , we use the condition W 6= NULL to check that the value of the attribute A in a tuple T in a relation R is not null . Thus , literal triples are generated only for non null values . The following is an example of a literal triple :
TRIPLE("http://example.edu/db/STUDENT#SID=1" ,
"http://example.edu/db/STUDENT#NAME" , "John" )
5 . PROPERTIES OF DM We now study our direct mapping DM with respect to the two fundamental properties ( information preservation and query preservation ) and the two desirable properties ( monotonicity and semantics preservation ) defined in Section 3 .
5.1 Information preservation of DM First , we show that DM does not lose any piece of information in the relational instance being translated :
Theorem 1 The direct mapping DM is information preserving .
The proof of this theorem is straightforward , and it involves providing a computable mapping N : G → I that satisfies the condition in Definition 2 , that is , a computable mapping N that can reconstruct the initial relational instance from the generated RDF graph .
5.2 Query preservation of DM Second , we show that the way DM maps relational data into RDF allows one to answer a query over a relational instance by translating it into an equivalent query over the generated RDF graph .
Theorem 2 The direct mapping DM is query preserving .
In [ 4 ] , it was proved that SPARQL has the same expressive power as relational algebra . Thus , one may be tempted to think that this result could be used to prove Theorem 2 . However , the version of relational algebra considered in [ 4 ] does not include the null value NULL , and hence cannot be used to prove our result . In addition to this , other researchers have addressed the issue of querying answering on DL ontologies with relational databases [ 21 ] . Our work is similar in the sense that we address the issue of query preservation between a database and an ontology . However , the main difference is that rather than a domain ontology , the ontology we use is synthesized in a standard way from the database schema . Therefore , their results cannot be directly applied to our setting .
We present an outline of the proof of this theorem , and refer the reader to [ 19 ] for the details . Assume given a relational schema R and a set Σ of PKs and FKs over R . Then we have to show that for every relational algebra query Q over R , there exists a SPARQL query Q⋆ such that for every instance I of R ( possibly including null values ) satisfying Σ :
For the sake of readability , we introduce a function ν that retrieves the IRI for a given relation R , denoted by ν(R ) , and the IRI for a given attribute A in a relation R , denoted by ν(A , R ) . The inductive proof starts by considering the two base relational algebra queries : the identity query R , where R is a relation name in the relational schema R , and the query NULLA . These two base queries give rise to the following three base cases for the inductive proof .
Non binary relations : Assume that Q is the identity relational algebra query R , where R ∈ R is a non binary relation ( that is , ISBINREL(R ) does not hold ) . Moreover , assume that att(R ) = {A1 , . . . , Aℓ} , with the corresponding IRIs ν(R ) = r , ν(A1 , R ) = a1 , . . . , ν(Aℓ , R ) = aℓ . Then a SPARQL query Q⋆ satisfying ( 2 ) is constructed as follows :
SELECT {?A1 , . . . , ?Aℓ} » · · ·„„„(?X , "rdf:type" , r )
OPT ( ?X , a1 , ?A1)« OPT ( ?X , a2 , ?A2)« OPT ( ?X , a3 , ?A3)« · · · OPT ( ?X , aℓ , ?Aℓ)– .
Notice that in order to not lose information , the operator OPT is used ( instead of AND ) because the direct mapping DM does not translate NULL values . In our example , the relation name STUDENT is a non binary relation . Therefore the following equivalent SPARQL query is generated with input STUDENT :
SELECT {?SID , ?NAME} »„(?X , "rdf:type" , :STUDENT )
OPT ( ?X , :STUDENT#SID , ?SID)« OPT ( ?X , :STUDENT#NAME , ?NAME)–
It should be noticed that in the previous query , the symbol : has to be replaced by the base IRI used when generating IRIs for relations and attributes in a relation ( see Section 431 ) 4 .
Binary relations : Assume that Q is the identity relational algebra query R , where R ∈ R is a binary relation ( that is , ISBINREL(R ) holds ) . Moreover , assume that att(R ) = {A1 , A2} , where A1 is a foreign key referencing the attribute B of a relation S , and A2 is a foreign key referencing the attribute C of a relation T . Finally , assume that ν(R ) = r , ν(B , S ) = b and ν(C , T ) = c , Then a SPARQL query Q⋆ satisfying ( 2 ) is defined as follows :
SELECT {?A1 , ?A2} ( (?T1 , r , ?T2 ) AND
( ?T1 , b , ?A1 ) AND ( ?T2 , c , ?A2) ) .
Given that a binary relation is mapped to an object property , the values of a binary relation can be retrieved by querying the datatype properties of the referenced attributes . In our example , the relational name ENROLLED is a binary relation . Therefore the following equivalent SPARQL query is generated with input ENROLLED : tr(JQKI ) = JQ⋆KDM(R,Σ,I ) .
( 2 )
SELECT {?SID , ?CID}(
Interestingly , the proof that the previous condition holds is by induction on the structure of Q , and thus it gives us a bottom up algorithm for translating Q into an equivalent SPARQL query Q⋆ , that is , a query Q⋆ satisfying condition ( 2 ) . In what follows , we consider the database used as example in Section 4 and the relational algebra query σName=Juan(STUDENT ) ⊲⊳ ENROLLED , which we will use as a running example and translate it step by step to SPARQL , showing how the translation algorithm works .
( ?T1 , :ENROLLED#SID,CID,SID,CID , ?T2 ) AND ( ?T1 , :STUDENT#SID , ?SID ) AND ( ?T2 , :COURSE#CID , ?CID) ) .
4In SPARQL terminology , we have included the following prefix in the query : @prefix : <http://example.edu/db/> , if the base IRI is <http://exampleedu/db/>
WWW 2012 – Session : Ontology Representation and Querying : RDF and SPARQLApril 16–20 , 2012 , Lyon , France655 Empty relation : Assume that Q = NULLA , and define Q⋆ as the empty graph pattern { } . Then we have that condition ( 2 ) holds because of the definition of the function tr , which does not translate NULL values to mappings .
We now present the inductive step in the proof of Theorem 2 . Assume that the theorem holds for relational algebra queries Q1 and Q2 . That is , there exists SPARQL queries Q⋆ 2 such that :
1 and Q⋆ tr(JQ1KI ) = JQ⋆ tr(JQ2KI ) = JQ⋆
1KDM(R,Σ,I ) , 2KDM(R,Σ,I ) .
( 3 )
( 4 )
The proof continues by presenting equivalent SPARQL queries for the following relational algebra operators : selection ( σ ) , projection ( π ) , rename ( δ ) , join ( ⊲⊳ ) , union ( ∪ ) and difference ( r ) . It is important to notice that the operators left outer join , right outer join and full outer join are all expressible with the previous operators , hence we do not present cases for these operators . Selection : We need to consider four cases to define query Q⋆ satisfying condition ( 2 ) . In all these cases , we use the already established equivalence ( 3 ) . 1 . If Q is σA1=a(Q1 ) , then
Q⋆ = ( Q⋆
1 FILTER ( ?A1 = a) ) .
2 . If Q is σA16=a(Q1 ) , then
Q⋆ = ( Q⋆
1 FILTER ( ¬(?A1 = a ) ∧ bound(?A1)) ) .
3 . If Q is σIsNull(A1)(Q1 ) , then
Q⋆ = ( Q⋆
1 FILTER ( ¬ bound(?A1)) ) .
4 . If Q is σIsNotNull(A1)(Q1 ) , then
Q⋆ = ( Q⋆
1 FILTER ( bound(?A1)) ) .
These equivalences are straightforward . However , it is important to note the use of bound(· ) in the second case ; as the semantics of relational algebra states that if Q is the query σA16=a(Q1 ) , then JQKI = {t ∈ JQ1KI | t.A1 6= NULL and t.A1 6= a} , we have that the variable ?A1 has to be bound because the values in the attribute A1 in the answer to σA16=a(Q1 ) are different from NULL . Following our example , we have that the following SPARQL query is generated with input σName=Juan(STUDENT ) :
„ SELECT {?SID , ?NAME} »„(?X , "rdf:type" , :STUDENT )
OPT ( ?X , :STUDENT#SID , ?SID)« OPT ( ?X , :STUDENT#NAME , ?NAME)–«
FILTER ( ?NAME = Juan )
=
1 ) .
It is important
Assume that Q satisfying condition ( 2 )
π{A1,,Aℓ}(Q1 ) Projection : Then query Q⋆ is defined as ( SELECT {?A1 , . . . , ?Aℓ} Q⋆ to notice that we use nested SELECT queries to deal with projection , as well as in two of the base cases , which is a functionality specific to SPARQL 1.1 [ 12 ] . Rename : Assume that Q = δA1→B1 ( Q1 ) and att(Q ) = {A1 , . . . , Aℓ} . Then query Q⋆ satisfying condition ( 2 ) is defined as ( SELECT {?A1 AS ?B1 , ?A2 , . . . , ?Aℓ} Q⋆ 1 ) . Notice that this equivalence holds because the rename operator in relational algebra renames one attribute to another and projects all attributes of Q .
Join : Assume that Q = ( Q1 ⊲⊳ Q2 ) , where ( att(Q1)∩att(Q2 ) ) = {A1 , . . . , Aℓ} . Then query Q⋆ satisfying condition ( 2 ) is defined as follows :
1 FILTER ( bound(?A1 ) ∧ · · · ∧ bound(?Aℓ))« AND »„Q⋆ 2 FILTER ( bound(?A1 ) ∧ · · · ∧ bound(?Aℓ))«– . „Q⋆
Note the use of bound(· ) which is necessary in the SPARQL query in order to guarantee that the variables that are being joined on are not null . Following our example , Figure 1 shows the SPARQL query generated with input σName=Juan(STUDENT ) ⊲⊳ ENROLLED . Union : Assume that Q = ( Q1 ∪ Q2 ) . Then query Q⋆ satisfying condition ( 2 ) is simply defined as ( Q⋆ 2 ) . Notice that in this case we are using the already established equivalences ( 3 ) and ( 4 ) .
1 UNION Q⋆
Difference : We conclude our proof by assuming that Q = ( Q1 r Q2 ) . In this case , it is also possible to define a SPARQL query Q⋆ satisfying condition ( 2 ) . Due to the lack of space and the complex structure of this query , we refer the reader to [ 19 ] for its complete description .
5.3 Monotonicity and semantics preservation of DM
Finally , we consider the two desirable properties identified in Section 32 First , it is straightforward to see that DM is monotone , because all the negative atoms in the Datalog rules defining DM refer to the schema , the PKs and the FKs of the database , and these elements are kept fixed when checking monotonicity . Unfortunately , the situation is completely different for the case of semantics preservation , as the following example shows that the direct mapping DM does not satisfy this property .
Example 2 Assume that a relational schema contains a relation with name STUDENT and attributes SID , NAME , and assume that the attribute SID is the primary key . Moreover , assume that this relation has two tuples , t1 and t2 such that t1.SID = 1 , t1.NAME = John and t2.SID = 1 , t2.NAME = Peter . It is clear that the primary key is violated , therefore the database is inconsistent . However , it is not difficult to see that after applying DM , the resulting RDF graph is consistent .
In fact , the result in Example 2 can be generalized as it is possible to show that the direct mapping DM always generates a consistent RDF graph , hence , it cannot be semantics preserving .
Proposition 1 The direct mapping DM is not semantics preserving .
Does this mean that our direct mapping is incorrect ? What could we do to create a direct mapping that is semantics preserving ? These problems are studied in depth in the following section .
6 . SEMANTICS PRESERVATION OF
DIRECT MAPPINGS
We now study the problem of generating a semantics preserving direct mapping . Specifically , we show in Section 6.1 that a simple extension of the direct mapping DM can deal with primary keys . Then we show in Section 6.2 that dealing with foreign keys is more difficult , as any direct mapping that satisfies the condition of being monotone cannot be semantics preserving . Finally , we present two possible ways of overcoming this limitation .
WWW 2012 – Session : Ontology Representation and Querying : RDF and SPARQLApril 16–20 , 2012 , Lyon , France656 »„„ SELECT {?SID , ?NAME} »„(?X , "rdf:type" , :STUDENT ) OPT ( ?X , :STUDENT#SID , ?SID)« OPT
( ?X , :STUDENT#NAME , ?NAME)–« FILTER ( ?NAME = Juan)« FILTER ( bound(?SID))–
AND
»„ SELECT {?SID , ?CID}„(?T1 , :ENROLLED#SID,CID,SID,CID , ?T2 ) AND ( ?T1 , :STUDENT#SID , ?SID ) AND
( ?T2 , :COURSE#CID , ?CID)«« FILTER ( bound(?SID))–
Figure 1 : SPARQL translation of the relational algebra query σName=Juan(STUDENT ) ⊲⊳ ENROLLED .
6.1 A semantics preserving direct mapping for
6.2 Semantics preserving direct mappings for primary keys
Recall that a primary key can be violated if there are repeated values or null values . At a first glance , one would assume that owl:hasKey could be used to create a semantics preserving direct mapping for primary keys . If we consider a database without null values , a violation of the primary key would generate an inconsistency with owl:hasKey and the unique name assumption ( UNA ) . However , if we consider a database with null values , then owl:hasKey with the UNA does not generate an inconsistency because it is trivially satisfied for a class expression that does not have a value for the datatype expression . Therefore , we must consider a different approach .
Consider a new direct mapping DMpk that extends DM as follows . A Datalog rule is used to determine if the value of a primary key attribute is repeated , and a family of Datalog rules are used to determine if there is a value NULL in a column corresponding to a primary key . If some of these violations are found , then an artificial triple is generated that would produce an inconsistency . For example , the following rules are used to map a primary key with two attributes :
TRIPLE(a , "owl:differentFrom" , a ) ← PK2(X1 , X2 , R ) ,
VALUE(V1 , X1 , T1 , R ) , VALUE(V1 , X1 , T2 , R ) , VALUE(V2 , X2 , T1 , R ) , VALUE(V2 , X2 , T2 , R ) , T1 6= T2
TRIPLE(a , "owl:differentFrom" , a ) ← PK2(X1 , X2 , R ) ,
VALUE(V , X1 , T , R ) , V = NULL
TRIPLE(a , "owl:differentFrom" , a ) ← PK2(X1 , X2 , R ) ,
VALUE(V , X2 , T , R ) , V = NULL
In the previous rules , a is any valid IRI . If we apply DMpk to the database of Example 2 , it is straightforward to see that starting from an inconsistent relational database , one obtains an RDF graph that is also inconsistent . In fact , we have that :
Proposition 2 The direct mapping DMpk is information preserving , query preserving , monotone , and semantics preserving if one considers only PKs . That is , for every relational schema R , set Σ of ( only ) PKs over R and instance I of R : I |= Σ iff DMpk(R , Σ , I ) is consistent under OWL semantics .
Information preservation , query preservation and monotonicity of DMpk are corollaries of the fact that these properties hold for DM , and of the fact that the Datalog rules introduced to handle primary keys are monotone .
A natural question at this point is whether DMpk can also deal with foreign keys . Unfortunately , it is easy to construct an example that shows that this is not the case . Does this mean that we cannot have a direct mapping that is semantics preserving and considers foreign keys ? We show in the following section that monotonicity has been one of the obstacles to obtain such a mapping . primary keys and foreign keys
The following theorem shows that the desirable condition of being monotone is , unfortunately , an obstacle to obtain a semantics preserving direct mapping .
Theorem 3 No monotone direct mapping is semantics preserving .
It is important to understand the reasons why we have not been able to create a semantics preserving direct mapping . The issue is with two characteristics of OWL : ( 1 ) it adopts the Open World Assumption ( OWA ) , where a statement cannot be inferred to be false on the basis of failing to prove it , and ( 2 ) it does not adopt the Unique Name Assumption ( UNA ) , where two different names can identify the same thing . On the other hand , a relational database adopts the Closed World Assumption ( CWA ) , where a statement is inferred to be false if it is not known to be true . In other words , what causes an inconsistency in a relational database , can cause an inference of new knowledge in OWL .
In order to preserve the semantics of the relational database , we need to ensure that whatever causes an inconsistency in a relational database , is going to cause an inconsistency in OWL . Following this idea , we now present a non monotone direct mapping , DMpk+fk , which extends DMpk by introducing rules for verifying beforehand if there is a violation of a foreign key constraint . If such a violation exists , then an artificial RDF triple is created which will generate an inconsistency with respect to the OWL semantics . More precisely , the following family of Datalog rules are used in DMpk+fk to detect an inconsistency in a relational database :
VIOLATION(S ) ←
FKn(X1 , . . . , Xn , S , Y1 , . . . , Yn , T ) , VALUEn(V1 , X1 , T , S ) , . . . , VALUE(Vn , Xn , T , S ) , V1 6= NULL , . . . , Vn 6= NULL , ¬ISVALUEn(V1 , . . . , Vn , Y1 , . . . , Yn , T )
In the preceding rule , the predicate ISVALUEn is used to check whether a tuple in a relation has values for some given attributes . The predicate ISVALUEn is defined by the following rule :
ISVALUEn(V1 , . . . , Vn , B1 , . . . , Bn , S ) ←
VALUE(V1 , B1 , T , S ) , . . . , VALUE(Vn , Bn , T , S )
Finally , the following Datalog rule is used to obtain an inconsistency in the generated RDF graph :
TRIPLE(a , "owl:differentFrom" , a ) ← VIOLATION(S )
In the previous rule , a is any valid IRI . It should be noticed that DMpk+fk is non monotone because if new data in the database is added which now satisfies the FK constraint , then the artificial RDF triple needs to be retracted .
WWW 2012 – Session : Ontology Representation and Querying : RDF and SPARQLApril 16–20 , 2012 , Lyon , France657 9 . REFERENCES
[ 1 ] W3C OWL Working Group . OWL 2 Web ontology language document overview . W3C Recommendation 27 October 2009 , http://wwww3org/TR/owl2 overview/
[ 2 ] D2R Server . Publishing Relational Databases on the Semantic Web http://www4wiwissfu berlinde/bizer/d2r server/
[ 3 ] S . Abiteboul , R . Hull , and V . Vianu . Foundations of Databases .
Addison Wesley , 1995 .
[ 4 ] R . Angles and C . Gutierrez . The expressive power of sparql . In
ISWC , pages 114–129 , 2008 .
[ 5 ] M . Arenas , A . Bertails , E . Prud’hommeaux , and J . Sequeda . Direct mapping of relational data to RDF . W3C Working Draft 20 September 2011 , http://wwww3org/TR/rdb direct mapping/
[ 6 ] A . Bertails , and E . Prud’hommeaux . Interpreting relational databases in the RDF domain In K CAP , pages 129–136 , 2011 .
[ 7 ] D . Calvanese , G . D . Giacomo , D . Lembo , M . Lenzerini , and R . Rosati . Eql lite : Effective first order query processing in description logics . In IJCAI , pages 274–279 , 2007 .
[ 8 ] F . Cerbah . Mining the Content of Relational Databases to Learn Ontologies with Deeper Taxonomies In Web Intelligence , pages 553 557 , 2008 .
[ 9 ] F . Donini , M . Lenzerini , D . Nardi , W . Nutt , and A . Schaerf . An epistemic operator for description logics . Artif . Intell . , 100(1 2):225–274 , 1998 .
[ 10 ] F . M . Donini , D . Nardi , and R . Rosati . Description logics of minimal knowledge and negation as failure . ACM TOCL , 3(2):177–225 , 2002 .
[ 11 ] S . Grimm and B . Motik . Closed world reasoning in the semantic web through epistemic operators . In OWLED , 2005 .
[ 12 ] S . Harris and A . Seaborne . SPARQL 1.1 query language . W3C
Working Draft 12 May 2011 , http://wwww3org/TR/sparql11 query/
[ 13 ] B . He , M . Patel , Z . Zhang , and K . C C Chang . Accessing the deep web . Commun . ACM , 50:94–101 , May 2007 .
[ 14 ] A . Mehdi , S . Rudolph , and S . Grimm . Epistemic querying of OWL knowledge bases . In ESWC ( 1 ) , pages 397–409 , 2011 .
[ 15 ] B . Motik , I . Horrocks , and U . Sattler . Bridging the gap between OWL and relational databases . J . Web Sem . , 7(2):74–89 , 2009 .
[ 16 ] J . Pérez , M . Arenas , and C . Gutierrez . Semantics and complexity of
SPARQL . ACM Trans . Database Syst . , 34(3 ) , 2009 .
[ 17 ] E . Prud’hommeaux and A . Seaborne . SPARQL query language for
RDF . W3C Recommendation 15 January 2008 , http://wwww3org/TR/rdf sparql query/
[ 18 ] R . Reiter . On integrity constraints . In TARK , pages 97–111 , 1988 . [ 19 ] J . F . Sequeda , M . Arenas , and D . P . Miranker . On Directly Mapping
Relational Databases to RDF and OWL ( Extended Version ) . arXiv:1202.3667 [ cs.DB ] ( February 2012 ) , http://arxivorg/abs/12023667
[ 20 ] J . F . Sequeda , S . H . Tirmizi , O . Corcho , and D . P . Miranker . Survey of directly mapping sql databases to the semantic web . Knowledge Eng . Review , 26(4 ) : 445 486 ( 2011 )
[ 21 ] I . Seylan , E . Franconi , and J . De Bruijn . Effective query rewriting with ontologies over DBoxes . In IJCAI , pages 923–929 , 2009 .
[ 22 ] J . Tao , E . Sirin , J . Bao , and D . L . McGuinness . Integrity constraints in OWL . In AAAI , 2010 .
[ 23 ] S . H . Tirmizi , J . Sequeda , and D . P . Miranker . Translating SQL
Applications to the Semantic Web . In DEXA , pages 450–464 , 2008 .
Theorem 4 The direct mapping DMpk+fk is information preserving , query preserving and semantics preserving .
Information preservation and query preservation of DMpk+fk are corollaries of the fact that these properties hold for DM and DMpk . A direct mapping that satisfies the four properties can be obtained by considering an alternative semantics of OWL that expresses integrity constraints . Because OWL is based on Description Logic , we would need a version of DL that supports integrity constraints , which is not a new idea . Integrity constraints are epistemic in nature and are about “ what the knowledge base knows ” [ 18 ] . Extending DL with the epistemic operator K has been studied [ 7 , 9 , 10 ] . Grimm et al . proposed to extend the semantics of OWL to support the epistemic operator [ 11 ] . Motik et al . proposed to write integrity constraints as standard OWL axioms but interpreted with different semantics for data validation purposes [ 15 ] . Tao et al . showed that integrity constraint validation can be reduced to SPARQL query answering [ 22 ] . Recently , Mehdi et al . introduced a way to answer epistemic queries to restricted OWL ontologies [ 14 ] . Thus , it is possible to extend DMpk to create an information preserving , query preserving and monotone direct mapping that is also semantics preserving , but it is based on a non standard version of OWL including the epistemic operator K .
7 . CONCLUDING REMARKS In this paper , we study how to directly map relational databases to an RDF graph with OWL vocabulary based on two fundamental properties ( information preservation and query preservation ) and two desirable properties ( monotonicity and semantics preservation ) . We first present a monotone , information preserving and query preserving direct mapping considering databases that have null values . Then we prove that the combination of monotonicity with the OWL semantics is an obstacle to generating a semantics preserving direct mapping . Finally , we overcome this obstacle by presenting a nonmonotone direct mapping that is semantics preserving , and also by discussing the possibility of generating a monotone mapping that assumes an extension of OWL with the epistemic operator .
Related Work : Several approaches directly map relational schemas to RDFS and OWL . We refer the reader to the following survey [ 20 ] . D2R Server has an option that directly maps the relational database into RDF , however this process is not documented [ 2 ] . RDBToOnto presents a direct mapping that mines the content of the relational databases in order to learn ontologies with deeper taxonomies [ 8 ] . Currently , the W3C RDB2RDF Working Group is developing a direct mapping standard that focuses on translating relational database instances to RDF [ 5 , 6 ] .
Future Work : We would like to extend our direct mapping to consider datatypes , relational databases under bag semantics and evaluate this rule based approach on large relational databases . The extension of our direct mapping to bag semantics is straightforward . In our setting each tuple has its own identifier , which is represented in the VALUE predicate . Thus , even if repeated tuples exist , each tuple will still have its unique identifier and , therefore , exactly the same rules can be used to map relational data under bag semantics .
8 . ACKNOWLEDGMENTS The authors would like to thank the anonymous referees for many helpful comments , and the members of the W3C RDB2RDF Working group for many fruitful discussions . J . F . Sequeda was supported by the NSF Graduate Research Fellowship , M . Arenas by Fondecyt grant #1090565 and DP Miranker by NSF grant #1018554 .
WWW 2012 – Session : Ontology Representation and Querying : RDF and SPARQLApril 16–20 , 2012 , Lyon , France658
