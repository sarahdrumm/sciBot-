Handling Forecast Errors
While Bidding for Display Advertising
Kevin J . Lang Yahoo! Research Santa Clara , CA langk@yahoo inc.com
Benjamin Moseleyfi University of Illinois
Urbana , IL bmosele2@illinois.edu
Sergei Vassilvitskii
Yahoo! Research
New York , NY sergei@yahoo inc.com
ABSTRACT Most of the online advertising today is sold via an auction , which requires the advertiser to respond with a valid bid within a fraction of a second . As such , most advertisers employ bidding agents to submit bids on their behalf . The architecture of such agents typically has ( 1 ) an offline optimization phase which incorporates the bidder ’s knowledge about the market and ( 2 ) an online bidding strategy which simply executes the offline strategy . The online strategy is typically highly dependent on both supply and expected price distributions , both of which are forecast using traditional machine learning methods . In this work we investigate the optimum strategy of the bidding agent when faced with incorrect forecasts . At a high level , the agent can invest resources in improving the forecasts , or can tighten the loop between successive offline optimization cycles in order to detect errors more quickly . We show analytically that the latter strategy , while simple , is extremely effective in dealing with forecast errors , and confirm this finding with experimental evaluations .
Categories and Subject Descriptors F20 [ Analysis of Algorithms and Problem Complexity ] : General ; G23 [ Mathematics of Computing ] : Discrete Mathematics|Applications
General Terms Algorithms , Theory , Experimentation
Keywords Ad Exchanges , Bidding Agents , Adaptive Bidding
1 .
INTRODUCTION
Online advertising is a multi billion dollar industry , with billions of auctions taking place daily . At such scales automated bidding agents have become the norm . An automated agent takes as input a set of parameters , or goals , of the advertiser : for example , the targeting constraints , desired number of impressions , quality constraints , etc . , and fiWork done while visiting Yahoo! Labs . Partially supported by the NSF grant CCF 1016684 .
Copyright is held by the International World Wide Web Conference Committee ( IW3C2 ) . Distribution of these papers is limited to classroom use , and personal use by others . WWW 2012 , April 16(cid:150)20 , 2012 , Lyon , France . ACM 978 1 4503 1229 5/12/04 . then outputs a bid for every advertising opportunity . The bids from all interested parties are collected by the publisher , often through an advertising exchange ( eg RightMedia Exchange , Google Ad Exchange ) , and the opportunity to show an advertisement is given to the highest bidder .
The goals of the bidding agents are quite diverse : some bidding agents aim to maximize the number of clicks or conversions for an advertiser , others look to achieve a representative allocation , aiming for a uniform slice of all eligible impressions [ 8 ] , still others care about temporal smoothness , making sure the advertiser receives a stream of impressions throughout the day , as opposed to getting them all in the morning or in the evening . Regardless of the specific goal , almost all of the agents rely on some sort of forecasting in order to properly set the bidding parameters . Specifically , almost all of the optimization formulations rely on supply and price forecasts . Intuitively , the forecasts are needed to judge the utility of a specific impression . Deciding whether an impression looks cheap or expensive requires the knowledge of the typical price of such impressions . Similarly , knowing how many of such impressions will arrive in the future helps decide the urgency with which the bidding agent should be bidding , since most advertisers have an additional budget constraint on their campaigns .
Accurately predicting both supply and price forecasts is a non trivial endeavor . For example , for the supply forecasts , although general traffic trends stay consistent day to day| there are more impressions in the middle of the day than in the middle of the night|the exact forecasts experience a lot of daily fluctuations |the Oscars , for example will change the traffic pattern for websites related to the entertainment industry .
Moreover , an individual bidder may not have access to the necessary data to make the desired predictions . Some exchanges employ selective call out strategies [ 1 ] , wherein the number of eligible impressions observed by the bidder is correlated with his win percentage . In other situations , when the bidding agents are hosted by the exchange , the exchange only reports the number of won opportunities for each bidder , not the number of eligible opportunities . ( In fact early termination methods [ 11 ] result in situations where a full eligible set is never computed for each opportunity . )
All of the above leads to a natural question for a bidding agent designer : how to deal with forecast errors in developing a bidding strategy . One approach requires investing heavily in better forecasting strategies to reduce the number of errors , but one quickly hits a state of diminishing returns : there is enough entropy in the system , so that perfect fore
WWW 2012 – Session : Advertising on the Web 2April 16–20 , 2012 , Lyon , France371 casts are simply not achievable . A different approach is to myopically adjust the bidding parameters based on the past history , relying on frequent re optimization to achieve the goals of the agent . In this work we formally analyze the latter approach , and show that as long as the adjustments are done sufficiently frequently , the agent can automatically compensate for reasonably large errors in forecasts . 1.1 Related Work
Advertising exchanges sell billions of impressions per day requiring the use of automated bidding agents to buy advertising opportunities online [ 13 ] . The typical problem facing a bidding agent is to obtain a target number of impressions to users satisfying specific targeting characteristics ( eg Male , Age > 30 ) over some limited time horizon ( eg one week ) , while limited by a budget constraint .
The problem of finding a good bidding strategy falls under the larger umbrella of allocation problems for display advertising . Previous work focused on the allocation problem in the Guaranteed Advertising scenario , where a publisher is trying to satisfy multiple display advertising contracts simultaneously , by deciding which ad to show to each user visiting his page . This problem is often modeled as an online matching problem , which has a rich history beginning with the seminal work by Karp et al . [ 10 ] who showed a lower bound of 1 , 1=e on the competitive ratio of any algorithm , and gave a randomized algorithm that matched that bound . This work has been applied to the online advertising scenario in a series of works by Feldman et al . [ 6 , 7 ] , who used the specifics of the problem to improve on that bound .
A different direction was to phrase the problem as a stochas tic optimization problem , where the user arrivals are not adversarial , but rather are drawn from some distribution . Devanur and Hayes [ 5 ] assumed that the arrivals are independent and effectively showed how to learn the distribution before performing the analysis . Vee et al . [ 14 ] , assumed full knowledge of the distributions and focused on providing a compact strategy that can be readily implemented in ad serving . Only the recent work by Chen et al . [ 3 ] explicitly addressed the limitations of supply forecasts and experimentally showed that control theory based methods mitigate the impact of forecast errors . In this work we show both analytically and experimentally that even simpler methods lead to good performance .
The allocation problems described above focus on obtaining the target number of impressions in situations where the publisher controls the allocation , and hence no explicit bidding is necessary . Requiring that the bidding agent buy the impressions directly from an exchange adds an additional layer of complexity . In addition to supply forecasts , the competitors bids need to be forecast as well [ 4 ] , or learned in real time [ 9 ] . Moreover , the choice of the objective function for the bidder becomes more important . For example , Ghosh et al . [ 8 ] conclude that one should aim for a fair or representative allocation , rather than getting the cheapest impressions possible . 1.2 Our Contribution
We explicitly study the problem faced by the bidding agent designer in the face of inaccurate forecasts . We begin by analytically bounding the error in the number of impressions won and the total spend when given inaccurate forecasts and using a well known bidding strategy . We then show that a simple algorithm that myopically re optimizes the bidding parameters can greatly mitigate the errors in the forecasts . The algorithm is simple and requires minimal feedback from the system , yet a formal analysis shows that the re optimization approach quickly converges to the bidder ’s desired budget and demand . We prove the algorithm ’s effectiveness as a function of the number of update cycles and the original error in the forecasts . We conclude with an experimental analysis on both synthetic and real world datasets . Our experimental evaluations shows that the algorithm performs extremely well on real data , even with forecasts with large error .
2 . PRELIMINARIES
We consider the problem from the perspective of a single advertiser , Alice , bidding in a second price auction . Alice has a total budget of B and desires to win D impressions . We note that Alice ’s goal is not to win D impressions at minimum cost : as [ 8 ] argued , advertisers in these markets have a common value , which means the cheapest impressions are precisely the lowest quality ones . This setting best describes advertisers buying individual impressions.1 At every opportunity , Alice can submit a bid b . Other advertisers submit bids as well , and we model the highest competing bid as being chosen independently from a distribution with density pfi , and CDF of P fi . Let c P fi be the highest competitor bid . If b > c then Alice wins the impression , decrementing her desired demand by 1 and her budget by c . Otherwise , c b and Alice loses the impression , leaving her demand and her remaining budget unchanged .
If the distribution P fi and the total number of impressions nfi is known to Alice , she can use an easy bidding strategy that achieves her demand while spending exactly the budget . We call this algorithm SingleRound . To analyze the algorithm , we will denote by DA the total number of auctions won using bidding strategy A , dropping the subscript when it ’s clear from the context . Similarly , denote by BA the expected budget spent using strategy A .
Let t = B=D be the desired target spend per win . If t E[P fi ] then there exists a bid bfi so that the expected price to Alice conditioned on winning the impression is exactly t , ie
E[pjp < bfi ] = t :
The expected number of impressions won by bidding bfi is exactly n P fi(bfi ) . The SingleRound bidding strategy bids bfi with probability qfi = nfi P fi(bfi ) ( For simplicity we assume that qfi 1 , we investigate this further in Section 5 . ) It is easy to see that E[D ] = D and E[B ] = B .
D
Unfortunately , in practice , neither the total supply , nfi , nor the price distribution , P fi are known ahead of time , instead only forecasts , which we denote by n and P respectively , are available . To quantify the forecast error , we will use ffi to denote the relative error in the supply forecast : nfi(1 , ffi ) n nfi(1 + ffi ) . Similarly , we denote by fl the relative error in the price forecast : for any b 0 , pfi(b)(1 , fl ) p(b ) pfi(b)(1 + fl ) . We emphasize that while we use ffi and fl for the analysis , neither of the parameters is known to the advertiser .
1The underlying problem is similar for CPC advertisers who only pay per click .
WWW 2012 – Session : Advertising on the Web 2April 16–20 , 2012 , Lyon , France372 3 . NON ADAPTIVE ALGORITHM
4 . ADAPTIVE ALGORITHM
In this Section we analyze the performance of a nonadaptive bidding algorithm as a function of the forecast errors , ffi and fl . As we saw before , given the bidding agent parameters : the demand D and the budget B , and the forecast of others’ behavior : the total supply , n and the distribution of the highest competing bid , P , the algorithm SingleRound achieves the goals in expectation . Here SingleRound uses the forecasts P and n as if they were the actual supply and bid landscape to determine the bid and probability of bidding .
Now consider the performance of SingleRound in the face of forecast errors . We bound the demand fulfilled , ie the number of auctions won , and the budget spent :
Theorem 31 Consider the bidding strategy SingleRound , under supply forecast error , ffi , and bid forecast error fl .
Then and
D
( 1 + fl)(1 + ffi )
E [ D ]
D
( 1 , fl)(1 , ffi )
B
( 1 + fl)(1 + ffi )
E [ B ]
B
( 1 , fl)(1 , ffi )
;
:
Proof . Let y be the bid computed by SingleRound , and q the probability of participating . Then the expected number of impressions won is
E[D ] = q P fi(y ) nfi
=
D nP ( y )
P fi(y ) nfi
D
( 1 + ffi)(1 + fl )
2
;
D
( 1 , ffi)(1 , fl )
To bound the total budget spent , consider the expected amount spent :
E[B ] = nfi q P fi(y ) EP fi [ x : x < y ]
= nfi
D
P fi(y ) EP fi [ x : x < y ] n P ( y ) nfi n
P fi(y ) P ( y )
= B
EP fi [ x : x < y ] EP [ x : x < y ]
Since EP [ x : x < y ] = 1 b=0 bp(b)db , we can simplify to :
E[B ] = B nfi
P ( y ) R y n R y R y b=0 bpfi(b)db b=0 bp(b)db B
( 1 + ffi)(1 + fl )
2
;
B
( 1 , ffi)(1 , fl ) ; where the last line follows because pfi(b ) 2 p(b )
1fl for all b .
At this point we have shown that a simple algorithm will have bounded error in the expected budget spent and the expected number of auctions won . However , this error maybe quite large depending on the exact values of ffi and fl . In the next section we show that a myopic adaptive algorithm can dramatically reduce the overall error .
We show that the simplest adaptive strategy , which periodically reruns the SingleRound Algorithm using updated budget and impressions targets , can be very powerful in limiting the effect of the forecast errors . The only intermediate information required to rerun SingleRound is the total amount spent and total number of impressions won during the previous time period . We state our results more broadly for any optimization algorithm A that takes a supply forecast , bid landscape forecast , desired demand and remaining budget . 4.1 Analysis
For the purposes of the analysis , we assume that impressions begin arriving at time t = 0 and denote by T the expiration date of the contract . Let k 2 N+ denote the number of optimization routines performed in time T . We will assume that supply is distributed uniformly during the T time steps . This assumption does not hold in practice , but makes for a simpler analysis . We investigate its effect If nfi is the on the algorithm ’s performance in Section 5 . total available supply , then nfi ( 1 , i k ) opportunities are available after time T i=k , which will also serve as the time of the i + 1 st optimization by A .
Our goal is to bound the expected budget spent and the expected demand received by the optimization algorithm as a function of the forecast errors ffi and fl and the number of optimization cycles , k . We will show that as k increases , the total error in the demand received and budget spent decreases as a function of k . To do this , we abstract both problems into one general problem . In this problem there are nfi events . During each event the algorithm makes a decision and experiences some reward . Let Yi be the random variable i=1 Yi . The goal of the algorithm is to make decisions on each event so that the expected value of X is equal to a goal parameter , ff . In the case of analyzing the demand , ff = D and Yi is the probability of winning the impression . In case of analyzing the total spend , ff = B and Yi is the expected spend per impression . denoting the reward during the ith event . Let X = Pnfi
The goal of this section is to prove the following theorem , which roughly shows that the error experienced by the algorithm drops as 1=k , and so even a small number of reoptimization cycles can go a long way towards improving performance . ( We note that a more specialized version of this theorem geared specifically for performance of target demand appears in [ 2] . )
Theorem 41 Let ffl ; ffl0 > 0 . If A ensures that
( 1 , ffl0 ) ff nfi E[Yi ] ( 1 + ffl ) ff nfi for any possible value of nfi , ff and i 2 [ nfi ] then re running A k 1 times every nfi=k events , guarantees :
,ffffl0 1 k1,ffl0
E[X , ff ] ffffl 1 k1,ffl0
:
The algorithm A ’s goal is to have E[X ] = ff , however the algorithm may not be able to achieve this in expectation . This is because the algorithm may have some bounded error as described by ffl and ffl0 . Now , if we use the algorithm to optimize k times , then the algorithm converges on E[X ] = ff
WWW 2012 – Session : Advertising on the Web 2April 16–20 , 2012 , Lyon , France373 k 1,ffl0 at a rate of , 1
. Thus , simply optimizing k times makes the algorithm converge on the correct value quickly . For a concrete example , let A be SingleRound , ffl = ffi+fl,ffifl ( 1,ffi)(1,fl ) , ffl0 = ffi+fl+ffifl ( 1+ffi)(1+fl ) and ff to be either the budget or the demand . In this case , using previous theorem with Theorem 3.1 we have the following corollary .
Using the previous lemma we upper bound E[R(k) ] .
Lemma 44 We have that E[R(k ) ] ff , 1
Proof . k (1,ffl0 ) .
Corollary 42 If the SingleRound is rerun k times at even time intervals between 0 and T , then :
E[R(k ) ] ff
( 1 , ffl0 1
)D E[D ] ( 1 + ffl 1 and
( 1 , ffl0 1
)B E[B ] ( 1 + ffl 1 k1,ffl0 k1,ffl0 k1,ffl0 k1,ffl0
)D
)B
As an example , suppose that both supply and price forecasts are off by 25 % : ffi = fl = 1=4 . Then , a single optimization may lead to an underdelivery factor of 36 % = ffl0 , or a budget overspend of 78 % = ffl . A single additional retopimization ( setting k = 2 ) , reduces both by a factor of 1 2 leads to a reduction in error of more than half ( 56% ) .
0:78 , or over 20 % . Having k = 10 re optimizations ,
1,ffl0
To show the previous theorem , let Xi = Pnfii=k j=1 Yi be the expected value given to the algorithm just before the ith optimization where 1 i k + 1 . ( Xk+1 denotes the value remaining in the end . ) Define the recurrence R(i ) = ff,E[Xi ] . Intuitively , R(i ) is either the remaining demand or budget just before the ith optimization . Note that R(1 ) := ff . Further , R(i + 1 ) = ff , E[Xi+1 ] = ff , E[Xi ] , ( E[Xi+1 ] , E[Xi ] ) = R(i ) , ( E[Xi+1 ] , E[Xi] ) . The goal is to find a lower bound and upper bound on R(k + 1 ) . To do this , the proof proceeds as follows . First , we bound R(i ) in terms of R(i , 1 ) . Using this we can upper bound R(k ) . With an upper bound on R(k ) we can derive the final bounds on R(k + 1 ) .
Lemma 43 ( 1 , 1+ffl k,i+1 )E[R(i ) ] E[R(i + 1 ) ] ( 1 ,
1,ffl0 k,i+1 )E[R(i ) ] for any 1 < i k .
Proof . Consider the time the ith optimization is performed . At this time there are nfi(1 , i,1 k ) events remaining . There will be nfi=k events available before the ( i + 1)st optimization . Therefore a 1=(k , i + 1 ) fraction of the remaining events occur in the ith stage . We have that ,
E[R(i + 1 ) ] = Xx Xx
E[R(i + 1)jR(i ) ] Pr[R(i ) = x ]
( 1 ,
1 + ffl k , i + 1
)R(i ) Pr[R(i ) = x ]
[ Definition of A and R ]
= ( 1 ,
1 + ffl k , i + 1
)E[R(i ) ] and similarly we have ,
E[R(i + 1 ) ] = Xx Xx
E[R(i + 1)jR(i ) ] Pr[R(i ) = x ]
( 1 ,
1 , ffl0 k , i + 1
)R(i ) Pr[R(i ) = x ]
[ Definition of A and R ]
= ( 1 ,
1 , ffl0 k , i + 1
)E[R(i ) ] k
Yj=2 k
Yj=2
( 1 ,
1 , ffl0 k , j + 2
)
[ Lemma 4.3 and R(1 ) = ff ] ff exp ,
1 , ffl0 k , j + 2 k ff exp ,(1 , ffl0 ) Xj=2 ff exp,,(1 , ffl0 ) log kff 1 k(1,ffl0 )
1 k , j + 2!
Now we find upper and lower bounds on E[R(k + 1) ] .
Lemma 45 ,ffffl , 1
Proof . We have that , k (1,ffl0 ) E[R(k+1 ) ] ,ffffl0 , 1 k (1,ffl0 )
E[R(k + 1 ) ] ,fflE[R(k ) ]
[ Lemma 4.3 ]
,ffffl 1 k(1,ffl0 )
[ ffl > 0 and Lemma 4.4 ] and
E[R(k + 1 ) ] ffl0
E[R(k ) ]
[ Lemma 4.3 ] ffffl0 1 k(1,ffl0 )
[ ffl0 > 0 and Lemma 4.4 ]
Lemma 4.5 and the definition of R gives Theorem 41
5 . OVERVIEW OF EXPERIMENTS
The previous sections described a bidding algorithm that is tolerant of errors in the supply and price forecasts , and presented a theoretical analysis showing that , under certain simplifying assumptions , an advertiser using this bidding algorithm can nearly hit a campaign ’s demand target and spending target , with errors that become smaller when the campaign ’s lifetime is divided into more time blocks ( thus causing more re optimizations to occur ) .
Because the problem addressed by this paper is real , that theoretical analysis is only the first step . It is also important to find out whether the simplifying assumptions made during the analysis are reasonable , and whether the algorithm is sufficiently practical and robust to work under realistic conditions . Among the simplifying assumptions were the following :
WWW 2012 – Session : Advertising on the Web 2April 16–20 , 2012 , Lyon , France374 ffl The analysis assumes that the supply which a campaign encounters during its lifetime is divided equally between the time intervals . In reality , the amount of supply in the various time intervals can be highly unequal . ffl The analysis makes a feasibility assumption that D impressions can be obtained while spending B . In the experiments , we will examine the assumption violating case where the bid z leading to the correct demand is greater than the bid y leading to the correct spend . ffl The analysis assumes that the forecasts are being used as is , with no updates . This is a reasonable assumption given that it would be expensive to obtain the feedback necessary to update the forecasts . Nevertheless , it is natural to ask whether better performance could be obtained if the forecasts could be updated .
The next couple of sections contain experiments that ad dress the following 5 questions :
1 Do the errors decrease with increasing k ?
2 Is the algorithm robust enough to still work when the assumption about equal time intervals is violated ?
3 Is the algorithm robust enough to work with real price distributions . ?
4 What should the algorithm do when the assumption that z y is violated ?
5 Can updating the forecasts yield better results ?
Since there is value both in using real data , and in using non proprietary data , we will present two sets of experiments in the next two sections . In Section 6 we will use real data to address questions 1,2,3 from the list above . In Section 7 we will use synthetic ( and hence non proprietary ) data to address questions 1,2,4,5 from the list above .
6 . EXPERIMENTS ON RMX DATA
In this section we give an experimental study of the algorithm introduced in this paper . The goal of this section is to show that the algorithm does not only perform well theoretically , but the algorithm , in fact , performs well on real world data sets and is robust . All of the data used in the experiments was gathered from live auctions from the RightMedia exchange . RightMedia is currently the largest ad exchange currently in industry with over nine billion transactions daily [ 13 ] .
The highest bid from 100,000 auctions was collected from four separate days . We will refer to these as four separate datasets . These bids were used to represent the bid landscape . To construct the bid forecast we used the bid distribution from one of the datasets . One of the goals of the experiments was to show the robustness of the algorithm . To this end , we constructed the bid forecast on only 10,000 auctions from one of the datasets . Then we ran the algorithm , using this forecast , on the 100,000 auctions from the other three datasets , separately . For each experiment we ran the algorithm 5 times and took the average of the outputs considered ( eg the budget spent or demand received ) .
Convergence of Budget and Demand with Supply and Landscape Error : .
Our first experiment is designed to show that the budget spent and demand received converges to the desired budget B and demand D as the number of optimizations increase . First we focus on the case which we call the ‘non varying interval’ case . In this case , when the number of optimizations is k , the algorithm is optimized after each 1=k fraction of the total number of opportunities have occurred . To exemplify that the algorithm is robust , we set two parameters ffi and fi . The value of ffi represents the error in the supply forecast . Here the forecasted supply which was input to the algorithm is ( 1 + ffi ) multiplied by the actual supply . For this experiment ffi was set to 1=2 and therefore the forecasted supply for each of the experiments was 150 ; 000 while the actual supply was 100 ; 000 . In practice , this would be a quite large margin of error in the supply forecast . Now consider the bid landscape forecast . In the experiment , a small sample of real bids were used to construct the supply forecast . It would seem somewhat surprising that using this as the forecast would accurately forecast bids from another day ’s auctions . However , the following data shows that the optimization algorithm overcomes this . To further show the robustness of the algorithm , we also used a parameter fi , which is the error in the bid landscape forecast.2 When using this parameter , the real bids used to construct the forecast were multiplied by ( 1 , fi ) . In the following experiment we set fi = :5 . Thus , each bid in the training data set used for the bid landscape forecast was scaled by a factor of :5 . Still the optimization algorithm performed well .
The second experiment performed we call the ‘varying interval’ case . In this case , the number of opportunities between each optimization is random . Here we choose k , 1 random numbers between 0 and the total supply 100 ; 000 . When the number of opportunities which occurred previously was equal to the one of the random numbers then an optimization was performed . In practice , the number of auctions which occur during a time period do vary and here we essentially consider the worst cast scenario .
For the advertiser we set the demand D to be 10 ; 000 , one tenth of the total supply . The advertiser ’s budget was set at about 2:3 % of the total sum of the bids . Thus , the advertiser desires a large fraction of the total supply ( 10 % ) while using a relatively small budget ( 2:3% ) . When bidding in the auction , if there was a tie between the advertiser and the external bid then it was assumed that the external bidder won the auction . We used the advertiser with these parameters on the auctions from the three different datasets using a different number of optimizations during each run . The data from each of the three datasets was quite similar and the graph in Figure 1 and Figure 2 shows one of the datasets .
First consider the non varying interval case . Figure 1 shows that if the algorithm performs only a single optimization , then an average of 6349.8 auctions are won , which is about 63:5 % of the desired demand . However , if the algorithm were to optimize 15 times then the demand received would increase to about 9000 , within 10 % of the desired demand . This shows that with a small number of optimizations the algorithm converges to the desired demand . Fur
2This fi controls the error in the values of the bids , and so is slightly different from the fl in the theoretical analysis , which bounds the error in the probabilities of bids .
WWW 2012 – Session : Advertising on the Web 2April 16–20 , 2012 , Lyon , France375 n o W s n o i t c u A
12000
10000
8000
6000
4000
2000
0
0
Demand Varying Intervals Actual Demand Non Varying Intervals Desired Demand
10
20
30
40
50
Optimizations
Figure 1 : Demand received , as a function of number of optimizations . The desired demand was 10,000 . The ‘Actual Demand’ is the demand received in the experiments . ther , if the number of optimizations is as large as 50 then the algorithm is within 5 % of the desired demand . Being able to optimize frequently can be difficult to do in practice because it is time consuming to receive feedback from the system . However , even if the optimizations can not be done often , the algorithm still converges well .
Figure 2 shows the corresponding budget . It can be seen that the budget has 3 % error when no optimizations were performed . With a large number of optimizations the budget converges with less than :4 % error with 50 optimizations . Thus , converging on the desired demand comes at little relative expense in the budget spent .
Actual Budget Spent Varying Intervals Actual Budget Spent Non Varying Intervals Desired Budget t n e p S t e g d u B
1.4
1.2
1
0.8
0.6
0
10
20
30
40
50
Optimizations
Figure 2 : Budget spent , as a function of number of optimizations . The desired budget was 1 .
Now consider the varying interval case . It can be seen that the demand received and the budget spent is more variable in this case . The demand received converges to within 10 % of the desired demand when the number of optimizations is larger than 10 . The budget is more variable , however , once the number of optimizations is larger than 10 the over spent budget was no larger than 10 % . This shows that the algorithm is fairly robust to there being fluctuations in the number of opportunities available during a single optimization .
Similar results were obtained as above when the parameters ffi and fi were varied up to :8 . However , once the error parameters became too large , the algorithm could not overcome the error in the forecasts . Further , similar results were obtain when the budget and demand were varied . However , once the demand becomes too close to the total number of opportunities , there were not enough remaining opportunities for the algorithm to converge on the budget and demand . Also when the budget was quite small the algorithm , naturally , was unable to win enough auctions .
In summary , this section contained experiments using real price distributions which yielded the answer \yes" for questions 1 3 in Section 5 .
Forecasted Supply
Fcast . Prices too high accurate too low too low accurate too high ffi=0.4 fi= 0.4 ffi=0.4 fi= 0.0 ffi=0.4 fi= 0.6 ffi=0.0 fi= 0.4 ffi=0.0 fi= 0.0 ffi=0.0 fi= 0.6 ffi= 0.2 fi= 0.4 ffi= 0.2 fi= 0.0 ffi= 0.2 fi= 0.6
Figure 3 : The 9 scenarios tested in Section 7 .
7 . EXPERIMENTS ON SYNTHETIC DATA This section describes some additional experiments that are easier to replicate because they use synthetic rather than proprietary data . First , in Section 7.1 , the experimental setup is described , and some basic results are presented that once again demonstrate that the errors in hitting the campaign ’s demand and spending targets decrease with increasing k , and also that the algorithm is robust to unequal subdivision of supply between time intervals . Then in Sections 7.2 and 7.3 , the previously unaddressed questions 4 and 5 are empirically investigated . 7.1 Experimental Setup and Basic Results ffl True supply N = 100000 auctions . ffl Forecasted supply Nf = N ( 1 + ffi ) , where ( 1 + ffi ) is the simulation ’s forecast error factor . ffl Demand Target D = 10000 auction wins . ffl Budget Target B = 2500 units of money . ffl Implied target spend per win = 025 ffl Competitors’ bids are drawn from the lognormal dis tribution exp(gaussian(mean=0,sigma=4/3) ) . ffl The price forecast given to the bidding agent is represented by a separate ensemble of samples drawn from the same lognormal distribution , but then multiplied by the simulation ’s price error factor ( 1 , fi ) . ffl Simulations were run with two different schemes for subdividing the supply amongst the time intervals : nearly equal random subdivision , which is probably better
WWW 2012 – Session : Advertising on the Web 2April 16–20 , 2012 , Lyon , France376 Results of 25 simulations for each of 9 Scenarios updateModels=false favorDemand=false equalIntervals updateModels=false favorDemand=false varyingIntervals
0.29
0.28
0.27
0.26
0.25
0.24
0.23 i n W r e p d n e p S e g a r e v A k=1
0.29
0.28
0.27
0.26
0.25
0.24
0.23 i n W r e p d n e p S e g a r e v A k=1 k=4 k=16 k=64
0.29
0.28
0.27
0.26
0.25
0.24
0.23 i n W r e p d n e p S e g a r e v A k=1 k=4 k=16 k=64
0.22
2500 5000 7500 10000 12500 15000 17500 20000 22500
0.22
2500 5000 7500 10000 12500 15000 17500 20000 22500
0.22
2500 5000 7500 10000 12500 15000 17500 20000 22500
Number of Auctions Won
Number of Auctions Won
Number of Auctions Won
Figure 4 : Left : Simulation results for k=1 . The 9 obvious clusters correspond to the 9 scenarios listed in Table 3 , with the same layout . Middle : Results for k in f1,4,16,64g . Notice that as k is increased , the distribution of outcomes contracts towards the target demand of 10000 and target price of 025 Right : the results are more scattered , but the same kind of contraction is evident when the supply is subdivided arbitrarily rather than equally between intervals .
Campaign Inputs : ( D ; B ; k ) Model Inputs : ( Nf , Pf ) Control Inputs : ( favorDemand , updateModels )
// supply model // price model
SM initSM(Nf ; k ) PM initPM(Pf ) Da 0 ; Ba 0 for ka = 0 to k , 1 do // loop over time blocks Dr D , Da ; Br B , Ba ; kr k , ka Ne estimateRemainingSupply(SM , kr ) Pe estimatePriceDistribution(PM ) define : Fe(y ) = 1 winratez Dr=Ne spendratey Br=Dr bidz = P ,1 ( winratez ) bidy = F ,1 ( spendratey ) winratey = Pe(bidy ) if ( bidz bidy ) then curBid bidy ; bidProb winratez=winratey
// \feasible" case
Pe(y ) R y
0 b pe(b)db // aim for D
// aim for B e e else
// \infeasible" case where ( bidz > bidy ) if ( favorDemand ) then curBid bidz else curBid bidy end if bidProb 1:0 end if ( numWins , amtSpent , numAuctions , competingBids )
ResultsOfBlock ( curBid , bidProb )
Da Da + numWins Ba Ba + amtSpent if updateModels then updateSupplyModel ( SM , numAuctions ) updatePriceModel ( PM , competingBids ) end if end for
Outputs : ( Da ; Ba )
Figure 5 : Pseudocode for bidding algorithm . than reality , and unconstrained random subdivision , as described in section 6 , which is probably worse than reality . ffl Nine different error scenarios were tested , each specified by values for the supply error ffi and the price error fi . These scenarios are listed in Table 3 . ffl 25 simulations were performed for every combination of ( intervalScheme , ErrorScenario , k ) . ffl The results are presented as scatter plots , with number of auctions won on the x axis , and average spend per win on the y axis . ffl Pseudocode for the simulated bidding agent appears in Figure 5 . There are control flags called favorDemand and updateModels . These will be explained in Sections 7.2 and 7.3 , but were both set to false for the basic simulations whose results we will now discuss .
Consider the plots in Figure 4 . The leftmost pane shows results for k=1 and equalIntervals . There are nine obvious clusters of points which correspond to the nine error scenarios , and in fact have the same spatial layout as the table in Figure 3 . We will mention a couple of the clusters . The middle cluster in this leftmost plot is for the accurateforecast scenario ( ffi = 0 ; fi = 0 ) . Naturally , this cluster of outcomes is centered on the target demand of 10000 and the target price of 025 The upper left cluster is for the scenario ( ffi = 0:4 ; fi = 0:4 ) . The inaccurate forecasts are causing the bidding agent to under deliver ( 5000 wins ) and over spend per win ( price of about 028 )
Now consider the center pane of Figure 4 , in which k ranges over f1,4,16,64g . Evidently the ensemble of outcomes ( comprising 25 runs each for 9 scenarios ) is contracting towards the target demand and target price as k increases . This re affirms the earlier answer of \yes" for question 1 .
Now consider the rightmost pane of Figure 4 , which differs from the center pane in that the simulator subvided the supply unequally rather than equally between the time intervals . The results for the unequal subdivision are much more more scattered , but still there is an overall pattern of contraction towards the target demand and target price as k increases . This re affirms the earlier answer of \yes" for question 2 .
WWW 2012 – Session : Advertising on the Web 2April 16–20 , 2012 , Lyon , France377 i n W r e p d n e p S e g a r e v A i n W r e p d n e p S e g a r e v A
0.31
0.3
0.29
0.28
0.27
0.26
0.25
0.24
0.23
0.22
0.31
0.3
0.29
0.28
0.27
0.26
0.25
0.24
0.23
0.22 updateModels=false favorDemand=false varyingIntervals updateModels=F favorDemand=F eqIntvls ( delta=beta=0.4 ) k=1 k=4 k=16 k=64 k=1 k=2 k=3 k=4 k=6 k=8 k=12 k=16 k=24 k=32 k=48 k=64 k=96
0.32
0.31
0.3
0.29
0.28
0.27
0.26 i n W r e p d n e p S e g a r e v A
5000
10000
15000
20000
25000
Number of Auctions Won
0.25
2000 3000 4000 5000 6000 7000 8000 9000 10000
Number of Auctions Won updateModels=false favorDemand=true varyingIntervals updateModels=F favorDemand=T eqIntvls ( delta=beta=0.4 ) k=1 k=4 k=16 k=64 k=1 k=2 k=3 k=4 k=6 k=8 k=12 k=16 k=24 k=32 k=48 k=64 k=96
0.32
0.31
0.3
0.29
0.28
0.27
0.26 i n W r e p d n e p S e g a r e v A
5000
10000
15000
20000
25000
Number of Auctions Won
0.25
2000 3000 4000 5000 6000 7000 8000 9000 10000
Number of Auctions Won
Figure 6 : These plots are discussed in x72
Figure 7 : These plots are discussed in x72
7.2
Investigation of Z > Y Case
In this section we investigate Question 4 : what should the algorithm do when the demand based bid z exceeds the spending based bid y ? This case can occur in reality , but it violates a simplifying assumption that was made during the theoretical analysis . The experimental investigation of this case involves new algorithmic details : 721 New Algorithmic Details for Z > Y Case The favorDemand flag in the pseudocode of Figure 5 determines which bid is used in the assumption violating \infeasible" case where the demand based bid z is greater than the spending based bid y . If favorDemand=true , then the algorithm will use the demand based bid z , and will attempt to fulfill the demand even though that might result in overspending . If favorDemand=false , then the algorithm will use the spending based bid y , and will avoid overspending but will tend to fall short of satisfying the demand . It is worth pointing out that in the \feasible" case z y ( which was assumed in the theoretical analysis ) there is no corresponding policy question because it is possible to simultaneously hit the demand and spending targets . 722 Experimental Results for Z > Y Case To study the policy question for the z > y case , we ran all of the experiments on synthetic data twice , once with favorDemand=false and once with favorDemand=true .
Some of the results are shown in Figure 6 . Both panes contain scatter plots showing the outcomes of 25 runs each of the 9 error scenarios , with 4 different values of k , all with with unequal division of supply between time blocks . The top pane shows results for favorDemand=false , while the bottom pane shows results for favorDemand=true . The results are qualitatively similar , except for the larger number of magenta squares near the top of the bottom plot , indicating that some of the 25*9 runs for k = 64 ended up paying an excessive average price per auction win .
Further investigation showed that the runs in which the k = 64 runs overpaid were mostly for the ( ffi = 0:4 ; fi = 0:4 ) error scenario , which for k=1 causes a bidder to underdeliver and over pay per auction win .
To more clearly illustrate what is going on , consider the plots in Figure 7 , which only contains results for the ( ffi = 0:4 ; fi = 0:4 ) scenario , and which were obtained under the less noisy simulation conditions where supply is equally divided between time intervals .
The top pane in Figure 7 , which is for favorDemand=false , shows that as k is increased , the algorithm ’s demand achieved and average price paid initially moves towards the target values , but then seems to asymptote at values that fall short of the targets .
The bottom pane in Figure 7 , which is for favorDemand=true , shows a very different behavior . The amount of demand satisfied continues to increase with increasing k , but the price paid stops decreasing and starts increasing around k = 24 .
WWW 2012 – Session : Advertising on the Web 2April 16–20 , 2012 , Lyon , France378 updateModels=T favorDemand=F eqIntvls ( delta=beta=0.4 ) k=1 k=2 k=3 k=4 k=6 k=8 k=12 k=16 k=24 k=32 k=48 k=64 k=96
0.32
0.31
0.3
0.29
0.28
0.27
0.26
0.25
2000 3000 4000 5000 6000 7000 8000 9000 10000
Number of Auctions Won updateModels=T favorDemand=T eqIntvls ( delta=beta=0.4 ) k=1 k=2 k=3 k=4 k=6 k=8 k=12 k=16 k=24 k=32 k=48 k=64 k=96
0.32
0.31
0.3
0.29
0.28
0.27
0.26 i n W r e p d n e p S e g a r e v A i n W r e p d n e p S e g a r e v A
0.25
2000 3000 4000 5000 6000 7000 8000 9000 10000
Number of Auctions Won
Figure 8 : These plots are discussed in x73
This is actually a general phenomenon that can occur whenever the following three conditions are met :
1 . Large errors in the forecasts cause the algorithm to fall behind in satisfying the demand target .
2 . Only a small fraction of the campaign ’s lifetime re mains . This can only happen for larger values of k .
3 . The algorithm is allowed to climb arbitrarily far up the price curve in pursuit of the faster win rates that would allow it to catch up .
Notice that the favorDemand=true policy can climb too far up the price curve , but the favorDemand=false policy cannot .
In summary , when forecast errors are such that the z > y case arises , one can adopt the favorDemand=false policy and end up with some demand that is unsatisfied even for large k , or one can adopt the favorDemand=true policy and end up with an excessive average price that is exacerbated by large k .
It is in this situation , where increasing k does not strictly improve the outcome , that the idea of updating the erroneous forecasts begins to sound attractive . That idea is explored in the next section . 7.3 Updating the Forecasts
In this section we investigate Question 5 : Can updating the forecasts yield better results ? This involves some new algorithmic details .
731 New Algorithmic Details for Updates The updateModels flag in the pseudocode of Figure 5 determines whether the supply and price models are updated after each time block . We note that the basic algorithm , as considered in all previous sections , corresponds to updateModels=false . This paper does not address the question of how to optimally update the models given the hypothetical feedback that would enable those updates . Instead , the models are updated in a very simple way that suffices to give some preliminary insight into question 5 . 732 Updating the Supply Model When updateModels = false , remaining supply is estimated as follows : ( the variables here are explained in Table 9 )
Ne = kr
Nf k
When updateModels = true , remaining supply is esti mated as follows :
Ne = kr wNf + Na wk + ka
The rate at which observations overcome the forecast is affected by the parameter w . In these experiments , w = 1 , so at the end of the simulation , the initial forecast and the observed data have approximately equal weight . 733 Updating the Price Model The initial price model is represented by a set of samples drawn from the true price distribution and multiplied by the error factor ( 1 , fi ) . If updateModels = false , this initial model is never changed , but if updateModels = true , the model is updated after each time block by unioning the model ’s current set of samples with the set of competing bids observed during that time block . The rate at which observations overcome the forecast is affected by the size of the initial set of samples . In these experiments , there are 100000 samples in the initial forecast , and 100000 opportunities during the campaign , so at the end of the simulation the initial forecast and the observed data have equal weight . 734 Experimental Results for Forecast Updates To study the question of whether a simple scheme for updating forecasts can yield improved performance , we ran all of the experiments on synthetic data twice , once with updateModels=false , and once with updateModels = true . In all , we performed 23400 simulations , which are ( 25 tries ) * ( 9 error scenarios ) * ( 13 values of k ) * ( 2 supply subdivision schemes ) * ( 2 values for favorDemand ) * ( 2 values for updateModels ) . The general impression one obtains from looking at all of the resulting plots is that updating the models tends to give a tighter concentration of results around the target values , but not greatly so .
Due to space limitations , here we will just exhibit the plots in Figure 8 , which correspond directly to the plots in Figure 7 , except that the models are being updated in Figure 8 .
A comparison of the top panes in the two figures , which are both for favorDemand=false , shows that the updating algorithm was able to get past the demand value of about 9000 at which the non updating algorithm was asymptoting .
WWW 2012 – Session : Advertising on the Web 2April 16–20 , 2012 , Lyon , France379 variable meaning
D Dr Da B Br Ba k kr ka Nf Ne Na Pf Pe
Demand Target Demand Remaining Unsatisfied Demand Already Satisfied Budget Target Budget Remaining Unspent Budget Already Spent Number of Time Blocks Time Blocks Remaining Time Blocks Already Occurred Forecasted Total Supply Estimated Remaining Supply Supply actually observed so far Forecasted Price Distribution Estimated Price Distribution
The following are hidden from the bidder .
N fi P fi ffi fi
True total Supply True Price Distribution Supply Error : Nf = N fi ( 1 + ffi ) Price Error : Pf = P fi ( 1 , fi )
Figure 9 : Explanation of variables appearing in the pseudocode of Figure 5 .
A comparison of the bottom panes in the two figures , which are both for favorDemand=true , shows that the average price paid by both algorithms starts to increase above a certain value of k . However , the average price paid for any given value of k is less for the updating algorithm .
8 . CONCLUSION
Most online advertising today is sold via real time auctions in which advertisers are represented by automated bidding agents that bid strategically in an attempt to achieve various goals including hitting demand targets and spending targets over a specified period of time . The inputs to these agents typically include machine learned models of the world which facilitate extrapolation from the past to the future and from common events to rare events . Given their extrapolative function , it is not surprising that these models are imperfect .
While improving the accuracy of the models is a worthwhile research goal , in this paper , we have instead assumed that the models of future supply and future prices are inaccurate , and investigated the question of how a bidding agent can win the right number of impressions and spend the right amount of money given this inaccuracy .
In Theorem 4.1 , we proved that , subject to certain feasibility conditions , a very simple bidding strategy , which only requires occasional feedback of the number of auctions actually won and the amount of money actually spent , quickly converges to the bidder ’s desired budget and demand .
We have also provided experimental evidence in Sections 5 through 7 that the proposed bidding strategy is robust enough to work even when some of the simplifying assumptions in the formal analysis are violated .
9 . REFERENCES [ 1 ] T . Chakraborty , E . Even Dar , S . Guha , Y . Mansour , and S . Muthukrishnan . Selective call out and real time bidding . In A . Saberi , editor , WINE , volume 6484 of Lecture Notes in Computer Science , pages 145{157 . Springer , 2010 .
[ 2 ] P . Chen , W . Ma , S . Manalapu , C . Nagarajan ,
S . Vassilvitskii , E . Vee , M . Yu , and J . Zien . Ad serving using a compact allocation plan . submitted to WWW , 2012 .
[ 3 ] Y . Chen , P . Berkhin , B . Anderson , and N . R .
Devanur . Real time bidding algorithms for performance based display ad allocation . In C . Apte , J . Ghosh , and P . Smyth , editors , KDD , pages 1307{1315 . ACM , 2011 .
[ 4 ] Y . Cui , R . Zhang , W . Li , and J . Mao . Bid landscape forecasting in online ad exchange marketplace . In Proceedings of the 17th ACM SIGKDD international conference on Knowledge discovery and data mining , KDD ’11 , pages 265{273 , New York , NY , USA , 2011 . ACM .
[ 5 ] N . R . Devenur and T . P . Hayes . The adwords problem : online keyword matching with budgeted bidders under random permutations . In J . Chuang , L . Fortnow , and P . Pu , editors , ACM Conference on Electronic Commerce , pages 71{78 . ACM , 2009 .
[ 6 ] J . Feldman , M . Henzinger , N . Korula , V . S . Mirrokni , and C . Stein . Online stochastic packing applied to display ad allocation . In M . de Berg and U . Meyer , editors , ESA ( 1 ) , volume 6346 of Lecture Notes in Computer Science , pages 182{194 . Springer , 2010 .
[ 7 ] J . Feldman , A . Mehta , V . S . Mirrokni , and
S . Muthukrishnan . Online stochastic matching : Beating 1 1/e . In FOCS , pages 117{126 . IEEE Computer Society , 2009 .
[ 8 ] A . Ghosh , P . McAfee , K . Papineni , and
S . Vassilvitskii . Bidding for representative allocations for display advertising . In Leonardi [ 12 ] , pages 208{219 .
[ 9 ] A . Ghosh , B . I . P . Rubinstein , S . Vassilvitskii , and
M . Zinkevich . Adaptive bidding for display advertising . In J . Quemada , G . Leon , Y . S . Maarek , and W . Nejdl , editors , WWW , pages 251{260 . ACM , 2009 .
[ 10 ] R . M . Karp , U . V . Vazirani , and V . V . Vazirani . An optimal algorithm for on line bipartite matching . In STOC ’90 : Proceedings of the twenty second annual ACM symposium on Theory of computing , pages 352{358 , New York , NY , USA , 1990 . ACM .
[ 11 ] K . Lang , J . Delgado , D . Jiang , B . Ghosh , S . Das ,
A . Gajewar , S . Jagadish , A . Seshan , C . Botev , M . Bindeberger Ortega , S . Nagaraj , and R . Stata . Efficient online ad serving in a display advertising exchange . In I . King , W . Nejdl , and H . Li , editors , WSDM , pages 307{316 . ACM , 2011 .
[ 12 ] S . Leonardi , editor . Internet and Network Economics ,
5th International Workshop , WINE 2009 , Rome , Italy , December 14 18 , 2009 . Proceedings , volume 5929 of Lecture Notes in Computer Science . Springer , 2009 . [ 13 ] S . Muthukrishnan . Ad exchanges : Research issues . In
Leonardi [ 12 ] , pages 1{12 .
[ 14 ] E . Vee , S . Vassilvitskii , and J . Shanmugasundaram . Optimal online assignment with forecasts . In D . C . Parkes , C . Dellarocas , and M . Tennenholtz , editors , ACM Conference on Electronic Commerce , pages 109{118 . ACM , 2010 .
WWW 2012 – Session : Advertising on the Web 2April 16–20 , 2012 , Lyon , France380
