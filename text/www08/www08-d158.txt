Structured Objects in OWL : Representation and
Reasoning
Boris Motik†
Bernardo Cuenca Grau†
Ulrike Sattler‡
†Computing Laboratory , University of Oxford , UK
‡Department of Computer Science ,
University of Manchester , UK
January 18 , 2008
Abstract
Applications of semantic technologies often require the representation of and reasoning with structured objects—that is , objects composed of parts connected in complex ways . Although OWL is a general and powerful language , its class descriptions and axioms cannot be used to describe arbitrarily connected structures . OWL representation of structured objects can thus be underconstrained , which reduces the inferences that can be drawn and causes performance problems in reasoning . To address these problems , we extend OWL with description graphs , which provide for the description of structured objects in a simple and precise way . To represent conditional aspects of the domain , we also allow for SWRL like rules over description graphs . Based on a novel observation about the nature of structured objects , we ensure decidability of our formalism . We also present a hypertableau based decision procedure , which we implemented in the HermiT reasoner . To evaluate its performance , we extracted description graphs from the GALEN and FMA ontologies , classified them successfully , and even detected a modeling error in GALEN .
1
Introduction
Ontologies are nowadays being used in disciplines as diverse as biology [ 27 ] , medicine [ 9 ] , geography [ 10 ] , astronomy [ 6 ] , and agriculture [ 28 ] . A de facto standard for ontology modeling is the Web Ontology Language ( OWL),1
1In this paper , we focus on OWL DL—the most expressive of the decidable languages of the OWL family .
1 so most ontologies in these domains were either developed from the start using OWL or translated into OWL from other formalisms . OWL is an expressive language capable of supporting diverse applications . Its logical underpinning is given by description logics ( DLs ) , which provide OWL with a clean model theoretic semantics , well understood reasoning problems , and powerful reasoners .
Structured objects—that is , objects composed of other , possibly interrelated objects—pose some well known problems to OWL and DLs [ 4 , 1 , 26 ] . Such objects abound , for example , in molecular biology and the clinical sciences . Clinical ontologies such as GALEN [ 29 ] , the Foundation Model of Anatomy ( FMA ) [ 24 ] , the National Cancer Institute ( NCI ) Thesaurus [ 11 ] , and SNOMED CT [ 30 ] are currently being used in large scale applications . For example , SNOMED CT is being used to annotate patients’ medical records in the National Programme for Information Technology ( NPfIT ) by the UK ’s National Health Service . All of these ontologies describe structured objects . For example , GALEN models the heart as consisting of the left and the right ventricles , the two atria , and the valves , all of which participate in complex relationships , such as “ the two ventricles of a heart are separated by the intraventricular septum . ”
OWL can be used to describe domains consisting of an arbitrary or even infinite number of objects , but it only allows for axioms that can connect these objects in a certain tree like manner . In other words , OWL enjoys ( a variant of ) the tree model property [ 32 ] : if an OWL ontology has a model , then it has a model with a tree like ( or forest like ) relational structure as well . This property is responsible for the decidability of OWL reasoning [ 32 ] ; however , it prevents sufficiently accurate description of complex structured objects . This is because schema level axioms in OWL cannot describe arbitrary relational structures . Consider the previously mentioned diamondshaped structure involving a heart , its right and left ventricles , and a septum . In addition to a model that corresponds to the structure in which the objects are connected as expected , each schema level description of the heart in OWL will also have a model where one heart has two septa , each as a part of the left and the right ventricle , respectively . Thus , certain consequences of the diamond shaped structure cannot be drawn from its formulation in OWL . For example , we cannot conclude that , if the right ventricle has a perforated septum , the left ventricle also has a perforated septum .
To address this lack of expressive power , in Section 4 we propose an extension of OWL for modeling structured objects using description graphs . Such graphs consist of vertices labeled with atomic concepts and edges labeled with atomic roles . According to our proposed model theoretic semantics , these graphs are class level statements that specify general patterns of connections between objects . In addition , we allow for SWRL like rules [ 12 ] to enable the description of conditional statements about graphs .
2
Extending DLs with axioms that can enforce arbitrary structures easily leads to undecidability [ 16 ] . Our formalism , however , is decidable because it can represent only structured objects whose number of parts is bounded . In practice , structured objects are usually modeled up to a certain level of granularity , which naturally determines this bound . In Section 5 , we present a reasoning algorithm for the case where the OWL part is expressed in SHIQ [ 14 ] ; it should , however , be possible to extended the algorithm to SHOIQ [ 13 ] and hence cover OWL DL . We thus obtain a powerful , decidable , and practicable language that combines two complementary formalisms : unbounded but tree like structures can be described using standard OWL axioms , and the naturally bounded structured parts can be described using arbitrarily connected description graphs and rules . We have implemented our algorithm in the DL reasoner HermiT [ 21].2 The validation of our approach is currently difficult due to the lack of test data . Thus , we have devised an algorithm that extracts description graphs from OWL ontologies , and have applied it to GALEN and FMA . The resulting ontologies should be treated with caution ; however , domain experts have confirmed that substantial parts of the ontologies reflect the actual human anatomy . Our transformation can thus be a starting point for a more comprehensive remodeling using description graphs . Finally , the ontologies are sufficiently complex to allow us to estimate the practicability of reasoning . We present the transformation algorithm in Section 6 .
In Section 7 , we discuss the results obtained by classifying the transformed ontologies . Our transformation allowed us to discover a modeling error in GALEN , which we take as indication that our formalism can indeed be useful in practice . Furthermore , classification times for the transformed ontologies are of similar orders of magnitude as for the original ontologies , even though our formalism adds considerable expressive power to OWL .
2 Preliminaries
In this section we recapitulate some well known definitions of description logics and rules .
2.1 Description Logics
In order not to overload the technical presentation with details , in this paper we present the reasoning algorithms for the DL SHIQ [ 14 ] ; we believe , however , that it is straightforward to extend our approach to the more expressive DL SHOIQ [ 13 ] that provides the logical underpinning of OWL DL . Furthermore , with minor modifications our approach can be used with DLs that provide for n ary relations such as DLR [ 5 ] .
2http://webcomlaboxacuk/oucl/work/borismotik/HermiT/
3
A SHIQ signature is a triple Σ = ( NC , NR , NI ) consisting of mutually disjoint sets of atomic concepts NC , atomic roles NR , and individuals NI . The set of roles is NR ∪ {R− | R ∈ NR} . For R ∈ NR , let Inv(R ) = R− and Inv(R− ) = R . The set of concepts is the smallest set containing ⊤ ( the top concept ) , ⊥ ( the bottom concept ) , A ( atomic concept ) , ¬C ( negation ) , C ⊓ D ( conjunction ) , C ⊔ D ( disjunction ) , ∃R.C ( existential restriction ) , ∀R.C ( universal restriction ) , ≥ n R.C ( at least restriction ) , and ≤ n R.C ( at most restriction ) , for A ∈ NC , C and D concepts , R a role , and n a nonnegative integer .
A TBox T is a finite set of role inclusions R ⊑ S for R and S roles , transitivity axioms Trans(R ) for R a role , and general concept inclusions ( GCIs ) C ⊑ D for C and D concepts . Let ⊑∗ T be the reflexive transitive closure of {R ⊑ S , Inv(R ) ⊑ Inv(S ) | R ⊑ S ∈ T } . A role R is transitive in T if a role S exists such that S ⊑∗ T S , and either Trans(S ) ∈ T or Trans(Inv(S ) ) ∈ T ; R is simple if no transitive role S exists with S ⊑∗ T R . The following property must be satisfied for each TBox T : in each concept ≥ n R.C and ≤ n R.C occurring in T , the role R must be simple.3
T R , R ⊑∗
An ABox A is a finite set of assertions for the form C(a ) ( concept assertion ) , R(a , b ) ( role assertion ) , a ≈ b ( equality assertion ) , and a 6≈ b ( inequality assertion ) , where C is a concept , R is a role , and a and b are individuals . A SHIQ knowledge base K is a pair ( T , A ) .
An interpretation for K is a pair I = ( △I , ·I ) , where △I is a nonempty set and ·I assigns an element aI ∈ △I to each individual a , a set AI ⊆ △I to each atomic concept A , and a relation RI ⊆ △I × △I to each atomic role R . The function ·I is extended to concepts and roles as shown in the upper part of Table 1 . I is a model of K , written I |= K , if it satisfies all axioms of K as shown in the bottom part of Table 1 . The basic inference problem for SHIQ is checking satisfiability of K—that is , checking whether a model of K exists . Other interesting inference problems , such as checking concept subsumption or query answering , can be reduced to satisfiability checking using well known transformations [ 2 ] .
Without loss of generality , we can assume that the ABox of each SHIQ knowledge base K is extensionally reduced—that is , its assertions contain only possibly negated atomic concepts and atomic roles . This is so because we can rewrite each assertion R−(a , b ) as R(b , a ) , and we can rewrite each assertion C(a ) where C is not a possibly negated atomic concept as AC(a ) and AC ⊑ C for AC a fresh concept . This transformation clearly preserves satisfiability of K and is linear in the size of K .
The negation normal form of a concept C , written nnf(C ) , is the concept ˙¬C equivalent to C containing negations only in front of atomic concepts ; is an abbreviation for nnf(¬C ) . Each concept can be brought into negation
3This restriction is necessary to make reasoning decidable [ 14 ] .
4
Table 1 : Model Theoretic Semantics of SHIQ
Semantics of Roles and Concepts
( R−)I = {hy , xi | hx , yi ∈ RI}
⊤I = △I ⊥I = ∅
( ¬C)I = △I \ C I ( C ⊓ D)I = C I ∩ DI ( C ⊔ D)I = C I ∪ DI ( ∀R.C)I = {x | ∀y : hx , yi ∈ RI → y ∈ C I} ( ∃R.C)I = {x | ∃y : hx , yi ∈ RI ∧ y ∈ C I }
( ≤ n S.C)I = {x | ♯{y | hx , yi ∈ SI ∧ y ∈ C I} ≤ n} ( ≥ n S.C)I = {x | ♯{y | hx , yi ∈ SI ∧ y ∈ C I} ≥ n}
Semantics of Axioms
I |= C ⊑ D if C I ⊆ DI if RI ⊆ SI I |= R ⊑ S I |= Trans(R ) if hx , yi ∈ RI ∧ hy , zi ∈ RI → hx , zi ∈ RI I |= C(a ) I |= R(a , b ) I |= a ≈ b I |= a 6≈ b if aI ∈ C I if haI , bI i ∈ RI if aI = bI if aI 6= bI normal form in linear time using well known transformations [ 2 ] . The DL ALCHIQ is obtained from SHIQ by disallowing transitive roles .
2.2 Rule Extensions of DLs
The basic principles for extending DLs with rules were laid down in [ 16 , 7 , 12 ] . Let Σ = ( NC , NR , NI ) be a SHIQ signature , and let NV be a countably infinite set of variables disjoint from NI . A term is an individual or a variable . A predicate is a concept , a role , or the equality predicate ≈ . Concepts have arity one , and roles and ≈ have arity two . An atom over Σ has the form P ( t1 , . . . , tn ) , where P is a predicate of arity n , and ti , 1 ≤ i ≤ n are terms . Atoms involving the equality predicate are usually written in the infix notation as t1 ≈ t2 . A rule r is an expression of the form
B1 ∧ . . . ∧ Bn → H1 ∨ . . . ∨ Hm
( 1 ) where n ≥ 0 , m ≥ 0 , and Bi and Hj are atoms . The set of atoms {B1 , . . . , Bn} is called the antecedent , and the set of atoms {H1 , . . . , Hm} is called the consequent . A program P is a finite set of rules . A rule of the form ( 1 ) with m = 0 is usually written as B1 ∧ . . . ∧ Bn → ⊥ and is said to
5
Table 2 : The Semantics of Rules
I , µ |= C(s ) I , µ |= R(s , t ) I , µ |= s ≈ t if sI,µ ∈ C I if hsI,µ , tI,µi ∈ RI if sI,µ = tI,µ
I , µ |= Vm I |= Vm i=1 Ui → Wn i=1 Ui → Wn
I |= P j=1 Vn if I , µ |= Vm i=1 Ui → Wn
I |= r for each rule r ∈ P if j=1 Vn if I , µ |= Vj for some 1 ≤ j ≤ n whenever
I , µ |= Ui for each 1 ≤ i ≤ m j=1 Vn for all mappings µ have the empty consequent . A rule is safe if each variable in the rule occurs in some antecedent atom .
Let I = ( △I , ·I ) be an interpretation and µ : NV → △I a mapping of variables to elements of △I . Furthermore , let aI,µ = aI for an individual a and xI,µ = µ(x ) for a variable x . Satisfaction of an atom , a rule , and a program P in I and µ is defined as shown in Table 2 .
Without loss of generality , we can assume that no rule contains an atom x ≈ s in the antecedent , since such a rule is equivalent to the one obtained by replacing x with s . Finally , A ∧ s 6≈ t → B is equivalent to A → B ∨ s ≈ t and A → B ∨ s 6≈ t is equivalent to A ∧ s ≈ t → B ; therefore , to simplify the presentation , we do not allow the rules to contain inequality atoms .
3 Modeling Structured Objects using Logic
To understand the limitations of modeling structured objects in OWL , let us consider modeling the anatomy of the heart shown in Figure 1 . This example has been derived by reconstructing the intention behind the axioms describing the heart in GALEN . We next consider possibilities for a logical interpretation of the figure .
Figure 1 could be represented in OWL using an ABox A . ABox assertions , however , represent concrete data ; thus , A would represent the structure of one particular heart . In this paper , we are concerned with modeling structured objects at the schema level—that is , we want to describe the general structure of all hearts . We should be able to instantiate such a description many times . For example , if we say that each patient has a heart , then , for each concrete patient , we should instantiate a different heart , each of the structure shown in Figure 1 . This clearly cannot be achieved if we describe the structure of the heart using ABox assertions . Consequently , GALEN , SNOMED CT , and NCI contain only schema level axioms and no ABox assertions .
6
Figure 1 : The Structure of the Heart
We can give a logical , schema level interpretation to Figure 1 by treating vertices as concepts and arrows as participation constraints specifying relationships between concepts . For example , LeftSideOfHeart and AorticValve are concepts and the arrow between them states that each left side of the heart has an aortic valve as a structural component . Participation constraints can be represented using existential quantification , which can be encoded in OWL using axioms of the form ( 2 ) . Let K be a DL knowledge base containing the following axioms .
LeftSideOfHeart ⊑ ∃hasStructuralComponent .AorticValve
AorticValve ⊑ ∃hasAlphaConnection .LeftVentricle
LeftSideOfHeart ⊑ ∃hasSolidDivsion.LeftVentricle
( 2 )
( 3 )
( 4 )
Let I be an interpretation that corresponds to Figure 1 in the obvious way . Clearly , I is a model of K , which justifies the formalization of Figure 1 by axioms ( 2)–(4 ) .
Such a schema level representation of a heart can be put to use in many ways . We might represent knowledge about various heart conditions ; for example , if the aortic valve suffers from aortic regurgitation ( AR ) , then the left ventricle suffers from left ventricular hypertrophy ( LVH ) :
AorticValve ⊓ HasAR ⊑ ∀hasAlphaConnection .HasLVH
( 5 )
We might expect to derive from ( 2)–(5 ) that , if the aortic valve of the left side of the heart suffers from aortic regurgitation , then the left ventricle
7
Figure 2 : An Unintended Tree Model of K suffers from hypertrophy :
LeftSideOfHeart ⊓
∃hasStructuralComponent .(AorticValve ⊓ HasAR ) ⊑
( 6 )
∃hasSolidDivision.HasLVH
Unfortunately , ( 6 ) does not follow from K : axioms ( 3 ) and ( 4 ) imply the existence of two left ventricles , but no axiom in K states that these two ventricles are necessarily the same object . Thus , an interpretation I ′ In I ′ , even if the aortic corresponding to Figure 2 is also a model of K . valve has aortic regurgitation , the second left ventricle is unaffected . Hence , I ′ 6|= ( 6 ) , so K 6|= ( 6 ) as well .
The knowledge base K is thus underconstrained : some models of K do not correspond to the actual structure of the heart shown in Figure 1 . This discrepancy can prevent us from drawing some quite reasonable conclusions , such as ( 6 ) . Furthermore , it can also cause problems with the performance of reasoning . For example , we might use axioms ( 4 ) and ( 7)–(8 ) to describe the relationships between the left side of the heart , the left ventricle , and the mitral valve .
LeftVentricle ⊑ ∃isBetaConnectionOf .MitralValve
MitralValve ⊑ ∃isStructuralComponentOf .LeftSideOfHeart
( 7 )
( 8 )
While admitting a model corresponding to Figure 1 , these axioms do not state that the mitral valve in ( 7 ) is a structural component of the “ initial ” left side of the heart . Hence , the interpretation from Figure 3 is also a model of these axioms . In fact , the latter model is “ canonical ” in the sense that it reflects the least amount of information derivable from the axioms . In order to disprove an entailment from these axioms , an OWL reasoner will try to construct such a “ canonical ” model . In practice , such models can be highly
8
Figure 3 : An Unintended Infinite Model of K repetitive and much larger than the intended models , which , according to our experience , is the main reason why OWL reasoners still cannot process ontologies such as FMA and certain versions of GALEN .
To avoid such problems , we need to extend K with additional axioms that make all models of K correspond as much as possible to the intended conceptualization shown in Figure 1 . Such axioms , however , cannot be stated in OWL , for reasons we explain next . OWL can represent unbounded or even infinite domains , which is appropriate in many cases . For example , in the domain of people , we should not make any assumptions about the number of people in the world . In other words , the domain of all people does not exhibit a natural bound on its size . Thus , we can represent the fact that every person has exactly two parents who are persons :
Person ⊑ ≥ 2 hasParent .Person ⊓ ≤ 2 hasParent .⊤
( 9 )
Reasoning with such axioms is not straightforward . A model containing one person γ must contain two parents δ1 and δ2 , each of which requires the existence of two additional parents and so on . Effectively , we obtain a model that is similar to the one shown in Figure 3 .
To ensure termination of the model construction outlined in the previous paragraph , the structure of the axioms allowed in OWL is restricted such that the language exhibits ( a variant of ) the tree model property [ 32 ] : whenever a knowledge base K has a model , it also has a model of a certain tree shape . The relationship between the left side of the heart , the aortic valve , and the left ventricle in Figure 1 is , however , triangular and cannot be represented as a tree . Hence , if we want to ensure that the ventricles whose existence is implied by ( 3 ) and ( 4 ) are the same in every model of K , we must leave the confines of OWL and DLs .
Certain rule formalisms can axiomatize nontree structures . For example , the following SWRL [ 12 ] rule can be used to make the two ventricles from Figure 2 the same :
LeftSideOfHeart(x ) ∧ hasStructuralComponent ( x , y ) ∧ hasAlphaConnection ( y , z ) ∧ LeftVentricle(z ) ∧ hasSolidDivsion(x , w ) ∧ LeftVentricle(w ) → z ≈ w
( 10 )
9
This , however , has significant drawbacks . From the standpoint of modeling , such a solution is quite complex , as it requires the modeler to anticipate which objects need to be made the same . The fact that the two left ventricles are the same follows from the complex interaction between axioms ( 2)–(4 ) and ( 10 ) , and is thus not represented explicitly . Clearly , such a modeling formalism is likely to be hard to use and susceptible to modeling errors . From the standpoint of automated reasoning , the extension of OWL with SWRL is undecidable [ 12 ] , which is a significant impediment to the adoption of SWRL in practice .
SWRL like rules can , however , naturally express certain conditional aspects of structured objects . For example , if the septum has a ventricular septal defect , then there is a blood flow from the left to the right ventricle :
IntraventricularSeptum ( x ) ∧ HasVSD(x ) ∧ hasLayer ( y1 , x ) ∧ LeftVentricle(y1 ) ∧ hasLayer ( y2 , x ) ∧ RightVentricle(y2 ) → hasBloodFlow ( y1 , y2 )
( 11 )
The variables in the antecedent of this rule are connected in a non treelike way , so such a rule cannot be expressed in OWL . If we , however , deal with arbitrarily connected structures , such as the one shown in Figure 1 , non tree like antecedents are essential for drawing the correct inferences .
Various decidable combinations of DLs and rules cannot be used for schema modeling . For example , the DL safe rules [ 20 ] are syntactically restricted such that they apply only to the explicitly named objects . Rolesafe [ 16 ] and weakly safe [ 23 ] rules also impose restrictions that prevent the application of the rules to arbitrary elements of the domain , and similar restrictions are also employed by various nonmonotonic rule extensions of OWL [ 8 , 23 , 19 ] . While these are quite useful in query answering , they cannot be used to derive new conclusions from the schema .
The DL SROIQ [ 15 ] and the OWL 1.1 extension of OWL DL extend OWL with complex role inclusions of the form R1 ◦ . . . ◦ Rn ⊑ S , restricted appropriately to ensure decidability . Such axiom solve some of the problems ; however , they still cannot axiomatize arbitrary structures such as the one in Figure 1 or express axioms such as ( 11 ) .
4 The Formalism for Structured Objects
We now present an extension of OWL that addresses the problems outlined in Section 3 . In Section 4.1 , we present the basic principles behind our idea , which we then formalize in Section 42
4.1 Basic Principles
The main aspect of a description of a structured object is the connection between the object ’s parts , which can naturally be represented as a graph .
10
Hence , we introduce the notion of a description graph G = ( V , E , λ)—a directed graph in which each vertex i ∈ V is labeled with a set of atomic concepts λhii and each edge hi , ji ∈ E is labeled with a set of atomic roles λhi , ji . For example , Figure 1 can be understood as a description graph that describes the heart .
Semantically , G = ( V , E , λ ) should be understood as a “ template ” for a fragment of a model . Let I be a model and A an atomic concept labeling some graph vertex i ∈ V . If I contains an object γ such that γ ∈ AI , then I must also contain an instance of G in which γ corresponds to i . For example , if I contains an instance γ of the Heart concept , then I must contain a relational structure corresponding to Figure 1 in which γ corresponds to the top most vertex .
As discussed in Section 3 , extending DLs with constructs that allow the description of arbitrarily connected structures of unbounded size easily leads to undecidability . In practice , structured objects are usually modeled up to a certain level of granularity , which naturally determines this bound . For example , a human body consists of a certain number of organs . These organs might be decomposed into smaller parts ; however , each such decomposition is bounded , so the entire model of human anatomy requires a bounded number of objects . Even though the number of required objects may be large and difficult to determine by hand , the fact that the domain is bounded is intrinsic to the modeling problem . The reasoning algorithm presented in Section 5 uses this bound to ensure termination even on arbitrarily connected , non tree like structures .
We assume that the set of atomic roles is divided into a set of atomic tree roles NRt and a set of atomic graph roles NRg . A graph extended DL knowledge base is a 4 tuple K = ( T , G , P , A ) where T is a DL TBox , G is a description graph , P is a set of rules , and A is an ABox . Furthermore , T is allowed to refer only to tree roles , G and P are allowed to refer only to the graph roles , and A is allowed to refer to both graph and tree roles .
For example , let K = ( T , G , P , A ) be a graph extended DL knowledge base with the following components . Let T contain the axioms ( 12)–(14 ) . Intuitively , axiom ( 12 ) says that each person has a parent and a heart ; axiom ( 13 ) ensures that the heart of each sufferer from aortic regurgitation is an instance of HasAR ; and axiom ( 14 ) says that , on each aortic valve suffering from aortic regurgitation , some person is performing a surgery on it .
Person ⊑ ∃hasParent .Person ⊓ ∃hasHeart .Heart
AR Sufferer ⊑ ∀hasHeart .HasAR
AorticValve ⊓ HasAR ⊑ ∃performsSurgeryOn −.Person
( 12 )
( 13 )
( 14 )
Let G correspond to Figure 1 , and let P contain the rule that propagates the HasAR concept over the structural components of the heart .
HasAR(x ) ∧ hasStructuralComponent ( x , y ) → HasAR(y )
( 15 )
11
Figure 4 : A Typical Model of K
Let A contain the assertions Person(a ) and AR Sufferer ( a ) .
The semantics of graph extended knowledge bases ensures that each model I of K is of the form shown in Figure 4 . The model I consists of two distinct parts . The tree backbone consists of objects ( shown as large squares ) connected through tree roles ( shown using thick lines ) , and it is constructed using the standard DL axioms in T . As discussed in Section ( 3 ) , the number of persons is not naturally bounded so , if we want a decidable formalism , we must employ standard DL restrictions . Apart from the tree backbone , I also contains arbitrarily connected but naturally bounded graph instances , such as the structure of the heart of each person . Unlike in the case of axioms ( 2)–(4 ) and Figure 2 , each graph instance is necessarily of the form as specified by G in each such model I . Note that the tree backbone of I need not be contiguous : the bottom most AorticValve object av can be connected to other objects through tree roles . To summarize , for a graph extended knowledge base K , we can consider only models that consist of graph instances , connected among themselves and with other objects through tree roles .
Decidability of the formalism is now ensured by the separation of the roles into tree and graph ones . The axioms in T can propagate constraints across tree roles just like in standard DLs ; however , we can adapt the blocking technique [ 14 ] to ensure termination of model construction . Furthermore , the rules in P can propagate constraints within a graph ; however , the size of the graph is naturally bounded , so this does not cause termination
12 problems either .
Our way of obtaining decidability is related to fusions of abstract description systems ( ADSs ) [ 3 ] , which provide for the combination of different modal and description logics . The component ADSs can share concepts ; however , the interaction between them through roles is restricted to ensure decidability . Our separation of roles into graph and tree ones is similar in spirit . Bounded structures and rules , however , cannot directly be expressed as an ADS . In addition , we present a practical decision procedure for our formalism .
This example also demonstrates a minor modeling problem . The intention behind axioms ( 13 ) and ( 15 ) is to mark the aortic valve of each sufferer from aortic regurgitation with the HasAR concept . Doing this in two separate axioms seems unnatural , and the following , more compact DL axiom can be used for this purpose :
AR Sufferer ⊑ ∀hasHeart .∀hasStrucutralComponent .
∀hasStrucutralComponent .HasAR
( 16 )
This is currently not possible because DL axioms are not allowed to contain graph roles . This problem , however , can be solved by appropriate syntactic sugar . For example , we might extend the definition of T to allow for graph roles to occur under ∀ quantifier ; then , for reasoning , we might replace each subconcept concept ∀R.C where R is a graph role using a new name that we axiomatize appropriately using rules . Such extensions , however , do not change the essence of our formalism , so we do not discuss them further .
Our way of obtaining obtaining decidability is related to fusions of abstract description systems ( ADSs ) [ 3 ] , which allow one to combine different modal and description logics . The component ADSs can share concepts ; however , the interaction between them through roles is restricted to ensure decidability . Our separation of roles into graph and tree ones is similar in spirit . Bounded structures and rules , however , cannot directly be expressed as an ADS ( an encoding might exist , but it is not obvious and is unlikely to be suitable for practical usage ) . In addition , we present a practical decision procedure for our formalism .
4.2 Formalization
We now present the formal definition of our formalism . We start by separating the tree form the graph roles .
Definition 1 ( Graph Extended DL Signature ) . A graph extended DL signature is a 4 tuple Σ = ( NC , NRt , NRg , NI ) consisting of pair wise disjoint sets of atomic concepts NC , atomic tree roles NRt , atomic graph roles NRg , and individuals NI .
13
All subsequent definitions in this paper are implicitly parameterized with a graph extended DL signature . Next , we formalize the notion of description graphs . We make the technical assumption that the vertices of the description graph are integers , as this allows us to use vertices as indices.4
Definition 2 ( Description Graph ) . A description graph G = ( V , E , λ ) is a directed labeled graph where
• V = {1 , . . . , ℓ} is a finite set of integers called vertices ,
• E ⊆ V × V is a set of edges , and
• λ is a labeling function that assigns a set of atomic concepts λhii ⊆ NC to each vertex i ∈ V , and a set of atomic graph roles λhi , ji ⊆ NRg to each edge hi , ji ∈ E .
For an atomic concept A , let VA = {k ∈ V | A ∈ λhki} .
Finally , we define the notion of graph extended DL knowledge bases . The definition of graph regular rules ensures that each such rule can become applicable only to objects from the same instance of the description graph G . As discussed in the previous section , this is required for decidability of the formalism .
Definition 3 ( Graph Extended KBs ) . A graph extended DL knowledge base is a 4 tuple K = ( T , G , P , A ) , where different components have the following structure :
• T is a TBox over the signature ( NC , NRt , NI ) expressed in some de scription logic DL .
• G is a description graph .
• P is a program consisting of a finite number of graph regular rules . A rule r is graph regular if it uses only atomic concepts and graph roles and for each two variables x1 and x2 occurring in r , some antecedent atom of r contains both x1 and x2 .
• A is an extensionally reduced ABox whose assertions can refer to all elements in the signature ( NC , NRt , NRg , NI ) ; furthermore , in addition to the standard ABox assertions of DL , the ABox A can contain graph assertions of the form G(a1 , . . . , aℓ ) , where ai ∈ NI and ℓ is the number of vertices of the description graph G .
4For example , given a vector of variables x1 , . . . , xℓ and a vertex i ∈ V , we can refer to the variable xi .
14
Graph regular rules can express conjunctive queries over G , so we do not consider query answering separately . We now formalize the semantics of description graphs .
Definition 4 ( Semantics ) . An interpretation I = ( △I , ·I ) interprets a description graph G = ( V , E , λ ) with ℓ vertices as an ℓ ary relation GI ⊆ ( △I )ℓ . Moreover , I satisfies G , written I |= G , if all of the following conditions hold .
• The i key property must hold for each 1 ≤ i ≤ ℓ :
∀x1 , . . . , xℓ , y1 , . . . , yℓ ∈ △I : hx1 , . . . , xℓi ∈ GI ∧ hy1 , . . . , yℓi ∈ GI ∧ xi = yi → V1≤j≤ℓ xj = yj
• The disjointness property must hold :
∀x1 , . . . , xℓ , y1 , . . . , yℓ ∈ △I : hx1 , . . . , xℓi ∈ GI ∧ hy1 , . . . , yℓi ∈ GI → V1≤i<j≤n xi 6= yj
• The A start property must hold for each atomic concept A with VA 6= ∅ :
∀x ∈ △I : x ∈ AI → ∃x1 , . . . , xℓ ∈ △I : hx1 , . . . , xℓi ∈ GI ∧ Wk∈VA x = xk
• The vertex layout property must hold for each i ∈ V and A ∈ λhii :
∀x1 , . . . , xℓ ∈ △I : hx1 , . . . , xℓi ∈ GI → xi ∈ AI
• The edge layout property must hold for each hi , ji ∈ E and R ∈ λhi , ji :
∀x1 , . . . , xℓ ∈ △I : hx1 , . . . , xℓi ∈ GI → hxi , xji ∈ RI
The intuition behind this definition is as follows . Each tuple in the ℓ ary relation GI corresponds to one instance of the description graph G .
The i key properties and the disjointness property ensure that no two instances of G can share an object , which essentially captures the idea behind natural boundedness . Consider the axiom B ⊑ A and a graph G consisting of two vertices 1 and 2 such that λh1i = {A} , λh2i = {B} , and λh1 , 2i = {R} . Without the i key and the disjointness properties , we could build a model I of G where γ1 ∈ AI , hγ1 , γ2i ∈ RI , and γ2 ∈ BI ; to ensure that BI ⊆ AI , we must also set γ2 ∈ AI ; but then , we must instantiate G for γ2 , which clearly leads to a cyclic computation . The i key and the disjointness properties ensure that such a model I cannot exist : each object occurring in a graph part of I occurs in exactly one tuple of GI . Since this tuple is bounded in
15 size , each graph part of I is bounded as well , which can be used to ensure termination of model construction .
The A start property ensures that I contains an appropriate instance of G whenever I contains an instance γ of a concept A labeling a vertex of G . If A labels more than one vertex of G , the A start property “ guesses ” the vertex of G that γ should be matched to . Consider , for example , a graph containing a vertex labeled with Hand and five vertices labeled with Finger . If some object γ is an instance of Finger , without further information we cannot disambiguate which of the five fingers γ stands for . Therefore , we need to make a “ guess ” and examine all five possibilities independently . Note that no other property requires guessing ; hence , unless we label two vertices in G with the same concept A , the semantic properties of graphs allow for deterministic reasoning .
Finally , the vertex and edge layout properties simply ensure that each instance of G indeed contains the appropriate relational structure of G .
A satisfaction of a graph extended knowledge base K = ( T , G , P , A ) in an interpretation I is defined in the obvious way : I |= K iff I |= T , I |= G , I |= P , and I |= A .
5 Reasoning with Graph Extended KBs
We now present an algorithm for reasoning with a graph extended knowledge base K = ( T , G , P , A ) with T expressed in SHIQ . We extend the hypertableau algorithm , which has been implemented in the HermiT reasoner and has proven very effective in practice [ 21 ] : HermiT is currently the only reasoner that can classify the original version of GALEN—a long standing open problem in DL reasoning . In the following section , we present an overview of our algorithm and , in the subsequent sections , we introduce the algorithm formally and prove its soundness , completeness , and termination .
5.1 Algorithm Overview
Our algorithm decides satisfiability of K = ( T , G , P , A ) . All other interesting reasoning problems , such as subsumption and instance checking , can be reduced to satisfiability checking as in standard DLs [ 2 , Chapter 2 ] . Satisfiability of K is checked in two main phases . The task of the preprocessing phase is to translate T and G into a set of rules of the form ( 1 ) that are equisatisfiable with T and G . In the hypertableau phase , our algorithm attempts to construct a model satisfying the rules obtained in the preprocessing phase , the rules in P , and the ABox assertions in A .
The TBox T is preprocessed into a set of rules with Ξ(T ) exactly as it is done in [ 21 ] . To make this paper self contained , we repeat the translation in Section 52 The first preprocessing step is to remove transitivity axioms from T . Thus , T is converted into a TBox Ω(T ) that does not contain
16 transitivity axioms but is equisatisfiable with T . The next step is to convert each concept inclusion from Ω(T ) into a normalized form shown below , for Ai , Bi , Ci , and Di atomic concepts :
⊤ ⊑ G(¬)Ai ⊔G ∀Ri.(¬)Bi ⊔G ≥ ni Si.(¬)Ci ⊔G ≤ mi Ri.(¬)Di
( 17 )
This greatly simplifies the structure of the axioms , as the normalized axioms do not contain implicit negations or complex nested subconcepts . Note that concepts of the form ∃R.C are represented in the normalized form as ≥ 1 RC We denote the result of the normalization with ∆(T ) . The final preprocessing step is to translate ∆(T ) into an equivalent set of rules Ξ(T ) . This is done by expanding the ∀R.C and ≥ n R.C concepts according to the standard semantics . For example , the axiom ⊤ ⊑ ∃R.A ⊔ ∀R.¬B is translated into the rule R(x , y ) → ( ∃R.A)(x ) ∨ B(y ) .
The description graph G is translated into a set of rules Ξ(G ) that encodes the conditions of Definition 4 . The i key , disjointness , vertex , and edge layout properties are encoded as rules in a straightforward way . To encode the A start property , we first extend the rule consequents to allow for concepts of the form ∃G|k ; intuitively , ∃G|k(x ) is true in a model I if x occurs in I in some instance of G at vertex k . For each concept A labeling vertices i1 , . . . , ik of G , the following rule is added to Ξ(G ) :
A(x ) → ∃G|i1(x ) ∨ . . . ∨ ∃G|ik(x )
( 18 )
For example , Ventricle concept , the following rule is added to Ξ(G ) : if G contains vertices 4 and 9 that are labeled with the
Ventricle(x ) → ∃G|4(x ) ∨ ∃G|9(x )
( 19 )
Intuitively , each instance x of the Ventricle concept must occur in some instance of G either at vertex 4 or vertex 9 . Hence , this rule encodes the “ guessing ” that we discussed in Section 42
The preprocessing produces a set of rules R = Ξ(T ) ∪ Ξ(G ) ∪ P that is equisatisfiable with ( T , G , P ) . Thus , satisfiability of K = ( T , G , P , A ) can be shown by proving satisfiability of ( R , A ) , which can be done using our hypertableau algorithm . The algorithm is presented formally in Section It attempts to construct a representation of a model of ( R , A ) by 54 applying different inference rules to A and R , which produce new ABoxes A1 , . . . , An . All inference rules are such that at least one resulting ABox contains more information about a model for A and R . For example , if A(s ) ∈ A and A(x ) → B(x ) ∨ C(x ) ∈ R , an application of the Hyp rule to A and R produces ABoxes A ∪ {B(s)} and A ∪ {C(s)} ; intuitively , in each model of ( R , A ) , either B(s ) or C(s ) must be true as well . If ≥ 1 R.C(s ) ∈ A , an application of the ≥ rule produces an ABox A ∪ {R(s , t ) , C(t)} with t a new individual ; intuitively , in each model of A , the individual s must be
17 connected to some individual which is also an instance of C . If s ≈ t ∈ A , an application of the ≈ rule produces an ABox in which , roughly speaking , s is replaced with t ; intuitively , if s and t denote the same object , we can refer to that object using just one of the two names . Finally , if s 6≈ s ∈ A or {A(s ) , ¬A(s)} ⊆ A , then A is obviously unsatisfiable , which is detected by the ⊥ rule . Finally , the ∃G rule is a new rule that is similar to the ≥ rule : if ∃G|i(s ) ∈ A , this rule derives A ∪ {G(t1 , . . . , ti−1 , s , ti+1 , . . . , tℓ)} with tj new individuals .
It is easy to see that , on axioms ( 4 ) and ( 7)–(8 ) , our algorithm would generate a model shown in Figure 3 , and would therefore not terminate . In standard ( hyper)tableau algorithms , termination is achieved using blocking : roughly speaking , if two individuals s and s′ occur in the same concepts in A , then s “ behaves ” just like s′—that is , we do not expand s any further . Thus , to ensure decidability , we adapt the well known pair wise blocking [ 14 ] to our setting . Roughly speaking , we separate the individuals in A into named , tree , and graph individuals . The named individuals are the ones that occur in the original graph extended knowledge base , the tree individuals are introduced by an application of the ≥ rules , and the graph individuals are introduced by an application of the ∃G rule . We use this distinction in the definition of blocking : only tree individuals can be blocked , and the blocking individual must also be a tree individual .
5.2 Preprocessing the DL TBox into Rules
We now present the part of the preprocessing phase that translates a SHIQ TBox T into a set of equisatisfiable rules Ξ(T ) .
Elimination of Transitivity Axioms . We first encode a SHIQ TBox T into an equisatisfiable ALCHIQ knowledge base Ω(T ) . Roughly speaking , an axiom Trans(S ) is replaced with axioms ∀R.C ⊑ ∀S(∀SC ) , for each R with S ⊑∗ R and C a “ relevant ” concept from T . This encoding is polynomial and has been presented several times for various description [ 31 ] and modal [ 25 ] logics . Therefore , we omit the details of the transformation and refer the reader to [ 17 , Section 52 ] After this transformation , there is no distinction between simple and complex roles , so , without loss of generality , in the rest of this paper we treat ∃R.C as a syntactic shortcut for ≥ 1 RC
Structural Transformation . Axioms are next brought into a certain normalized form , defined as follows : called literal concepts . A GCI is normalized if it is of the form ⊤ ⊑ Fn
Definition 5 . For A an atomic concept , the concepts A , ¬A , ⊤ , and ⊥ are i=1 Ci , where each Ci is of the form B , ∀R.B , ≥ n R.B , or ≤ n R.B , and B is a literal concept . A TBox T is normalized if all GCIs in it are normalized .
18
Table 3 : The Structural Transformation
∆(T ) =
∆(⊤ ⊑ nnf(¬C1 ⊔ C2 ) )
SC1⊑C2 ∈T
∆(⊤ ⊑ C ⊔ C ′ ) = ∆(⊤ ⊑ C ⊔ αC ′ ) ∪
∆(⊤ ⊑ ˙¬αC ′ ⊔ Ci ) for C ′ = n d i=1
Ci n
Si=1
∆(⊤ ⊑ C ⊔ ∀R.D ) = ∆(⊤ ⊑ C ⊔ ∀R.αD ) ∪ ∆(⊤ ⊑ ˙¬αD ⊔ D )
∆(⊤ ⊑ C ⊔ ≥ n R.D ) = ∆(⊤ ⊑ C ⊔ ≥ n R.αD ) ∪ ∆(⊤ ⊑ ˙¬αD ⊔ D ) ∆(⊤ ⊑ C ⊔ ≤ n R.D ) = ∆(⊤ ⊑ C ⊔ ≤ n R . ˙¬αD′ ) ∪ ∆(⊤ ⊑ ˙¬αD′ ⊔ D′ ) for D′ = ˙¬D
∆(β ) = {β} for any other axiom β
αC = fl QC if pos(C ) = true
¬QC if pos(C ) = false where QC is a fresh atomic concept unique for C pos(⊤ ) = false pos(A ) = true pos(⊥ ) = false pos(¬A ) = false pos(C1 ⊓ C2 ) = pos(C1 ) ∨ pos(C2 ) pos(C1 ⊔ C2 ) = pos(C1 ) ∨ pos(C2 ) pos(∀R.C1 ) = pos(C1 ) pos(≥ n R.C1 ) = true pos(≤ n R.C1 ) = fl pos( ˙¬C1 ) true if n = 0 otherwise
Note : A is an atomic concept , Ci are arbitrary concepts , C is a possibly empty disjunction of arbitrary concepts , and D is not a literal concept . In C ⊔ C , the concept C should be understood as any , and not just the right most disjunct of C ⊔ C .
A TBox T can be brought into normalized form ∆(T ) as follows :
Definition 6 . For T an ALCHIQ TBox , ∆(T ) is the TBox computed as shown in Table 3 .
Intuitively , pos(C ) is used to determine whether C should be replaced with a positive or a negative literal concept αC . If pos(C ) = false , then C can be converted into clauses with only negative literals , so we rename C by a negative literal concept ¬QC ; otherwise , the clausification of C requires at least one positive literal , so we rename C by a positive literal concept QC . This prevents the introduction of new disjunctions due to normalization [ 21 ] . We now show that normalization does not affect satisfiability .
Lemma 1 . A graph extended knowledge base ( T , G , P , A ) , where T is an ALCHIQ TBox , is satisfiable if and only if ( ∆(T ) , G , P , A ) is satisfiable ; ∆(T ) can be computed in polynomial time ; and ∆(T ) is normalized .
Proof . It is easy to see that our transformation is a syntactic variant of the structural transformation from [ 22 ] , from which the first two claims follow . i=1 Ci and then keeps replacing nested subconcepts of Ci as long as the GCI is not normalized .
Observe that ∆ essentially rewrites each GCI into a form ⊤ ⊑ Fn
Translation into Rules . We now show how to transform a normalized TBox into an equivalent set of rules .
19
Table 4 : Translation of Normalized GCIs to Rules
Ξ(T ) = {.Vn i=1 lhs(Ci)fi → .Wn i=1 rhs(Ci)fi | for each ⊤ ⊑ Fn
{ar(R , x , y ) → ar(S , x , y ) | for each R ⊑ S in T } i=1 Ci in T } ∪ ar(R , s , t ) = fl R(s , t )
S(t , s ) if R is an atomic role if R is an inverse role and R = S−
Note : Whenever lhs(Ci ) or rhs(Ci ) is undefined , it is omitted in the rule . lhs(C )
A(x ) ar(R , x , yC ) rhs(C ) A(x )
≥ n R.A(x ) ≥ n R.¬A(x )
A(yC )
C A ¬A
≥ n R.A ≥ n R.¬A
∀R.A ∀R.¬A ≤ n R.A
≤ n R.¬A
Note : Each variable y(i ) ar(R , x , yC ) ∧ A(yC ) Vn+1 C ) ∧ A(yi i=1 [ ar(R , x , yi
C ) ]
C ≈ yj Vn+1 n+1 j=i+1 yi i=1 ar(R , x , yi C is unique for C ( and i ) , and it is different from x .
Wn+1 j=i+1 yi Wn+1 C ) ∨Wn+1 i=1 A(yi
C ) n+1 i=1 i=1
C
C ≈ yj
C
Definition 7 . For a normalized ALCHIQ TBox T , the set of rules Ξ(T ) is obtained as shown in Table 4 .
To simplify the inference rules presented in Section 5.4 , the role atoms in Ξ(T ) involve only atomic roles . Thus , the function ar from Table 4 is used to convert inverse role atoms R−(s , t ) in Ξ(T ) into atomic role atoms R(t , s ) . An inverse role can occur only in concepts of the form ≥ n R−.C , and the ar function is used when expanding such concepts to produce atoms containing atomic roles .
We now show that translation of a TBox into rules does not affect its satisfiability .
Lemma 2 . Let T be a normalized ALCHIQ TBox . Then , I |= T if and only if I |= Ξ(T ) .
Proof . The following equivalences between DLs and first order logic are known :
∀R.C(x ) ≡ ∀y : ¬R(x , y ) ∨ C(y )
≤ n R.C(x ) ≡ ∀y1 , . . . , yn+1 :
[ ¬R(x , yi ) ∨ ¬C(yi ) ] ∨ n+1
W1=i
W1≤i<j≤n+1 yi ≈ yj
Clearly , Ξ(T ) is obtained from normalized GCIs by expanding the concepts ∀R.C and ≤ n R.C according to these equivalences , and then moving all negative atoms into the antecedent and all positive atoms into the consequent of the rule .
20
5.3 Preprocessing the Description Graph into Rules
We now present the part of the preprocessing phase that translates a description graph G into a set of graph regular rules Ξ(G ) . In Definition 8 we introduce some auxiliary notions ; then , we present the actual translation in Definition 9 .
Definition 8 . A graph existence concept is an expression of the form ∃G|i , where G = ( V , E , λ ) is a description graph with ℓ vertices and i ∈ V . It is interpreted in an interpretation I as follows :
( ∃G|i)I = {s | ∃t1 , . . . , tℓ : ht1 , . . . , tℓi ∈ GI ∧ s = ti}
In the rest of this paper , we extend the definition of graph regular rules ( see Definition 3 ) to allow for ( i ) graph atoms G(x1 , . . . , xn ) in antecedents , and ( ii ) graph existence atoms ∃G|i(x ) in consequents , where x(i ) are variables . The semantics of such rules is defined in the obvious way .
Definition 9 . Given a description graph G = ( V , E , λ ) with ℓ vertices , the set Ξ(G ) consists of the following rules :
1 . The following rule is instantiated for each i , j ∈ V such that j 6= i :
G(x1 , . . . , xℓ ) ∧ G(y1 , . . . , yi−1 , xi , yi+1 , . . . , yℓ ) → xj ≈ yj ;
2 . The following rule is instantiated for each 1 ≤ i < j ≤ ℓ :
G(x1 , . . . , xℓ ) ∧ G(y1 , . . . , yj−1 , xi , yj+1 , . . . , yℓ ) → ⊥ ;
3 . The following rule is instantiated for each atomic concept A such that
VA 6= ∅ :
A(x ) → _k∈VA
∃G|k(x ) ;
4 . The following rule is instantiated for each i ∈ V and A ∈ λhii :
G(x1 , . . . , xℓ ) → A(xi ) ;
5 . The following rule is instantiated for each hi , ji ∈ E and R ∈ λhi , ji :
G(x1 , . . . , xℓ ) → R(xi , xj ) .
By taking into account the semantics of the concepts ∃G|k from Definition 8 , the rules in Ξ(G ) obviously encode the conditions of Definition 4 , which implies the following lemma .
Lemma 3 . Let G = ( V , E , λ ) be a description graph and I an interpretation . Then , I |= G if and only if I |= Ξ(G ) .
21
5.4 The Hypertableau Calculus
We now present a calculus for checking satisfiability of ( R , A ) , for R a set of rules , G a description graph , and A an ABox . To check satisfiability of a graph extended DL knowledge base K = ( T , G , P , A ) , we shall apply the calculus to R = Ξ(T ) ∪ Ξ(G ) ∪ P . Our algorithm , however , can handle to any set of rules R that satisfies certain conditions . These conditions are more general than what is strictly necessary to handle Ξ(T ) ∪ Ξ(G ) ∪ P ; for example , they allow for rules such as A(x ) ∧ R(x , y ) → S(x , y ) , which can be useful in practice .
Definition 10 . A set of rules R is admissible if it can be represented as a disjoint union of two subsets Rt and Rg satisfying the following conditions . The set Rg can contain only graph regular rules , and it must contain all the rules specified in items 1 and 2 of Definition 9 for each description graph G occurring in R and A .
Each rule r ∈ Rt must be tree like—that is , it must be possible to separate the variables of r into one center variable x and the set of leaf variables {yi} such that the following conditions are satisfied , for R an atomic tree role , A an atomic concept , and C a concept of the form ≥ n S.A or ≥ n S.¬A with S a ( not necessarily atomic ) tree role :
• Each atom in the antecedent of r is of the form A(x ) , A(yi ) , R(x , yi ) , or R(yi , x ) .
• Each atom in the consequent is of the form A(x ) , A(yi ) , C(x ) , C(yi ) ,
R(x , yi ) , R(yi , x ) , or yi ≈ yj .
• Each variable yi in the rule occurs in some binary atom in the an tecedent .
By inspecting the types of rules generated in Definitions 7 and 9 , it is easy to see that , for an arbitrary graph extended DL knowledge base K = ( T , G , P , A ) where T is expressed in the DL SHIQ , the set of rules R = Ξ(T ) ∪ Ξ(G ) ∪ P is admissible . We are now ready to formally define our hypertableau calculus .
Definition 11 . Generalized Individuals . Let T and Γ be two disjoint countably infinite sets of tree and graph symbols . A generalized individual is a finite string of symbols α0α1 . . . .αn such that α0 ∈ NI , αi ∈ T ∪ Γ for 1 ≤ i ≤ n , and αi−1 ∈ Γ implies αi 6∈ Γ . If αn ∈ NI , the individual is named ; if αn ∈ T , the individual is a tree individual ; and if αn ∈ Γ , the individual is a graph individual .
Successors and Predecessors . A generalized individual x.α is a successor of x , predecessor is the inverse of successor , and descendant and ancestor are the transitive closures of successor and predecessor , respectively .
22
Graph Cluster . Generalized individuals s and t are from the same graph clusters if either ( i ) s is either a named individual or a graph successor of a named individual , and t is also either a named individual or a graph successor of a named individual , ( ii ) both s and t are graph successors of the same tree individual , or ( iii ) one individual is a graph successor of the other individual .
Generalized ABox . We generalize the notion of ABoxes by allowing them to contain generalized individuals in the assertions . Furthermore , since ≈ and 6≈ are symmetric relations , we take a ≈ b and a 6≈ b to also stand for the assertions b ≈ a and b 6≈ a . Finally , we allow an ABox to contain a special assertion ⊥ that is false in all interpretations . Unless otherwise noted , all ABoxes in the rest of this paper are generalized .
Initial ABox . An ABox is said to be initial if it contains only named individuals , it is extensionally reduced , and it is not empty .
Pairwise Anywhere Blocking . A concept is blocking relevant if it is of the form A , ≥ n R.A , ≥ n R.¬A , or ∃G|i , for A an atomic concept , R a ( not necessarily atomic ) role , and G a description graph . The labels of an individual and of an individual pair in an ABox A are defined as follows :
LA(s ) = {C | C(s ) ∈ A and C is a blocking relevant concept}
LA(s , t ) = {R | R(s , t ) ∈ A}
Let ≺ be a strict ordering ( ie , a transitive and irreflexive relation ) on the generalized individuals containing the ancestor relation—that is , if s′ is an ancestor of s , then s′ ≺ s . By induction on ≺ , we assign to each individual s in A a status as follows :
• s is directly blocked by an individual s′ iff all of the following is true , for t and t′ the predecessors of s and s′ , respectively :
– both s and s′ are tree individuals , – s′ is not blocked , – s′ ≺ s , – LA(s ) = LA(s′ ) and LA(t ) = LA(t′ ) , and – LA(s , t ) = LA(s′ , t′ ) and LA(t , s ) = LA(t′ , s′ ) .
• s is indirectly blocked iff its predecessor is blocked .
• s is blocked iff it is either directly or indirectly blocked .
Pruning . The ABox pruneA(s ) is obtained from A by removing all assertions that contain a descendant of s .
Merging . The ABox mergeA(s → t ) is obtained from pruneA(s ) by re placing the individual s with the individual t in all assertions .
23
Clash . An ABox A contains a clash if and only if ⊥ ∈ A ; otherwise , A is clash free .
Derivation Rules . Table 5 specifies derivation rules that , given a clash free ABox A and a set of rules R , derive the ABoxes hA1 , . . . , Ani . In the Hyp rule , σ is a mapping from the set of variables NV to the individuals occurring in A , and σ(U ) is obtained from U by replacing each variable x with σ(x ) .
Rule Priority . The ∃G rule is applicable only if no other rule is appli cable .
Derivation . A derivation for a set of admissible rules R and an initial ABox A is a pair ( T , ρ ) where T is a finitely branching tree and ρ is a function that labels the nodes of T with ABoxes such that ( i ) ρ(ǫ ) = A for ǫ the root of the tree , and ( ii ) for each node t , if one or more derivation rules are applicable to ρ(t ) and R , then t has children t1 , . . . , tn such that the ABoxes hρ(t1 ) , . . . , ρ(tn)i are the result of applying one applicable derivation rule chosen by respecting the rule priority . A derivation is clash free if it contains a leaf node labeled with a clash free ABox .
The main difference to the algorithm presented in [ 21 ] is the distinction between named , tree , and graph individuals . To understand why this is important , assume that Figure 4 depicts the contents of an ABox A , generated using a set of tree rules Rt corresponding to axioms ( 12)–(14 ) and a graph G shown in Figure 1 . The individual a is clearly named . The individual h1 is generated by deriving ∃hasHeart .Heart ( a ) by ( 12 ) and then expanding it by the ≥ rule ; hence , h1 is a tree individual . All other individuals that correspond to the structure of the heart ( including av ) are created by instantiating G , so they are graph individuals . We say that h1 and all these individuals are from the say graph cluster—that is , they are allowed to occur in one instance of the graph . Note that each graph cluster can contain arbitrarily many graph individuals , but at most one tree individual which is used to “ enter ” the graph .
Our calculus ensures that each application of an inference rule does not violate the structure of an ABox outlined in the previous paragraph . The main problem is with the ≈ rule : if we merged , say , the tree individual h2 into h1 by simply replacing h2 with h1 , the upper instance of G ( see Figure 1 ) would contain individual h1 which is from the wrong graph cluster than as all other individuals in the graph instance . This , however , is prevented by pruning : before replacing h2 with h1 , we prune h2 , which also removes the graph instance surrounding h2 . The following lemma proves that each ABox labeling a derivation node is indeed of the form outlined above .
Lemma 4 . The following properties hold for each ABox A′ labeling a node in a derivation for an admissible set of rules R and an initial ABox A , where a and b are named individuals , u is a generalized individual , γi , γj ∈ Γ , and τi , τj ∈ T .
24
Table 5 : Derivation Rules of the Hypertableau Calculus
Hyp rule
If 1 . U1 ∧ ∧ Um → V1 ∨ ∨ Vn ∈ R ,
2 . a mapping σ : NV → NA exists such that 2.1 2.2
σ(Ui ) ∈ A for each 1 ≤ i ≤ m and σ(Vj ) 6∈ A for each 1 ≤ j ≤ n , then A1 = A ∪ {⊥} if n = 0 ; or
Aj := A ∪ {σ(Vj)} for 1 ≤ j ≤ n if n > 0 .
≥ rule
If 1 . ≥ n R.C(s ) ∈ A ,
2 . s is not blocked in A , and 3 . there are no individuals u1 , . . . , un such that {ar(R , s , ui ) , C(ui ) | 1 ≤ i ≤ n} ∪ {ui 6≈ uj | 1 ≤ i < j ≤ n} ⊆ A , then A1 := A ∪ {ar(R , s , ti ) , C(ti ) | 1 ≤ i ≤ n} ∪ {ti 6≈ tj | 1 ≤ i < j ≤ n} where t1 , . . . , tn are fresh pairwise distinct tree successors of s .
∃G rule
If 1 . ∃G|i(s ) ∈ A for G a description graph with ℓ vertices ,
2 . s is not blocked in A , and 3 . there are no individuals u1 , . . . , ui−1 , ui+1 , . . . , uℓ such that G(u1 , . . . , ui−1 , s , ui+1 , . . . , uℓ ) ∈ A then A1 := A ∪ {G(t1 , . . . , ti−1 , s , ti+1 , . . . , tℓ)} where t1 , . . . , ti−1 , ti+1 , . . . , tℓ are fresh pairwise distinct graph individuals from the same graph cluster as s .
≈ rule s ≈ t ∈ A and s 6= t
If then A1 := mergeA(s → t ) if t is a named individual or if s is a descendant of t ; or
A1 := mergeA(t → s ) otherwise .
⊥ rule s 6≈ s ∈ A or {A(s ) , ¬A(s)} ⊆ A
If then A1 := A ∪ {⊥} . Note : A is a generalized ABox , R is a set of admissible rules , and NA is the set of individuals occurring in A .
1 . Each R(s , t ) ∈ A′ with R a tree role is of the form R(a , b ) , R(u , u.τi ) , or R(u.τi , u ) .
2 . Each s ≈ t ∈ A′ is of the form u ≈ u , a ≈ b , a ≈ b.τi , u.τi ≈ u.τj , u ≈ uτiτj , u ≈ u.γi , u.γi ≈ u.γj , a ≈ b.γi , or a.γi ≈ bγj
3 . In each graph assertion and each assertion involving a graph role , all individuals are from the same graph cluster .
4 . For each tree individual tn , a sequence(s0 , t0 ) , . . . , ( sn , tn ) of pairs of individuals—called a link to root for tn of length n—exists such that ( i ) s0 is a named individual , ( ii ) each ti is a tree successor of si , ( iii ) ti−1 is from the same graph cluster as si for each 1 ≤ i ≤ n ,
25
( iv ) for each 0 ≤ i ≤ n , either R(si , ti ) ∈ A′ or R(ti , si ) ∈ A′ for some tree role R .
Proof . We prove the claim by induction on the derivation depth . For the base case , note that the ABox A contains only named individuals , so all claims are trivially satisfied . For the induction step , assume that the claim holds for some ABox A′ and consider an ABox A′′ obtained from A′ by an application of a derivation rule .
An application of the Hyp rule to a tree like rule r can introduce an assertion of the form R(s , t ) if r contains an atom R(x , y ) in the consequent . Since r is tree like , its antecedent contains an atom S(x , y ) or S(y , x ) for S a tree role . This atom is matched to an assertion S(s , t ) or S(t , s ) in A′ that satisfies Property ( 1 ) by induction assumption . But then , R(s , t ) also satisfies Property ( 1 ) , and so does A′′ .
An application of the Hyp rule to a tree like rule r can introduce an equality assertion of the form s ≈ t if the consequent of r contains an atom y1 ≈ y2 . But then , the antecedent of r contains either S(x , y1 ) ∧ S(x , y2 ) or S(x , y1 ) ∧ S(y2 , x ) . The following table summarizes the ways in which S(x , y1 ) ∧ S(x , y2 ) can be matched to assertions in A′ and the types of equalities that can be derived . The case for S(x , y1 ) ∧ S(y2 , x ) is symmetric , so A′′ satisfies Property ( 2 ) .
S(x , y1 ) S(u , u.τi )
S(x , y2 ) S(u , u.τj ) u.τi ≈ u.τj S(u.τi , uτiτj ) S(u.τi , u ) uτiτj ≈ u y1 ≈ y2
S(a , a.τi )
S(a , b )
S(a , b ) S(a , c ) a.τi ≈ b b ≈ c
An application of the Hyp rule to a graph regular rule r can introduce a concept assertion , a role assertion with a graph role , or an equality assertion . By Definitions 3 and 8 , each atom in the antecedent of r is either a graph , an atomic concept , or a graph role atom . Furthermore , each two variables occurring in r occur together in some atom A in the antecedent of r . Hence , A is matched to an assertion in A′ that satisfies Property ( 3 ) by induction assumption ; thus , all variables of r are matched to individuals from the same graph cluster in the inference . It is then easy to see that the resulting assertion satisfies Properties ( 2 ) and ( 3 ) .
An application of the ≥ rule can introduce an assertion of the form R(s , ti ) or R(ti , s ) . But then , ti is a tree successor of s , so A′′ satisfies If s is a graph individual , let s′ be the predecessor of s ; Property ( 1 ) . otherwise , let s′ = s . Then , s′ is a named or a tree individual for which Property ( 4 ) holds , so Property ( 4 ) holds for ti as well .
An application of the ∃G rule introduces graph assertions of the form G(u1 , . . . , ui−1 , s , ui+1 , . . . , uℓ ) , where uj are from the same graph cluster as s . Clearly , A′′ satisfies Property ( 3 ) .
26
Consider an application of the ≈ rule to an equality of the form a ≈ b.τi , u.τi ≈ u.τj , u ≈ uτiτj The following table summarizes the types of assertions that can be produced by merging :
Replacing b.τi with a in . . . produces . . .
R(b , b.τi ) R(b.τi , b ) c ≈ b.τi
Replacing u.τj with u.τi in . . .
R(u , u.τj ) R(u.τj , u ) u.τk ≈ u.τj v ≈ vτkτj
Replacing uτiτj with u in . . .
R(u.τi , uτiτj ) R(uτiτj , u.τi ) uτiτk ≈ uτiτj uτiτk ≈ u
R(b , a ) R(a , b ) c ≈ a produces . . . R(u , u.τi ) R(u.τi , u ) u.τk ≈ u.τi v ≈ vτkτi produces . . . R(u.τi , u ) R(u , u.τi ) uτiτk ≈ u u ≈ u for u = v.τk
All assertions containing a tree successor of the merged individual are removed , so A′ satisfies Property ( 1 ) . Furthermore , if the merged individual occurs in a graph assertion , an assertion with a graph role , or an equality assertion containing a graph individual , by Property ( 3 ) this assertion contains a successor of the merged individual , so it is pruned . Thus , A′′ satisfies Properties ( 2 ) and ( 3 ) . Pruning removes all the successors of some individual , so A′′ satisfies Property ( 4 ) .
Consider an application of the ≈ rule to an equality of the form u ≈ u.γj , u.γi ≈ u.γj , a ≈ b , a ≈ b.γi , a.γi ≈ bγj The following table summarizes the types of assertions that can be produced by merging in the first case :
Replacing u.γj with u in . . . produces . . . a ≈ b.γi u.γk ≈ u.γj u ≈ u.γj for b = u a ≈ b u.γk ≈ u u ≈ u
The remaining four types of equalities produce similar types of assertions . This inference prunes one individual and replaces it with another one from the same graph cluster , so A′′ satisfies Properties ( 1)–(3 ) . Pruning removes all the successors of some individual , so A′′ satisfies Property ( 4 ) .
The following lemma shows that our inference rules are sound .
Lemma 5 ( Soundness ) . Let R be an admissible set of rules and A an ABox , and let A1 , . . . , An be obtained by applying a derivation rule to R and A . If ( R , A ) is satisfiable , then ( R , Ai ) is satisfiable for some 1 ≤ i ≤ n .
27
Proof . Let I be a model of ( R , A ) , and let us consider all possible applications of derivation rules shown in Table 5 .
( Hyp rule ) Since σ(Ui ) ∈ A , we have I |= σ(Ui ) for all 1 ≤ i ≤ m . But then , n > 0 and I |= σ(Vj ) for some 1 ≤ j ≤ n . Since Aj = A ∪ {σ(Vj )} , we conclude that I |= ( R , Aj ) .
( ≥ rule ) Since ≥ n R.C(s ) ∈ A , we have I |= ≥ n R.C(s ) , which means that α1 , . . . , αn ∈ △I exist such that hsI , αii ∈ RI and αi ∈ C I for 1 ≤ i ≤ n , and αi 6= αj for 1 ≤ i < j ≤ n . Let I ′ be obtained from I by setting tI ′ i = αi . Clearly , I ′ |= ar(R , s , ti ) , I ′ |= C(ti ) , and I ′ |= ti 6≈ tj for i 6= j . Therefore , we have I ′ |= ( R , A1 ) .
( ∃G rule ) Since ∃G|i(s ) ∈ A , we have I |= ∃G|i(s ) , which means that individuals α1 , . . . αℓ ∈ △I exist such that hα1 , . . . αℓi ∈ GI and αi = s . Let I ′ be obtained from I by setting tI j = αj for 1 ≤ j ≤ ℓ and j 6= i . Clearly , I ′ |= ( R , A1 ) .
( ≈ rule ) Since s ≈ t ∈ A , we have I |= s ≈ t , so sI = tI . Pruning removes assertions , so I is a model of the pruned ABox by monotonicity . Merging simply replaces an individual with an individual that is interpreted in the same way so , clearly , I |= ( R , A1 ) .
( ⊥ rule ) Since I |= ( R , A ) , the precondition of the ⊥ rule cannot be sat isfied , so the rule cannot be applied to R and A .
The following lemma shows that our calculus is complete . Our proof adapts the well known unraveling technique [ 14 ] .
Lemma 6 ( Completeness ) . Let R be an admissible set of rules and A an initial ABox . If a derivation for R and A exists in which a leaf node is labeled with a clash free ABox A′ , then ( R , A ) is satisfiable .
, xn+1 x′ n+1
, . . . , xn x′ n
, . . . , xn x′ n n . Furthermore , let q = [ p | xn+1
Proof . To construct a model of ( R , A ) , we first introduce the following definitions . A path is a finite sequence of pairs of individuals p = [ x0 ] with x′ 0 n ≥ 0 . Let tail(p ) = xn and tail′(p ) = x′ ] be the path [ x0 ] ; we say that q is a successor of p , and p is a prex′ 0 decessor of q . Furthermore , paths p and q are from the same graph cluster if either ( i ) tail(p ) is either a named individual or a graph successor of a named individual , and tail(q ) is also either a named individual or a graph successor of a named individual , ( ii ) both tail(p ) and tail(q ) are graph individuals and p and q are successors of the same path , or ( iii ) one path , say p , is a successor of the other path q and tail(p ) is a graph individual . The set of all paths P(A′ ) is defined inductively as follows : x′ n+1
• [ a a ] ∈ P(A′ ) if a is a named individual and it occurs in A′ ;
• [ p | s′ s′ ] ∈ P(A′ ) if p ∈ P(A′ ) , and s′ is a successor of tail(p ) , it occurs in an assertion of A′ , and it is not blocked in A′ ; and
28
• [ p | s s′ ] ∈ P(A′ ) if p ∈ P(A′ ) , and s′ is a successor of tail(p ) , it occurs in an assertion of A′ , and it is directly blocked in A′ by s .
The following property , which we denote with ( * ) , follows immediately from the previous definition : for each blocking relevant concept C and each path p ∈ P(A′ ) , the individual tail(p ) is not blocked in A′ , so C(tail(p ) ) ∈ A′ if and only if C(tail′(p ) ) ∈ A′ .
Let I be the following interpretation , where A is an atomic concept , R is an atomic ( tree or graph ) role , G is a description graph with ℓ vertices , p(i ) are paths from P(A′ ) and are all from the same graph cluster , and a is a named individual .
△I = P(A′ ) aI = [ a aI = bI if named individuals a = c0 , c1 , . . . , cn = b exist such that each a ] if a occurs in A′ ci−1 was merged into ci in the derivation leading to A′
AI = {p | A(tail(p ) ) ∈ A′} RI = {hp1 , p2i | R(tail(p1 ) , tail(p2 ) ) ∈ A′} ∪
{hp , [ p | s {h[p | s s′ ]i | s′ is a successor of tail(p ) and R(tail(p ) , s′ ) ∈ A′} ∪ s′ ] , pi | s′ is a successor of tail(p ) and R(s′ , tail(p ) ) ∈ A′}
GI = {hp1 , . . . , pℓ]i | G(tail(p1 ) , . . . , tail(pℓ ) ) ∈ A′}
Since A is initial , the ABox A′ contains at least one assertion , so △I is t′ ] from not empty . We now show that , for each ps = [ qs | s △I , the following claims hold ( ** ) : s′ ] and pt = [ qt | t
• If s′ ≈ t′ ∈ A′ and qs = qt , then ps = pt : Since the ≈ rule is not ap plicable to A′ , we have s′ = t′ , which implies ps = pt .
• If s′ 6≈ t′ ∈ A′ , then ps 6= pt : Since the ⊥ rule is not applicable to s′ 6≈ t′ , we have s′ 6= t′ , which implies ps 6= pt .
• If A(s′ ) ∈ A′ , then ps ∈ AI : By ( * ) , we have A(s ) ∈ A′ , so ps ∈ AI .
• If ¬A(s′ ) ∈ A′ , then ps 6∈ AI . Since the ⊥ rule is not applicable to ¬A(s′ ) , we have A(s′ ) 6∈ A′ . By ( * ) , this implies A(s ) 6∈ A′ , so ps 6∈ AI .
• If ≥ n R.C(s′ ) ∈ A′ , then ps ∈ ( ≥ n R.C)I : Note first that R is a tree role , since only such roles can occur in concepts of the form ≥ n RC By ( * ) , ≥ n R.C(s ) ∈ A′ and s is not blocked . The ≥ rule is not applicable to ≥ n R.C(s ) , so individuals u1 , . . . , un exist such that ar(R , s , ui ) ∈ A′ and C(ui ) ∈ A′ for 1 ≤ i ≤ n , and ui 6≈ uj ∈ A′ for 1 ≤ i < j ≤ n . By property ( 1 ) of Lemma 4 , the following possibilities exist for each ui :
29
– ui can be a successor of s . If ui is directly blocked by u′ i , then let pui = [ ps | u′ i ui
] ; otherwise , let pui = [ ps | ui ui
] .
– ui can be a predecessor of s . Let pui = qs . If tail′(pui ) 6= ui , this is because s′ is blocked , but then , by the conditions of blocking , C(tail′(pui ) ) ∈ A′ and ar(R , s′ , tail′(pui ) ) ∈ A′ .
– ui can be neither a predecessor nor a successor of s . Then , both s and ui are named individuals , so let pui = [ ui ui
] .
In all cases ar(R , s′ , tail′(pui ) ) ∈ A′ , which implies hps , puii ∈ RI , and C(tail′(pui ) ) ∈ A′ , which implies pui ∈ C I . Consider now each pair of paths pui and puj with i 6= j . If tail′(pui ) 6≈ tail′(puj ) ∈ A′ , then clearly pui 6= puj . If tail′(pui ) 6≈ tail′(puj ) /∈ A′ , this is because tail′(pui ) 6= ui , which is possible only if s′ is directly blocked by s and ui is a predecessor of s . Since s can have at most one predecessor , no uj with j 6= i is a predecessor of s , so pui 6= puj . Thus , ps ∈ ( ≥ n R.C)I .
• If ∃G|i(s′ ) ∈ A′ , then ps ∈ ( ∃G|i)I : By ( * ) , ∃G|i(s ) ∈ A′ and s is not blocked . The ∃G rule is not applicable to ∃G|i(s ) , so individuals uj exist such that G(u1 , . . . , ui−1 , s , ui+1 , . . . , uℓ ) ∈ A′ . By Lemma 4 , all uj are from the same graph cluster as s . If s is a graph individual , since it is not blocked , its tree predecessor is not blocked either ; otherwise , s is a nonblocked predecessor of all uj . Either way , none of the individuals uj are blocked . But then , by the definition of I , we have huI
ℓ i ∈ ( ∃G|i)I , so ps ∈ ( ∃G|i)I .
1 , . . . , uI
Property ( ** ) implies that I |= α′ for each assertion α′ ∈ A′ that contains only named individuals . Consider now each assertion α ∈ A . If α 6∈ A′ , then some named individuals in α were merged into other individuals ; but then , A′ contains the assertion α′ obtained by this merging , so I |= α by the definition of I . Hence , I |= A , and it remains to be shown that I |= R .
Consider first each tree like rule r ∈ Rt and each mapping µ of variables of r to objects of △I . By Definition 10 , the rule is of the following form , where Ri and Si are ( not necessarily atomic ) tree roles .
V Ai(x ) ∧V ar(Ri , x , yi ) ∧V Bi(yi ) →
W Ci(x ) ∨W Di(yi ) ∨W ar(Si , x , yi ) ∨W yi ≈ yj
Let px = µ(x ) , pyi = µ(yi ) , and s′ = tail′(px ) . Assume now that each atom from the antecedent of r is true in I and µ—that is , px ∈ AI i , and hpx , pyii ∈ RI i . i , pyi ∈ BI
If s′ is not blocked , let s = s′ and ti = tail′(pyi ) . By the definition of I , we have Ai(s ) ∈ A′ , Bi(ti ) ∈ A′ , and ar(Ri , s , ti ) ∈ A′ .
If s′ is blocked , let s = tail(px ) ; that is , s is the individual that blocks i , we have Ai(s ) ∈ A′ . If tail′(pyi ) s′ . By the definition of I , since px ∈ AI
30 is a successor of s , let ti = tail′(pyi ) ; now pyi ∈ BI i imply Bi(ti ) ∈ A′ and ar(Ri , s , ti ) ∈ A′ . If tail′(pyi ) is not a successor of s , let ti be the predecessor of s ; this predecessor exists by the definition of blocki imply Bi(tail′(pyi ) ) ∈ A′ and ing . Furthermore , pyi ∈ BI ar(Ri , s′ , tail′(pyi ) ) ∈ A′ ; by the definition of blocking , we have Bi(ti ) ∈ A′ and ar(Ri , s , ti ) ∈ A′ as well . i and hpx , pyii ∈ RI i and hpx , pyii ∈ RI
Let σ be a mapping such that σ(x ) = s and σ(yi ) = ti . The Hyprule is not applicable to r and A′ , so some of the atoms from the consequent of σ(r ) are present in A′ . Assume first that Ci(s ) ∈ A′ , Di(ti ) ∈ A′ , or ar(Si , s , ti ) ∈ A′ . By the definition of blocking , then Ci(tail′(px ) ) ∈ A′ , Di(tail′(pyi ) ) ∈ A′ , or ar(Si , tail′(px ) , tail′(pyi ) ) ∈ A′ , respectively ; by ( ** ) , this implies px ∈ C I i ,respectively , so I , µ |= r . Assume now that ti ≈ tj ∈ A′ . If pyi and pyj are both predecessors of px , then pyi = pyj so I , µ |= r . If pyi is a predecessor and pyj is a successor of px , then tail′(pyj ) = tj ; furthermore , since ti is not blocked , tail′(pyj ) 6= ti , which contradicts the assumption that ti = tj . Finally , if both pyi and pyj are successors of px , then pyi = pyj by ( ** ) , so I , µ |= r . i , or hpx , pyi ∈ SI i , pyi ∈ DI
Consider now r ∈ Rg to be a graph regular rule of the form
A1 ∧ . . . ∧ An → B1 ∨ . . . ∨ Bm and let µ be a variable mapping such that I , µ |= Ai for 1 ≤ i ≤ n . For each variable x , let px = µ(x ) and σ(x ) = tail(px ) . By the definition of I , none of σ(x ) is blocked , so σ(Ai ) ∈ A′ . Since the Hyp rule is not applicable to r and A′ , we have σ(Bj ) ∈ A′ for some 1 ≤ j ≤ m . But then , by the definition of I , we have I , µ |= Bj , so I , µ |= r .
We next prove that our calculus terminates . Using the standard argument , we show that each tree individual can have exponentially many tree predecessors . Thus , the only thing that might prevent the calculus from terminating is a situation described after Definition 4 : the calculus might create infinitely many instances of G . The ∃G rule , however , is applied with the lowest priority . Thus , if we instantiate G twice , before any further application of the ∃G rule , either the rules from item 1 of Definition 9 will have merged these two instances of G , or the rules from item 2 of Definition 9 will have detected a clash . Thus , these rules and the rule priority guarantee that we never have more than two instances of G in the same graph cluster , which can be used to prove termination .
Lemma 7 ( Termination ) . Let R be an admissible set of rules and A an initial ABox . Then , each derivation for R and A is finite .
Proof . We prove the claim by showing that ( i ) each individual can cause only a limited number of rule applications and ( ii ) the number of new individuals introduced on each path of a derivation is finite .
31
We first prove ( i)—that is , that each derivation rule can be applied a limited number of times to a fixed set of individuals on every path of every derivation . Observe that the supply of individuals is infinite ; hence , if an individual s is pruned in some ABox in the derivation , we can assume that s is not introduced later in the derivation . We now show that ( i ) holds for each derivation rule .
• An application of the Hyp rule to a rule r ∈ R and a mapping σ introduces an assertion σ(Vi ) for some atom Vi from the consequent of r , which prevents repeated application of the Hyp rule to the same r and σ . Merging and pruning can remove σ(Vi ) in subsequent derivation steps , but this would also remove some individual in σ , thus preventing the use of the same σ in future .
• An application of the ≥ rule to ≥ n R.C(s ) extends the ABox with assertions C(t1 ) , . . . , C(tn ) , ar(R , s , t1 ) , . . . , ar(R , s , tn ) , and ti 6≈ tj for 1 ≤ i < j ≤ n . Thus , the individuals u1 , . . . , un from the precondition of the ≥ rule can be matched to t1 , . . . , tn , which prevents future applications of the ≥ rule to ≥ n RC(s ) If some tj is merged into an individual v , then the assertions C(v ) , ar(R , s , v ) , and v 6≈ tk are added to the ABox , so s retains a set of a neighbors which prevents subsequent application of the ≥ rule to ≥ n RC(s )
• An application of the ∃G rule to ∃G|i(s ) extends the ABox with an assertion G(t1 , . . . , ti−1 , s , ti+1 , . . . , tℓ ) . Thus , the individuals uj from the precondition of the the ∃G rule can be matched to tj , which prevents future applications of the ∃G rule to ∃G|i(s ) . If some tj is merged into an individual v , then the appropriate graph assertion is added to the ABox that prevents subsequent application of the ∃G rule to ∃G|i(s ) .
• The ≈ rule is never applied twice to the same assertion s ≈ t since either s or t is removed from the ABox .
• If the ⊥ rule is applied , then the resulting ABox labels a leaf of the derivation .
Next we prove ( ii)—that is , that the total number of individuals intro duced on a derivation path is finite .
Let c be the number of concepts and r the number of atomic roles that occur in R and A . For an individual s and its predecessor t , the number of different labels LA(s ) and LA(t ) is 2c , and the number of different labels LA(s , t ) and LA(t , s ) is 2r . Hence , if there are more than δ = 22c+2r + 1 such pairs of individuals , at least two pairs have the same labels ; we denote this observation with ( * ) . By Lemma 4 , each tree individual u has a link to root of some length n . Since the ordering ≺ used in the definition of blocking contains the predecessor relationship and because of ( * ) , u is blocked if
32 n = δ . Since ≥ and ∃G rules are not applied to blocked individuals , each individual u in A′ has at most δ tree predecessors ; since each tree individual has at most one graph predecessor , u can have at most 2δ predecessors . Furthermore , the number of the applications of the ≥ rule to each individual with k predecessors is bounded by ( i ) , which limits the overall number of tree individuals with k + 1 predecessors introduced in a derivation .
1 , . . . , t′
ℓ ) such that ti = t′
To complete the proof , we show that , for each tree individual s , the number of graph individuals occurring in A′ that are from the same graph cluster as s is bounded . The set of rules R is admissible , so it contains all the rules from items 1 and 2 of Definition 9 . Furthermore , the Hyp , ⊥ , and ≈ rules are applied with higher priority than the ∃G rule . Therefore , whenever an ABox A′ in a derivation contains graph assertions G(t1 , . . . , tℓ ) and G(t′ j , the applications of the Hyp , ⊥ , and ≈ rule will either derive ⊥ or will merge one graph assertion into the other . Thus , whenever the ∃G rule is applicable to some assertion ∃G|i(t ) with t from the same graph cluster as s , the ABox A′ contains at most one instance of G containing t . The ∃G rule can be applied to each of the vertices in that instance , so the number of graph individuals from the same graph cluster as s is at most ℓ2 . Similar reasoning applies if s is a named individual . But then , exactly as in the previous paragraph , we conclude that the total number of graph individuals is bounded .
The total number of individuals introduced in a derivation is bounded , and the number of applications of derivation rules to each individual is bounded as well , which gives us a bound on the maximum length in a derivation . Since each derivation is finitely branching , it is finite as well .
The following theorem follows immediately from Lemmas 1 , 2 , 3 , 5 , 6 , and 7 .
Theorem 1 . Let K = ( T , G , P , A ) be a graph extended DL knowledge base where T is a SHIQ TBox and A is an initial ABox ; furthermore , let R = Ξ(T ) ∪ Ξ(G ) ∪ P .
• If K is satisfiable , then each derivation for R and A is clash free .
• If a clash free derivation for R and A exists , then K is satisfiable .
• Each derivation for R and A is finite .
6 Transforming OWL Ontologies into Graphs
The evaluation of the adequacy of our approach is rather difficult due to lack of adequate test data . Furthermore , remodeling existing ontologies using a new modeling paradigm may require considerable effort . In order to both obtain test data for our reasoner and make the adoption of our approach in
33 practice easier , we have developed an algorithm that automatically transforms a TBox T into a graph extended knowledge base K . For example , our algorithm can automatically construct the graph shown in Figure 1 from the axioms such as ( 2)–(4 ) . Clearly , the resulting graph extended knowledge base can only be taken as a rough approximation ; however , it can be used as a starting point for a more comprehensive remodeling of T into a proper graph extended knowledge base . We applied our algorithm to GALEN and FMA , and domain experts have assured us that the resulting description graph correctly reflects many aspects of human anatomy .
In Section 6.1 we describe the intuition behind our algorithm and present the algorithm ’s pseudo code . Then , in Section 6.2 we discuss the results we got by applying the algorithm to GALEN and FMA .
6.1 The Transformation Algorithm
Our transformation of a TBox T1 into a graph extended knowledge base K = ( T , G , P , A ) is based on two assumptions .
The first assumption is that only some concepts and roles from T1 are relevant for G . For example , the Heart concept is clearly relevant to the description graph of human anatomy ; in contrast , the Disease concept is not relevant because it does not represent the structure of a human body . Similarly , the hasStructuralComponent role clearly belongs to the graph , while the hasAge role does not .
Our second assumption is that each concept relevant to G should be represented by one vertex in G , and that edges in G can be decoded from axioms of the form A ⊑ ∃RB Our assumption is that , by writing axioms such as ( 2)–(4 ) , modelers actually wanted to say “ the aortic valve has an alpha connection to the left ventricle , and the left side of heart has the same left ventricle as a solid division . ”
We use these two assumptions in the core part of our algorithm , which is parameterized with a DL TBox T1 , a set of relevant concepts NCg , and a set of relevant roles NRg . The latter set actually defines the set of graph roles , and all other roles are considered to be tree roles . Our algorithm first computes ∆(T1 ) and thus normalizes the input TBox ; as in Section 5 , this has the benefit of making all negations explicit . Then , the algorothm creates a vertex i in V for each concept A ∈ NCg and sets λhii = {A} . Then , it processes each axiom α ∈ T1 as follows :
• If α is of the form A ⊑ ∃R.B where {A , B} ⊆ NCg and R ∈ NRg , then , for i and j vertices such that λhii = {A} and λhji = {B} , the algorithm adds the edge hi , ji to E and extends λ such that R ∈ λhi , ji .
• If α does not contain a role from NRg , the algorithm simply copies α to the resulting TBox T .
34
• If α contains only roles from NRg and no existential quantifier , the algorithm translates α into a graph regular rule and adds it to P .
• If α is not of the above form , then either it involves a graph and a tree role simultaneously , or it is of the form A ⊑ ∃R.B but some of A , B , or R are not relevant for the graph . Such an axiom either invalidates the syntactic restrictions of our formalism or it does not have a natural interpretation ; hence , our algorithm simply ignores such an axiom α .
Our translation cannot correctly handle axioms of the form A ⊑ ≥ n R.B with n ≥ 2 . Intuitively , such axioms might be handled by creating n vertices in G , labeling all of them with B , and then connecting the vertex of A with all the vertices of B using the role R . The situation , however , is not so simple if , in addition , we also have the axiom B ⊑ ≥ m RA It is now not clear which vertices of the description graph labeled with A to “ reuse ” to satisfy this axiom . Therefore , we decided to ignore such axioms . This is partly justified by the fact that GALEN and FMA—our main sources of inspiration and test data—do not contain ≥ n R.B concepts with n ≥ 2 . In human anatomy , different objects of the domain are naturally given different names . For example , instead of an axiom
Heart ⊑ ≥ 2 hasStructuralComponent .SideOfHeart ,
( 20 )
GALEN introduces explicit names for the left and the right side of the heart :
Heart ⊑ ∃hasStructuralComponent .LeftSideOfHeart Heart ⊑ ∃hasStructuralComponent .RightSideOfHeart
( 21 )
( 22 )
On ontologies with at least restrictions , our algorithm simply treats each ≥ n R.B as ∃RB It is natural to use number restrictions for modeling symmetric organs such as the kidney . On such an ontology , our algorithm produces a description graph containing just one copy of the object , and the graph can then be corrected by the modeler .
Determining the sets NCg and NRg manually is not easy . According to our experience with GALEN and FMA , a good strategy is to manually identify a set of roles N ′ Rg that naturally belong to the graph , and then to take NRg as the closure of N ′ Rg wrt the explicit role inclusions from T1 . Then , we take NCg as the set of all concepts A and B occurring in an axiom A ⊑ ∃R.B ∈ T1 such that R ∈ NRg . Intuitively , if A and B are connected by a role that should be included into the graph , then it is likely that A and B should be included into the graph as well .
This idea , however , requires some refinement . For example , GALEN contains the following axioms :
LeftVentricle ⊑ Ventricle
( 23 )
35
RightVentricle ⊑ Ventricle
( 24 )
Let us assume that NCg contains the concepts Ventricle , LeftVentricle , and RightVentricle . The core transformation then generates a description graph G containing three different vertices , each labeled with one of these concepts . It is , however , counterintuitive for G to contain a Ventricle vertex : no ventricle as such exists on its own ; rather , each concrete ventricle is either the left of the right ventricle . In fact , such a description graph G is unsatisfiable . Assume that an object x as instance of LeftVentricle ; due to ( 23 ) , x is also an instance of Ventricle . To satisfy the A start property for LeftVentricle , x must correspond to the i th vertex of some instance of G ; similarly , to satisfy the A start property for Ventricle , x must also correspond to the j th vertex of some instance of G . Finally , because LeftVentricle and Ventricle label different vertices of G , we have i 6= j , which then invalidates the disjointness property of Definition 4 . The concept Ventricle is thus an abstract concept : it is not meant to be instantiated directly , but only through a subclass . Such concepts clearly do not belong into a description graph . Hence , after computing NCg as described in the previous paragraph , our algorithm classifies the input TBox T1 using standard DL reasoning ; then , it removes from NCg all concepts that are not leaves in the resulting classification . Intuitively , if A is not a leaf concept in the classification of T1 , then A is likely to be an abstract concept , so it should not be added to G .
The pseudo code of the transformation is shown in Algorithm 1 . The algorithm is given a DL TBox T1 and a set of graph roles N ′ Rg . For the same reasons as in Section 5 , the algorithm first normalizes the input TBox axioms ( line 2 ) . Then , it closes the set N ′ Rg according to the explicitly specified role inclusion relationships in T1 ( line 3 ) . Next , it computes the set NCg as outlined in the previous paragraphs ( lines 4–9 ) . The main part of the algorithm then processes all the TBox axioms as explained previously ( lines 10–27 ) . Finally , the algorithm outputs the resulting graph extended knowledge base K ( line 28 ) . The transformation tool implementing this algorithm can be downloaded from HermiT ’s Web page .
6.2 Applying the Transformation to GALEN and FMA
We applied the algorithm from Section 6.1 to the original version of GALEN ; furthermore , FMA is a very large ontology , so we have applied our algorithm to a fragment of FMA that describes the heart . Both ontologies can be downloaded from HermiT ’s Web page . Table 6 summarizes information about the original and the transformed ontologies .
Our transformation clearly leads to a change in the semantics of the ontology , and some information is lost in the process . Many parts of the resulting description graph , however , correspond with the intuitive descrip
36
Algorithm 1 The Transformation Algorithm 1 : procedure ToGraphExtendedKB(T1 , N ′ 2 :
Rg )
T ′ ← ∆(T1 ) NRg ← {S | ∃R ∈ N ′ NCg ← ∅ for each ⊤ ⊑ ¬A ⊔ ∃R.B ∈ T ′ where R ∈ NRg do
Rg such that S ⊑∗ T1
R}
⊲ Normalize T1
3 :
4 : 5 :
6 :
7 :
8 :
9 :
10 :
11 :
12 :
13 :
14 :
15 : 16 :
17 :
18 :
19 :
20 :
21 :
22 :
23 :
24 :
25 :
26 : 27 :
NCg ← {A , B} end for compute the subsumption hierarchy H(T1 ) remove from NCg all nonleaf concepts from H(T1 ) V ← ∅ , E ← ∅ , for each α ∈ T ′ do
T ← ∅ , P ← ∅
λ ← ∅ , if α = ⊤ ⊑ ¬A ⊔ ∃R.B with {A , B} ⊆ NCg and R ∈ NRg then let i be the vertex of V such that A ∈ λhii if no such i exists then i ← 1 + |V | ,
V ← V ∪ {i} ,
λhii ← {A} end if let j be the vertex of V such that B ∈ λhji if no such j exists then j ← 1 + |V | ,
V ← V ∪ {j} ,
λhji ← {B} end if E ← E ∪ {hi , ji} ,
λhi , ji ← λhi , ji ∪ {R} else if α does not contain a role from NRg then
T ← T ∪ {α} else if α contains only roles from NRg and no ∃R.B then
P ← P ∪ Ξ(α ) end if end for return K = ( T , G = ( V , E ) , P , ∅ )
28 : 29 : end procedure tions of the anatomy of the body . For example , the graph shown in Figure 1 has been extracted from the transformed ontology .
7 Evaluation and Discussion
To evaluate our approach , we have classified the original ontologies using HermiT , transformed them using the algorithm from Section 6 into graphextended KBs , and classified the resulting KBs using the reasoning algorithm presented in Section 5 . We now present the performance results and discuss the classification results .
37
Table 6 : Information about Test Ontologies
Total number of concepts : Total number of roles : Total number of GCIs : GCIs discarded in the transformation : With both a tree and a graph role : With existentials on abstract concepts :
Translated GCIs :
Into the description graph : Into rules over the graph : Into the DL TBox :
With existentials on tree roles : With universals on tree roles : Involving concept names only :
Vertices in the description graph : Edges in the description graph :
GALEN FMA 430 38 3479 328 0 328 3151 2966 1 184 16 0 168 342 1076
2748 413 6962 320 74 246 6642 680 155 5807 1741 952 3114 325 667
7.1 Performance Results
We performed the experiments using a standard laptop with 1 GB of RAM . The classification of the original version of GALEN and the fragment of FMA took 129 s and 57 s , respectively ; furthermore , the classification of the transformed ontologies took 781 s and 6 s , respectively .
The increase in the classification time for GALEN is partly due to the fact that our implementation of the reasoning algorithm in Section 5 is still very prototypical . In the case of FMA , the classification times are substantially lower because most of the original ontology is translated into the graph , so the generated models are much smaller .
Our performance results show that , even with a very prototypical implementation , we can process complex ontologies , which we take as indication that our approach is practically feasible .
7.2 Changes in the Semantics
The transformed ontologies are more constrained than the original ones , so we expect to obtain new entailments .
In the case of GALEN , we discovered a concept that is satisfiable in the original version of the ontology , but is unsatisfiable in the transformed ontology , which revealed a modeling error in GALEN . The problem occurs in the representation of the patella—a bone that is connected to certain ten
38 dons through two retinacula ; the retinacula are represented using the concepts LateralPatellaRetinaculum and MedialPatellaRetinaculum . GALEN describes the relationship between the patella and the retinacula as follows :
LateralPatellaRetinaculum ≡ ∃hasOtherEndAt .Patella ⊓ ( . . . ) MedialPatellaRetinaculum ≡ ∃hasOtherEndAt .Patella ⊓ ( . . . ) hasOtherEndAt ≡ isAtOtherEndOf −
⊤ ⊑ ≤ 1 isAtOtherEndOf
( 25 )
( 26 )
( 27 )
( 28 )
According to these axioms , each patella has both the lateral and the medial retinacula , but due to functionality of isAtOtherEndOf , the two must be the same objects . Intuitively , this is an undesirable consequence , since the two retunaculae are in reality different objects ; in other words , isAtOtherEndOf should probably not have been declared functional . Since GALEN is underconstrained , this does not cause inconsistency of either concept , so this error has not been detected so far . The description graph produced by our transformation , however , contains one node for the patella and one for each retinaculum ; furthermore , both retinacula are connected through isAtOtherEndOf to the same patella . Since isAtOtherEndOf is functional , the retinacula should be the same , which invalidates the disjointness property for the graph ( see Definition 4 ) and makes Patella unsatisfiable .
In the case of FMA , we did not obtain any new subsumption relationships . This is due to the fact that most of the subsumption relationships in FMA are represented explicitly as axioms of the form A ⊑ B where A and B are atomic concepts . For example , the fact that the heart is an organ is represented explicitly with the axiom Heart ⊑ Organ , and it is not derived from the structure of the heart ; clearly , such inferences are performed in the same way on both tree like and nontree structures .
As explained in Section 6 , our algorithm discards some axioms from the ontology . We compared the class hierarchies of the original and the graphextended versions of GALEN . In total , 361 subsumption relationships were lost , such as Femur ⊑ BodySpace ( the femur is a body space ) , and
InteratrialSeptum ⊑ TwoAndAHalfDimensionalStructure
( the interatrial septum of the heart is a structure with two and a half dimensions ) . All these entailments involve an abstract concept , so their loss is not surprising since the transformation algorithm discards GCIs that involve an abstract concept and an existential on a graph role . No information about concrete concepts has been lost , though .
In contrast , in the case of FMA we did not lose any subsumption relationships . As explained before , the reason is that the structural information in FMA largely does not influence subsumption .
39
7.3 Discussion
Our experience with GALEN and the discussions we had with the authors of GALEN lead us to conclude that our formalism represents the anatomical structures in the human body in a way that is closer to the modelers’ intention than the original OWL axioms.5 The fact that we found a modeling error in GALEN leads us to believe that our formalism and its semantics are based on “ reasonable ” assumptions .
Furthermore , capturing the semantics of abstract concepts and axioms involving them properly is likely to be the most important open problem . We briefly discuss possibilities for addressing it . Consider the following axiom in GALEN that is eliminated by the transformation algorithm because both AtrioventricularValve and Ventricle are abstract concepts :
AtrioventricularValve ⊑ ∃hasAlphaConnection .Ventricle
( 29 )
Since both concepts in ( 29 ) are abstract , this axiom does not say anything about the structure of the concrete objects ( ie , the objects that are likely to be included into a description graph ) . Thus , one might expect the actual relationship between valves and ventricles to be described for the concrete subclasses of AtrioventricularValve and Ventricle . Axiom ( 29 ) can then be interpreted as a check which makes sure that this abstract relationship is concretized at a lower level . In [ 18 ] , a formalism has been presented that might be useful for this purpose . Another possibility is to interpret Ventricle disjunctively over its subclasses : each valve is connected to either left or the right ventricle , but we do not know which . Currently , it is not clear which interpretation is appropriate ; in fact , the proper interpretation of abstract concepts is made more difficult by the fact that whether a concept is abstract or concrete depends on the level of granularity .
8 Conclusion
We have extended OWL with description graphs , which can be used to describe structured objects—that is , objects consisting of parts connected in a complex , arbitrary way . We also allow for arbitrary SWRL like rules over description graphs . Unlike most existing combinations of DLs and rules in which rules can be used only for query answering [ 16 , 20 , 23 , 8 , 19 ] , our rules also fully participate in schema reasoning . Based on an observation that many structured objects exhibit a natural bound on their size , we derived a hypertableau reasoning algorithm for our formalism , which we implemented in the HermiT reasoner . To obtain suitable test data , we extracted description graphs out of GALEN and FMA medical terminologies . We successfully classified the resulting ontologies and even detected a modeling error .
5Thanks to Alan Rector and Sebastian Brandt .
40
We see three open problems for future research . First , graph extended KBs should provide for several and not just one description graph , as this would allow breaking up a large graph into several more manageable parts . The main challenge is to identify an appropriate paradigm for specifying relationships between different description graphs . Second , an adequate semantics for modeling abstract concepts at different levels of granularity is needed . Third , to allow for a wider users’ community , ontology editors such as Prot´eg´e should be extended with description graphs .
Acknowledgments
We than Alan Rector and Sebastian Brandt for providing us with invaluable comments from the users’ perspective .
References
[ 1 ] A . Artale , E . Franconi , N . Guarino , and L . Pazzi . Part whole relations in object centered systems : An overview . Data Knowledge & Engineering , 20(3):347–383 , 1996 .
[ 2 ] F . Baader , D . Calvanese , D . McGuinness , D . Nardi , and P . F . PatelSchneider , editors . The Description Logic Handbook : Theory , Implementation and Applications . Cambridge University Press , 2nd edition , August 2007 .
[ 3 ] F . Baader , C . Lutz , H . Sturm , and F . Wolter . Fusions of Description Logics and Abstract Description Systems . Journal of Artificial Intelligence Research , 16:1–58 , 2002 .
[ 4 ] D . Calvanese , G . De Giacomo , and M . Lenzerini . Structured Objects : Modeling and Reasoning . In T . W . Ling , A . O . Mendelzon , and L . Vieille , editors , Proc . of the 4th Int . Conf . on Deductive and Object Oriented Databases ( DOOD ’95 ) , volume 1013 of LNCS , pages 229–246 , Singapore , December 4–7 1995 . Springer .
[ 5 ] D . Calvanese , G . De Giacomo , and M . Lenzerini . On the Decidability of Query Containment under Constraints . In Proc . of the 17th ACM SIGACT SIGMOD SIGART Symposium on Principles of Database Systems ( PODS ’98 ) , pages 149–158 , Seattle , WA , USA , June 1–3 1998 . ACM Press .
[ 6 ] S . Derriere , A . Richard , and A . Preite Martinez . An Ontology of Astronomical Object Types for the Virtual Observatory . In Proc . of the 26th meeting of the IAU : Virtual Observatory in Action : New Science ,
41
New Technology , and Next Generation Facilities , pages 17–18 , Prague , Czech Republic , August 21–22 2006 .
[ 7 ] F . M . Donini , M . Lenzerini , D . Nardi , and A . Schaerf . AL log : Integrating Datalog and Description Logics . Journal of Intelligent Information Systems , 10(3):227–252 , 1998 .
[ 8 ] T . Eiter , T . Lukasiewicz , R . Schindlauer , and H . Tompits . Combining Answer Set Programming with Description Logics for the Semantic Web . In D . Dubois , C . A . Welty , and M A Williams , editors , Proc . of the 9th Int . Conf . on the Principles of Knowledge Representation and Reasoning ( KR 2004 ) , pages 141–151 , Whistler , Canada , June 2–5 , 2004 2004 . AAAI Press .
[ 9 ] C . Golbreich , S . Zhang , and O . Bodenreider . The Foundational Model of Anatomy in OWL : Experience and Perspectives . Journal of Web Semantics , 4(3):181–195 , 2006 .
[ 10 ] J . Goodwin . Experiences of using OWL at the Ordnance Survey . In Proc . of the OWL : Expreiences and Directions Workshop ( OWLED 2005 ) , volume 188 of CEUR WS Proceedings , Galway , Ireland , November 11–12 2005 .
[ 11 ] F . W . Hartel , S . de Coronado , R . Dionne , G . Fragoso , and J . Golbeck . Modeling a description logic vocabulary for cancer research . Journal of Biomedical Informatics , 38(2):114–129 , 2005 .
[ 12 ] I . Horrocks and P . F . Patel Schneider . A Proposal for an OWL Rules Language . In Proc . of the 13th Int . World Wide Web Conference ( WWW 2004 ) , pages 723–731 , New York , NY , USA , May 17–22 2004 . ACM Press .
[ 13 ] I . Horrocks and U . Sattler . A Tableaux Decision Procedure for SHOIQ . In Proc . of the 19th Int . Joint Conf . on Artificial Intelligence ( IJCAI 2005 ) , pages 448–453 , Edinburgh , UK , July 30–August 5 2005 . Morgan Kaufmann Publishers .
[ 14 ] I . Horrocks , U . Sattler , and S . Tobies . Practical Reasoning for Very Expressive Description Logics . Logic Journal of the IGPL , 8(3):239– 263 , 2000 .
[ 15 ] O . Kutz , I . Horrocks , and U . Sattler . The Even More Irresistible SROIQ . In P . Doherty , J . Mylopoulos , and C . A . Welty , editors , Proc . of the 10th Int . Conf . on the Principles of Knowledge Representation and Reasoning ( KR 2006 ) , pages 68–78 , Lake District , UK , June 2–5 2006 . AAAI Press .
42
[ 16 ] A . Y . Levy and M C Rousset . Combining Horn Rules and Description
Logics in CARIN . Artificial Intelligence , 104(1–2):165–209 , 1998 .
[ 17 ] B . Motik . Reasoning in Description Logics using Resolution and Deductive Databases . PhD thesis , Univesit¨at Karlsruhe , Germany , 2006 .
[ 18 ] B . Motik , I . Horrocks , and U . Sattler . Bridging the Gap Between OWL and Relational Databases . In Proc . of the 16th International World Wide Web Conference ( WWW 2007 ) , pages 807–816 , Banff , AB , Canada , May 8–12 2007 . ACM Press .
[ 19 ] B . Motik and R . Rosati . A Faithful Integration of Description Logics with Logic Programming . In Proc . of the 20th Int . Joint Conf . on Artificial Intelligence ( IJCAI 2007 ) , pages 477–482 , Hyderabad , India , January 6–12 2007 . Morgan Kaufmann Publishers .
[ 20 ] B . Motik , U . Sattler , and R . Studer . Query Answering for OWL DL with Rules . Journal of Web Semantics , 3(1):41–60 , 2005 .
[ 21 ] B . Motik , R . Shearer , and I . Horrocks . Optimized Reasoning in Description Logics using Hypertableaux . In F . Pfenning , editor , Proc . of the 21st Conference on Automated Deduction ( CADE 21 ) , volume 4603 of LNAI , pages 67–83 , Bremen , Germany , July 17–20 2007 . Springer .
[ 22 ] D . A . Plaisted and S . Greenbaum . A Structure Preserving Clause Form Translation . Journal of Symbolic Logic and Computation , 2(3):293–304 , 1986 .
[ 23 ] R . Rosati . DL + log : A Tight Integration of Description Logics and Disjunctive Datalog . In P . Doherty , J . Mylopoulos , and C . A . Welty , editors , Proc . of the 10th Int . Conf . on the Principles of Knowledge Representation and Reasoning ( KR 2006 ) , pages 68–78 , Lake District , UK , June 2–5 2006 . AAAI Press .
[ 24 ] C . Rosse and J . V . L . Mejino . A reference ontology for biomedical informatics : the Foundational Model of Anatomy . Journal of Biomedical Informatics , 36:478–500 , 2003 .
[ 25 ] R . A . Schmidt and U . Hustadt . A Principle for Incorporating Axioms into the First Order Translation of Modal Formulae . In F . Baader , editor , Proc . of the 19th Int . Conf . on Automated Deduction ( CADE19 ) , volume 2741 of LNAI , pages 412–426 , Miami Beach , FL , USA , July 28–August 2 2003 . Springer .
[ 26 ] J . Seidenberg and A . L . Rector . Representing Transitive Propagation in OWL . In D . W . Embley , A . Oliv´e , and S . Ram , editors , Proc . of the 25th Int . Conf . on Conceptual Modeling ( ER 2006 ) , volume 4215 of LNCS , pages 255–266 , Tucson , AZ , USA , November 6–9 2006 . Springer .
43
[ 27 ] A . Sidhu , T . Dillon , E . Chang , and B . Singh Sidhu . Protein Ontology Development using OWL . In Proc . of the OWL : Expreiences and Directions Workshop ( OWLED 2005 ) , volume 188 of CEUR WS Proceedings , Galway , Ireland , November 11–12 2005 .
[ 28 ] D . Soergel , B . Lauser , A . Liang , F . Fisseha , J . Keizer , and S . Katz . Reengineering Thesauri for New Applications : The AGROVOC Example . Journal of Digital Information , 4(4 ) , 2004 .
[ 29 ] WD Solomon , A . Roberts , J . E . Rogers , C . J . Wroe CJ , and A . L . Rector . Having our cake and eating it too : How the GALEN Intermediate Representation reconciles internal complexity with users’ requirements for appropriateness and simplicity . In Proc . of the Annual Fall Symposium of American Medical Informatics Association , pages 819–823 , Los Angeles , CA , USA , November 4–8 2000 .
[ 30 ] K . A Spackman . SNOMED RT and SNOMEDCT . Promise of an in ternational clinical terminology . MD Computing , 17(6):29 , 2000 .
[ 31 ] S . Tobies . Complexity Results and Practical Algorithms for Logics in Knowledge Representation . PhD thesis , RWTH Aachen , Germany , 2001 .
[ 32 ] M . Y . Vardi . Why Is Modal Logic So Robustly Decidable ? In N . Immerman and P . Kolaitis , editors , Proc . of a DIMACS Workshop on Descriptive Complexity and Finite Models , volume 31 of DIMACS Series in Discrete Mathematics and Theoretical Computer Science , pages 149–184 , Princeton University , USA , January 14–17 1996 . American Mathematical Society .
44
