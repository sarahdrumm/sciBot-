DoCoMo USA Labs Technical Report DCL TR 2007 0035
Better Abstractions for Secure Server Side Scripting
Dachuan Yu
Ajay Chander
Hiroshi Inamura
Igor Serikov
DoCoMo Communications Laboratories USA
{yu,chander,inamura,iserikov}@docomolabs usa.com
Abstract It is notoriously difficult to program a solid web application . Besides addressing web interactions , state maintenance , and whimsical user navigation behaviors , programmers must also avoid a minefield of security vulnerabilities . The problem is fundamentally twofold . On the one hand , we lack a clear understanding of the essence of the new computation model underlying web applications . On the other hand , we lack proper abstractions for hiding common and subtle coding details that are orthogonal to the business functionalities of specific web applications .
This report addresses both issues . First , we present a high level language BASS for declarative server side scripting . BASS allows programmers to work in an ideal world , using some new abstractions to tackle common but problematic aspects of web programming . The meta properties of BASS provide useful security guarantees . Second , we present a low level language MOSS reflecting realistic web programming concepts and scenarios , thus articulating the computation model behind web programming . Finally , we present a rigorous translation from BASS to MOSS , demonstrating how the ideal programming model and security guarantees of BASS can be implemented and enforced in practice .
Introduction
1 . The Web of today is commonly used as a platform for hosting sophisticated applications and services . A key component of such web based applications is the programs running on the web servers . These server side programs ( referred to as “ server programs ” from now on ) take client input in the form of HTTP requests , perform computation and enforce the business logics of the applications , and produce output for the client in the form of HTML pages .
With the growing popularity of web applications , especially those which manage sensitive data and perform critical functionalities ( eg , online banking ) , the security of the server programs has become a major concern . Indeed , web applications face more security threats than conventional desktop applications [ 10 , 26 ] . Some representative ones include command injection [ 27 ] , crosssite scripting ( XSS ) [ 22 ] , cross site request forgery ( CSRF ) [ 5 ] , and session fixation [ 19 ] . Any of these could cause serious consequences : sensitive user information could be stolen , data and associated belongings could be damaged , or service availability could be compromised .
In response to such security threats , existing languages and frameworks for server side scripting ( eg , JSP [ 11 ] , PHP [ 1 ] , Ruby on Rails [ 17] ) , as well as the web application security community ( eg , CERT [ 7 ] , OWASP [ 25 ] , WASC [ 30] ) , largely promote secure coding practices ( eg , input validation ) and provide useful libraries in support ( eg , filtering functions ) . However , there is no guarantee that programmers will follow the recommendations correctly , if they followed them at all . Furthermore , even if all programs are written with the security practices strictly enforced , the extra care that programmers spend on preventing vulnerabilities much dis tracts from the business functionalities . Take the implementation of online payments as an example . To securely code a web interaction of “ obtaining payment details , ” one must correctly perform input validation , maintain program states across the interaction , and prevent CSRF .
Observing that many of the security issues are orthogonal to the business logic of specific web applications , we propose some new abstractions for writing secure server programs . These abstractions provide an ideal view of some key aspects of web programming ( eg , “ to obtain a web input ” ) , and hide the common security handling ( eg , input validation , state maintenance , CSRF prevention ) . Using these abstractions , a language for server side scripting can be given a high level syntax and semantics that reflect useful and secure web operations , with the correct enforcement of the semantics taken care of by the underlying language implementation following established security practices once and for all . As a result , all programs written in the language , although not directly dealing with low level security constructs , are guaranteed to be free of certain common vulnerabilities . In addition , now thinking in terms of the high level semantics , programmers can focus more on the business logic , which results in better security and higher productivity . To some extent , the new abstractions hide security details in the same way as object creation primitives in object oriented languages hide low level memory management details .
On the technical side , this report presents two formal models ( languages ) : one is an ideal model that we propose for future web programs to be written in ; the other is the real world model that underlies existing web programming . By comparing these two models side by side , and by formalizing a translation between them , we argue that web programming ( secure server side scripting , in particular ) could benefit significantly through the use of domain specific language abstractions . Specifically , this report makes the following contributions .
First , we identify some common aspects of web programming that are important for security , and propose new abstractions to help implement the corresponding tasks ( Section 2 ) . The new abstractions are rigorously presented in a self contained formal language BASS ( “ better abstractions for server side scripting ” ) ( Section 3 ) . The new BASS primitives and operational semantics shield programmers from certain malicious exploits , thus serving as an ideal model of web programming . The security guarantees of BASS are articulated in its formal semantics and meta properties .
Next , we formalize a second language MOSS ( “ a model of server side scripting ” ) that reflects the programming model underlying existing server side scripting ( Section 4 ) . This directly demonstrates the complexity of web programming and the benefit of the proposed BASS abstractions . In addition , MOSS is of independent value—it articulates server program execution , attacker exploits , and client server interactions all within the same model , thus serving as a foundation for formal studies of web programming . MOSS can be used to illustrate both secure programs and vulnerable ones .
Figure 1 . Idealistic work flow of online banking
Figure 2 . Actual work flow of online banking
We give formal encoding of some common exploit patterns and typical attacks as an example use of MOSS .
Finally , the BASS approach to security is that the operational semantics dictates “ good ” behaviors only , thus leaving no room for certain attacks . A BASS compiler must carry out the operational semantics correctly . We present a formal translation from BASS to MOSS ( Section 5 ) , where the ideal model of BASS is enforced using proper MOSS primitives for manipulating security concepts . We explain how the security guarantees of BASS are maintained .
2 . Server Side Scripting and Security 2.1 An Ideal View We use an online banking example to explain what is involved in secure server side scripting , and how proper abstractions can help . This application provides two services : showing the account balance ( the “ balance ” service ) and setting up a payment ( the “ payment ” service ) . A user must be logged in to access the services .
Although serving multiple users , this web application logically deals with one client at a time . In an ideal view , there are multiple orthogonal instances of the server program running , each taking care of a single client . Every single instance of the program can be viewed as a sequential program of a conventional application . A work flow graph following this ideal view is shown in Figure 1 . 2.2 A Limited Mechanism The above ideal view cannot be directly implemented , because of some limitations of the underlying HTTP mechanism for web interactions . In particular , there is no persistent channel for a server program to obtain input from a client . Instead , HTTP supports a oneshot request response model where a client requests resource identified by a URL , and a server responds with the resource if the request is accepted . Using HTTP , web interactions are typically carried out as a sequence of requests ( form submissions ) and responses ( web pages ) , where the requests provide user input , and the responses present information to the user : HTTP 0 → HTML 0 → HTTP 1 → HTML 1 → HTTP 2 → HTML 2 . . . Using this model , a server program is often split into multiple fragments , each taking an HTTP request and producing an HTML response . In the response , there can be a web form with an embedded URL pointing to the next fragment , so that the next request is targeted correctly . Therefore , the server work flow of our banking application is more accurately described as in Figure 2 . There are 4 program fragments connected with URL embeddings , as indicated by the dashed lines . In particular , because the payment service requires user input , the structure of the service loop in the ideal view can no longer be coded as an explicit loop . Instead , a goto style structure is exhibited through URL embeddings . Such fragmentation and low level control structures obscure the control flow of the server program .
Besides obscurity , there is a bigger issue : since HTTP is stateless , server programs must maintain program states on their own . In the example , the user name obtained from the login input must be saved and restored explicitly across the later web interactions . In addition , one must somehow correlate incoming requests with specific clients , since multiple clients may be interacting with the server at the same time , although in logically separate transactions .
In general , a web application needs to encode states at a level above HTTP . There are several alternatives applicable to different situations . Typically , a virtual concept of “ a session ” is used to refer to a logical transaction . Every session is associated with a unique ID , called SID . Saved program states and incoming client requests are both identified by the SID . As a result , much code in server programs is dedicated to managing sessions . Before generating a response , a server program must save state and embed the SID in the response . Upon receiving a request , the server program must obtain an SID from the request and load state . Based on the application , some parts of the state should be saved on the server , whereas others should be on the client via the cookie or URL embedding . These routine manipulations increase the complexity of server programs , reduce productivity , and extend the chances of programming errors .
2.3 A Dangerous World Assuming a programmer has taken care of all the above issues correctly , the result program may still not be ready for deployment . The problem there is security : clients in the real world may be malicious , or attackers may trick innocent clients into making mistakes .
Indeed , there have been many common web security vulnerabilities identified . Secure programming solutions have been proposed accordingly . Nonetheless , a programmer must be aware of all the issues involved and implement the related defenses . Most of the defenses are orthogonal to the business logic of specific web applications . Their handling further complicates server side scripting .
In what follows , we briefly overview some representative security issues . The goal is to demonstrate the complexity of web programming , rather than to give a comprehensive list [ 10 , 26 ] .
CSRF : An attacker may forge a request as if it were intended by another user . This is mainly applicable when SIDs are stored in cookies . Suppose a banking program is not coded securely . Such an attack can be launched if a user , while logged in , opens a malicious email containing a crafted image link . Trying to load the image , the user ’s browser may follow the link and send a request to the server asking for a payment to be set up to the attacker .
XSS : An attacker may inject malicious code into the web page that a server program sends to a victim user . In one scenario , an attacker sends to a victim a crafted link with malicious JavaScript code embedded ; when the victim loads the link , a vulnerable server program may propagate the embedded code into the HTML response . The malicious code , now coming from the server , gains the privilege of the server domain . For example , it may read the cookie set by the server and send it to the attacker . This scenario is somewhat related to CSRF . However , there are also second order attacks [ 24 ] that do not require the use of forged requests .
Session fixation : An attacker may fix an SID beforehand and trick a user into communicating with the server using it . This is mainly applicable if SIDs are embedded in URLs . An innocent user may click on a link in a malicious email which claims to be from our
Input login informationSelect serviceShow balanceGet payment detailsSet up paymentLog outProg0Send login form(PC=Prog1)Prog1Parse loginSend service form ( PC=Prog2)Prog2Parse selectionSend balance& service form(PC=Prog2)Send payment form ( PC=Prog3)Prog3Parse paymentSet up paymentSend confirmation& service form(PC=Prog2 ) banking site . The link takes the user to our banking site , but using an SID fixed by an attacker . If the server programs use the same SID for later web interactions after the user logs in , the knowledge of the SID will grant the attacker the user ’s privileges .
Others : Many other aspects affect security [ 26 ] . Consider the fact that a web application is implemented as multiple program fragments . Each fragment is open as a service interface . An attacker could make up requests to these interfaces without strictly following the links provided in the server responses . Using the crafted requests , they could poison program states ( eg , by modifying na¨ıve implementations of client side states ) , inject malformed input ( eg , by exploiting insufficient input validation ) , or circumvent intended work flows ( eg , by unexpected use of the “ back ” button ) .
Programmers need to be aware of all these issues and follow the relevant security practices . In the result code , business logic is intertwined with security manipulations . Consequently , secure web programming is difficult , and web programs are hard to maintain .
2.4 A Declarative Layer We propose to program web applications using a high level language that handles some common security aspects behind the scene . This language benefits from new abstractions designed for web programming . A program in this language more directly reflects the business logic of the target application ; therefore , it is easier to write , to reason about , and to maintain . The language implementation ( the compiler ) will generate secure target code following established security practices . Abstracting web interactions From earlier discussions , it is easy to see that much of the complication is due to the need of obtaining user input . Therefore , supporting web interactions is a key . We introduce a dedicated construct form for this purpose : form(p : “ username ” , q : “ password ” ) ;
The intention of the form construct is to present an HTML page to the client and obtain some input . In a realistic deployment , such a construct would take as argument a full fledged HTML document , possibly generated dynamically and/or containing multiple component forms . In this report , we simply let it take arguments to describe input parameters of a single web form . In the above example , the form construct presents to the client a simple form comprised of two fields : username and password . After the client fills in the form and submits it , the form construct assigns the values provided in the fields to the two variables p and q .
There are a few issues handled transparently by the underlying implementation . First , the server program is split upon a form construct , and proper URL embedding is used in the web page to connect the control flow . Second , the input values of the variables are parsed from the form submission , and input validation is performed according to the declared variable types . Third , standard security practices are followed to manage sessions , maintain states , and defend against common exploits . The details of the implementation will be discussed in Section 5 . For now , it suffices to understand this construct from a programmer ’s point of view as an abstract and secure web input operation which does not break the control flow . Supporting user navigation Such a form construct implicitly opens up a service interface for receiving user requests . There would be vulnerabilities if it were not handled properly , or if its handling were not sufficiently understood by the programmer . Previous work ( sans security ) [ 4 , 6 , 9 ] on web interaction abstractions requires that the interface be “ open ” only once—a second request to the interface would not be accepted . This significantly restricts user navigation [ 15 , 16 , 28 ] . In practice , it is common for a user to return to a previous navigation stage using the “ back ” button . In general , the user could revisit any item in the browser history .
For this purpose , we allow two modes of web interactions : a single use mode ( formS ) and a multi use mode ( formM ) . In the single use mode , the interface is open for request only once ; revisiting the interface ( eg , by activating a browser bookmark ) results in an error . In the multi use mode , the interface remains open for future requests . The semantics of BASS articulates the program behavior in both cases ; therefore , the programmer can choose the suitable one based on the application . In either case , a request is accepted only if it follows the intended control flow of the server program to the interface . Consider our banking example . It is okay if the user reached the service selection page , bookmarked it , and reused it before logging out . However , it is not okay if the user forged a payment request without first going through the login and service selection pages . Maintaining program states Multi use forms are sufficient to accommodate all possible client navigation behaviors , because any behavior can be viewed as revisiting a point in the browser history . From a programmer ’s point of view , the program is virtually forked into multiple parallel “ threads ” at a multi use form statement , together with all appropriate program state . The handling of the program state there is nontrivial . Some parts of the state could be local to the individual threads , whereas others could be global to all threads . The “ local ” state of a thread will not be affected by other threads , whereas the “ global ” state may be affected by others . Careless treatment of the state may result in logical errors [ 16 ] .
The exact partitioning of the state should be determined by the application . We let programmers declare mutable variables as either volatile or nonvolatile . In the BASS implementation , volatile state can be stored in a database on the server across web interactions , thus all forked threads refer to the same volatile state . In contrast , nonvolatile state ( after proper protection against client modifications ) can be embedded in the URLs of web forms upon web interactions , thus every forked thread has its own nonvolatile state . Manipulating client history Sometimes it is useful to disable some previously forked threads . Suppose the user tries to reload the service selection page after logging out of our banking application . The server program will receive a request that should not be processed . In general , we need a mechanism to disable some of the entries in the client history . In existing web applications , this is sometimes handled by embedding special tokens into web forms and checking them upon requests . While logging out , the server program expires the corresponding token , thus further requests to the service selection page will no longer be processed .
The validity of such an operation should be determined by the application , rather than be dismissed all together . For our banking example , it is reasonable to allow a user to duplicate the service selection page and proceed with both “ balance ” and “ payment ” in parallel .
We do not wish to expose the details of token embedding to the programmer . Instead , we introduce a simple clear command for a similar purpose . From the programmer ’s point of view , clear simply resets the client history , so that all previously forked threads are discarded . This corresponds to the “ session timeout ” behaviors of many web applications . However , instead of thinking in terms of disabling the token of SID , BASS encourages programmers to think in terms of the client history . There are certainly more general ways to manipulate the client history . One possibility is to attach a privilege level to every web form , and to manipulate the forked threads by levels . Note that such level management can easily be implemented by the programmer using our provided abstractions of web input , volatile state , and nonvolatile state . More specifically , the current level can be stored in a volatile variable on the server as the global level . Upon a web interaction , the current level can be attached to the current thread using a nonvolatile variable as the local level . Comparison between the global and local levels and sel , amnt ; string user , pass , payee ; int formS(user : “ username ” , pass : “ password ” ) ; LoginCheck(user , pass ) ; while ( true ) do { formM(sel : “ 1 : balance ; 2 : payment ; others : logout ” ) ; if ( sel == 1 ) then ShowBalance(user ) else if ( sel == 2 ) then {formS(payee : “ payee ” ; amnt : “ amount ” ) ; else {clear ; break}
DoPayment(user , payee , amnt)}
}
Figure 3 . Simple banking in BASS proper handling can be done upon any user requests . Although not increasing the expressiveness of the language , abstractions for such level based privilege management may prove convenient for certain applications . However , since its handling is straightforward , we omit it and use the simple clear command for demonstration . Example revisited Figure 3 demonstrates the appeal of these abstractions by revisiting our banking example . The new abstractions provide an ideal world where there is only one client and the client is well behaved . In the code , we obtain login information from the client , perform login check ( LoginCheck terminates the program if the check fails ) , and proceed with a service loop . In the loop , based on the service selection of the client , we carry out the balance service ( ShowBalance ) or the payment service ( DoPayment ) , or log the user out . The service selection input is coded using a multi use form , therefore the user may duplicate the corresponding web page and proceed with the two services in parallel . In addition , clear is used to disable all service threads when the user logs out . In this example , only the user variable is live across web interactions . Its value is obtained from a single use form , and will not be updated after the login process . Therefore , it can be declared as either volatile or nonvolatile .
This code corresponds well to the work flow of Figure 1 , and is much cleaner than a version directly written in an existing language . More importantly , it does not sacrifice security , because the implementation of the new abstractions will take care of the “ plumbings ” transparently—it will split the program into multiple fragments , maintain program states across web interactions , filter input based on variable types , and carry out relevant security manipulations such as the embedding of secret tokens .
Of course , these abstractions may not be suitable for all programming tasks . For applications which require little dynamic manipulation and state maintenance , it may not be as big a burden to directly code the security details . However , observing the growing popularity and complexity of web applications , especially in critical areas , we believe such abstractions will bring many benefits .
3 . BASS We formalize the above ideas in BASS , which provides a declarative view for programmers to write secure programs without worrying about the low level details described in Section 2 . The meta properties of BASS provide useful security guarantees . Assuming the semantics is enforced by an underlying implementation , all wellformed BASS programs will be secure in a certain sense . For example , values obtained from web input will have the expected types , forged requests from attackers will be rejected , and the program control flow will be enforced . These properties will be articulated in Section 34
Figure 4 . A virtual view of the execution environment
( World ) W ::= ( Σ , κ , κ ) ( Global Env ) Σ ::= {a : τ = v} κ ::= ( σ , C ) | σ σ ::= {x : τ = v} τ ::= int | str
( Closure ) ( Local Env ) ( T ype )
( Command ) C ::= skip | a := E | x := E | C ; C
| if E then C else C | while E do C | formS(a :s ) | formM(a :s ) | clear
( Exp ) E ::= a | x | i ( integers ) | s ( strings ) | op( E ) ( V alue ) v ::= i | s
Figure 5 . BASS syntax
3.1 Syntax Figure 4 gives a graphical depiction of the virtual execution environment of BASS . We emphasize the word “ virtual ” because the view does not dictate how BASS is implemented ; it simply provides a tractable world for the programmer to deal with .
In this world , there is a single server and a single client . The server consists of a global environment for volatile variables and a closure of the current execution . The closure is made up of a local environment for nonvolatile variables and some code . During execution , the server executes the code with respect to the two variable environments . Upon a web interaction , the server sends a proper closure to the client , and the client is then activated .
The client involves a list of closures reflecting the browsing history . When the client is active , it chooses an arbitrary closure in the history , fills in the corresponding web form , and sends the result to the server . We point out that although many code pieces appear in the closures on the client , they would actually be realized in an implementation as program pointers embedded in the forms . Similarly , the local environments can also be realized in forms .
Figure 5 gives the syntax . We use the vector κ to refer to the list
[ κ1 . . . κn ] . Similar notations apply to other meta variables , too .
A world W is a 3 tuple ( Σ , κ , κ ) . The first element Σ is the global variable environment , which is a mapping from volatile variables to their types and values . The second element κ is the closure currently active on the server . The third element κ is the client browsing history .
A closure is usually a pair of a local environment and a command . Sometimes , an environment without a command also makes a closure , which either contains useful information or signifies termination . A local environment maps nonvolatile variables to types and values . We assume that the names of volatile and nonvolatile variables are disjoint . By convention , we use a , a , a1 , . . . for volatile variables , and x , x , x1 , . . . for nonvolatile variables . We use two types : integers ( int ) and strings ( str ) . Booleans are simulated with integers .
Commands are common except for web interactions ( formS , formM ) and history clearing ( clear ) as described in Section 24 For conciseness , web forms only input volatile variables ; this does not affect expressiveness , because the input values can be passed on to nonvolatile variables with assignments . Expressions and values are as expected . We use op to abstract over all operations free from
WorldServerClientCode1GlobalVariablesCoden…LocalVarsLocalVarsCodeLocalVars side effects , such as string concatenation and comparison . We omit function calls for conciseness , because they introduce no new issues .
3.2 Operational Semantics We use a big step semantics for expressions . Details are standard , thus omitted . We present in Figure 6 the small step execution of a world . The key concept is a “ world step ” relation W ; W . A multi step relation W ;∗ W is defined as the reflexive and transitive closure of the world step relation .
In world step , some rules reflect server side computation , whereas others reflect client side input . Rule ( 1 ) describes a server computation step by referring to a single thread step relation ( Σ , κ ) ; ( Σ , κ ) . This is applicable only when the current command starts with skip , assignment , conditional , or loop ( the single thread step relation is undefined on other cases ) . If the current command is clear , Rules ( 2 ) and ( 3 ) apply to remove all closures from the client . In these rules and the remainder of this report , we use to denote the empty vector . Upon any form commands , Rule ( 4 ) applies to transfer the closure to the client . The notation [ κ ] ∪ κ means to combine the singleton vector [ κ ] with κ .
Client input through a single use form is captured in Rules ( 5 ) and ( 6 ) . Note that there is no further command to execute on the server ( the closure on the server is simply σ0 ) , therefore the client takes control . In Rule ( 5 ) , the client selects the closure κi to proceed with next . This corresponds to picking an arbitrary point in the browsing history . The client may input arbitrary values to the form , as long as they are of the right types ( v ∈ τ ) . The global environment is updated using the macro update(Σ , a , v ) , which updates Σ so that the variables a will have the values v . As a the result of the step , the global environment is updated , and the chosen client closure is moved to the server for execution . The notation κ − [ κi ] means to remove κi from κ . Rule ( 6 ) is a variant of Rule ( 5 ) where there is no further command in the chosen closure to execute after the form input . In this case , the chosen closure is simply removed . Rules ( 7 ) and ( 8 ) are for client input through multi use forms . The difference in comparison with the single use ones lies in the result browsing history . For single use forms , the selected closure is removed from the history so that it cannot be revisited . For multiuse forms , the history remains the same . All client request rules are non deterministic on closure selection . A client may “ abandon ” a closure by never selecting it .
The single thread step relation is straightforwardly described in Rules ( 9)–(16 ) . Here the macro update is overloaded to update both the global and the local environments .
3.3 Typing Rules We give some non standard typing rules in Figure 7 . In Rule ( 17 ) , a world ( Σ , κ , κ ) is well formed if all closures ( κ and κ ) are wellformed with respect to the global environment ( Σ ) , and every closure ( κi ) on the client side contains code which starts with a web form . The well formedness of closures is defined in Rules ( 18 ) and ( 19 ) . A trivial closure σ is always well formed . A nontrivial closure ( σ , C ) is well formed with respect to Σ if C is well formed with respect to Σ and σ . We omit the standard handling on commands and expressions , where types of variables are pulled from the corresponding environments .
3.4 Meta Properties BASS enjoys standard type soundness via preservation and progress .
Lemma 1 ( Preservation ) If W and W ; W , then W .
Lemma 2 ( Progress ) If W then either there exists W such that W ; W , or W is of the form ( Σ , σ , ) .
Σ ; σ E ⇓ v
W ;∗ W
W ; W
Server computation :
History clearing :
Omitted .
Omitted .
( Σ , κ ) ; ( Σ , κ )
( Σ , κ , κ ) ; ( Σ , κ , κ )
( Σ , ( σ , clear ; C ) , κ ) ; ( Σ , ( σ , C ) , )
( Σ , ( σ , clear ) , κ ) ; ( Σ , σ , )
Server response :
C ∈ {(formS(a :s ) ; C ) , formS(a :s ) , ) , formM(a :s)} ( formM(a :s ) ; C ( Σ , ( σ , C ) , κ ) ; ( Σ , σ , [ (σ , C ) ] ∪ κ )
Client request :
κi ∈ κ ( a : τ = . . . ) ∈ Σ update(Σ , a , v ) = Σ v ∈ τ
κi = ( σ , ( formS(a :s ) ; C ) ) ( Σ , σ0 , κ ) ; ( Σ , ( σ , C ) , κ − [ κi ] ) κi ∈ κ
κi = ( σ , ( formS(a :s) ) )
( Σ , σ0 , κ ) ; ( Σ , σ0 , κ − [ κi ] ) κi = ( σ , ( formM(a :s ) ; C ) ) ( Σ , σ0 , κ ) ; ( Σ , ( σ , C ) , κ ) κi ∈ κ v ∈ τ
κi = ( σ , ( formM(a :s) ) )
κi ∈ κ ( a : τ = . . . ) ∈ Σ update(Σ , a , v ) = Σ
( Σ , κ ) ; ( Σ , κ )
( Σ , σ0 , κ ) ; ( Σ , σ0 , κ )
( Σ , ( σ , skip ) ) ; ( Σ , σ )
Σ ; σ E ⇓ v update(Σ , a , v ) = Σ
( Σ , ( σ , a := E ) ) ; ( Σ , σ )
Σ ; σ E ⇓ v update(σ , x , v ) = σ
( Σ , ( σ , x := E ) ) ; ( Σ , σ )
( Σ , ( σ , C ) ) ; ( Σ , σ )
( Σ , ( σ , C ; C ) ) ; ( Σ , ( σ , C ) )
Σ ; σ E ⇓ i i = 0
( Σ , ( σ , if E then C else C ) ) ; ( Σ , ( σ , C ) )
Σ ; σ E ⇓ 0
( Σ , ( σ , if E then C else C ) ) ; ( Σ , ( σ , C ) )
Σ ; σ E ⇓ i i = 0
( Σ , ( σ , while E do C ) ) ; ( Σ , ( σ , C ; while E do C ) )
Σ ; σ E ⇓ 0
( Σ , ( σ , while E do C ) ) ; ( Σ , σ )
Figure 6 . BASS operational semantics
( 1 )
( 2 )
( 3 )
( 4 )
( 5 )
( 6 )
( 7 )
( 8 )
( 9 )
( 10 )
( 11 )
( 12 )
( 13 )
( 14 )
( 15 )
( 16 )
∀κi ∈ κ .
W
Σ κ
Σ κ
Σ ; σ C Σ ; σ E fl κi = ( σi , Ci )
Σ κi
Ci starts with formS or formM ( Σ , κ , κ ) Σ σ Σ ; σ C Σ ( σ , C ) Omitted . Omitted .
( 17 )
( 18 )
( 19 )
Figure 7 . BASS typing rules
As usual , these imply that well formed programs will execute till termination without getting stuck . These seemingly simple theorems provide useful guarantees for server side scripting . They essentially guarantee that the program execution will be confined by the operational semantics—only the transitions defined by the operational semantics may occur . Therefore , all behaviors reflected by the operational semantics are guaranteed , including : 1 . The control flow will follow the explicit high level structures ; 2 . Values obtained from web input will be well typed ; 3 . Program states will be kept intact across web interactions ; 4 . Entries in the client history will be disabled upon clear ; 5 . There will be only one client interacting with the program in stance .
These free programmers from some low level maneuvers , such as : 1 . Embedding and enforcing the control flow ; 2 . Validating the names and types of web input parameters ; 3 . Recovering program states across web interactions ; 4 . Addressing unexpected user navigation behaviors ; 5 . Protecting against malicious exploits that involve multiple clients
( eg , CSRF , first order XSS , and session fixation ) .
We stress the point that the BASS approach to security is to directly preclude questionable behaviors from the operational semantics . BASS programmers enjoy a clean view of web programming , with common security handling transparently taken care of by the BASS implementation ( the compiler ) . This enables programmers to focus on the business logic of specific web applications , thus improving security and productivity . Specifically on security , the BASS semantics leaves no room for CSRF , first order XSS , session fixation , session poisoning , malformed input , and work flow circumvention . Of course , the semantics must be enforced by an implementation . This is the topic of the next two sections , where we formalize a realistic web programming model MOSS , and translate BASS into MOSS so that the BASS semantics is faithfully carried out .
4 . MOSS MOSS articulates server program execution and client behaviors . It reflects realistic web interactions , and can be used to illustrate both well behaved client activities and malicious exploits . We will explain how concepts in MOSS correspond to real world entities throughout the section .
4.1 Syntax A graphical depiction of the model is given in Figure 8 . On the server , there are a group of programs collaborating to implement the
Figure 8 . A model of web programming
( World ) ( Global Env ) ( Session Env ) ( Closure ) ( Local Env )
W ::= ( ˙Σ , ˙κ , Φ ) ˙Σ ::= {[ι : ς ] , [ f = ( a ) C]∗} ::= {a = v} ς ˙κ ::= ( i , v , ˙σ , C ) | ( v , ˙σ ) ˙σ ::= {x = v}
( Client ) Φ ::= ( v , φ ) ( F orm ) ( Sealed ) ( Command )
φ ::= form f ( s a =v ) with ψ ψ ::= x = v C ::= sk | a← E | C ; ; C | cond(E , C , C )
( Exp )
| loop(E , C ) | f ( E ) | input(E ) | setCk(E ) | unpack(E ) | verif(E , τ ) | err E ::= a | x | i ( integers ) | s ( strings ) | op(E ) | {E} | in(E , E ) | ins(E , E ) | del(E , E ) | form f ( s a =v ) with E | getCk( ) | ψ | pack( ) | ι ( tokens ) | newTk( )
( V alue ) v , w ::= i | s | {v} | φ | ψ | ι
( BASS T ype )
τ ::= int | str
Figure 9 . MOSS syntax desired application logic . They access and update data that belong to multiple clients . The server interacts with multiple clients simultaneously , although in separate logical transactions . Every client has its own cookie , and maintains a list of forms as the browsing history . Although forms are expected to be obtained from the server through web interactions , a client may also forge a form on its own ( as illustrated using Formx and Formy , which appear to come from nowhere ) . This reflects real world exploits where a client makes up an HTTP request without going through the intended application logic . In addition , a malicious client B may trick an innocent client A by inserting a form from B ’s history ( part of which may be forged ) into A ’s history ( as illustrated using Formz ) . In the real world counterpart , an attacker may send crafted links to a victim in an email ; sometimes , these links are image links that may be automatically loaded by a browser .
Whereas the virtual execution environment in Figure 4 provides an ideal view for the programmer to work with , the model in Figure 8 reflects real world web application scenarios , where server programs interact with and maintain data for multiple clients , who are no longer always well behaved . To implement secure web applications in this model , the server programs need special primitives for manipulating security concepts and constructs . For example , special tokens ( eg , SID ) can be used to identify users and logical transactions , and those tokens can be embedded in the cookies and forms on the clients .
We present the details of this model as a low level language MOSS . The syntax is given in Figure 9 . MOSS is untyped for conciseness , but it is straightforward to give it a standard typing . Vector notations ( eg , Φ ) are sometimes used when referring to a
Client AServerProg1DataBDataA……CookieProgn…Client BCookieFormyClients C , D , E , ……FormxFormpForm1…FormqForm1Formz list of items ( eg , [ Φ1 . . . Φn] ) . The symbols for certain language constructs are borrowed from BASS to show correspondence of the underlying concepts , but minor modifications are applied to avoid confusion . In particular , we use a different font for reused English letters ( W , C , E and v ) , and add a dot on top for reused Greek letters ( ˙Σ , ˙κ , and ˙σ ) .
A world W in this language consists of three elements . The first is a global environment ˙Σ on the server . The second is a closure ˙κ currently active on the server . The third is a list of browsing histories Φ , each belonging to a different client .
The global environment ˙Σ contains both data and code . The data part is essentially a list of session environments ς organized by some tokens ι for identifying sessions ( ie , SIDs ) . Every session environment ς captures the values of the volatile variables ( eg , a , a , a1 ) for a session . The code part is simply a collection of functions , with every function consisting of a name f , a list of input parameters a , and a body command C . Here , the symbols [ ] are used as parentheses of the meta language , rather than as part of MOSS .
The closure ˙κ is usually a tuple consisting of a client identifier i ( indicating that the current computation is for the ith client ; this corresponds to the transient but dedicated connection established between the client and the server for an HTTP request response ) , a value v as the content of the cookie ( transferred from the client to the server in a request and passed back to the client in a response ) , a local environment ˙σ , and a command C . Sometimes a pair of a cookie value and a local environment also makes a closure ; such a closure cannot be executed , but the information therein may be propagated to other closures . The local environment ˙σ collects the values of non volatile variables ( eg , x , x , x1 ) . We assume that ˙σ contains a special variable xsid dedicated for storing the SID of the underlying session . Alternatively , one may wish to store the SID in the cookie . Since the cookie is shared by all forms on a client , that would prevent the same client from accessing multiple sessions simultaneously . Therefore , we choose to store the SID in the local environments of the individual “ threads . ”
The clients vector Φ deserves attention . In BASS , the single client is idealized as a list of closures . In MOSS , a world involves multiple clients . Each client Φ consists of a list of forms φ and a cookie with the value v . A form φ is made up of input parameters a and their textual explanations s and default values v ( ie , input fields in a web form ) , a target f ( ie , the web link behind the “ submit ” button ) , and some sealed client side state ψ . Note that ψ is not meant to be modified by the client . This restriction will be enforced in the operational semantics . In the syntax , we use the notation . . . to indicate that it is a “ package ” that cannot be taken apart by the client . In a real language , such sealed state can be signed by the server to prevent client modifications . We also point out that the forms in a client may belong to different sessions , because the client may initiate different sessions in different browser windows . Although reserving a dedicated variable xsid in the local environments for session identification , MOSS does not automatically maintain it ( or any other non volatile variables ) across web interactions . As in the case of real web programming , the programmer may maintain the relevant information in the sealed state .
Commands C involve the common ones and some new primitives adapted from real world entities for secure server side scripting . For distinction from BASS , we use a different syntax for the common commands of skip ( sk ) , assignment ( a ← E ) , sequential composition ( C ; ; C ) , conditional ( cond(E , C , C) ) , and while loop ( loop(E , C) ) . f ( E ) is a function call to f with the arguments E . When the server program needs web input , input(E ) is used to send a form computed from E to the client . setCk(E ) sets a new value for the cookie in the current closure . unpack(E ) unpacks the sealed state from E . verif(E , τ ) validates E against BASS types τ . Finally , err exits the program upon an error ; we use this abrupt pro
ς ; vck ; ˙σ E ⇓ v
ς ; vck ; ˙σ a ⇓ ς(a ) ς ; vck ; ˙σ x ⇓ ˙σ(x ) ς ; vck ; ˙σ v ⇓ v ς ; vck ; ˙σ E ⇓ v
ς ; vck ; ˙σ op(E ) ⇓ ˆop(v )
ς ; vck ; ˙σ E ⇓ v
ς ; vck ; ˙σ {E} ⇓ {v}
ς ; vck ; ˙σ E ⇓ v ς ; vck ; ˙σ E
ς ; vck ; ˙σ E ⇓ v
⇓ {v} i = ς ; vck ; ˙σ in(E , E ) ⇓ i ς ; vck ; ˙σ E ) ⇓ {v , v} ⇓ {v} ) ⇓ {w}
ς ; vck ; ˙σ ins(E , E ς ; vck ; ˙σ E ς ; vck ; ˙σ del(E , E fl0 if v /∈ v
1 if v ∈ v
⇓ {v}
ς ; vck ; ˙σ E ⇓ v w = v − {v}
ς ; vck ; ˙σ E ⇓ v
ς ; vck ; ˙σ formf ( s a=τ ) withE ⇓ formf ( s a=τ ) withv
ς ; vck ; ˙σ getCk( ) ⇓ vck
ς ; vck;{x = v} pack( ) ⇓ x = v f resh(ι )
ς ; vck ; ˙σ newTk( ) ⇓ ι
Figure 10 . MOSS expression evaluation
( 20 )
( 21 )
( 22 )
( 23 )
( 24 )
( 25 )
( 26 )
( 27 )
( 28 )
( 29 )
( 30 )
( 31 ) gram termination for simplicity , although real web applications typically perform more sophisticated error handling ( eg , giving error messages , redirecting to other pages ) . The exact meanings of these commands will be defined by the operational semantics .
, and del(E , E
MOSS reuses the variables a and x , integers i , strings s , and abstract operations op(E ) of BASS for ease of exposition of the translation in Section 5 . It also introduces some set expressions : {E} is ) checks if E belongs to the set E , a set with elements E , in(E , E ) inserts E into the set E ) removes E from ins(E , E . form constructs a form by putting together some input the set E parameters , a target function , and an expression carrying the sealed state . getCk( ) obtains the cookie value . ψ is a sealed state , and it is typically created using pack( ) . Finally , tokens ι are unique and unforgeable entities created using newTk( ) ; newTk( ) will never create two identical tokens , and the tokens created cannot be guessed or forged by clients . The exact form of tokens is abstract in MOSS . We have already mentioned the use of tokens as SIDs . Later when translating BASS , we will also use tokens to identify clients , enforce control flows , and prevent request forgeries .
4.2 Operational Semantics Figure 10 gives the semantics of expressions . The evaluation is carried out with respect to three entities : a session environment ς , a cookie value vck , and a local environment ˙σ . The values for volatile and nonvolatile variables are pulled from their environments respectively in Rules ( 20 ) and ( 21 ) . Values require no further evaluation ( Rule ( 22) ) . In Rule ( 23 ) , we use ˆop to refer to the corresponding meta level computation of op . The set expressions are evaluated as expected in Rules ( 24)–(27 ) , where integers are used to simulate booleans . Rule ( 28 ) evaluates the expression component of a form , which is expected to be a sealed state , and composes a form value . Rule ( 29 ) simply provides the cookie as the result of evalu
W ;∗ W
W ; W Server computation :
Omitted .
( ˙Σ , ˙κ ) ; ( ˙Σ , ˙κ )
( ˙Σ , ˙κ , Φ ) ; ( ˙Σ , ˙κ , Φ )
Server response :
˙κ = ( i , vck , ˙σ , input(E ) ) or ˙κ = ( i , vck , ˙σ , input(E ) ; ; C ) ˙σ(xsid ) = ι Φi = ( v , φ )
˙Σ(ι ) ; vck ; ˙σ E ⇓ φ i = ( vck , [ φ ] ∪ φ ) Φ
( ˙Σ , ˙κ , Φ ) ; ( ˙Σ , ( vck , ˙σ ) , ( Φ − [ Φi ] ) ∪ [ Φ i ] )
Client forging ( form filling ) :
Φi ∈ Φ φ ∈ φ φ = form f(s a =w ) with ψ
Φi = ( vck , φ ) φ = form f ( s a =v ) with ψ Φ i = ( v
( ˙Σ , ( v , ˙σ ) , Φ ) ; ( ˙Σ , ( v , ˙σ ) , ( Φ − [ Φi ] ) ∪ [ Φ i ] )
, [ φ ] ∪ φ )
Client request :
Φi ∈ Φ ( f = ( asrl , a ) C ) ∈ ˙Σ
Φi = ( vck , φ ) formf ( s a=v ) with ψ ∈ φ
( ˙Σ , ( v , ˙σ ) , Φ ) ; ( ˙Σ , ( i , vck,{} , f ( ψ,v) ) , Φ )
Attacker tricking :
Φi ∈ Φ Φj ∈ Φ
, φ )
Φi = ( v Φj = ( vck , φ )
φ ∈ φ j = ( vck , [ φ ] ∪ φ ) Φ
( ˙Σ , ( v , ˙σ ) , Φ ) ; ( ˙Σ , ( v , ˙σ ) , ( Φ − [ Φj ] ) ∪ [ Φ j ] )
New session :
Φi ∈ Φ ˙Σ = ˙Σ ∪ {ι : {}}
Φi = ( vck , φ ) f resh(ι )
˙κ = ( i , vck,{xsid = ι} , fstart( ) )
( ˙Σ , ( v , ˙σ ) , Φ ) ; ( ˙Σ , ˙κ , Φ )
New client : f resh(ι ) f resh(ι )
˙Σ = ˙Σ ∪ {ι : {}} ˙κ = ( n + 1 , ι,{xsid = ι} , fstart( ) )
|Φ| = n
( ˙Σ , ( v , ˙σ ) , Φ ) ; ( ˙Σ , ˙κ , Φ ∪ [ (• , ) ] )
( Σ , κ ) ; ( Σ , κ )
( ˙Σ , ( i , vck , ˙σ , sk ) ) ; ( ˙Σ , ( vck , ˙σ ) ) ˙Σ(ι ) ; vck ; ˙σ E ⇓ v
˙σ(xsid ) = ι update( ˙Σ(ι ) , a , v ) = ˙Σ ( ˙Σ , ( i , vck , ˙σ , a← E ) ) ; ( ˙Σ , ( vck , ˙σ ) ) ˙Σ(ι ) ; vck ; ˙σ E ⇓ v ˙σ(xsid ) = ι update( ˙σ , x , v ) = ˙σ ( ˙Σ , ( i , vck , ˙σ , x← E ) ) ; ( ˙Σ , ( vck , ˙σ ) )
( ˙Σ , ( i , vck , ˙σ , C ) ) ; ( ˙Σ , ( v , ˙σ ) ) ) ) ; ( ˙Σ , ( i , v , ˙σ , C
( ˙Σ , ( i , vck , ˙σ , C ; ; C
˙Σ(ι ) ; vck ; ˙σ E ⇓ i
) ) i = 0 ) ) ) ; ( ˙Σ , ( i , vck , ˙σ , C ) )
( ˙Σ , ( i , vck , ˙σ , cond(E , C , C
˙σ(xsid ) = ι
˙σ(xsid ) = ι
( ˙Σ , ( i , vck , ˙σ , cond(E , C , C
˙Σ(ι ) ; vck ; ˙σ E ⇓ 0 ) ) ) ; ( ˙Σ , ( i , vck , ˙σ , C i = 0
˙Σ(ι ) ; vck ; ˙σ E ⇓ i
) )
˙σ(xsid ) = ι
( ˙Σ , ( i , vck , ˙σ , loop(E , C) ) ) ; ( ˙Σ , ( i , vck , ˙σ , C ; ; loop(E , C) ) )
˙σ(xsid ) = ι
˙Σ(ι ) ; vck ; ˙σ E ⇓ 0
( ˙Σ , ( i , vck , ˙σ , loop(E , C) ) ) ; ( ˙Σ , ( vck , ˙σ ) )
( f = ( a ) C ) ∈ ˙Σ ˙σ(xsid ) = ι
|E| = |a|
˙Σ(ι ) ; vck ; ˙σ E ⇓ v
( ˙Σ , ( i , vck , ˙σ , f ( E) ) ) ; ( ˙Σ , ( i , vck , ˙σ , C[v/a] ) )
˙Σ(ι ) ; vck ; ˙σ E ⇓ v ˙σ(xsid ) = ι ( ˙Σ , ( i , vck , ˙σ , setCk(E) ) ) ; ( ˙Σ , ( v , ˙σ ) ) ˙Σ(ι ) ; vck ; ˙σ E ⇓ x = v
˙σ(xsid ) = ι update( ˙σ , x,v ) = ˙σ ( ˙Σ , ( i , vck , ˙σ , unpack(E) ) ) ; ( ˙Σ , ( vck , ˙σ ) )
˙σ(xsid ) = ι ∀k . ( ∃i.vk = i and τk = int ) or ( ∃s.vk = s and τk = str )
˙Σ(ι ) ; vck ; ˙σ E ⇓ v
( ˙Σ , ( i , vck , ˙σ , verif(E , τ ) ) ) ; ( ˙Σ , ( vck , ˙σ ) )
( 39 )
( 40 )
( 41 )
( 42 )
( 43 )
( 44 )
( 45 )
( 46 )
( 47 )
( 48 )
( 49 )
( 50 )
( 32 )
( 33 )
( 34 )
( 35 )
( 36 )
( 37 )
( 38 ) ating getCk( ) . Rule ( 30 ) creates a sealed state based on the local environment . Finally , Rule ( 31 ) produces a fresh token .
The remainder of the operational semantics is given in Figure 11 . . Similar to BASS , the key concept is a “ world step ” relation W ; W is defined as the reflexive and A multi step relation W ;∗ W transitive closure of the world step relation .
Most of the server side computation is captured in Rule ( 32 ) , which delegates the task to a single thread step relation ( ˙Σ , ˙κ ) ; ( ˙Σ , ˙κ ) . Upon an input(E ) command ( Rule ( 33) ) , the expression E is evaluated to a form φ , and the result is transferred to the client . Note that the special variable xsid is used to obtain the SID ι , and ι is used to locate the session environment ( ˙Σ(ι ) refers to the session environment identified by ι in ˙Σ ) . In addition , the client identifier i is used to locate the client history Φi . Φi may contain a different cookie value v , because the server may have updated the cookie to vck in the current closure ˙κ . We update the client history from Φi to Φ i using the new cookie vck and form φ . In the result of the step , the clients vector is updated by removing the old Φi and inserting
Figure 11 . MOSS world execution the updated Φ i . Any command C following input(E ) is discarded . This reflects the case that the server execution stops after sending a response to the client , and resumes after receiving the next request ; the control flow is connected by a link embedded in the web form E , not by sequencing with another command C . This Rule ( 33 ) is the only one that describes the execution upon an input(E ) command . Therefore , the execution of a MOSS program gets stuck if E is not a form , if ι is not recognized by ˙Σ , or if xsid does not contain a valid token at all . Similar observations apply to all other rules .
The remainder rules of the world step relation concern things initiated by a client . An ideal case is that a client fills in a form with values . However , in the real world handling of a web form , the target function name and input fields are subject to malicious modifications , because they are directly embedded behind the “ submit ” button for the browser to recognize and produce an HTTP request . Such a scenario is captured in Rule ( 34 ) , where a client Φi forges a new form φ ( the ideal form filling is a special case of this ) . Here , the client may make up arbitrary things on the function name and input fields , but not the sealed state ψ ( eg , the client cannot forge the server ’s signature ) ; ψ must come from some form φ in the history of Φi . In addition , the cookie value may also be modified by . As a result of the step , the new client Φ the client from vck to v i includes the forged form φ and cookie v , and the clients vector Φ is updated accordingly . The server side remains unchanged .
In Rule ( 35 ) , the ith client picks a form from the history and submits it . On the server side , the function f must be recognized by the global environment , and the function must expect the proper number of arguments ( asrl is a special argument for the sealed state ) . In the result of the step , a new closure is composed for execution , where the cookie is obtained from the client , and the function f is applied to the sealed state and the input values . No input validation on the argument types is done in this rule . Therefore , a program which does not perform proper input validation on its own may go wrong in later computation .
Sometimes an attacker tricks a victim into sending a request composed by the attacker . In Rule ( 36 ) , the attacker client i picks an arbitrary form φ from Φi , and inserts it into the victim client j ’s history . The server side remains unchanged . Now that the form is injected into the victim client , a later request following Rule ( 35 ) may submit it to the server , thus completing the attack .
An existing client may initiate a new session using Rule ( 37 ) . On the server side , a fresh token ι is created as the SID , an empty session ˙Σ , and a new environment is added into the global environment closure ˙κ is composed . In the closure ˙κ , the local environment is initialized so that xsid is bound to ι , and the code starts from fstart , which is a special function reserved as the entry point of MOSS programs . The session environment and the local environment do not contain entries for programmer defined variables yet . Instead , those variables will be declared implicitly upon their first use , which is articulated in later rules for executing assignments .
The last client initiated step , Rule ( 38 ) , applies when a new client joins . Similar to Rule ( 37 ) , a new session with SID ι is created . In addition , another fresh token ι is created as an ID for uniquely identifying the client ( we will refer to this as a CID ) . ι is stored in the cookie of the new closure ˙κ,1 and will be propagated to the client upon a web interaction using Rule ( 33 ) . As a result of the step , the global environment is updated , the new closure is activated for execution , and the clients vector is updated to include the new client , which has the transient client identifier n+1 , an empty cookie indicated by the special value • , and an empty history vector . The right hand side of Figure 11 defines the single thread step relation ( ˙Σ , ˙κ ) ; ( ˙Σ , ˙κ ) . The cases for skip ( Rule ( 39) ) , sequencing ( Rule ( 42) ) , conditional ( Rules ( 43 ) and ( 44) ) , and while loop ( Rules ( 45 ) and ( 46 ) ) are standard . Assignments are defined in Rules ( 40 ) and ( 41 ) , where a macro update is overloaded to update both session environments ς and local environments ˙σ . If the variable to be updated is not in the environment , the macro will create a new entry , thus the variable is implicitly declared upon first use .
Rule ( 47 ) carries out a function call using capture avoiding substitution , after checking the number of and evaluating the arguments . Rule ( 48 ) updates the cookie of the current closure . Rule ( 49 ) evaluates E to a sealed state , and updates the local environment ˙σ accordingly . Finally , Rule ( 50 ) validates E against BASS types τ . There is no rule for the case where the validation fails—the execution gets stuck upon a failed validation .
1 We store CID in cookie automatically for a simpler exposition of the translation in Section 5 . This does not restrict the expressiveness of MOSS , because the semantics does not inspect the cookie for CID , and a programmer may always choose to ignore the CID and use the cookie for other purposes .
4.3 Example Use : Patterns of Exploits MOSS is designed to be very flexible , and some syntactically correct programs could result in stucks during execution . Some causes of stucks include unrecognized SIDs or function names , unmatched number of function parameters , illegal usage of values ( eg , unpacking an integer ) , and failed input validations . Indeed , MOSS is meant to reflect real world scenarios , rather than to confine web program behaviors using a restricted semantics or a type system . Similar to existing web programming languages , MOSS can be used to write both secure programs and vulnerable ones .
Besides serving as the target of our BASS translation , MOSS is of independent value to understanding web programming , because it helps to articulate the essence of common exploits and attacks . We demonstrate this by encoding two exploit patterns , which cover all the example attacks discussed in Section 23
The first is an attacker victim pattern , where an attacker takes advantage by tricking a victim into submitting an unintended request , which in turn triggers a vulnerability in a server program . We assume the application stores the SID in the client cookie .
( ˙Σ , ( v , ˙σ ) , [ (ιA , φA ) , ( ιB , φB) ] )
; ( ˙Σ , ( v , ˙σ ) , [ (ιA , φA ) , ( ιB , φB∪[φ]) ] ) ; ( ˙Σ , ( v , ˙σ ) , [ (ιA , φA∪[φ] ) , ( ιB , φB∪[φ]) ] ) ; ( ˙Σ , ˙κ , [ (ιA , φA∪[φ] ) , ( ιB , φB∪[φ]) ] )
( forge by Rule ( 34 ) ) ( trick by Rule ( 36 ) ) ( request by Rule ( 35 ) ) Here the attacker B forges a form φ in the first step , and injects it into A ( eg , by emailing a link ) in the second step . When A submits the form ( eg , by following the link ) in the third step , the server program composes a closure ˙κ to process the request . Whereas a careful server program may inspect φ to identify injected requests ( Section 5 ) , a vulnerable one might simply identify the session based on the SID ιA transferred from A ’s cookie . Therefore , the request is processed as if it were intended by A .
This pattern captures different attacks when φ and ˙κ are instantiated with different entities based on different program vulnerabilities . For instance , suppose a banking program has a CSRF vulnerability—it accepts payment requests solely based on the SID stored in the cookie , while a client is logged in . The attacker B may instantiate the above pattern with φ = form fpay( “ payee ” p= “ B ” , “ amnt ” a = 100 ) with . Upon receiving the request , the server program would compose a closure to set up a payment from A . Similarly , a program with an XSS vulnerability would propagate a crafted string ( eg , cookie stealing JavaScript code ) from B ’s forged form to an HTML page displayed in A ’s browser , and a program with a session fixation vulnerability would set A up to use an SID fixed by B .
The second is a malicious client pattern , where a malicious client crafts a request to exploit server program vulnerabilities .
( forge by Rule ( 34 ) ) ( request by Rule ( 35 ) )
( ˙Σ , ( v , ˙σ ) , [ (ιA , φA) ] ) ; ( ˙Σ , ( v , ˙σ ) , [ (ιA , φA∪[φ]) ] ) ; ( ˙Σ , ˙κ , [ (ιA , φA∪[φ]) ] ) Since a malicious client A may use arbitrary target function names , parameter names and values , and sealed states ( eg , ones obtained from other forms in the history ) to compose the request φ , a server program which does not carefully code against these possibilities would be subject to attacks including session poisoning , malformed input , and work flow circumvention .
5 . Translation By comparing BASS ( our proposed ideal programming model ) and MOSS ( the actual programming model in use today ) , the advantage of BASS is clear—none of the above attacks can happen to a BASS program , simply because BASS has a “ well behaved ” semantics . We now discuss how this semantics can be implemented . Specif ically , we will point out how the two patterns of attacks are prevented . Although focusing on a particular translation , we note that other pertinent secure coding practices could be applied instead . The bottom line is , with the BASS abstractions implemented following secure coding practices once and for all , programmers enjoy an ideal model that is free from common exploits .
In particular , BASS has an ideal model where the control flow is not disrupted by web input , there is only a single session , and the client is well behaved . These no longer hold in the MOSS model of real world scenarios . To connect the two models , the translation takes care of program splitting , form making , session management , state maintenance , forgery prevention , and input validation . Recall from Figures 8 and 9 that a client in MOSS consists of a cookie and a list of forms . In our translation , we maintain the invariant that the cookie stores the CID of the client , and the forms are of the following shape : form f ( s a =w ) with xcid=ιcid , xsid=ιsid , xtok=ιtok , xf un=sf , x=v
A key to the translation , this is in essence an encoding of BASS client closures in MOSS forms . Besides the target function f and input parameters a , we also encode information about the local environment ( nonvolatile variables x=v ) . In addition , some special variables are used for session management and forgery prevention . The first special variable , xcid , stores the CID that the server assigned to the client in Rule ( 38 ) . In a translated program , before sending a response to the client , we obtain the CID from the cookie in the current closure , and store it in variable xcid . On the other hand , when processing a request from a client , we inspect xcid and check it against the client cookie . This ensures that the request indeed comes from the client , because : ( 1 ) a sealed state cannot be modified by a client ; ( 2 ) the cookie of a client cannot be updated by others ; ( 3 ) although a client may modify her cookie , she cannot change it to the value of another client ’s unforgeable CID . These together prevents attacker crafted forms , inserted into a victim ’s history using Rule ( 36 ) , from being accepted by the server . As a result , the attacker victim pattern will not succeed .
The variable xsid stores the SID . The variable xtok stores a server generated token for history control . The validity of this token will be checked when the server program processes the request . For single use forms , the token will be invalidated after the first use , thus preventing future resubmissions . In addition , the token can also be invalidated if we choose to expire all existing forms ( cf . a BASS clear operation ) . We point out that values in xsid and xtok only need to be unique ; they do not have to be unforgeable on their own , because they are stored in the sealed state and thus cannot be forged . We reuse the same token construct for CID , SID and history control in MOSS , but a realization may relax this .
Besides the three tokens , there is a special variable xf un that stores the target function name . This is to prevent certain request forgeries where the client modifies the target function of the form . Upon a request , xf un will be inspected and the request will be processed only if it matches the actual target function . This effectively binds the target function name and sealed state together in a form . Together with some type based input validation code generated by the translation , this prevents attacks of the malicious client pattern . The exact translation is given in Figure 12 . Since all BASS expressions/values are MOSS expressions/values , the expression translation is trivial . In the translation rules , we simply adjust the font , updating E to E to indicate the trivial translation from a BASS expression E to the corresponding MOSS expression E . Command translation has the form |C|(Σ , ˙Σ , f ) = ( ˙Σ , C ) . Here we translate the BASS command C into the MOSS command C . The translation takes as input a BASS global environment Σ , a MOSS ˙Σ , and a function name f . Σ is propagated global environment
|C|(Σ , ˙Σ , f ) = ( ˙Σ , C )
|skip|(Σ , ˙Σ , f ) = ( ˙Σ , f ( ) )
|C|(Σ , ˙Σ , f ) = ( ˙Σ , C )
|skip ; C|(Σ , ˙Σ , f ) = ( ˙Σ , sk ; ; C )
|C|(Σ , ˙Σ , f ) = ( ˙Σ , C )
|a := E ; C|(Σ , ˙Σ , f ) = ( ˙Σ , a← E ; ; C )
|C|(Σ , ˙Σ , f ) = ( ˙Σ , C )
|x := E ; C|(Σ , ˙Σ , f ) = ( ˙Σ , x← E ; ; C ) |C|(Σ , ˙Σ , f ) = ( ˙Σ0 , C ) ˙Σ1 = update( ˙Σ0 , f , ( ) C ) |C1 ; skip|(Σ , ˙Σ1,f ) = ( ˙Σ2,C1 ) |C2 ; skip|(Σ , ˙Σ2,f ) = ( ˙Σ3,C2 ) f resh(f )
|(ifE thenC1 elseC2 ) ; C|(Σ , ˙Σ,f ) = ( ˙Σ3,cond(E,C1,C2 ) ) f resh(f )
|C1|(Σ , ˙Σ , f ) = ( ˙Σ0 , C1 ) ˙Σ1 = update( ˙Σ0 , f , ( ) sk ) |C ; skip|(Σ , ˙Σ1 , f ) = ( ˙Σ2 , C ) ˙Σ3 = update( ˙Σ2 , f , ( ) cond(E , C , C1 ) ) |(while E do C ) ; C1|(Σ , ˙Σ , f ) = ( ˙Σ3 , f( ) )
( a : τ = v ) ∈ Σ s = toString(f ) f resh(f ) C1 = xcid← getCk( ) ; ; xf un← s ; ;
|C|(Σ , ˙Σ , f ) = ( ˙Σ0 , C ) xtok ← newTk( ) ; ; astok ← ins(xtok , astok ) ; ; input(form f(s a =v ) with pack( ) )
( 51 )
( 52 )
( 53 )
( 54 )
( 55 )
( 56 )
C2 = verif(a , τ ) ; ; unpack(asrl ) ; ; cond(E , C3 , err ) where E = ( xcid==getCk( ) ) ∧ in(xtok , astok ) ∧ ( xf un==s ) ˙Σ1 = update( ˙Σ0 , f , ( asrl , a ) C2 )
C3 = astok ← del(xtok , astok ) ; ; C
|formS(a :s ) ; C|(Σ , ˙Σ , f ) = ( ˙Σ1 , C1 )
( 57 )
( a : τ = v ) ∈ Σ f resh(f ) C1 = xcid← getCk( ) ; ; xf un← s ; ; xtok ← amtok ; ;
|C|(Σ , ˙Σ , f ) = ( ˙Σ0 , C ) s = toString(f ) input(form f(s a =v ) with pack( ) )
C2 = verif(a , τ ) ; ; unpack(asrl ) ; ; cond(E , C , err ) where E = ( xcid==getCk( ) ) ∧ ( xtok==amtok ) ∧ ( xf un==s ) ˙Σ1 = update( ˙Σ0 , f , ( asrl , a ) C2 ) ( 58 )
|formM(a :s ) ; C|(Σ , ˙Σ , f ) = ( ˙Σ1 , C1 ) |C|(Σ , ˙Σ , f ) = ( ˙Σ , C ) = astok ←{} ; ; amtok ← newTk( ) ; ; C C
|clear ; C|(Σ , ˙Σ , f ) = ( ˙Σ , C )
|W|Σ = W
σ = {x : τ = w}
Σ = {a : τ = v} ˙Σ0 = {fexit = ( ) . . .} |C ; skip|(Σ , ˙Σ0 , fexit ) = ( ˙Σ1 , C ) = a←v ; ; x←w ; ; astok ←{} ; ; amtok ← newTk( ) ; ; C C ) ˙Σ2 = update( ˙Σ1 , fstart , ( ) C
|(Σ , ( σ , C ) , )|Σ = ( ˙Σ2,◦ , )
Figure 12 . Translation
( 59 )
( 60 ) throughout the translation without change ; it is used to obtain the types of input variables when producing code for input validation . ˙Σ is an environment to be updated to ˙Σ , so that new code blocks introduced during program splitting can be accumulated . f is provided as a continuation to the current command .
Rule ( 51 ) describes the base case of translating a skip . The translation simply produces the same environment ˙Σ and a call to the continuation f . All other rules translate compound commands . Rules ( 52 ) , ( 53 ) and ( 54 ) translate compound commands which start with a skip or assignment . These commands are simply translated into their counterparts in MOSS . Note that the environment ˙Σ may be updated to ˙Σ when translating the tail command C .
Rule ( 55 ) translates a compound command starting with a conditional . First , we translate the tail C into C , producing the envi˙Σ0 . Next , we create a fresh label f and add it into ˙Σ0 ronment ˙Σ1 is then used to transto refer to C . The updated environment late the branches C1 and C2 ( skip is inserted so that command translation needs only one base case—Rule ( 51) ) , with the new label f as the continuation for both . Finally , we produce the translation result using the latest environment ˙Σ3 and a MOSS conditional . In this rule , the new label f is created to restructure the control flow in case either branch involves web input . Suppose C1 is of the form a := 1 ; formS( . . . ) ; a := 2 . Rule ( 55 ) would produce split target code—C1 would be a← 1 ; ; input(φ ) , and the link embedded in φ would point to a function with the code a← 2 ; ; f( ) . If neither branch involves web input , an optimized version can be used to produce simpler target code , which is straightforward and omitted . Rule ( 56 ) translates a while loop . A fresh label f is created as the entry point of the loop . We insert into ˙Σ1 some dummy code for f , use ˙Σ1 to translate C with f as the continuation , and update the code of f with a conditional in the final environment ˙Σ3 . If the expression E evaluates to true , C will be executed ; a loop is formed because C uses f as the continuation . If E evaluates to false , C1 ( translated from C1 ) will be executed , thus exiting the loop . Again , an optimized version can be used if C does not involve web input . The translation of web input follows the intuition described at the beginning of this section . Rule ( 57 ) translates a single use form formS(a :s ) . The program is split into two parts : the first part C1 will be explicit in the translation result ; the second C2 will be stored in the result environment ˙Σ1 under a fresh label f . In C1 , we put the cookie value ( the CID ) into xcid , put the function name s into xf un ( toString converts function names to unique strings ) , put a fresh token into xtok , update a volatile variable astok to include the new token in the set of valid tokens , and send out a form . The form contains the target f , the default values v ( we obtain these from Σ , but other values can be used in practice ) , and the sealed state created using pack( ) . In C2 , which will be executed when the form is submitted , we validate the input parameters by type , unpack the sealed state , and check the validity of the request using E . In E , we compare the CID in xcid against the cookie to detect attacker injected forms , check the validity of the token xtok to prevent the single use form from being submitted a second time , and check the target name xf un to prevent forged links . If all these checks succeed , we remove the used token xtok from the list of valid tokens astok , and proceed with the command C translated from C . Otherwise , we terminate the program with err .
Rule ( 58 ) translates a multi use form . The idea is similar to Rule ( 57 ) , except that we reuse the same token stored in amtok for all multi use forms . In command C2 , after the validation and unpacking , we check whether the token xtok still matches amtok .
The last command translation case is described in Rule ( 59 ) . Upon a clear , we simply reset the volatile variables astok and amtok . This effectively disables all existing forms on the client , because the form translations in Rules ( 57 ) and ( 58 ) check the validity of the embedded tokens against astok and amtok .
World translation is given in Rule ( 60 ) . We only translate those that correspond to unexecuted programs , where the client history is empty . The translation uses two special labels : fstart as the entry point of the program , and fexit as the exit point . We translate the program body C with fexit as the continuation , and create an entry for fstart in the final environment ˙Σ2 . The body of fstart initializes the program variables based on BASS environments Σ and σ , and assigns initial values to astok and amtok .
This concludes our formal translation , where the high level semantics of BASS is enforced using careful manipulations of tokens and sealed states in MOSS . Note that a BASS program corresponds to a single session in MOSS . With the translation ( a compiler ) taking care of the common manipulations on web interactions and security once and for all , programs can be written in BASS following a simple and elegant declarative view of web programming .
5.1 Correctness and Prototyping The correctness of the translation has been discussed throughout the translation . We now summarize some key arguments on the preservation of all the properties discussed in Section 3.4 , which can be easily established by inspecting the form encoding presented earlier . Since the sealed state is protected , the only form component subject to client modification is the input parameters . Modifications on the target function name will not succeed , because the function name is also stored in the sealed state . As a result , the control flow of a BASS program will be enforced , since clients cannot forge target links—they can only follow the server provided forms to access the server programs . In addition , an attacker cannot masquerade as another client—although an attacker may modify the cookie , she cannot set it to the unforgeable CID of another client . More interestingly , CSRF , first order XSS and session fixation , which require an attacker to inject a form into a client ( Rule ( 36) ) , are prevented because the injected form will have a different CID than that stored in the client ’s cookie . Finally , input validation , session state recovery , and history control are all properly carried out .
We have implemented a prototype compiler of BASS in OCaml . The compiler takes well formed BASS programs and produces secure Perl code following Figure 12 . SSL is used for web interactions to prevent eavesdropping and tampering . All constructs of MOSS and the translation have clear counterparts in the prototype , demonstrating that our modeling is faithful to real world scenarios , and that the translation can be carried out effectively . The compiler consists of 1456 lines of OCaml code ( about 49KB ) , and uses a runtime library of 342 lines of Perl code ( about 7KB ) . The executable in FreeBSD ELF format is about 346KB . The compiler translated the banking example of Figure 3 into 99 lines of Perl code . Focusing on the formal BASS language , the scale of this prototype is small . We plan to experiment with a larger scale prototype in the future , where the ideas of this report will be implemented for an existing language as a library .
6 . Related and Future Work Declarative web programming MAWL [ 3 , 4 ] and its descendants ( <bigwig> [ 6 ] , JWIG [ 9 ] ) use domain specific language constructs to program web applications . They view web applications as form based services , and provide abstractions on some key aspects such as web input and state management . These abstractions hide implementation details ( eg , input validation , embedding of continuation and state in URL ) , thus preventing certain programming errors . In another line of work , Graunke et al . [ 14 ] propose the design and implementation of an I/O construct for web interactions . This construct helps to program web applications in a more traditional model of interactions , and avoids the manual saving and restoring of control state between interactions .
Although similar in spirit to BASS on these aspects , the above work does not provide a formal semantics with the same security guarantees . However , security should not be overlooked for declarative web programming—now that the details of web interactions are hidden by new abstractions , programmers can no longer carry out the secure coding practices by themselves . As a result , a na¨ıve application of new abstractions could suffer from security vulnerabilities such as CSRF . It is thus crucial that the proposed abstractions and their implementation provide related security guarantees .
On expressiveness , MAWL and descendants enforce a strict control flow where every form is , in the BASS terminology , single use . For example , users will be redirected to the beginning of a session if they hit the back button . In contrast , BASS leaves the design decision to the programmer , rather than disabling “ whimsical navigation ” [ 16 ] altogether . This additional flexibility is important for many applications [ 15 , 16 , 28 ] .
We emphasize that the goal of BASS is to facilitate secure web programming with language abstractions more suitable for the domain . Besides having declarative support on web interactions , single /multi use forms , state declarations , and history control , it is important that the features are all modelled within an original and self contained semantic specification . BASS has an intuitive and formal programming model with an explicit notion of a client , and its meta properties are articulated . This allows programmers to fully grasp how BASS programs behave . The common task of following secure coding practices , which is orthogonal to the specific application logic , is carried out by a BASS implementation once and for all .
There has also been work developing domain specific languages or frameworks for web programming as libraries of existing typesafe languages . Some notable examples are the Curry based serverside scripting language by Hanus [ 18 ] , Haskell based WASH/CGI by Thiemann [ 28 ] , and Smalltalk based Seaside by Ducasse et al . [ 12 ] . These provide useful abstractions in the form of libraries to handle some common aspects of web programming , such as structured HTML generation , session management , and client server communication . However , they do not provide the formal security guarantees of BASS . Furthermore , there is no stand alone formal semantics for the new abstractions , although in principle the behaviors could be inferred from the implementations and the semantics of the host languages . Finally , they are tied to the host languages , thus the ideas are not easily applicable to other languages . In contrast , BASS is translated into a flexible model underlying web programming in general . The rigorous BASS and MOSS allow us to formally derive security guarantees .
Finally , some recent work uses unified languages and frameworks for web application development , automatically partitioning programs among the server and the client . Most of such work does not address security . A notable exception is Swift [ 8 ] , which ensures confidentiality and integrity of web application information using type annotations which reflect information flow policies . The security guarantee of Swift is largely orthogonal to those of BASS . If programmers use proper annotations , the general information flow guarantees of Swift can help guarding against some common vulnerabilities such as SQL injection and XSS . However , it remains vulnerable to ( it is up to the programmer to write secure code against ) others such as CSRF . In addition , the formal semantics of BASS helps providing a rigorous foundation on web interaction and browser navigation in general . Models of web programs Besides building new abstractions , it is also important to understand what the existing web programming model is and how to write secure programs within it . Although there are many security recommendations and coding practices available on the topic , web programming has rarely been formally studied from the language principles . An exception is the work by Graunke et al . on modeling web interactions [ 16 ] . In particular , they model web interactions in presence of whimsical navigation behaviors of well intended ( non malicious ) users , identify two classes of errors ( form field mismatch , client server state mismatch ) , and propose to catch the errors with a static type system ( typed web forms ) and dynamic checks ( time stamped states ) .
In comparison with our work , Graunke et al . do not address the wider security questions , where the server interacts with multiple clients , some of whom may be malicious . Specifically , they do not have security related primitives in their server side computation , they model web programs in the presence of a single client , and their transitions lack the counterparts of the forging ( Rule ( 34 ) ) and tricking ( Rule ( 36 ) ) behaviors of MOSS . In contrast , we more accurately model web interactions and server computations . This allows us to encode common exploit patterns ( Section 4.3 ) , which are then amenable to formal reasoning . Instead of using a type system or dynamic checks to close up the two classes of errors , we use principled but flexible abstractions in BASS for web programming and present their realization in MOSS . This hides some common details of secure web programming and precludes some different classes of errors and vulnerabilities . Although we do not propose techniques preventing errors associated with whimsical navigations , the corresponding error scenarios can be rigorously illustrated in BASS and MOSS ; therefore , programmers are fully aware of the issues , and the techniques of Graunke et al . can be applied . Future work We believe that web programming will benefit significantly from the use of domain specific abstractions , and much can be done in the area . For starters , the form constructs of BASS can be generalized to take an arbitrary HTML page as a parameter in practice . Sometimes an HTML page may contain multiple forms , each with a separate submit button linking to a different target . A more interesting aspect is to include client side scripting ( eg , JavaScript ) into the model . This is orthogonal to the focus of serverside scripting in this report , and previous work on the formal aspects of JavaScript [ 29 , 2 , 32 ] and web application development frameworks and policies [ 13 , 21 ] provide some good starting points .
Using some new abstractions , BASS provides several useful security guarantees as articulated in Section 34 However , the BASS abstractions are not meant to be “ complete , ” and there are other desirable program properties uncovered . It is thus useful to explore abstractions for other areas , such as dynamic HTML generation , privilege management , and dynamic SQL construction . HTML generation has been much studied [ 18 , 9 , 23 , 28 ] , where the wellformedness of the generated document can be guaranteed statically . Privilege management has been discussed in Section 24 Dynamic SQL construction is worth mentioning . Most web languages manipulate SQL commands with strings , na¨ıve handling of which is subject to injection attacks . Previous work [ 27 , 31 ] has articulated that injection attacks happen when client input changes the intended structure of the constructed commands . In response , it is useful to provide abstractions that statically enforce the structures of SQL commands before client input is plugged in at runtime . Prepared statements [ 20 ] provide some support on this aspect if used properly , but further study on more generally shaped queries and more friendly syntax is useful . Similar ideas may also help addressing second order XSS [ 24 ] .
Designed for web programming in general , BASS addresses only common security aspects , rather than issues on the specifics of an application . For example , directory traversal [ 10 ] ( accessing the parent directory using the path “ \ ” ) is not prevented by common type based input validation , and programmers must perform additional filtering . Application specific security and code analysis will still be necessary . However , with the new abstractions closing up some common vulnerabilities and clarifying the control flow , such analysis should be easier . In general , the new abstractions should also help the analysis , reasoning , and testing of web programs , because they provide an ideal model ( eg , structured control flow , automatic state maintenance , single well behaved client ) that is amenable to established language techniques .
In this report , MOSS serves mainly as the target of the BASS translation . However , it is also of independent value to web programming studies . In MOSS , a client may take control only if the server contains no active closure . This is similar in spirit to nonpreemptive multi threading . A preemptive version of MOSS is interesting future work . In addition , type systems and program logics for confining and reasoning about MOSS programs are useful .
7 . Conclusion Web applications reflect a different computation model than conventional software , and the security issues therein deserve careful study from both language principles and practical implementations . This report serves as a useful step towards building a formal foundation for secure server side scripting . In particular , we propose two self contained formalizations on the topic , using familiar language concepts such as continuations , threads , and small step semantics . The first is a formal language BASS for server side scripting . BASS provides an ideal programming model where the server interacts with a single client , using some dedicated constructs to obtain web input and manipulate client history . The meta properties and formal guarantees of BASS allow programmers to focus on the application logic without being distracted by common implementation details , thus improving productivity and security .
The second is a formal model MOSS characterizing realistic web programming concepts . As is the case of existing server side scripting languages , MOSS can be used to write both secure programs and vulnerable ones . We present a formal translation from BASS to MOSS , demonstrating how the BASS abstractions and guarantees can be enforced using a few common primitives for manipulating security concepts . Our prototype shows much promise on the idea of better abstractions for secure server side scripting , and we hope to experiment more on the topic with real world web programming languages and frameworks .
Acknowledgments We wish to thank Zhong Shao , Gary Wassermann , and the anonymous reviewers at WWW 2008 for helpful suggestions .
References [ 1 ] M . Achour et al PHP manual . http://wwwphpnet , 2007 . [ 2 ] C . Anderson , P . Giannini , and S . Drossopoulou . Towards type In Proc . 19th European Conference on inference for JavaScript . Object Oriented Programming , pages 429–452 , July 2005 .
[ 3 ] D . Atkins , T . Ball , M . Benedikt , G . Bruns , K . Cox , P . Mataga , and
K . Rehor . Experience with a domain specific language for form based services . In Proc . 1997 Conference on Domain Specific Languages , 1997 .
[ 4 ] D . L . Atkins , T . Ball , G . Bruns , and K . Cox . MAWL : A domainspecific language for form based services . IEEE Trans . on Software Engineering , 25(3):334–346 , 1999 .
[ 5 ] R . Auger . The Cross Site Request Forgery FAQ . http://www . cgisecurity.com/articles , 2007 .
[ 6 ] C . Brabrand , A . Møller , and M . I . Schwartzbach . The <bigwig> project . ACM Trans . on Internet Technology , 2(2):79–114 , 2002 .
[ 7 ] CERT . Computer emergency response team . http://wwwcert org , 2007 .
[ 8 ] S . Chong , J . Liu , A . C . Myers , X . Qi , K . Vikram , L . Zheng , and X . Zheng . Secure web applications via automatic partitioning . In
Proc . 21st Symposium on Operating Systems Principles , pages 31–44 , Oct . 2007 .
[ 9 ] A . S . Christensen , A . Møller , and M . I . Schwartzbach . Extending Java for high level Web service construction . ACM Trans . on Programming Languages and Systems , 25(6):814–875 , Nov . 2003 .
[ 10 ] S . Christey and R . A . Martin . Vulnerability type distributions in CVE . http://cvemitreorg/docs/vuln trends , 2007 .
[ 11 ] P . Delisle , J . Luehe , and M . Roth . JavaServer Pages specification . http://javasuncom/products/jsp , 2006 .
[ 12 ] S . Ducasse , A . Lienhard , and L . Renggli . Seaside — a multiple control flow web application framework . In Proc . 12th International Smalltalk Conference , pages 231–257 , Sept . 2004 .
[ 13 ] ´U . Erlingsson , B . Livshits , and Y . Xie . End to end web application security . In Proc . 11th Workshop on Hot Topics in Operating Systems , May 2007 .
[ 14 ] P . Graunke , R . B . Findler , S . Krishnamurthi , and M . Felleisen . In Proc . 16th
Automatically restructuring programs for the Web . International Conference on Automated Software Engineering , pages 211–222 , Nov . 2001 .
[ 15 ] P . Graunke and S . Krishnamurthi . Advanced control flows for flexible graphical user interfaces . In Proc . 2002 International Conference on Software Engineering , pages 277–296 , 2002 .
[ 16 ] P . Graunke , S . Krishnamurthi , S . V . D . Hoeven , and M . Felleisen . Modeling web interactions . In Proc . 2003 European Symposium on Programming , pages 122–136 , 2003 .
[ 17 ] D . H . Hansson . Ruby on Rails . http://wwwrubyonrails org .
[ 18 ] M . Hanus . High level server side web scripting in Curry . In Proc . 3rd International Symposium on Practical Aspects of Delcarative Languages , pages 76–92 , 2001 .
[ 19 ] J . Kolˇsek . Session fixation vulnerability in web based applications . http://wwwacrossecuritycom/papershtm , 2002 .
[ 20 ] J . Lam . Prepared statements and SQL injections . http://isc . sansorg/diaryhtml?storyid=2301&rss , 2007 .
[ 21 ] B . Livshits and ´U . Erlingsson . Using web application construction frameworks to protect against code injection attacks . Programming Languages and Analysis for Security , June 2007 .
In Proc .
[ 22 ] G . A . D . Lucca , A . R . Fasolino , M . Mastoianni , and P . Tramontana . In Proc . 6th Identifying XSS vulnerabilities in web applications . International Workshop on Web Site Evolution , pages 71–80 , 2004 .
[ 23 ] K . Nørmark . Web programming in Scheme with LAML . Journal of
Functional Programming , 15(1):53–65 , 2005 .
[ 24 ] G . Ollmann . Second order code injection attacks . http://www . nextgenss.com/papers , 2004 .
[ 25 ] OWASP . Open web application security project . http://www . owasp.org , 2007 .
[ 26 ] OWASP Foundation . The ten most critical web application security vulnerabilities . http://wwwowasporg , 2007 .
[ 27 ] Z . Su and G . Wassermann . The essence of command injection attacks in web applications . Programming Languages , pages 372–382 , Jan . 2006 .
In Proc . 33rd Symposium on Principles of
[ 28 ] P . Thiemann . An embedded domain specific language for type safe server side web scripting . ACM Trans . on Internet Technology , 5(1):1– 46 , Feb . 2005 .
[ 29 ] P . Thiemann . Towards a type system for analyzing JavaScript
In Proc . 2005 European Symposium on Programming , programs . pages 408–422 , Apr . 2005 .
[ 30 ] WASC . Web application security consortium . http://www . webappsec.org , 2007 .
[ 31 ] G . Wassermann and Z . Su . Sound and precise analysis of web applications for injection vulnerabilities . In Proc . 2007 Conference on Programming Language Design and Implementation , pages 32–41 , June 2007 .
[ 32 ] D . Yu , A . Chander , N . Islam , and I . Serikov . JavaScript instrumentation for browser security . Programming Languages , pages 237–249 , Jan . 2007 .
In Proc . 34th Symposium on Principles of
