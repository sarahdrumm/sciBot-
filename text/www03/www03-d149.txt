Implementing an XML Editing Framework with Web Based Architectural Constructs
Jenghan Hsieh
Institute of Information Science
Academia Sinica
Taipei 115
Taiwan jenghan@iissinicaedutw
Today , dynamic and apparently structured forms are usually treated ad hoc . While the transmission of the data is still flat name value pairs . Further , ad hoc systems require significant repeated development effort each time they are used , and minor requirement changes will propagate throughout the whole system . form appears structured , the form based
Abstract Currently , development of dynamic , hierarchical web forms is labor intensive and lacks standardized infrastructure . In this paper , we present a framework for building versatile web applications through framework , entitled “ Architectural XML Editing Framework , ” or “ AXEFramework , ” is implemented using exclusively existing standards , making it easy to adopt . Furthermore , the framework strives to avoid undue complexity , and thus feature a quick learning curve . These characteristics make it a desirable choice for building large scale digital archives , and complex enterprise applications . interaction . Our
Keywords XML , Forms , Architectural Form , XMLSpace
1 . Introduction HTML Forms[9 ] , one of the most important features of the World Wide Web , has remained relatively stagnant over the last eight years , despite many attempts to improve them . Most proposals to improve web forms , such as XFDL[5 ] , XFA[16 ] , FML[15 ] , and XForms[14 ] have taken the approach of defining new markup languages to improve forms , although each has approached the problem from its own unique perspective . XFDL[4 ] provides full security features and supports built in logic , calculations , type checking , enclosures , and online help . These features make it suitable for government and business uses . XFA[16 ] supports multiple views of the document and the data , absolute and relative positioning of form objects and data , and digital signatures that make it an appropriate intermediate format for forms in client applications . The design of FML[10 ] is focused on improving web base interaction and is defined as an XHTML module . It is more “ web oriented ” by design and is suitable for building web interfaces . Although these specifications are all open to public , their implementations are still proprietary and special viewers or servers are required . Currently , XForms[14 ] is an official effort by W3C XForms Working Group to realize the vision of a “ Next Generation Form ” . XForms is designed to cover a broad range of issues including : purpose definition , data entry , event model , schema validation , and form submission . Since all of these features have been integrated into a single specification , XForms is inevitably a lot more complex than HTML itself . We believe that simplicity is one of the key success factors of HTML , and therefore our approach differs from XForms , in that we strive for a low learning curve through simplicity and reliance on existing popular standards .
Figure 1 . The ad hoc interactive web forms
2 . Framework Overview Under the AXEFramework , to develop a dynamic structured form , a developer will complete the following steps :
1 ) The developer will build an HTML document T representing the form , as it should be displayed in its simplest state . The document T must reference the framework ’s JavaScript Library .
2 ) The developer will ( optionally ) develop one or more interaction scripts that control the form ’s dynamic behavior when needed .
3 ) The developer will specify the underlying structural and metadata features in previous HTML document T , using predefined attributes . T is also referred to as a template and will be used later at run time .
At runtime , the server , client , user , and AXEFramework interact as follows :
1 ) The user visits a page utilizing the AXEFramework 2 ) A javascript in the AXEFramework enabled page invokes the AXEFramework ’s Get(url ) method , fetching an XML fragment R from the query broker on the server . R represents the initial values for the form .
3 ) A javascript in the page calls ExpandTemplate(R , T ) to generate an HTML representation of R , denoted as H .
4 ) The user manipulates H by filling in form fields , clicking on scripted elements , etc . The state of the document after these manipulations is denoted as H’ .
5 ) When the user presses “ submit , ” a javascript in the page calls AXEFramework ’s ExtractFormValue(H’ ) method , to extract the modified data R’ .
6 ) Optionally , the AXEFramework performs validity checks against R’ using Regular Expressions , DTDs , or Schematron as specified by the developer .
7 ) The AXEFramework ’s Put(R’ , url ) method will be called to send the resulting data R’ as an XML fragment back to the listener on the server .
8 ) Optionally , the server may utilize metadata indicators embedded in R’ for further processing . the overall process : “ Architectural Figure 2 demonstrates Templates ” generated by the developer ( see item1 in figure 2 ) , and initial data from the managing framework on the server ( see item3 in figure 2 ) , is input to the editing framework ( see item2 in figure 2 ) to generate HTML . Subsequent user inputs are also fed into the editing framework , which processes the results and sends them back to the management framework . The architectural processor used optionally by the management framework will be discussed in later sections .
Figure 2 . AXEFramework Process Flow
Data Instances
In the paper we simplify our discussion by assuming that all formbased activities can be generalized to the process of modifying a resource of predefined XML structure through client/server interactions , we will refer to these XML resources as “ Data Instances ” . We refer to the Data Instance representing information present on the web pages prior to user input as the “ Original Data Instance . ” Likewise , “ Modified Data Instance ” refers to the XML resource representing the information present on the web page after user input . Thus , a client/server interaction consists of the delivery of an original data instance from the server to the client , and the return of the modified data instance from client to server .
Information Model
Since DTDs , XML Schema or other formal schema definitions are not required in this framework . We use the term “ information model ” as a less restrictive alternative for Schema or DTD when referring to structural constraints of data instances . Developers may build additional application layers to enforce the structural integrity among templates , however that is beyond the scope of this paper .
Architecture / Architectural Constructs
In this paper , we use the terms architecture and architectural constructs interchangeably . By “ Architecture ” , we mean a set of common structures and semantic features that may appear in different document structures[1 ] . For example , XLink[17 ] is an architectural construct that you can use in XHTML , SVG or other markup languages to describe complex linking relationships . The “ Derived Architecture ” , a term borrowed from Annex36 of ISO10744 HyTime[1 ] , is a structure instance conforming to single or multiple “ Base Architectures ” . A derived architecture may be the base architecture of another architectural layer . A detailed example will be given in the next paragraph .
In this framework , the “ Architectural Templates ” are the only part that application developers have to deal with at design time . The Editing and Managing Frameworks consist of application independent processing engines or agents that do not require customization . We will provide detailed descriptions of these three parts later in section 4 , 5 , 6 respectively .
3 . Terminology and Concepts Several Instances , Architectures , Architectural Constructs , Template Fragments , Template Expansion , Form Recognition and Architectural Processor are described in this section to denote the origin of concepts and the terminology used in this paper . Reader who cares more about implementation details may skip this section . terms and concepts , including Data
Figure 3 . The base / derived relationships of architectural constructs
Template Fragments
The template fragment is an HTML/XHTML document fragment containing a plain HTML fragment enhanced by additional attributes to denote the semantics of its components . It is derived from several base architectures that are defined either in this framework or individual user defined applications . For example , these architectures may be used to express the semantics of XML form value , metadata , workflow architecture and other application specific structures illustrated in Figure 3 . in
Template Expansion / Form Recognition
Template Expansion is the process of taking a template and initial values and producing an HTML page . This is handled in the AXEFramework by the ExpandTemplate method referred to above . After the user alters the HTML document by filling the input fields , or interacting with scripted elements that invoke the DOM API in javascript , the modified data instance is then recognized and extracted from the modified HTML document . Such a process of data extraction is called “ Form Recognition ” . The extracted data instance may then be submitted by standard HTTP Post , by simple extensions such as XMLHTTP implemented on Internet Explorer , or by complex infrastructures such as SOAP messaging with digital signature and encryption .
Architectural Processor
Architectural processors are software agents , or services , that take derived architectures as input , recognize some of the basic architectures that they are derived from , and then perform subsequent actions based on these base architectures . For example , the editing framework and management framework mentioned above are both architectural processors . The former takes the original data instance , the R mentioned in section 2 , as input and then recognizes the modified data instance and the regular expressions used to validate the form elements based on their base architectures . The latter takes the modified data instance as input , recognizes its base architectures ( such as metadata or workflow information ) and then performs subsequent actions such as storing the data in its storage and notifying the participants .
In this section , we describe the architectural constructs used in AXEFramework , and how we use them to achieve our design goals . 1 4.1 Architecture of Information Model This base architecture expresses the information model for each application . AXEFramework uses the attribute axe:name to indicate the tag names of elements in the corresponding information model , and uses axe:namespace to indicate the namespace URI of these elements . Figure 4 and the following code fragment show the same HTML fragment in different views . This template fragment is derived from a simple information model , which consists of a Head element with two child elements : Author and Date .
Figure 5 . An template fragment with attributes “ axe:name ” and “ axe:namespace ”
Figure 4 . Architectural processors and the architectural constructs that they use
4 . The Architectural Templates Of the three separate parts of AXEFramework , the “ Architectural Templates ” is the most important one for application developers in including presentation , interaction and structure of data instances , can be encoded in such templates . This logic embedded in the architectural templates may be used later by rest of the framework . that relevant application logics ,
Figure 6 . Visualization of the above fragment
Since this HTML template is derived from the information model , it can be used by the framework ’s functions ExpandTemplate( ) and ExtractFormValue( ) to reconstruct a template or extract a data instance from the template at run time .
1 1 Note that for simplicity , all namespace declarations in following examples are removed and the namespace prefix “ axe : ” is used as an integral part of attribute names .
4.2 Interactions and Substitution Groups To enable complex information models such as substitution groups , each fragment may reference other fragments by using the attribute “ axe:ref ” as shown in Figure 7 . This reference will be used by the Editing Framework for both template expansion and interaction .
4.3 Regular Expression Constraints Two attributes “ axe:regex ” and “ axe:report ” are defined to describe the matching pattern and error message for regular expression validity checking .
Figure 9 . Use “ axe:regex ” and “ axe:report ” to define the regular expression constraints
The validity check will then be automatically performed by the Editing Framework after form recognition or may be manually invoked during user input . Since this architectural construct does not require previous architectural definitions , it can be used without other parts of the framework . 4.4 Supporting Architectures The “ Supporting Architectures ” refers to the base architectures of the modified data instance that are recognized by the management framework . The architecture of the information model , described in section 4.1 , may choose to be derived from the supporting architectures to enable certain processes such as workflow applications and Dublin Core discovery , etc . In our implementation , “ axe:index ” is used to identify the indexing termsso that indexing agents can use them as important hints when building indexes . Applications such as workflow processors or discovery engines that recognize specific metadata sets can also be built on top of this indexing architecture . their design efforts when constructing which may be used by various applications
Figure 10 . “ axe:index ” is used to define indexed terms ,
5 . Editing Framework The “ Editing Framework ” is a set of software agents or libraries that interpret the architectural information contained in template fragments and perform their actions respectively ; these actions include form recognition , template expansion and regular expression validation , etc . Some reusable DHTML interactions and HTML fragments are also included as part of the editing framework to help developers reduce interactive templates .
Figure 7 . Use “ axe:ref ” to reference to template fragments
Figure 8 . Screenshots of actual implementation
Besides the static architectural descriptions , developers may also implement JavaScript functions and bind them to HTML elements to enable users to manipulate the document structure ( and underlying data instance ) according to the developer ’s rules and constraints as shown in Figure 8 . typically remote services ,
In this section , we describe the major functions in the Editing Framework , how and when they are used , and the relationships between the Architectural Templates and the Management Framework . 5.1 Core API The core API consists of functions that take the architectural template as input and perform processes based on the base architectures of that template . There are three functions in our implementation , ExpandTemplate( ) , ExtractFormValue( ) and ValidateRegEx( ) , described as follows : ExpandTemplate( ) takes as inputs the original data instance and the architectural template derived from the underlying structure of the given data instance . The function then generates an HTML document with initial form values corresponding to the original data instance , and in a proper layout delineated by developers at design time . ExtractFormValue( ) takes as input the modified HTML fragment and separates the modified data instance from the layout . ValidateRegEx( ) takes any HTML fragment as input , and tries to check the validity of all form elements according to the regular expression constraints . 5.2 Messaging API The functions inthe messaging API are invoked at run time to interact with the Management Framework . Two operations , Get( ) and Put( ) are defined and used to fetch and send XML data instances . In our simple implementation,the location of the query broker and the listener are predefined bythe developer at design time . However , it is easy to change the destination of data submittal and the delivery mechanism once an XML document is obtained . Advanced messaging related topics such as data synchronization , security , service quality control , and message routing are beyond the scope of this paper . 5.3 DHTML Utilities Since the template implementation and run time interactions are both based on popular standards such as HTML and JavaScript , developers can encapsulate most frequently used HTML templates as separate include files , or use them as part of the shared library of the editing framework . In our implementation , several helper functions for DOM manipulation andseveral frequently used HTML fragments are provided to reduce the coding effort needed for developers using AXEFramework . 6 . The Management Framework The “ Management Framework ” consists of services that take the submitted data instances as input . These services identify the base architectures of the modified data instances and perform proper actions such as extracting terms , managing the index structure , sending event notification or performing other application specific processes . In this section , we describe the interfaces in our proof of concept implementation of the management framework . These are : the “ Listener ” , “ Indexing Engine ” and “ Query Broker ” . We will describe these interfaces in a platform independent manner , without discussing underlying implementation details .
6.1 Listener A listener is a subsystem of the management framework whose responsibility is to receive the modified data instances . While it is possible to use a standard mechanism such as HTTP PUT to receive the modified data , in our implementation , we choose to build a shared listening service in order to make it easier to manage the access control , history tracking , change notification and synchronization , etc . 6.2 Indexing Engine/XML Information Space The Indexing Engine takes a submitted data instance as input . It then recognizes the supporting architecture that describes the index structure and retrieves the indexed terms from the data instance ( see figure 10 ) . The indexed terms in each data instance form a multidimensional vector representing the logical address of the data instance in a Tuple Space(see figure 11 ) . Various publications the benefits of XML based TupleSpaces . Because the index keys and values are defined by the developers during construction of the architectural templates ( see section 4.4 ) , we do not need to rely on complicated statistical , language processing , or other to accurately index and search these data instances . information retrieval mechanisms
[ 18][13]discuss
Figure 11 . Applying simple filters on the indexed XML information space
6.3 Query Broker The query broker is responsible for responding to HTTP GET commands with query strings , and returning the requested data as an XML document . The format of the query strings is beyond the scope of this paper . As mentioned in section 6.1 , such a centralized interface for queries provides better supports for access control and auditing . The query broker may supports advanced operations such as Take( ) or Lease( ) [ 13][18 ] when required . The resulting XML can either be edited with the editing framework , or be directly viewed using simple style sheets . A full fledged management interface based on the query broker is depicted in figure 12 .
Figure 12 . A standard template to display and manage the query result
7 . Case Study Several implementations or partial implementations of systems utilizing the AXEFramework are described below to show how this framework may be used and how it may help us to improve the processes and functions of existing system .
7.1 DIGRAPH Editor ( Interacting with SVG ) In order to demonstrate the client side capabilities of this framework , we built a directed graph editor by utilizing a modified version of GraphViz[8 ] , originally developed by AT&T Research , Adobe SVG Viewer , and the AXEFramework . With this editor , users can create XML representations of directed graphs by clicking on pairs of vertices in the SVG view . The user can also edit titles and other properties of the nodes by interacting with form fields in an automatically generated HTML document . This document is continually updated to match to the structure of the digraph . Developers can customize the DIGRAPH editor for application specific purposes , giving semantic meaning to the digraphs produced . For instance , developers can create multiple substitution groups for various classes of edges and vertices ( see section 42 ) In a workflow application , for instance , each node may represent a stage of a process . The developer may then associate several scripting blocks with each node , and an access control list with each edge . These could be used to represent the actions to be performed at each stage and the criteria for moving on to the next stage . To customize this system , the developers build architectural templates to describe the types of information to be associated with nodes and edges . The system then utilizes the interaction capabilities of the AXEFramework , and custom binding code , to keep the SVG representation of the digraph in sync with the HTML form representation .
Figure 13 . User creates complex graph by clicking on the SVG diagram
7.2 PKC Content Portal The “ Personal Knowledge Center ” is a powerful personalized knowledge management platform based on the research of the Computer Systems and Communication Laboratory in Academia Sinica , Taiwan . It was originally designed for corporate or academic users who want to manage digitized content and bookmarks with strong full text indexing capability . We utilized the AXEFramework to provide a user interface for associating each element in the knowledge center with structured data , giving the user a more standardized , structured view of the knowledge base . By utilizing the AXEFramework , we drastically reduced the incremental effort required by the system developers to make subsequent changes to the data structures . describe the object properties in PKC
Figure 15 . Additional architectural templates to
8 . Discussions Today , almost all applications used in enterprise have some level of XML support . However , to use XML for data exchange may not help much because the descriptive power and extensibility is bounded by the underlying technologies such as RPC , object oriented method invocation , or relational database design . Hence , sometimes these applications and architectures are actually “ web tunneled ” rather than “ web based ” as they claimed .
In AXEFramework , we require the developers to turn the HTML structures of their web pages into self describable yet standards compliant document . Such a document describes how the page should look , how it should interact with users , how the information may be recognized and preserved by others parties , and how to address the generated data in a universal XML information space etc . In our model , we explicitly combine the form description with the description of the data being collected . This approach is in direct opposition to XForm ’s approach of separately specifying the structure of the data and the structure of the form . Our motivation for choosing this approach is that , by using architectural forms , we can easily and automatically extract the structure of the data from an appropriately marked up specification of the form itself , whereas it is non trivial to take a form specification and data structure specification and combine them . Thus , our approach reduces developer effort – they need only develop one template , and from it we can extract both the form structure and the data structure .
9 . Conclusion Most proposed forms standards today support many complex functions such as dynamic value calculation , strong typing , XMLSchema validation , multiple views , XML encryption and digital signatures . However , AXEFramework takes a different approach and specifies a high level architecture that can be used in conjunction with other libraries for additional features such as encryption , validation , event notification , etc . The primary contribution of this paper is the demonstration that the concept of architectural forms can be used to build a simple standards based framework for dynamic structured forms . This simple framework can be specified concisely , learned quickly , and deployed effectively for a wide variety of applications . Furthermore , since the framework is built as a set of loosely coupled libraries that can be used independently of each other , developers can choose to use only the components that they need – and , more importantly , need not spend any time learning the components that they don’t . We believe that a framework that an average programmer can learn and begin to use in a few hours will have a strong competitive advantage over more allencompassing frameworks with long , dense specifications . The source code for the Editing Framework is open source , and located on SourceForge . 10 . Future Works To keep a low learning curve and thus high adoptability , we believe that as few additions as possible should be made to this core framework . Instead , additional optional loosely coupled libraries should be designed to add additional features and functionalities . One major feature that we believe might be worthwhile to add to the core framework is the ability to generate attributes in the XML . Currently , all XML generated by the system uses childelements , to associate additional information with a node . Careful study of the additional complexity and additional learning curve demanded by this feature must be done to justify its addition . One example of a potential optional loosely coupled library that may be of great value is integration with Schematron[12 ] . Schematron is an assertion based validity checker that , unlike than attributes , rather most validation engines , is capable of generating user friendly reports to explain validation failures . AXEFramework is only a small step towards transforming the web into a machine understandable information space .
11 . References [ 1 ] A.3 Architectural Form Definition Requirements http://wwwornlgov/sgml/wg8/docs/n1920/html/claus e A3html
[ 2 ] Architectural Styles and the Design of Network based
Software Architectures http://wwwicsuciedu/~fielding/pubs/dissertation/top htm
[ 3 ] ECMAScript Specification Version 3 ftp://ftpecmach/ecma st/Ecma 262pdf
[ 4 ] Evolvability http://wwww3org/DesignIssues/Evolutionhtml [ 5 ] Extensible Forms Description Language ( XFDL ) 4.0 http://wwww3org/TR/NOTE XFDL
[ 6 ] Extensible Markup Language ( XML ) 1.0 ( Second Edition ) http://wwww3org/TR/REC xml
[ 7 ] Formsheets and the XML Forms Language , http://www ukhplhpcom/people/sth/doc/XFormhtml
[ 8 ] GraphViz http://wwwgraphvizorg
[ 9 ] HTML4.01 Specification http://wwww3org/TR/html4/
[ 10 ] It's All About Architectures Third International HyTime
Conference http://wwwinfoloomcom/gcaconfs/WEB/seattle96/srn 2.HTM
[ 11 ] Naming and Addressing : URIs , URLs , http://wwww3org/Addressing/
[ 12 ] Resource Directory ( RDDL ) for Schematron 1.5 http://xmlasccnet/schematron
[ 13 ] Tspaces http://wwwalphaworksibmcom/tech/tspaces
[ 14 ] XForms – The Next Generation of Web Forms http://wwww3org/MarkUp/Forms/
[ 15 ] XHTML FML 1.0 : Forms Markup Language http://wwwmozquitoorg/sources/spec_xhtml fmlhtml
[ 16 ] XML Forms Architecture Template http://wwww3org/1999/05/XFA/xfa templatehtml
[ 17 ] XML Linking Language ( XLink ) Version 1.0 http://wwww3org/TR/xlink/
[ 18 ] XMLSpaces for coordination in web based systems
Tolksdorf , R . ; Glaubitz , D . Enabling Technologies : Infrastructure for Collaborative Enterprises , 2001 . WET ICE 2001 . Proceedings . Tenth IEEE International Workshops on , 2001 Page(s ) : 322 327
