Quality Driven Web Services Composition
Liangzhao Zeng
Boualem Benatallah
Marlon Dumas
University of New South Wales
University of New South Wales
Queensland University of
Technology
Brisbane , Australia mdumas@quteduau
Sydney , Australia
Sydney , Australia zlzhao@cseunsweduau boualem@cseunsweduau
Jayant Kalagnanam IBM TJ Watson Research
Center
New York , USA jayant@usibmcom
ABSTRACT
The process driven composition of Web services is emerging as a promising approach to integrate business applications within and across organizational boundaries . In this approach , individual Web services are federated into composite Web services whose business logic is expressed as a process model . The tasks of this process model are essentially invocations to functionalities offered by the underlying component services . Usually , several component services are able to execute a given task , although with different levels of pricing and quality . In this paper , we advocate that the selection of component services should be carried out during the execution of a composite service , rather than at design time . In addition , this selection should consider multiple criteria ( eg , price , duration , reliability ) , and it should take into account global constraints and preferences set by the user ( eg , budget constraints ) . Accordingly , the paper proposes a global planning approach to optimally select component services during the execution of a composite service . Service selection is formulated as an optimization problem which can be solved using efficient linear programming methods . Experimental results show that this global planning approach outperforms approaches in which the component services are selected individually for each task in a composite service .
Categories and Subject Descriptors H35 [ Information Systems ] : Web based services
General Terms Management , Performance
Keywords Web services , QoS , Service Composition
1 .
INTRODUCTION
Web services technologies are emerging as a powerful vehicle for organizations that need to integrate their applications Copyright is held by the author/owner(s ) . WWW2003 , May 20–24 , 2003 , Budapest , Hungary . ACM 1 58113 680 3/03/0005 .
Quan Z . Sheng
University of New South Wales
Sydney , Australia qsheng@cseunsweduau within and across organizational boundaries . In particular , the process based composition of Web services is gaining a considerable momentum as an approach for the effective integration of distributed , heterogeneous , and autonomous applications [ 1 ] . In this approach , applications are encapsulated as Web services and the logic of their interactions is expressed as a process model . This approach provides an attractive alternative to hand coding the interactions between applications using general purpose programming languages . A Web service is a self described application that uses standard Internet technologies to interact with other Web services . An example of a Web service is a SOAP based interface to place bids in an auction house . Once deployed , services can be aggregated into composite services . An example of a composite service would be a \Travel Planner" system that aggregates multiple component services for flight booking , travel insurance , accommodation booking , car rental , and itinerary planning , which are executed sequentially or concurrently .
The process model underlying a composite service identifies the functionalities required by the services to be composed ( ie , the tasks of the composite service ) and their interactions ( eg , control flow , data flow , and transactional dependencies ) . Component services that are able to provide the required functionalities are then associated to the individual tasks of the composite services and invoked during each execution of the composite service .
The number of services providing a given functionality may be large and constantly changing . Consequently , approaches where the development of composite services requires the identification at design time of the exact services to be composed are inappropriate . The runtime selection of component services during the execution of a composite service has been put forward as an approach to address this issue [ 2 , 6 , 11 ] . The idea is that component services are selected by the composite service execution engine based on a set of criteria . However , previous approaches in this area have not identified a set of criteria ( other than price and application specific criteria ) for selecting Web services . In addition , existing service selection approaches adopt a local selection strategy , meaning that they assign a component service to an individual tasks , one at a time . As a result , these approaches are not able to handle global user con
411 straints and preferences . For example , the overall duration of the composite service execution should be minimized , or a given budget constraint should be satisfied .
In this paper , we present quality driven approach to select component services during the execution of a composite service . The salient features of our approach are : ffl A Web services quality model . We propose an extensible multi dimensional Web services quality model . The dimensions of this model characterize non functional properties that are inherent to Web services in general : execution price , execution duration , reputation , reliability , and availability . ffl Quality driven service selection . In order to overcome the limitations of local service selection outlined above , we propose a global planning approach . In this approach , quality constraints and preferences are assigned to composite services rather than to individual tasks within a composite service . Service selection is then formulated as an optimization problem and a linear programming method is used to compute optimal service execution plans for composite services . Experimental results show that the proposed service selection strategy significantly outperforms local selection strategies .
The rest of the paper is organized as follows . Section 2 presents the service composition model and defines some key concepts used throughout the paper . Section 3 defines the service quality criteria used for service selection and explains how the values of these quality criteria can be computed for a given service . Section 4 formulates the global service selection problem and describes a linear programming method to efficiently solve it . Section 5 presents a prototype implementation of the proposed approach , as well as a set of experiments comparing the global planning approach with the local selection approach . Finally , Section 6 discusses related work , and Section 7 draws some conclusions .
2 . WEB SERVICE COMPOSITION MODEL In this section , we will present some basic concepts in Web service composition first , then give some definitions on composite service execution planning .
2.1 Composite services and communities
A composite Web service is an umbrella structure aggregating multiple other elementary and composite Web services , which interact with each other according to a process model . Following our previous work [ 2 ] , we choose to specify the process model of a composite service as a statechart [ 12 ] . The choice of statecharts for specifying composite Web services is motivated by two main reasons : ( i ) statecharts have a well defined semantics ; and ( ii ) they offer the basic flow constructs found in contemporary process modeling languages ( ie , sequence , conditional branching , structured loops , concurrent threads , and inter thread synchronization ) . The first characteristic facilitates the application of formal manipulation techniques to statechart models , while the second characteristic ensures that the service composition mechanisms developed in the context of statecharts , can be adapted to other process modeling languages like , for example , those that are being designed by Web services standardization efforts ( eg , BPEL4WS , WSCI , BPML)1 . A statechart is made up of states and transitions . In the proposed composition framework , the transitions of a statechart are labeled with events , conditions , and assignment operations over process variables . States can be basic or compound . Basic states are labelled with invocations to Web services operations . Compound states contain one or several statecharts within them . Specifically , compound states come in two flavors : OR and AND states . An OR state contains a single statechart within it whereas an AND state contains several statecharts ( separated by dashed lines ) which are intended to be executed concurrently . Accordingly , OR states are used as a decomposition mechanism for modularity purposes , while AND states are used to express concurrency : they encode a fork/join pair . The initial state of a statechart is denoted by a filled circle , while the final state is denoted by two concentric circles : one filled and the other unfilled .
PSfrag replacements A simplified statechart W specifying a \Travel Planner" ti composite Web Service is depicted in Figure 1 . In this comtf posite service , a search for attractions is performed in partc allel with a flight and an accommodation booking . After td these searching and booking operations are completed , the distance from the hotel to the accommodation is computed , and either a car or a bike rental service is invoked . Note that when two transitions stem from the same state ( in this case the state t4 ) , they denote a conditional branching , and the transitions should therefore be labelled with disjoint conditions . Ws1 Ws2 Ws3 Ws4 Ws5 ( We1 ) ( We2 ) ( )
DrivingTimeCalculation
AttractionSearching
FlightTicketBooking
HotelBooking
Initial State
Final State t7
CarRental
Legend
State
And−state
Transition t6
BikeRental t3 t4 t1 t2 t5 t8
Figure 1 : Statechart of a composite service \Travel Planner"
A basic state2 of a statechart describing a composite service can be labelled with an invocation to either of the following : ffl An elementary Web service , ie , a service which does not transparently rely on other Web services . ffl A composite Web service aggregating several other ser vices . ffl A Web service community , ie , a collection of Web services with a common functionality although different non functional properties ( eg , with different providers , different QoS parameters , reputation , etc . )
The concept of Web service community addresses the issue of composing a large and changing collection of Web services . Service communities provide descriptions of a desired functionality ( eg , flight booking ) without referring to any actual service ( eg , Qantas flight booking Web service ) .
1See http://dev2devbeacom/techtrack/standardsjsp 2Also called task in remainder of this paper .
412 The set of members of a community can be fixed when the community is created , or it can be determined through a registration mechanism , thereby allowing service providers to join , quit , and reinstate the community at any time . When a community receives a request to execute an operation , this request is delegated to one of its current members . The choice of the delegatee is done at execution time based on the parameters of the request , the characteristics of the members , the history of past executions , and the status of ongoing executions . Sections 3 and 4 deal with the selection of delegatees during the execution of a composite service whose states are labelled with invocations to communities .
2.2 Execution paths and plans
In this section , we define two concepts used in the rest of the paper : execution path and execution plan . Definition 1 ( Execution path ) . An execution path of a statechart is a sequence of states [ t1 , t2 , tn ] , such that t1 is the initial state , tn is the final state , and for every state ti ( 1 < i < n ) , the following holds :
Definition 2 ( DAG representation of an execution path ) . Given an execution path [ t1 , t2 , tn ] of a statechart ST , the DAG representation of this execution path is a graph obtained as follows : ffl The DAG has one node for each task t1 , t2 , tn . ffl The DAG contains an edge from task ti to task tj iff tj is a direct successor of ti in the statechart ST . fi
If a statechart diagram contains conditional branchings , it has multiple execution paths . Each execution path represents a sequence of tasks to complete a composite service execution . Figure 2 gives an example of a statechart ’s execution paths . In this example , since there is one conditional branching after task t4 , there are two paths , called We1 and We2 respectively . In execution path We1 , task t6 is executed after task t5 , while in execution path We2 , task t7 is executed after task t5 . ffl ti is a direct successor of one of the states in [ t1,,ti,1 ] is not a direct successor of any of the states in ffl ti
PSfrag replacements ti tf ta1 ta2
[ ti+1,,tn ] t1 t2      
      t3 t2 t3 t8 t8 t6 t5 t4
Execution Path 1
( We1 ) t5 t4 t7
Execution Path 2
( We2 )
Figure 2 : DAG representation of the execution paths of the statechart of Figure 1 .
As stated before , the basic states of a statechart describing a composite service can be labelled with invocations to communities . If this is the case , actual Web services ( ie , members of communities ) need to be selected during the execution of the composite service . Hence , it is possible to execute a path in very different ways by allocating different Web services to the states in the path . The concept of execution plan defined below captures the various ways of executing a given execution path . Definition 3 ( Execution plan ) . A set of pairs p = f< t1 ; si1 > ; < t2 ; si2 > ; : : : ; < tN ; siN >g is an execution plan of an execution path We iff : ffl ft1 , t2 , tNg is the set of tasks in We . ffl For each 2 tuple < tj ; sij > in p , service sij is assigned the execution of task tj . t1
Ws1 Ws2 Ws3 Ws4 Ws5
( ) ffl There is no state tj in [ t1 , , ti,1 ] such that tj and ti belong to two alternative branches of the statechart . ffl If ti is the initial state of one of the concurrent regions of an AND state AST , then for every other concurrent region C in AST , one of the initial states of C appears in [ t1 , , ti,1 , ti+1 , , tn ] . In other words , when an AND state is entered , all its concurrent branches are executed . fi
This definition relies on the concept of direct successor of a state . A basic state tb is a direct successor of another basic state ta if there is a sequence of adjacent transitions3 going from ta to tb without traversing any other basic state . In other words , the first transition in the sequence stems from ta , the last transition leads to tb , and all intermediate transitions stem from and lead to either compound , initial , or final states , but are not incident to a basic state .
It is straightforward to see that an acyclic statechart has a finite number of execution paths . To simplify the presentation , we initially assume that all the statecharts that we deal with are acyclic . If a statechart contains cycles , a technique for \unfolding" it into an acyclic statechart needs to be applied beforehand . The method used to unfold the cycles of a statechart is to examine the logs of past executions in order to determine the average number of times that each cycle is taken . The states appearing between the beginning and the end of the cycle are then cloned as many times as the cycle is taken in average . Details about this unfolding process are omitted for space reasons .
Under the assumption that the underlying statechart is acyclic , it is possible to represent an execution path of this statechart as a Directed Acyclic Graph ( DAG ) as follows .
3Two transitions are adjacent if the target state of one is the source state of the other . fi
413 3 . WEB SERVICE QUALITY MODEL
In a Web environment , multiple Web services may provide similar functionalities with different non functional property values ( eg , different prices ) . In the composition model presented in the previous section , such Web services will typically be grouped together in a single community . To differentiate the members of a community during service selection , their non functional properties need to be considered . For this purpose , we adopt a Web services quality model based on a set of quality criteria ( ie non functional properties ) that are transversal to all Web services , for example , their pricing and reliability . Although the adopted quality model has a limited number of criteria ( for the sake of illustration ) , it is extensible : new criteria can be added without fundamentally altering the service selection techniques built on top of the model . In particular , it is possible to extend the quality model to integrate non functional service characteristics such as those proposed in [ 22 ] , or to integrate service QoS metrics such as those proposed by [ 25 ] .
In this section , we first present the quality criteria in the context of elementary services , before turning our attention to composite services . For each criterion , we provide a definition , indicate its granularity ( ie , whether it is defined for an entire service or for individual service operations ) , and provide rules to compute its value for a given service .
3.1 Quality Criteria for Elementary Services We consider five generic quality criteria for elementary services : ( 1 ) execution price , ( 2)execution duration , ( 3 ) reputation , ( 4 ) reliability , and ( 5 ) availability . ffl Execution price . Given an operation op of a service s , the execution price qprice(s ; op ) is the amount of money that a service requester has to pay for executing the operation op . Web service providers either directly advertise the execution price of their operations , or they provide means to enquire about it . ffl Execution duration . Given an operation op of a service s , the execution duration qdu(s ; op ) measures the expected delay in seconds between the moment when a request is sent and the moment when the results are received . The execution duration is computed using the expression qdu(s ; op ) = Tprocess(s ; op ) + Ttrans(s ; op ) , meaning that the execution duration is the sum of the processing time Tprocess(s ; op ) and the transmission time Ttrans(s ; op ) . Services advertise their processing time or provide methods to enquire about it . The transmission time is estimated based on past executions of the service operations , ie , Ttrans(s ; op ) = , where Ti(s ; op ) is a past observation of the transmission time , and n is the number of execution times observed in the past . i=1 Ti(s;op )
Pn n ffl Reliability . The reliability qrel(s ) of a service s is the probability that a request is correctly responded within a the maximum expected time frame ( which is published in the Web service description ) . Reliability is a technical measure related to hardware and/or software configuration of Web services and the network connections between the service requesters and providers . The value of the reliability is computed from historical data about past invocations using the
Table 1 : Aggregation functions for computing the QoS of execution plans
Criteria
Aggregation function
Qdu(p ) = CP A(qdu(s1 ; op1 ) ; :: : ; qdu(sN ; opN ) ) i=1 qprice(si ; opi )
Price Duration Reputation Qrep(p ) = 1 Qrel(p ) = ffN Reliability Availability Qav(p ) = ffN
Qprice(p ) = PN N PN i=1 qrep(si ) i=1(eqrel ( si)fizi ) i=1(eqav ( si)fizi ) expression qrel(s ) = Nc(s)=K , where Nc(s ) is the number of times that the service s has been successfully delivered within the maximum expected time frame , and and K is the total number of invocations . ffl Availability . The availability qav(s ) of a service s is the probability that the service is accessible . The value of the availability of a service s is computed using the following expression qav(s ) = Ta(s)= , where Ta is the total amount of time ( in seconds ) in which service s is available during the last seconds ( is a constant set by an administrator of the service community ) . The value of may vary depending on a particular application . For example , in applications where services are more frequently accessed ( eg , stock exchange ) , a small value of gives a more accurate approximation for the availability of services . If the service is less frequently accessed ( eg , online bookstore ) , using a larger value is more appropriate . Here , we assume that Web services send notifications to the system about their running states ( ie , available , unavailable ) . ffl Reputation . The reputation qrep(s ) of a service s is a measure of its trustworthiness . It mainly depends on end user ’s experiences of using the service s . Different end users may have different opinions on the same service . The value of the reputation is defined as the average ranking given by to the service by end users , , where Ri is the end user ’s ranking on a service ’s reputation , n is the number of times the service has been graded . Usually , the end users are given a range to rank Web services , for example , in Amazon.com , the range is [ 0 ; 5 ] . ie , qrep = Pn i=1 Ri n
Given the above quality criteria , the quality vector of a service s is defined as follows : q(s ) = ( qprice(s ) ; qdu(s ) ; qav(s ) ; qre(s ) ; qrep(s ) )
( 1 )
Note that the method for computing the value of the quality criteria is not unique . The global planning model presented Section 4 is independent of these methods .
3.2 Quality Criteria for Composite Services
The above quality criteria are also applied to evaluate the QoS of composite services . Table 1 provides aggregation functions for the computation of the QoS of a composite service CS when executed using plan p = f< t1 ; si1 > ; < t2 ; si2 > ; : : : ; < tN ; siN >g . A brief explanation of each criterion ’s aggregation function follows :
414 PSfrag replacements ta1 ta2 ti tf s13 s28 s35 s49 s52 Ws1 Ws2 Ws3 Ws4 Ws5 ( We1 ) ( We2 ) ( ) ffl Execution price : The execution price Qprice(p ) of an execution plan p is a sum of every service si ’s execution price qprice(si ; opi ) . ffl Execution duration : The execution duration Qdu(p ) of an execution plan p is computed using the Critical Path Algorithm ( CPA ) [ 23 ] . Specifically , the CPA is applied to the the execution path of execution plan p , seen as a project digraph . The critical path of a project digraph is a path from the initial state to the final state which has the longest total sum of weights labelling its nodes . In the case at hand , the weights labelling the nodes correspond to the maximum expected execution durations . A task that belongs to the critical path is a critical task , while a service that belongs to the critical path is a critical service .
Figure 3 provides an example of critical path . In this example , the project digraph represents execution path We1 and its execution plan p , where p=f < t2 ; s23 > , < t3 ; s38 > , < t4 ; s45 > , < t5 ; s59 > , < t6 ; s62 > g . Each task ’s execution duration is given in the project digraph . There are two project paths in this project digraph , where project path 1 is < t2 ; t5 ; t6 > and project path 2 is < t3 ; t4 ; t5 ; t7 > . The total execution time of project path 1 ( project path 2 ) is 37 seconds ( 62 seconds ) . Since project path 2 ’s total execution duration is longer than that of project path 1 , the critical path for the project digraph is project path 2 . Thus , the execution plan ’s total execution duration is 62 seconds . Task t3 , t4 , t5 and t7 are critical tasks . Services s38 , s45 , s59 and s62 are critical services . t1 s23 , 20 Seconds t2 t3 s38 , 25 Seconds t6 s62 , 15 Seconds t8 t5 s59 , 2 Second t4 s45 , 20 Second
Legend : critical path of project digraph critical task critical service
   
   
Figure 3 : Critical Path ffl Reputation : The reputation Qrep(p ) of an execution plan p is the average of each service si ’s reputation qrep(si ) in the execution plan p . ffl Reliability : Reliability Qrel(p ) of an execution plan p is a product of eqrel(si )fizi . In the aggregation function , zi is equal to 1 if service si is a critical service in the execution plan p , or 0 otherwise . If zi = 0 , ie , service si is not a critical service , then eqrel ( si)fizi = 1 , and hence , the reliability of service si will not affect the value of execution plan ’s reliability . ffl Availability : The availability Qav(p ) of an execution plan p is a product of eqav ( si )fizi , where qav(si ) is service si ’s availability .
Using above aggregation functions , the quality vector of a composite service ’s execution plan is defined as :
Q(p ) = ( Qprice(p ) ; Qdu(p ) ; Qav(p ) ; Qre(p ) ; Qrep(p ) )
( 2 )
4 . GLOBAL SERVICE SELECTION
As mentioned before , in existing approaches , the selection of component service to execute a task is determined independently to other tasks of composite services [ 2 , 11 , 6 ] . More precisely , in our previous work [ 2 ] , service selection is done at each service community locally . The selection of a service is based on a selection policy involving parameters of the request , the characteristics of the members , the history of past executions , and the status of ongoing executions . Although service selection can be locally optimized , the global quality constraints may not be satisfied . For example , a global constraint such as composite services’ execution price is less than 500 dollars can not be enforced . In this section , we present a global planning based approach for Web services selection . We first present an approach of selecting an optimal execution plan for a composite service , then present a novel linear programming based method for optimal execution plan selection .
4.1 Selecting an Optimal Execution Plan
The basic idea of global planning is the same as query optimization in database management systems . Several plans are identified and the optimal plan is selected . The foregoing discussion makes it clear that a statechart has multiple execution paths and each execution path has its own set of execution plans if the statechart contains conditional branchings . In this subsection , we assume that the statechart does not contain any conditional branchings and has only one execution path . We will discuss the case where a statechart has multiple execution paths in Section 42
We also assume that for each task tj , there is a set of candidate Web services Sj that are available to which task tj can be assigned . Associated with each Web service sij is a quality vector ( see equation 1 ) . Based on the available Web services , by selecting a Web service for each task in an execution path , the global planner will generate a set of execution plans P :
P = fp1 ; p2 ; :: : ; png
( 3 ) n is the number of execution plans . After a set of execution plans is generated , the system needs to select an optimal execution plan . When selecting the execution plan , instead of computing the quality vector of a particular Web service , each execution plan ’s global service quality vector needs to be computed .
The selection of execution plan uses Multiple Attribute Decision Making ( MADM)[16 ] approach . Once the quality vector for each execution plan is derived , by accumulating all the execution plans’ quality vectors , we obtain matrix Q , where each row represents an execution plan ’s quality vector .
Q1;1 Q1;2 Q2;1 Q2;2 Qn;1 Qn;2
: : : Q1;5 : : : Q2;5 : : : Qn;5
Q =0 BBB@
1 CCCA
( 4 )
415 A Simple Additive Weighting ( SAW ) [ 4 ] technique is used to select an optimal execution plan . Basically , there are two phases in applying SAW : 411 Scaling Phase
Some of the criteria used could be negative , ie , the higher the value is , the lower the quality is . This includes criteria such as execution time and execution price . Other criteria are positive criteria , ie , the higher the value is , the higher the quality is . For negative criteria , values are scaled according to Equation 5 . For positive criteria , values are scaled according to Equation 6 . j j j
,Qi;j ,Qmin
Qmax 1
Vi;j =( Qmax Vi;j =( Qi;j ,Qmin
Qmax 1
,Qmin j j j if Qmax if Qmax j j , Qmin j , Qmin j , Qmin j , Qmin j if Qmax if Qmax
6= 0 j = 0
6= 0 j = 0 j = 1 ; 2
( 5 ) j = 3 ; 4 ; 5 ( 6 ) j j j j and Qmin
In the above equations , Qmax criterion in matrix Q , ie , Qmax Qmax ie , Qmin is maximal value of a quality = M ax(Qi;j ) ; 1 i n . is minimal value of a quality criterion in matrix Q , j = M in(Qi;j ) ; 1 i n . In fact , we can compute Qmax without generating all possible execution plans . For example , in order to compute the maximum execution price ( ie , Qmax price ) of all the execution plans , we select the most expensive Web service for each task and sum up all these execution prices to compute Qmax price . In order to compute the minimum execution duration ( ie , Qmin du ) of all the execution plans , we select the Web service that has shortest execution duration for each task and use CPA to compute Qmin du . The computation cost of Qmax is polynomial . and Qmin j j j
After the scaling phase , we obtain the following matrix :
0
Q
0
Q
=0 BBB@
V1;1 V1;2 V2;1 V2;2 Vn;1 Vn;2
: : : V1;5 : : : V2;5 : : : Vn;5
412 Weighting Phase
1 CCCA
The following formula is used to compute the overall qual ity score for each execution plan :
5
( Vi;j fi Wj )
( 7 )
Score(pi ) =
Xj=1 where Wj 2 [ 0 ; 1 ] and P5 j=1 Wj = 1 . Wj represents the weight of each criterion . In ( 7 ) , end users can give their preference on QoS ( ie , balance the impact of the different criteria ) to select a desired execution plan by adjusting the value of Wj . The global planner will choose the execution path which has the maximal value of Score(pi ) ( ie , max(Score(pi)) ) . If there are more than one execution plans which have the same maximal value of Score(pi ) , then an execution plan will be selected from them randomly . where statecharts have multiple execution paths . Assume that a statechart has n execution paths . For each execution path , an optimal execution plan can be selected . So , the global planner has n selected execution plans . Since each selected optimal execution plan only covers a subset of the entire statechart , then the global planner needs to aggregate these n execution plans into an overall execution plan to covers all the tasks in the statechart . This overall execution plan will be used to execute the statechart . For example , for travel planner statechart W ( see Figure 1 ) , there are two execution paths We1 and We2 . The optimal execution plans p1 and p2 of these two execution paths are selected . From the Figure 2 , it can be seen that both execution paths We1 and We2 are subsets of W . Thus neither p1 nor p2 covers all tasks in W . Since the global planner conducts planning before the execution time , it does not know which execution path will eventually be used for the composite service . Therefore it needs to aggregate p1 and p2 into an overall execution plan which covers all the tasks in W .
Assume that statechart W has k tasks ( ie , t1 , t2 , , tk ) and n execution paths ( ie , We1 , We2 , , Wen ) . Thus , for each execution path , the global planner selects an optimal execution plan . Consequently , we obtain n optimal execution plans ( ie , p1 ; p2 ; :: : ; pn ) for these execution paths . The global planner adopts the following approach to aggregate multiple execution plans into an overall execution plan .
1 . Given a task ti , if ti only belongs to one execution path ( eg , Wej ) , then the global planner selects Wej ’s execution plan pj to execute the task ti . We denote this as ti(pj ) . For example , in trip planning statechart , task t7 ( ie,CarRental ) only belongs to execution path We2 . In this case , We2 ’s execution plan p2 is used to execute t7 , ie , t7(p2 ) .
2 . Given a task ti , if ti belongs to more than one execution paths ( eg , Wej , Wej+1 , , Wem ) , then there is a set of execution plans ( ie , pj , pj+1 , , pm ) that can be used to execute Wsi . In this case , the global planner needs to select one of the execution plans from pj , pj+1 , , pm . The selection can be done by identifying the hot path for task ti . Here , the hot path of a task ti is defined as the execution path that has been most frequently used to execute task ti in the past . For example , in travel planner statechart , task t3 ( FlightTicketBooking ) belongs to both execution path We1 and We2 . Assume that the statechart W has been used to execute the composite service for 25 times . Also assume that , in 20 times the execution of the composite service follows the execution path We1 ; while in 5 times , the execution of the composite service follows the execution path We2 . This indicates that execution path We1 has been more frequently used to execute task t3 ( ie , We1 is the hot path for t3 ) . Thus , We1 ’s execution plan p1 is used to execute t3 , ie , t3(p1 ) .
The system keeps composite service execution traces in an execution history [ 10 ] . This allows the global planner to identify hot path for each task .
4.2 Handling Multiple Execution Paths
4.3 Linear Programming Solution
In Section 4.1 , we assume that the statechart only has one execution path . In this subsection , we discuss the case
The approach of selecting an optimal execution plan given in the previous section requires the generation of all possible
416 execution plans . Assume that there are N tasks in a statechart and there are M potential Web services for each task . The total number of execution plans is M N . The computation cost of selecting an optimal execution plan is O(M N ) . Such an approach is impractical for large scale composite services , where both the number of tasks in the composite services and the number of candidate Web services in communities are large . For example , assume that a composite service has one execution path and 10 tasks , and for each task , there are 10 candidate Web services . Then the total number of execution plans is 1010 . It is very costly to generate all these 1010 plans and select an optimal one . In this subsection , we present a method based on linear programming ( LP ) [ 15 ] , which can be used to select an optimal execution plan without generating all the possible execution plans .
There are three inputs in LP : variables , an objective function and constraints on the variables , where both the objective function and constraints must be linear . LP attempts to maximize or minimize the value of the objective function by adjusting the values of variables based on the constraints . The output of LP is the maximum ( or minimum ) value of the objective function as well as the values of variables at this maximum or minimum point .
In order to use LP to select an optimal execution plan , we model the selection of an optimal execution plan as an LP problem . The variables of the LP problem are yij representing the participation of service sij in the selected execution plan . The value of each variable yij is 1 if service sij is in the selected plan , 0 otherwise . The objective function of the LP problem , which is based on equations 5,6 , and 7 , is :
5
Xl=3 Qi;l , Qmin
Qmax
, Qmin l l l fi Wl!! ( 8 ) j=1 Wj = 1 . Wl is the weight fi Wl! + l l
Qmax
, Qi;l , Qmin
Xl=1 Qmax
M ax 2 where Wl 2 [ 0 ; 1 ] and P5 assigned to quality criteria l . l
In the following subsections , we discuss the constraints on the variables of the LP problem .
431 Constraints on Execution Duration and
Execution Price
In this subsection , we consider constraints on the execution duration and the execution price of an execution plan . Assume that A is the set of all tasks ( ie , basic states ) of the statechart . For each task tj , there is a set of Web services Sj that can be assigned to this task , but on the end , for each task tj , only one Web service should be selected . Given that yij ( yij = 0 or 1 ) denotes the participation of Web service sij in the selected plan , this latter fact is captured by the following constraints : yij = 1 ; 8j 2 A
Xi2Sj
( 9 )
For example , there are 100 potential Web services that can execute task j , since only one of them will be selected to execute the task j , then we have P100
Assume that variable xj represents the earliest start time of task tj , variable pj represents the execution duration for task j , and variable pij represents the execution duration for task tj by service sij . We use the notation tj ! tk to denote that task tk is task tj ’s direct successor task . We i=1 yij = 1 . have the following constraints : pij yij = pj ; 8j 2 A
Xi2Sj xk , ( pj + xj ) 0 ; 8tj ! tk ; j ; k 2 A Qdu , ( xj + pj ) 0 ; 8j 2 A
( 10 )
( 11 ) ( 12 )
Constraint 10 indicates that the execution duration of a given task tj is equal to the execution duration of one of the Web services in A . Constraint 11 captures the fact that if task tk is a direct successor of task tj , the execution of task tk must start after task tj has been completed . Constraint 12 indicates that the execution of a composite service is completed only when all its tasks are completed .
Assume that zij is an integer variable that has value 1 or 0 : 1 indicates that Web service sij is a critical service and 0 indicates otherwise . We have the following constraint on execution plan ’s execution duration Qdu :
Qdu = Xj2A Xi2Sj pijzij
( 13 )
For execution price , assume that variable cij represents the execution price of Web service sij , then we have the following constraint on total execution price of composition service :
Qprice = Xj2A Xj2Sj cij yij
An alternative of constraint 14 is as follows :
Xj2A Xj2Sj cij yij B ; B > 0
( 14 )
( 15 ) where B is the budget constraint given by the user . This constraint indicates that the entire composite service ’s execution price can not be greater than B . By introducing a budget constraint the above problem needs to be explicitly solved as an integer programming problem . This problem is a special case of the knapsack problem and hence it is NP hard [ 19 ] . Notice that constraints on other criteria can be easily incorporated into LP if the aggregation function is a linear function . For example , assume that variable rij represents the reputation of Web service sij , we can have the following constraint on the execution plan ’s reputation :
Qrep = Xj2A Xj2Sj rij yij
( 16 )
432 Constraints on Reliability and Availability
In this subsection , we consider constraints on criteria where the aggregation function is not a linear function . Among the criteria that are used to select Web services , both the availability ’s and the reliability ’s aggregation functions are non linear ( see Table 1 ) . We can linearize them using a logarithm function as shown below . Assume that variable aij represents the reliability of Web service sij . Since zij indicates whether Web service sij is a critical service or not , the reliability of execution plan is :
Qrel = ffj2A0 @Xj2Sj eaij zij1 A
417 By applying the logarithm function ln , we obtain :
Since Pj2A zij = 1 and zij = 0 or 1 , we obtain : ln(Qrel ) = Xj2A ln(Qrel ) = Xj2A ln0 @Xj2Sj 0 @Xj2Sj eaij zij1 A aijzij1 A
0
Let Q execution plan ’s reliability : rel = ln(Qrel ) , we have the following constraint on the
5 l l
Qmax
, Qi;l , Qmin
Xl=0 Qmax
M ax 2 where Q0 = 2 the deviation of the total execution duration .
Xl=3 Qi;l , Qmin du and W0 2 [ 0 ; 1 ] is the weight assigned to fi Wl! + fi Wl!! ( 22 )
Qmax
, Qmin l l l l
Given the above inputs for the LP problem , the output of the LP solver will be a set of values for variables yij , which indicate the selection or exclusion of Web services sij . The selected Web services compose an optimal execution plan .
5 . VALIDATION
Q
0 rel = Xj2A Xj2Sj aij zij
( 17 )
In this section , we present the implementation of the QoSdriven selection of services and some experimental results to evaluate the proposed approach .
Similarly , assuming that bij represents the availability of the Web service sij , the following constraint is introduced :
5.1 Implementation
Q
0 av = Xj2A Xi2Sj bijzij
( 18 ) where Q
0 av = ln(Qav ) .
Criteria that can be introduced into the LP problem are not limited to what we defined in Section 3 . Other criteria can be added once the aggregation functions are given .
433 Constraints on Uncertainty of Execution
Duration
In the previous sections , we assume that the execution durations pij of Web services are deterministic . In reality , the execution duration of a Web service sij may be uncertain . For example , Service s may advertise that the execution duration is 5 seconds , but the actual execution duration may be 4.5 , 4.6 , or 5.2 seconds . To address this issue , we model each pij using a normal distribution . Variable pij has therefore the following probability function : f ( x ) =
1 p2 exp ,
1
2 x ,
2 ; ,1 < x < 1 where the mean and the std . deviation are given by : n
1 n xi
Xi=1 ( xi , )2
= n
Xi=1
2 =
1 n , 1
( 19 )
( 20 )
By applying formulas 19 and 20 to the execution logs of a Web service sij , we can obtain ij and ij for this Web pij zij = Qdu , the total execution duration Qdu must follow a normal distribution4 whose deviation du is : service . Since Pi2APi2Sj
2 du =Xi2A Xi2Sj
2 ij zij
( 21 )
So in order to consider the deviation of the total execution duration in the LP problem , we should adopt the following objective function : 4A detailed proof can be found in [ 26 ] .
The proposed QoS driven selection technique is implemented in the SELF SERV prototype . Detailed description of SELF SERV can be found in [ 24 ] . In this section , we briefly overview the prototype architecture and discuss its extension to support the service selection approach . The prototype architecture ( Figure 4 ) features an interface , a service manager and a pool of services . Services communicate via Simple Object Access Protocol ( SOAP ) messages . The service manager consists of four modules , namely the service discovery engine , the service editor , the composite service orchestrater and the global planner . The service discovery engine facilitates the advertisement and location of services . It is implemented using the Universal Description , Discovery and Integration ( UDDI ) , the Web Service Description Language ( WSDL ) , and SOAP . In the implementation , we make extensive use of the IBM Web Services Toolkit 2.4 ( WSTK2.4 ) [ 14 ] , which is a showcase package for Web services emerging technologies .
The service editor provides facilities for defining new services and editing existing ones . A service is edited through a visual interface , and translated into an XML document for subsequent analysis and processing by the service orchestrater . The orchestrater is responsible for scheduling , initiating , and monitoring the invocations to the tasks of a composite service during its execution , and for routing events and data items between these components .
Finally , global planner is the module that plans the execution of a composite service using the global planning based approach . The global planner is implemented as a linear programming solver based on IBM ’s Optimization Solutions and Library ( OSL ) [ 13 ] . It should be noted that QoS information is retrieved via pre defined operations of services ( eg , getExecutionTime() ) .
5.2 Experimentation
We conducted experiments using the implemented prototype system to evaluate our approach . In the experiments , a cluster of PCs were used to run the prototype system . All PCs have the same configuration of Pentium III 933MHz with 512M RAM . Each PC runs Windows 2000 , Java 2 Edition V130 , and Oracle XML Developer Kit ( Oracle XDK , for XML parsing ) . They are connected to a LAN through 100Mbits/sec Ethernet cards . This section presents two experimental results . The first experiment compares the QoS
418 Service Manager
Service Discovery Engine
User
Web−based Interface requests/results
Service Builder
Service Advertisements
Composite Service Orchestrator
Service Discovery
UDDI
Registry
Global Planner
Communication Bus
Composite Services
CS1
CS2 is composed of
Communities
C1
C2
C3 is member of
CS3
Elementary Services
ES1
ES2
ES3
ES4
Figure 4 : Architecture of the prototype . metrics of the execution of composite services using the global planning and local selection approaches . The second experiment shows the system costs ( ie , computation cost and bandwidth cost ) of these two approaches .
521 QoS Metrics
The purpose of this experiment is to compare the QoS values of the global planning approach with that of the local selection . The comparison was done by measuring price and execution time of the composite services using both approaches . In the experiment , we created several composite services with different number of basic states . The services were created by randomly adding states to the composite service shown in Figure 1 . The number of states ranges over the values 10 , 20 , 30 , 40 , 50 , 60 , 70 , and 80 . For each composite service , we executed the service 12 times and recorded the price and execution time . Since we obtained similar experimental results for all created composite services , only the result of one composite service ( with 20 states ) is shown ( see Table 2 ) for clarity reasons .
From the table , we can see that for every instance of the composite service , the global planning approach gives better QoS than local selection approach . For example , for the instance 7 of Table 2 , the time required to execute the composite service is : ( i ) 6451 seconds in the global planning approach , ( ii ) 9480 seconds in the local selection approach . Similarly , the execution price spends for executing this composite service is : ( i ) 1231 dollars in the global planning approach , ( ii ) 1789 dollars in the local selection approach . Overall , the average execution time ( resp . , execution price ) is : ( i ) 6627.2 seconds ( resp . , 1191 dollars ) in the global planning approach , ( ii ) 9305.9 seconds ( resp . , 1753 dollars ) in the local selection approach .
522 System Costs
The aim of this experiment is to investigate the system costs of executing composite services using the LP based global planning and local selection approaches . The experiment was done by measuring : ( i ) computation cost ( ie , time used for selecting a Web service for each task of the composite service ) ; ( ii ) bandwidth cost ( ie , network bandwidth consumed between global planner and Web services ) .
Instance Qtime(W ) ( second ) Qprice(W ) ( dollar )
No 1 2 3 4 5 6 7 8 9 10 11 12
Average :
Global 6523.2 6634.4 6843.2 6432.5 6347.3 6512.3 6451.2 6440.5 6970.4 6890.3 6590.3 6890.3 6627.2
Local 8322.4 9123.9 9234.5 9292.2 8943.3 9902.8 9480.4 9470.5 9920.4 9628.3 9520.3 8920.5 9305.9
Global 1023 1117 1123 1132 1121 1185 1231 1275 1324 1235 1267 1250 1191
Local 1642 1728 1825 1824 1723 1888 1789 1787 1625 1759 1852 1599 1753
Table 2 : The QoS of a composite service with 20 states
In the experiment , we created several composite services with different number of tasks . The services were created by randomly adding states to the composite service shown in Figure 1 . The number of tasks ranges over the values 10 , 20 , 30 , 40 , 50 , 60 , 70 , and 80 . In addition , we created a set of Web services which were assigned to tasks of composite services as the candidate Web services . For each task , the number of candidate Web services we used varies as follows : 5 , 10 , 20 , and 40 services . We executed composite services with different number of states and candidate Web services . The computation and bandwidth costs for selecting Web services were recorded . The results for composite services with 40 candidate Web services of each state are shown in figures 5 and 6 respectively . Similar results were obtained for other cases .
From Figure 5 , we can see that for both global and local selection approaches , the computation cost increases when the number of tasks and the number of candidate Web services increases . As expected , the computation cost of global planning approach is a little bit higher than that of local selection approach . For example , a composite service with 40 tasks spends : ( i ) 1.6 seconds for selecting Web services in global planning approach , ( ii ) 0.7 seconds in local selection approach .
419 ) s d n o c e s n i ( t s o C n o i t a t u p m o C
8
7
6
5
4
3
2
1
0
Statechart has one execution path
Global Planning Local Selection
10
20
30
40
50
60
70
80
Number of Tasks in Statecharts
Figure 5 : The computation cost of selecting services for composite services ( each state has 40 candidate Web services )
Statechart has one execution path
Global Planning Local Selection
3500
3000
) s e
2500 t y B K n i ( t s o C h d w d n a B i t
2000
1500
1000
500
0
10
20
30
40
50
60
70
80
Number of Tasks in Statecharts
Figure 6 : The bandwidth cost of selecting service for composite services ( each state has 40 candidate Web services )
Similar observations are found regarding bandwidth cost . More specifically , for both approaches , the linear increase of the number of tasks and the number of candidate Web services leads almost a linear increase of bandwidth cost ( see Figure 6 ) . The bandwidth cost in global planning is slightly higher than that of local selection approach . For example , a composite service with 40 tasks consumes about 2080 KBytes of network bandwidth for selecting Web services in global planning approach , while it consumes 1910 KBytes in local selection approach .
6 . RELATED WORK
In this section , we briefly discuss the relationships between our work and existing Web service standards , Web service composition approaches , and QoS driven workflow management .
Several standardisation proposals aiming at providing infrastructure to support Web services composition have recently emerged including SOAP , WSDL , UDDI , and BPEL4WS . SOAP defines an XML messaging protocol for communication among services . WSDL is an XML based language for describing web service interfaces . UDDI provides the directory and a SOAP based API to publish and discover services . Finally , BPEL4WS provides a language for process based service composition . Other proposed notations for service description and composition include ebXML and DAML S . The above proposals however are complementary to ours . Indeed , our proposal aims at leveraging the above standards ( eg , SOAP , UDDI ) to provide a qualitydriven and dynamic service composition model .
Web service composition is a very active area of research and development [ 1 , 7 , 8 ] . Previous efforts in this area such as CMI [ 11 ] and eFlow [ 6 ] have investigated dynamic service selection based on user requirements . In particular , CMI ’s service definition model features the concept of a placeholder activity to cater for dynamic composition of services . A placeholder is an abstract activity replaced at runtime with a concrete activity type . A selection policy is specified to indicate the activity that should be executed in lieu of the placeholder . In eFlow , the definition of a service node contains a search recipe represented in a query language . When a service node is invoked , a search recipe is executed in order to select a reference to a specific service . Both CMI and eFlow focus on optimizing service selection at single task level ( ie local selection ) . In addition , no QoS model is explicitly supported . In contrast , our approach focuses on optimizing service selection at a composite service level , based on a generic QoS model , and using established linear programming techniques .
Related work on QoS has been conducted in the area of workflow . In particular , there are a number of research proposals addressing the specification and verification of temporal constraints in workflows [ 9 , 3 ] . Other proposals such as METEOR [ 5 ] and CrossFlow [ 18 , 17 ] have considered QoS models with other parameters than time . Specifically , [ 5 ] considers four quality dimensions , namely time , cost , reliability and fidelity . However , it does not consider the dynamic composition of services . Instead , it focuses on analyzing , predicting , and monitoring QoS of workflow processes . Similarly , [ 18 ] proposes the use of continuous time Markov chain to estimate execution time and cost of a workflow . Closer to our proposal is the one reported in [ 17 ] , which explores the issue of dynamically selecting several alternative tasks within a workflow , based on quality parameters , in a similar way as eFlow does using search recipes . As stated before , this local selection strategy contrasts with the global planning approaches that we advocate .
Other related research proposals include [ 20 , 21 ] , which focus on data quality management in cooperative information systems . They investigate techniques to select best available data from different service providers based on a set of data quality dimensions such as accuracy , completeness , and consistency .
7 . CONCLUSION
Dynamic selection of component services is an important issue in Web services composition . In this paper , we have presented a general and extensible model to evaluate QoS of both elementary and composite services . Based on the QoS model , a global service selection approach that uses linear programming techniques to compute optimal execution plans for composite services has been described .
We have conducted experiments to compare the proposed technique with the local selection approach . The results show that the proposed approach effectively selects high quality execution plans ( ie , plans which have higher overall
420 QoS ) . Our ongoing research includes the support for exception handling during composite service executions . For example , after an execution plan has been built and while it is being executed , an exception may occur ( eg , unavailability of a component service ) . We will explore the possibility of performing dynamic plan revision during composite service execution , as a means to respond to runtime exceptions .
Acknowledgments The work of Boualem Benatallah is partially supported by the Australian Research Council ’s Discovery GRANT DP021120 .
8 . REFERENCES
[ 1 ] B . Benatallah and F . Casati , editors . Distributed and
Parallel Database , Special issue on Web Services . Springer Verlag , 2002 .
[ 13 ] IBM Optimization Solutions and Library , 2002 . http://www3ibmcom/software/data/bi/osl/indexhtml
[ 14 ] IBM WSTK Toolkit . http://alphaworksibmcom/tech/webservicestoolkit
[ 15 ] H . Karloff . Linear Programming . Birkhauser , 1991 . [ 16 ] M . Kksalan and S . Zionts , editors . Multiple Criteria
Decision Making in the New Millennium . Springer Verlag , 2001 .
[ 17 ] J . Klingemann . Controlled Flexibility in Workflow
Management . In Proc . of the 12th International Conference on Advanced Information Systems ( CAiSE ) , pages 126{141 , Stockholm , Sweden , June 2000 . Springer .
[ 18 ] J . Klingemann , J . Wasch , and K . Aberer . Deriving
Service Models in Cross Organizational Workflows . In Ninth International Workshop on Research Issues in Data Engineering : Virtual Enterprise , RIDE VE’99 , Sydney , Australia , March 1999 .
[ 2 ] B . Benatallah , M . Dumas , Q . Z . Sheng , and A . Ngu .
[ 19 ] S . Martello and P . Toth . Knapsack Problems :
Algorithms and Computer Implementations . John Wiley and Sons , 2001 .
[ 20 ] M . Mecella , M . Scannapieco , A . Virgillito , R . Baldoni , T . Catarci , and C . Batini . Managing Data Quality in Cooperative Information Systems . In Proc . of the 10th International Conference on Cooperative Information Systems ( CoopIS ) , Irvine , CA , USA , 2002 . [ 21 ] F . Naumann , U . Leser , and J . C . Freytag . Quality driven Integration of Heterogenous Information Systems . In Proceedings of the International Conference on Very Large Databases ( VLDB ) , pages 447{458 , Edinburgh , UK , 1999 . [ 22 ] J . O’Sullivan , D . Edmond , and A . ter Hofstede .
What ’s in a Service . Distributed and Parallel Databases , 12(2{3):117{133 , September 2002 .
[ 23 ] M . Pinedof . Scheduling : Theory , Algorithms , and
Systems ( 2nd Edition ) . Prentice Hall , 2001 .
[ 24 ] Q . Z . Sheng , B . Benatallah , M . Dumas , and E . Mak .
SELF SERV : A Platform for Rapid Composition of Web Services in a Peer to Peer Environment . In Proc . of the 28th VLDB Conference , Hong Kong , China , August 2002 .
[ 25 ] A . van Moorsel . Metrics for the Internet Age : Quality of Experience and Quality of Business . Technical Report HPL 2001 179 , HP Labs , August 2001 . Also published in 5th Performability Workshop , September 2001 , Erlangen , Germany .
[ 26 ] D . D . Wackerly , W . Mendenhall , and R . L . Scheaffer .
Mathematical Statistics with Application . Duxbury Press , 1996 .
Declarative Composition and Peer to Peer Provisioning of Dynamic Web Services . In Proc . of ICDE’02 , IEEE Computer Society , pages 297{308 , San Jose , 2002 .
[ 3 ] C . Bettini , X . Wang , and S . Jajodia . Temporal
Reasoning in Workflow Systems . Distributed and Parallel Databases , 11(3):269{306 , 2002 .
[ 4 ] H . C. L and K . Yoon . Multiple Criteria Decision
Making . Lecture Notes in Economics and Mathematical Systems , Springer Verlag , 1981 .
[ 5 ] J . Cardoso . Quality of Service and Semantic
Composition of Workflows . PhD Thesis , University of Georgia , 2002 .
[ 6 ] F . Casati , S . Ilnicki , L J Jin , V . Krishnamoorthy , and M C Shan . eFlow : a Platform for Developing and Managing Composite e Services . Technical Report HPL 2000 36 , HP Laboratoris , Palo Alto , 2000 . [ 7 ] F . Casati , M C Shan , and D . Georgakopoulos , editors . VLDB Journal , Special Issue on E Services . Springer Verlag , 2001 .
[ 8 ] A . Dogac , editor . ACM SIGMOD Record 31(1 ) , Special Section on Data Management Issues in E Commerce . ACM , March 2002 .
[ 9 ] J . Eder , E . Panagos , and M . Rabinovich . Time
Constraints in Workflow Systems . In Proc . of the 11th International Conference on Advanced Information Systems Engineering ( CAiSE ) , pages 286{300 , Heidelberg , Germany , June 1999 .
[ 10 ] M C Fauvet , M . Dumas , and B . Benatallah . Collecting and Querying Distributed Traces of Composite Service Executions . In Proc . of the 10th International Conference on Cooperative Information Systems ( CoopIS ) , Irvine , CA , USA , 2002 .
[ 11 ] D . Georgakopoulos , H . Schuster , A . Cichocki , and D . Baker . Managing Process and Service Fusion In Virtual Enterprises . Information System , Special Issue on Information System Support for Electronic Commerce , 24(6):429{456 , 1999 .
[ 12 ] D . Harel and A . Naamad . The STATEMATE
Semantics of Statecharts . ACM Transactions on Software Engineering and Methodology , 5(4):293{333 , 1996 .
421
