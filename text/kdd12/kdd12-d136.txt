Mining Top K High Utility Itemsets
Cheng Wei Wu1 , Bai En Shie1 , Philip S . Yu2 , Vincent S . Tseng1
1Department of Computer Science and Information Engineering , National Cheng Kung University , Taiwan , ROC
2Department of Computer Science , University of Illinois at Chicago , Chicago , Illinois , USA
{silvemoonfox , brianshie}@gmail.com , psyu@csuicedu , tsengsm@mailnckuedutw
ABSTRACT Mining high utility itemsets from databases is an emerging topic in data mining , which refers to the discovery of itemsets with utilities higher than a user specified minimum utility threshold min_util . Although several studies have been carried out on this topic , setting an appropriate minimum utility threshold is a difficult problem for users . If min_util is set too low , too many high utility itemsets will be generated , which may cause the mining algorithms to become inefficient or even run out of memory . On the other hand , if min_util is set too high , no high utility itemset will be found . Setting appropriate minimum utility thresholds by trial and error is a tedious process for users . In this paper , we address this problem by proposing a new framework named top k high utility itemset mining , where k is the desired number of high utility itemsets to be mined . An efficient algorithm named TKU ( Top K Utility itemsets mining ) is proposed for mining such itemsets without setting min_util . Several features were designed in TKU to solve the new challenges raised in this problem , like the absence of anti monotone property and the requirement of lossless results . Moreover , TKU incorporates several novel strategies for pruning the search space to achieve high efficiency . Results on real and synthetic datasets show that TKU has excellent performance and scalability . Categories and Subject Descriptors H28 [ Database Management ] : Database Applications — Data Mining General Terms : Algorithms , Performance Keywords : Utility mining , high utility itemset , top k pattern mining 1 . INTRODUCTION Frequent itemset mining ( abbreviated as FIM ) [ 1 , 8 ] is a fundamental research in data mining . However , the traditional model of FIM may discover a large amount of frequent but low revenue itemsets and lose the information on valuable itemsets having low selling frequencies . Hence , FIM cannot satisfy the requirement of users who desire to discover itemsets with high utilities such as high profits . To address these issues , utility mining [ 2 , 3 , 6 , 11 , 12 , 13 , 18 , 19 , 20 , 21 , 23 , 24 , 25 ] emerges as an important topic in data mining . In utility mining , each item has a weight ( eg unit profit ) and can appear more than once in each transaction ( eg purchase quantity ) . The utility of an itemset represents its importance , which can be measured in terms topic of weight , profit , cost , quantity or other information depending on the user preference . An itemset is called a high utility itemset ( abbreviated as HUI ) if its utility is no less than a user specified minimum utility threshold . Utility mining is an important task and has a wide range of applications such as website click stream analysis [ 2 , 11 , 18 , 20 , 24 ] , cross marketing in retail stores [ 6 , 12 , 13 , 19 , 21 , 23 , 25 ] and biomedical applications [ 3 ] . Although this framework is essential to many applications , mining high utility itemsets is not an easy task because the downward closure property [ 1 ] does not hold . To facilitate the task of high utility itemset mining , most approaches [ 2 , 11 , 12 , 21 ] utilize the TWU model and TWDC property to prune the search space . In this model , an itemset is called HTWUI if its TWU is no less than min_util , where the TWU of an itemset represents the upper bound of its utility . The TWDC property states that for any itemset that is not an HTWUI , all its supersets are low utility itemsets . The TWU model consists of two phases named phase I and phase II . In phase I , all the HTWUIs are found . In phase II , the exact utilities of HTWUIs are calculated by scanning the database . Although many studies have devoted to HUI mining , it is difficult for users to choose an appropriate minimum utility threshold in practice . Depending on the threshold , the output size can be very small or very large . Besides , the choice of the threshold also greatly influences the performance of the algorithms . If the threshold is set too low , too many high utility itemsets will be presented to the users . It is difficult for the users to comprehend the results . A large number of high utility itemsets also causes the mining algorithms to become inefficient or even run out of memory , because the more high utility itemsets the algorithms generate , the more resources they consume . On the contrary , if the threshold is set too high , no high utility itemset will be found . In this case , users need to try different thresholds by guessing and re executing the algorithms over and over until being satisfied with the results . This process is both inconvenient and timeconsuming . We illustrate the problem of setting the minimum utility threshold with a real shopping transaction database named Chainstore . Figure 1 shows the runtime and the number of high utility itemsets in Chainstore dataset of the state of the art utility mining algorithm UP Growth [ 19 ] . As it can be seen , the choice of min_util has a major impact on the output size even if it is just changed slightly . For example , consider the case of a user who is interested in finding the top 1000 itemsets that contribute the highest profits in the Chainstore dataset . If the user does not possess the background knowledge about the database for setting min_util ( he needs to make a guess to choose the threshold ) , he has only a very small chance of selecting a min_util that will to set min_util satisfy his requirements ( he would need between 0.02 % and 003 % ) Moreover , if the threshold is set below 0.02 % , the algorithm can take up to one hour before terminating on a typical desktop computer .
78 ) . c e S ( e m T i
6000
5000
4000
3000 2000
1000
0
0.02
Runtime
0.04
0.06
MinUtil ( % ) s e t a d i d n a C #
5000
4000
3000
2000
1000
0
0.02
0.08
0.1
Number of HUIs
0.04
0.06
MinUtil ( % )
0.08
0.1
( a ) Runtime ( b ) Number of high utility itemsets
Figure 1 . Runtime and number of high utility itemsets in
Chainstore dataset under varied minimum utility thresholds A similar problem occurring in FIM is how to determine an appropriate minimum support threshold to mine enough but not too many itemsets for the users . To precisely control the output size and discover the most frequent patterns without setting the threshold , a good solution is to change the task of mining frequent patterns to the task of mining the top k frequent patterns [ 4 , 5 , 7 , 9 , 10 , 14 , 16 , 17 , 22 ] . The idea is to let the users specify k , ie , the number of desired patterns , instead of specifying the minimum support threshold . Setting k is more intuitive than setting the threshold because k represents the number of itemsets that the user wants to find whereas choosing the threshold depends solely on database ’s characteristics , which are often unknown to users . Although using a parameter k instead of a threshold would also be desirable in utility mining , developing an efficient algorithm for mining top k high utility itemsets is not an easy task . It poses four major challenges as discussed below . First , the utility of an itemset is neither monotone nor antimonotone . In other words , the utility of an itemset may be equal to , higher or lower than that of its supersets and subsets . Therefore , many techniques [ 5 , 7 , 9 , 10 , 14 , 16 , 17 , 22 ] developed in top k frequent pattern mining that rely on anti monotonicity to prune the search space cannot be directly applied to top k high utility itemset mining . The second challenge is how to incorporate the concept of top k pattern mining with the TWU model . Although the TWU model is widely used in utility mining , it is difficult to adapt this model to top k high utility itemset mining because the exact utilities of itemsets are unknown in phase I . When an HTWUI is generated in phase I , we cannot guarantee that its utility is higher than other HTWUIs and it is a top k high utility itemset before performing phase II . To guarantee that all the top k high utility itemsets can be captured in the set of HTWUIs , a naive approach is to run the algorithm with min_util = 0 . However , this approach may encounter the large search space problem . The third challenge is that min_util is not given in advance in topk high utility itemset mining . In the traditional high utility itemset mining , the search space can be efficiently pruned by the algorithms with a given min_util . However , in the scenario of topk high utility mining , the threshold is not provided . Therefore , the minimum utility threshold is initially set to 0 . The mining task has to gradually raise the threshold to prune the search space . Thus the challenge is to design an algorithm that can raise the threshold as high as possible and make the number of candidates produced in phase I as small as possible . The last challenge is how to effectively raise the threshold without missing any top k high utility itemsets . A good algorithm is one that can effectively raise the threshold during the mining process . However , if an incorrect method for raising the threshold is used , it may result in some top k high utility itemsets being pruned . Thus , how to effectively raise the threshold without missing any top k high utility itemsets is a crucial challenge for this work . In this paper , we address all of the above challenges by proposing an efficient algorithm named TKU for Top K Utility itemset mining . This work has three major contributions . First , we propose a novel framework for mining top k high utility itemsets . An algorithm named TKU is proposed for efficiently mining the complete set of top k high utility itemsets in the database without specifying min_util threshold . Second , five new strategies are proposed for effectively raising the threshold at different stage of the mining process . The first four strategies effectively raise the threshold during the mining process to prune the search space and reduce the number of candidates in phase I . The last strategy effectively reduces the number of candidates that need to be checked in phase II . It improves the runtime of phase II and the overall performance . Third , we conducted different kinds of experiments with real datasets . The results show that the performance of the proposed algorithm TKU is close to that of the optimal case of the state ofthe art utility mining algorithm UP Growth [ 19 ] . Moreover , it is over 100 times faster than the compared baseline algorithm . The remainder of this paper is organized as follows . In Section 2 , we introduce the background for utility mining and top k pattern mining . Section 3 presents the proposed methods . Experiments are shown in Section 4 and conclusions are given in Section 5 .
Table 1 . An example database
Transaction
( A,1 ) ( C,1 ) ( D,1 ) ( A,2 ) ( C,6 ) ( E,2 ) ( G,5 ) ( A,1 ) ( B,2 ) ( C,1 ) ( D,6 ) ( E,1 ) ( F,5 ) ( B,4 ) ( C,3 ) ( D,3 ) ( E,1 ) ( B,2 ) ( C,2 ) ( E,1 ) ( G,2 )
TID T1 T2 T3 T4 T5
TU 8 27 30 20 11
Item Profit
Table 2 . Profit table E A B C D 5 2 3
F G 1 1
1
2 2 . BACKGROUND This section introduces the preliminaries related to utility mining , and then defines the problem statement of top k high utility itemset mining . We adopt the notations used in [ 19 ] . For more details about high utility itemsets , readers can refer to [ 19 ] . 2.1 Problem definition Given a finite set of distinct items I = {i1 , i2 , … , im} . Each item ij ∈ I is associated with a positive number p(ij , D ) , called its external utility . A transactional database D = {T1 , T2 , … , Tn} is a set of transactions , where each transaction Tc∈D , ( 1 ≤ c ≤ n ) is a subset of I and has an unique identifier c , called Tid . In transaction Tc , each item ij is associated with a positive number q(ij , Tc ) , called its internal utility in Tc . An itemset X = {i1 , i2 , … , il} is a set of l distinct items , where ij∈I , 1 ≤ j ≤ l , and l is the length of X . A l itemset is an itemset of length l . An itemset X is said to be contained in a transaction Tc if X ⊆ Tc . Definition 1 . The support count of an itemset X is the number of transactions containing X in D and denoted as SC(X ) . The support of X is defined as the ratio of SC(X ) to |D| .
79 )
. c
,
)
.
DcTcTX ∈∧⊆ j Tiu , ( cTXu (
Definition 2 . The utility of an item ip in a transaction Tc is denoted as u(ij , Tc ) and defined as p(ij , D ) × q(ij , Tc ) . Definition 3 . The utility of an itemset X in a transaction Tc is denoted and defined as u(X , Tc ) = ∑ ∈Xji Definition 4 . The utility of an itemset X in D is denoted and defined as u(X ) = ∑ Definition 5 . An itemset X is called high utility itemset if u(X ) is no less than a user specified minimum utility threshold min_util . Definition 6 . Let min_util be the minimum utility threshold , the complete set of high utility itemsets in D is denoted as fH(D , min_util ) . The goal of high utility itemset mining is to discover fH(D , min_util ) . Example 1 . Let Table 1 be an example database containing five transactions . Each row in Table 1 represents a transaction , in which each letter represents an item and has a purchase quantity ( internal utility ) . The unit profit of each item is shown in Table 2 ( external utility ) . Suppose min_util is set to 30 , the set of high utility itemsets in Table 1 is {{BD}:30 , {ACE}:31 , {BCD}:34 , {BCE}:31 , {BDE}:36 , {BCDE}:40 , {ABCDEF}:30} , where the number beside each itemset is its utility . Note that the utility constraint is neither monotone nor antimonotone . In other words , the utility of an itemset may be equal to , higher or lower than that of its supersets and subsets . Therefore , we cannot directly use the anti monotone property ( also known as downward closure property ) to prune the search space . To facilitate the mining task , Liu et al . introduced the concept of transaction weighted downward closure [ 12 ] , which is based on the following definitions . Definition 7 . The transaction utility of a transaction TR is denoted as TU(TR ) and defined as u(TR , TR ) . Definition 8 . The transaction weighted utilization of an itemset X is the sum of the transaction utilities of all the transactions containing X , which is denoted as TWU(X ) and defined as TWU(X ) = ∑ Definition 9 . An itemset X is a high transaction weighted utilization itemset ( abbreviated as HTWUI ) if TWU(X ) ≥ min_util . Property 1 . ( TWDC property ) The transaction weighted downward closure property states that for any itemset X that is not a HTWUI , all its supersets are low utility itemsets [ 12 ] . Definition 10 . ( Top k high utility itemset ) An itemset X is called a top k high utility itemset in a database D if there are less than k itemsets whose utilities are larger than u(X ) in fH(D , 0 ) . Property 2 . Let H be the complete set of top k high utility itemsets in D . H may contain less than k high utility itemsets when |fH(D , 0)| ≤ k . Besides , H may contain more than k high utility itemsets when some itemsets have the same utility . Definition 11 . ( Optimal minimum utility threshold ) Let H be the complete set of top k high utility itemsets in D . A minimum utility threshold δ* is called optimal minimum utility threshold if there does not exist another threshold δ such that δ ≥ δ* and |fH(D , δ)| ≥ k . If |H| ≥ k , δ* = min{u(X)| X∈H} . Problem Statement . Given a transaction database D and the desired number of high utility itemsets k , the problem of finding the complete set of top k high utility itemsets in D is to discover k itemsets with the highest utilities in D . An equivalent problem
T ( R
∧ T
R
∈
D
⊆ TX
R
TU
)
. statement is to discover all the itemsets whose utilities are no less than δ* in D . Example 2 . Suppose the desired number of high utility itemset k is set to 3 , the top 3 high utility itemsets in Table 1 is H = {{BCDE}:40 , {BDE}:36 , {BCD}:34} . The optimal minimum utility threshold δ* to retrieve H is equal to min{40 , 36 , 34} = 34 . 2.2 Related work 221 High Utility Itemset Mining Many studies have been proposed for mining HUIs , including Two Phase [ 12 ] , IHUP [ 2 ] , IIDS [ 13 ] and UP Growth [ 19 ] . TwoPhase and IHUP utilize transaction weighted downward closure property to find high utility itemsets . They consist of two phases . In phase I , they find all HTWUIs from the database . In phase II , high utility itemsets are identified from the set of HTWUIs by scanning the original database . Although these methods capture the complete set of HUIs , they may generate too many candidates in phase I , ie HTWUIs , which degrades the performance of phase II and the overall performance ( in terms of time and space ) . To reduce the number of candidates in phase I , various methods have been proposed ( eg [ 13 , 19] ) . Recently , Tseng et al . proposed UP Growth [ 19 ] with four effective strategies DGU , DGN , DLU and DLN , for mining HUIs . Experiments showed that the number of candidates generated by UP Growth in phase I can be order of magnitudes smaller than that of HTWUIs . To the best of our knowledge , UP Growth is the state of the art method for mining high utility itemsets . Although many studies addressed the topic of mining high utility itemset from transaction databases , few of them showed the flexibility of mining top k high utility itemsets . Although the concept of top k high utility itemset mining was first introduced in [ 3 ] , the definition of high utility itemset in [ 3 ] is different from [ 2 , 13 , 15 , 20 ] and our work .
222 Top k Frequent Itemset Mining top k pattern mining In frequent pattern mining , several algorithms have been proposed [ 4 , 5 , 7 , 9 , 10 , 14 , 16 , 17 , 22 ] . Most of them ( eg [ 5 , 9 , 10 , 22 ] ) follow a same general process for finding top k patterns , although they also have several differences . We describe this general process below and then highlight the challenges for top k high utility itemset mining . The general process for mining top k patterns from a database is the following . Initially , a top k pattern mining algorithm sets minimum support threshold minsup to 0 to ensure that all the topk patterns will be found . Then , the algorithm starts searching for patterns by using a search strategy . As soon as a pattern is found , it is added to a list of patterns L ordered by the support of patterns . The list L is used to maintain the top k patterns found until now . Once k patterns are found , the value of minsup is raised to the support of the least interesting pattern in L . Raising minsup is used to prune the search space when searching for more patterns . Thereafter , each time a pattern is found that meets the minimum support threshold , the pattern is inserted into L , the patterns in L not respecting the threshold anymore are removed from L , and the threshold is raised to the support of the least frequent patterns in L . The algorithm continues searching for more patterns until no pattern is found by the search strategy . What distinguish each top k pattern mining algorithm are the data structures and search strategies to discover patterns . Top k pattern mining algorithm needs to use appropriate data structure and search strategies to be efficient in both memory and execution
80 time . Besides , the efficiency of a top k algorithm depends largely on how fast it can raise the minimum interestingness criterion ( minsup ) to prune the search space . To raise the threshold quickly , it is desirable that a top k pattern mining algorithm uses a search strategy that will find the most interesting patterns as early as top k pattern mining possible . Although several efficient algorithms [ 5 , 9 , 10 , 22 ] have been designed based on this idea , it is not possible to simply adapt this idea to HUI mining . The reason is that the HUI mining is performed in two phases and that the exact utility of itemsets is only known during phase II . Therefore , mining the top k HTWUIs during phase I would not necessarily result in finding the top k HUIs in phase II . Another challenge is how to integrate effective strategies for raising min_util given that the exact utility is only known in phase II . By the above literature reviews , although there are many studies about utility mining and top k pattern mining , fewer of them focus on the integration of mining top k high utility itemsets . This paper addresses this topic to find top k high utility itemsets .
Item TWU
Table 3 . Items and their TWUs A 65
C 96
D 58
E 88
B 61
F 30
G 38
Table 4 . Reorganized transactions and their RTUs
TID T1’ T2’ T3’ T4’ T5’
Reorganized transaction ( C,1 ) ( A,1 ) ( D,1 ) ( C,6 ) ( E,2 ) ( A,2 ) ( C,1 ) ( E,1 ) ( A,1 ) ( B,2 ) ( D,6 ) ( C,3 ) ( E,1 ) ( B,4 ) ( D,3 ) ( C,2 ) ( E,1 ) ( B,2 )
RTU
8 27 30 20 11
Item Item C C E E A A B B D D G G F F
TWU TWU
Link Link
96 96 88 88 65 65 61 61 58 58 38 38 30 30
{R}
{C} : 5 , 13
{E} : 4 , 27
{A} : 1 , 6
{A} : 2 , 31
{B} : 2 , 23
{D} : 1 , 8
{B} : 1 , 13
{D} : 1 , 20
{G} : 1 , 11
{G} : 1 , 27
{D} : 1 , 25
{F} : 1 , 30
Figure 2 . An UP Tree when min_util = 0 .
3 . MINING TOP K HIGH UTILITY ITEMSETS In this section , we propose an efficient algorithm named TKU ( mining Top K Utility itemsets ) for discovering top k high utility itemsets without specifying min_util . We first present a baseline named TKUBase approach and then introduce effective strategies to enhance its performance . 3.1 The baseline approach The baseline approach TKUBase takes k as parameter and outputs the k itemsets with the highest utilities . It is an extension of UPGrowth , the current best method for mining high utility itemsets , and it adopts the idea of UP Tree [ 19 ] to maintain the information of transactions and top k high utility itemsets . The framework of TKUBase consists of three parts : ( 1 ) construction of UP Tree , ( 2 ) generation of potential top k high utility itemsets ( abbreviated as PKHUIs ) from the UP Tree , and ( 3 ) identifying top k high utility itemsets from the set of PKHUIs .
311 UP Tree Structure In this subsection , we briefly introduce the structure of UP Tree . For the details about the UP Tree , readers can refer to [ 19 ] . In UP Tree , each node N consists of the following elements : N.name is the item name of N ; N.count is the support count of N ; N.nu is the node utility of N ; N.parent records the parent node of N ; N.hlink is a node link which points to a node whose item name is the same as Nname Header table is employed to facilitate the traversal of UP Tree . In the header table , each entry is composed of an item name , an estimate utility value , and a link . The link points to the last occurrence of the node having the same item name as the entry in the UP Tree . The nodes whose item names are the same can be traversed efficiently by following the links in header table and the nodes in UP Tree . 312 Construction of UP Tree A UP Tree can be constructed with only two scans of the original database . In the first scan , the transaction utility of each transaction and TWU of each single item are computed . Thus , items and their TWUs are obtained . Subsequently , items are inserted into the header table in descending order of their TWUs . During the second database scan , transactions are reorganized and then inserted into the UP Tree . Initially , the tree is created with a root R . When a transaction is retrieved , items in the transaction are sorted in descending order of TWU . A transaction after the above reorganization is called reorganized transaction and its transaction utility is called RTU ( reorganized transaction utility ) . The RTU of a reorganized transaction Td’ is denoted as RTU(Td’ ) . When a reorganized transaction Td’ = {i1 , i2 , … , im} ( ij∈I , 1 ≤ j ≤ m ) is retrieved , TKUBase applies the strategy DGN ( Discarding function Global Node Insert_Reorganized_Transaction(R , i1 ) to insert td’ . The function Insert_Reorganized_Transaction(N , ix ) takes a node N in the UP Tree and an item ix ( ix∈ Td’ , 1 ≤ x ≤ m ) in the reorganized transaction Td’ as inputs . The function is performed as follows : Line 1 : If N has a child S such that S.item = ix , then increment S.count by 1 ; otherwise , create a new child node S with S.item = ix , S.count = 1 , S.parent = N and S.nu = 0 . utilities ) calls
[ 19 ] and the
Line 2 : Increase S.nu by ( RTU(Td’ ) –
∑ m ( )1+(= p p Tiu , d x
)'
)
, where ip∈Td’ and 1≤ p ≤ m .
Line 3 : Call Insert_Reorganized_Transaction(S , ix+1 ) if p ≠ m . After inserting all reorganized transactions , the construction of the UP Tree is completed . Figure 2 shows an UP Tree for Table 1 when min_util = 0 . 313 Generating PKHUIs from the UP Tree The proposed algorithm uses an internal variable named border minimum utility threshold ( denoted as border_min_util ) which is initially set to 0 and raised dynamically after a sufficient number of itemsets with higher utilities has been captured during the generation of PKHUIs . The development of the proposed method is based on the following definitions and lemmas . Lemma 1 . Let P=<X1 , X2,… , Xm> be a set of itemsets ( m ≥ k ) , where Xi is the i th itemset in P and u(Xi ) ≥ u(Xj),∀ i < j . ( In other words , Xi is the itemset with the i th highest utility in P ) . For any itemset Y , if u(Y ) < u(Xk ) , Y is not a top k high utility itemset .
81 Rationale . According to Definition 10 , if there exist k itemsets whose utilities are higher than the utility of Y , Y is not a top k high utility itemset . Lemma 2 . Let P=<X1 , X2,… , Xm> be a set of itemsets ( m ≥ k ) , where Xi is the i th itemset in P and u(Xi ) ≥ u(Xj),∀ i < j . If δP = u(Xk ) , fH(D , δ*)⊆ fH(D , δP ) . Rationale . Let H be the complete set of top k high utility itemsets . If |H| ≥ k , δ* = min{u(X)| X∈H} ( by Definition 11 ) . Because δ* = min{u(X)| X∈H} ≥ min{u(Xi)| Xi ∈ P , 1 ≤ i ≤ k} = u(Xk ) = δP , δ* ≥ δP and fH(D , δ*)⊆ fH(D , δP ) . Example 3 . Suppose k = 4 and border_min_util = 0 initially . Let P be the set of 1 items in D . Then P = {{A}:20 , {D}:20 , {B}:16 , {E}:15 , {C}:13 , {G}:7 , {F}:5} , where the number beside each item is its exact utility . By Lemma 1 , items {C} , {G} , {F} are unpromising to be the top 4 high utility itemsets . Therefore border_min_util can be raised to 15 , the 4th highest utility value in P , and no top k high utility itemset will be missed . After raising border_min_util , the algorithm performs the UPGrowth search procedure with min_util = border_min_util to generate PKHUIs . Although Lemma 1 provides a way to raise border_min_util , it cannot be applied during the generation of PKHUIs in phase I . This is because the exact utilities of the PKHUIs are unknown during phase I . One of the solutions to this problem is to use lower bound of the utility of PKHUI to raise the border_min_util . A lower bound of the utility of an itemset can be estimated by the following definitions . Definition 12 . The minimum item utility of an item a is denoted as miu(a ) and defined as the value u(a , Tr ) for which ∃¬ Ts ∈ D such that u(a , Ts ) < u(a , Tr ) . Definition 13 . The minimum item utility of an itemset X={a1 , a2,… , am} is defined as MIU(X ) = ∑ Lemma 3 . Let C = <X1 , X2,… , Xm> be a set of itemsets ( m ≥ k ) , where Xi is the i th itemset in C and MIU(Xi ) ≥ MIU(Xj),∀ i < j . For any itemset Y , if TWU(Y ) < δC = min{MIU(Xi ) | Xi ∈ C , 1 ≤ i ≤ k} , Y is not a top k high utility itemset . Rationale . According to Definition 8 , u(Y ) ≤ TWU(Y ) . If TWU(Y ) < δC , u(Y ) < δC . Besides , u(Y ) < MIU(Xi ) ≤ u(Xi ) , Xi ∈ C , 1 ≤ i ≤ k . According to Definition 10 , if there exist k itemsets whose utilities are higher than the utility of Y , Y is not a top k high utility itemset . Lemma 4 . Let C =<X1 , X2,… , Xm> be a set of itemsets ( m ≥ k ) , where Xi is the i th itemset in C and MIU(Xi ) ≥ MIU(Xj),∀ i < j . If δC = MIU(Xk ) , fH(D , δ*)⊆ fH(D , δC ) . Rationale . Let H be the complete set of top k high utility itemsets . If |H| ≥ k , δ* = min{u(X)| X∈H} ( by Definition 10 ) . Because δ* = min{u(X)| X∈H} ≥ min{u(Xi)| Xi ∈ C , 1 ≤ i ≤ k} ≥ min{MIU(Xi ) | Xi ∈ C , 1 ≤ i ≤ k}= MIU(Xk ) , we have δ* ≥ δC and fH(D , δ*)⊆ fH(D , δC ) . Lemma 5 . For any itemset X , if TWU(X ) < border_min_util ≤ δ* , X and all its supersets are not top k high utility itemsets . Definition 14 . The maximum item utility of an item a is denoted as mau(a ) and defined as the value u(a , Tr ) for which ∃¬ Ts ∈ D such that u(a , Ts ) > u(a , Tr ) .
× SC(X ) . miu m i 1= a
(
) i
Table 5 . Items and their mius and maus
Item miu mau
A 5 5
B 4 8
C 1 3
D 2 6
E 3 6
F 5 5
G 2 5 i
) m i 1= amau (
× SC(X ) .
Definition 15 . The maximum utility of an itemset X={a1 , a2,… , am} is defined as MAU(X ) = ∑ Lemma 6 . For any itemset X , if MAU(X ) < border_min_util < δ* , X is not a top k high utility itemset . Rationale . According to Definition 15 , we have u(X ) ≤ MAU(X ) . If MAU(X ) < border_min_util , u(X ) < border_min_util . According to Definition 10 , X is not a top k high utility itemset . Lemma 7 . For any itemset X , the relationships between MAU(X ) TWU(X ) , u(X ) and MIU(X ) is MIU(X ) ≤ u(X ) ≤ min{MAU(X ) , TWU(X)} . Definition 16 . An itemset is called a PKHUI ( Potential top K High Utility Itemset ) if its estimated utility ( ie , TWU ) and MAU are no less than the border_min_util . Based on the above lemmas and definitions , we have the following ideas to raise border_min_util during the generation of PKHUIs . As soon as a candidate X is found by the UP Growth search procedure , we check whether its estimated utility ( i.e , TWU(X ) ) If TWU(X ) < border_min_util , X and all its supersets are not top k high utility itemsets ( Lemma 5 ) . Otherwise , we check whether its MAU is higher than border_min_util . If MAU(X ) < border_min_util , X is not a top k high utility itemset ( Lemma 6 ) . Otherwise , X is considered as a candidate for phase II and it is outputted with its estimated utility value according to Lemma 7 . If X is a valid PKHUI and MIU(X ) ≥ border_min_util , MIU(X ) can be used to raise the border_min_util ( Lemma 3 ) . To efficiently update border_min_util , we use a min heap structure L to maintain the k highest MIUs of the PKHUIs until now . Once k MIUs are found , border_min_util is raised to the k th MIU in L according to Lemma 3 . Each time a PKHUI X is found and its MIU is higher than border_min_util , X is added into L and the lowest MIU in L is removed . After that , border_min_util is raised to the k th MIU in L . The algorithm continues searching for more PKHUIs until no candidate is found by the UP Growth search procedure . Figure 3 gives the pseudo code for the above processes . than border_min_util . is higher
If(TWU(X ) ≥ border_min_util and MAU(X ) ≥ border_min_util )
{ Output X and min{TWU(X ) , MAU(X)}
If ( MIU(X ) ≥ border_min_util )
{ Add X to L and raise border_min_util by MIU(X)}
} else { X is not a valid PKHUI }
Figure 3 . The pseudo code for the strategy MC
Strategy 1 . Raising the threshold by MUI of Candidate ( MC ) For any newly mined PKHUI X , if its MIU , TWU and MAU are no less than the current border_min_util , then it is safe to use MIU(X ) to raise border_min_util . 314 Identifying top k HUIs from PKHUIs In this part , we propose a basic method for identifying top k high utility itemsets from the set of PKHUIs . Exact utilities of PKHUIs are identified and top k high utility itemsets are examined by scanning the original database . Main method of this part is similar to that of phase II in [ 12 , 19 ] . However , in previous work [ 12 , 19 ] , all candidates should be checked . Therefore , we only check the candidate itemset X whose estimated utility is larger than or equal to the border_min_util finally reached after phase I , ie , min(TWU(X ) , MAU(X ) ) ≥ border_min_util .
82 to to mine
( Pre Evaluation )
3.2 Effective strategies In this subsection , we introduce four effective strategies to effectively raise border_min_util during different stage of the mining process . 321 Pre evaluation Step top k HUIs , Although TKUBase provides a way border_min_util is set to 0 before the construction of the UP Tree . This results in the construction of a full UP Tree in memory , which degrades the performance of the mining task . If we could raise border_min_util before the construction of the UP Tree and prune unpromising items in the transactions , the number of nodes maintained in memory could be reduced and the mining algorithm could achieve better performance . To solve this problem , we propose a strategy named PE raise border_min_util during the first scan of the database . A structure named pre evaluation matrix ( PEM ) is used to store lower bounds for the utility of certain 2 itemsets . Each entry in PEM is denoted as PEM[x][y ] and corresponds to a lower bound of u(xy ) , where x , y ∈ I . Initially , each value in the matrix is set to 0 . When a transaction Td ={i1 , i2 , … , im} ( ij∈I , 1 ≤ j ≤ m ) is retrieved during the first scan of the database , the utility of the itemset {i1 ij} ( 1 < j ≤ m ) in Td is added to the value of the corresponding entry of PEM[i1][ij ] . For example , when T1 = {(A,1 ) , ( C,1 ) , ( D,1)} is retrieved , the corresponding entries PEM[A][C ] , PEM[A][D ] are accumulated with u({AC} , T1 ) = 6 and u({AD} , T1 ) = 7 . After scanning the database , border_min_util is set to the k th highest value in PEM . Figure 4 shows the value of each entry in PEM after scanning Table 1 . When k = 4 , the 4th highest value in PEM is 18 . Therefore , border_min_util can be raised to 18 . Strategy 2 . Pre Evaluation ( PE ) PE is applied during the first scan of the database . When a transaction Td ={i1 , i2 , … , im} ( ij∈I , 1 < j ≤ m ) is retrieved , the utility of u(i1 ij , Td ) is added to the corresponding entry PEM[i1][ij ] in the pre evaluation matrix , 1 < j ≤ m . Then , border_min_util can be raised to the k th highest values in PEM . The space complexity is O(|I|/2 ) , where |I| is the number of distinct items in the database . Notice that in TKUBase , the strategy DGU in [ 19 ] cannot be applied , because border_min_util is 0 before the construction of UP Tree . However , if we raise border_min_util at pre evaluation step , the strategy DGU can be applied to prune those items whose TWUs are less than border_min_util , which further reduces the size of UP Tree and the number of candidates produced in phase I . 322 Raising the threshold by node utilities The next proposed strategy is called NU ( Raising the threshold by Node Utilities ) , which is applied during the construction of UPTree . The strategy NU is developed based on the following lemmas . Lemma 8 . Let PA = {N1 , N2,… , Nm , R} be a path from a node N1 to the root R in the UP Tree and ij be an item in Nj , 1≤ j ≤ m . The node utility of N1 is a lower bound for the utility of the itemset {i1 , i2… , im} , 1≤ j ≤ m . Rationale . The UP Tree is constructed by applying the strategy DGN [ 19 ] . According to the rationale described in [ 19 ] , the utility of the itemset {i1 , i2… , im} is guaranteed to be higher than the node utility of N1.Therefore , N1.nu ≤ u({i1 , i2… , im} ) . Lemma 9 . Let S = <N1 , N2,… , Nm> be an ordered set of nodes in UP Tree ( m ≥ k ) , where Ni is the i th node in S and Ni.nu ≥ Nj.nu,∀ i < j . If δNU = Nk.nu , then fH(D , δ*)⊆ fH(D , δNU ) .
A B C D E F
B 9
F 10 0 0 0 0
Figure 4 . Pre evaluation matrix
C 28 17
D 24 14 0
E 24 18 0 0
G 15 6 0 0 0 0
Rationale . Each node Nj to the root R represents an unique itemset Xj , 1 ≤ j ≤ m ( Lemma 8 ) . Let S’ =<X1 , X2,… , Xm> be an ordered set of itemsets , where Nj.nu ≤ u(Xj ) and 1 ≤ j ≤ m . If |H| ≥ k , then δ* = min{u(X)| X ∈ H} ( Definition 10 ) . Because min{u(X)| X∈H} ≥ min{u(Xj)| Xj ∈ S , 1 ≤ j ≤ k} ≥ min{Nj.nu | Nj ∈ S’ , 1 ≤ j ≤ k} , we have δ* ≥ δNU and fH(D , δ*)⊆ fH(D , δNU ) . By Lemma 8 and 9 , if there are more than k nodes in the UP Tree during its construction and this value is higher than the current border_min_util , we can raise border_min_util to the k th highest node utility in the UP Tree . For example , suppose k = 4 , when the first reorganized transaction T1’ = {(C,1 ) , ( A,1 ) , ( D,1)} is inserted into the UP Tee , the nodes {C} , {A} and {D} are created with node utilities 1 , 6 and 8 , which represent lower bounds for the utilities of itemsets {C} , {AC} and {DAC} . When the second reorganized transaction is inserted into the tree , there are more than four nodes in the UP Tree . Therefore , we can apply Lemma 9 to raise border_min_util to the 4 th highest node utility in the UP Tree . Strategy 3 . Raising the threshold by Node Utilities ( NU ) NU is applied during the construction of the UP Tree ( the second scan of the database ) . If there are more than k nodes in the current UPTree and k th highest node utility is no less than the current border_min_util , border_min_util can be raised to the k th highest node utility in the current UP Tree . 323 Raising Descendents The third strategy that we propose is called MD ( Raising the threshold by MIU of Descendents ) . It is applied after the construction of the UP Tree and before the generation of PKHUIs . For each node Nα under the root in the UP Tree , we traverse the sub tree under Nα once to calculate the MIU of NαNβ for each descendent node Nβ of Nα . If there are more than k such values , border_min_util can be raised to the k th highest value . For example , consider the UP Tree in Figure 2 and suppose k = 4 . The node under the root is {C} . We traverse the sub tree under the node {C} once and calculate the MIUs of its descendents . For the descendent {A} , the total support count of {A} in the sub tree of {C} is ( 1 + 2 ) = 3 . Therefore , the MIU of {AC} is ( miu({A} ) + miu({C} ) ) ×SC({AC} ) = ( 5 + 4 ) × 3 = 27 . Strategy 4 . Raising the threshold by MIU of Descendents ( MD ) MD is applied after the construction of UP Tree and before the generation of PKHUIs . For each node Nα under the root in the UP Tree , the support count of NαNβ is calculated by traversing every its descendent node Nβ . For each pair NαNβ , we calculate the MIU of NαNβ . If there are more than k MIUs larger than border_min_util , the border_min_util can be raised to k th highest value . threshold by MIU of the
Table 6 . MIUs of descendents
G 3
F 1
Descendent
MIU
E 16
A 18
B 15
D 9
83 are found , larger for
324 Raising the threshold during Phase II In this part , top k high utility itemsets are identified by checking the real utilities of PKHUIs in the database . The purpose of this part is the same as the basic method ( in Section 314 ) Although the basic method can skip checking some candidates , the number of checked PKHUIs is still too large . Scanning database for checking the large amount of PKHUIs is very time consuming . In view of this , we propose an additional strategy for cooperating with the candidate skipping mechanism in Section 314 There are two main steps in this strategy . First , the candidates are sorted by the descendent order of estimated utilities , ie , min(TWU(X ) , MAU(X) ) . Thus , the candidates with larger estimated utility values will be first checked ; in other words , those having lower values will be checked later . After k PKHUIs whose exact utilities are than border_min_util a mechanism raising border_min_util is applied . If the exact utility of a new HUI Y is larger than border_min_util , Y and u(Y ) is inserted into a top k HUI list E ( All HUIs in E are ordered by their exact utilities ) , and the HUI with the lowest utility value is removed from E . Then border_min_util is raised to the utility of k th HUI in E . If the estimated utility of the current candidate Z , ie , min(TWU(Z ) , MAU(Z) ) , is less than the new border minimum utility threshold , all of the remaining candidates do not need to be checked . This is because that their upper bounds of exact utilities are not larger than border_min_util . Finally , E is the set of top k high utility itemsets of the database . By this mechanism , the candidates with lower estimated utility values may not be checked since the border_min_util is raised . The I/O cost and execution time for phase II can be further reduced . This technique works well especially when k is small . Strategy 5 . Sorting candidates & raising threshold by the exact utility of candidates . ( SE ) SE is applied during phase II of TKU . Let CI be the set of candidates produced in phase I . Candidates in CI are sorted in the descendent order of their estimated utilities . Next , if there are more than k HUIs whose exact utilities are larger than border_min_util , border_min_util can be raised to the k th highest exact utility . For any candidate Z , if min(TWU(Z ) , MAU(Z ) ) is less than border_min_util , Z and the remaining candidates do not need to be checked anymore . 4 . EXPERIMENTAL EVALUATION In this section , we evaluate the performance of the proposed algorithm . Experiments were performed on computer with a 3.40 GHz Intel Core Processor with 4 gigabyte memory , and running on Windows 7 . All of the algorithms are implemented in Java . Different types of real world datasets were used in the experiments . Foodmart , a sparse dataset , was acquired from Microsoft foodmart 2000 database [ 27 ] ; Mushroom , a dense dataset , was obtained from the FIMI Repository [ 26 ] ; Chainstore , a large dataset , was obtained from NU MineBench 2.0 [ 15 ] . The two datasets Foodmart and Chainstore already contain unit profits and purchased quantities . For Mushroom dataset , unit profits for items are generated between 1 and 1000 by using a log normal distribution and quantities of items are generated randomly between 1 and 5 , as the settings of [ 19 ] . Table 7 shows the characteristics of the datasets used in the experiments . To evaluate the performance of the proposed strategies , we prepared three versions of TKU and gave them the names TKU , TKUnoSE and TKUBase as shown in Table 8 . These three versions are compared with the state of the art utility mining algorithm UPGrowth [ 19 ] .
Dataset Foodmart Mushroom Chainstore
Table 7 . Datasets’ characteristics #Transactions Avg . length #Items 1,559 119 46,086
4.4 23.0 7.2
4,141 8,124
1,112,949
Type Sparse Dense Sparse Large
Phase II
SE Y
Y
Phase I
Table 8 . Strategies used by the algorithms
Algorithm TKU TKUnoSE TKUBase
PE Y Y
NU MD MC Y Y Y Y
Y
Y Y
Because UP Growth is not developed for mining top k HUIs , it cannot be compared directly with TKU . To compare their performance , we considered the scenario where the users choose the optimal parameters for UP Growth to produce the same amount of patterns as TKU ( denoted as UPOptimal in the following experiments ) . We first show the performance of the algorithms on the Foodmart dataset . The results are shown in Figure 5 and Table 9 . In Figure 5 ( a ) , it can be observed that the runtime for phase I of TKU approaches that of UPOptimal . On the contrary , the performance of TKUBase is the worst among all the algorithms . Its runtime is about 100 times slower than that of TKU . The reason is shown in Figure 5 ( b ) . This figure shows the thresholds that the TKU and TKUBase reached after phase I . Since UP Growth does not raise the thresholds during the mining process , we show its initial thresholds ( the optimal thresholds ) . In this figure , it can be observed that the thresholds reached by TKU are closer to the optimal thresholds than those of TKUBase . On the other hand , TKUBase does not apply the strategies PE , NU and MD . Therefore , it constructs a full UP Tree with min_util = 0 . Since raising the threshold for TKUBase strictly depends on the MC strategy , it cannot be raised effectively . Thus its search space is the largest and its runtime is the longest . The ineffectiveness of raising the threshold for TKUBase also influences the number of candidates generated in phase I . The number of candidates generates by each algorithm is shown in Table 9 . In this table , it can be observed that the number of candidates for TKUBase is over 1000 times larger than TKU when k is less than 1000 . The reason is that the strategies PE , NU and MD effectively raise the threshold at different stages of the mining process . Thus the number of patterns generated by TKU is much smaller than that of TKUBase . The runtime of each algorithm for phase II is shown in Figure 5 ( c ) . Because each candidate needs to be checked in phase II and TKUBase has the largest number of candidates , its performance for phase II is the worst . The performance of TKUnoSE is worse than TKU because the latter uses the strategy SE , which reduces the number of candidates need to be checked in phase II . Overall runtime of the algorithms is shown in Figure 5 ( d ) . We can see that the runtime of TKU is over 100 times faster than TKUBase , and only about twice less than that of UPOptimal . Therefore , it can be concluded that TKU is an efficient algorithm since it can exactly find the top k HUIs within a reasonable time .
84 ) . c e S ( e m T i
10000
1000
100
10
1
0.1
1
Phase I Time
10
K
100
1000 d l o h s e r h T
30000
25000
20000
15000
10000
5000
0
Reached Threshold
UP(Optimal ) TKU TKU(Base )
TKU(Base )
TKU
( a ) Phase I time ( b ) Reached threshold after phase I
UP(Optimal )
K
1
10
100
1000
) . c e S ( e m T i
70 60
50 40 30 20
10 0
Phase II Time
TKU TKU(no SE ) TKU(Base ) UP(Optimal )
1
10
100
1000
K
100000
10000
) . c e S ( e m T i
1000
100
10
1
1
Total Time
TKU TKU(Base ) UP(Optimal )
10
K
100
1000
( c ) Phase II time ( d ) Total time
Figure 5 . Performance of the algorithms on Foodmart
Table 9 . Number of candidates after Phase I
K
1 10 100 1,000
TKU
1,379 1,503 2,456 39,289
TKUBase 2,466,459 2,494,446 2,537,225 2,585,300
Reduction ratio
1788.59 1659.65 1033.07 65.80
Phase I Time
TKU TKU(Base ) UP(Optimal )
Reached Threshold
UP(Optimal ) TKU TKU(Base )
16000000
12000000
8000000
4000000 d l o h s e r h T
1
10
100 K
1000
5000
0
1
10
1000
5000
100 K
( a ) Phase I time ( b ) Reached threshold after phase I
) . c e S ( e m T i
150
120
90
60
30
0
10000
1000
) . c e S ( e m T i
100
10
1
1
Phase II Time
TKU TKU(no SE ) TKU(Base ) UP(Optimal )
10
100 K
1000
5000
Total Time
TKU TKU(Base ) UP(Optimal )
1500
1200
900
600
300
) . c e S ( e m T i
0
1
10
1000
5000
100 K
( c ) Phase II time ( d ) Total time
Figure 6 . Performance of the algorithms on Mushroom
Table 10 . Number of candidates after Phase I
K 1 10 100 1,000 5,000
TKU 427
597,301 803,377 1,540,583 2,594,337
TKUBase 508,462 713,793 920,040 1,657,403 2,711,248
Reduction ratio
1190.78
1.20 1.14 1.08 1.05
Next , we show the performance on the Mushroom dataset . The results are shown in Figure 6 and Table 10 . Figure 6 ( a ) shows the runtime for phase I of the algorithms . It can be observed that the runtime for phase I of TKU is close to that of TKUBase . This is because Mushroom is a dense dataset . The estimated utility values , ie , TWU values , of itemsets are much larger than their exact utilities . Thus the thresholds cannot be raised effectively in phase I . The thresholds reached by the algorithms are shown in Figure 6 ( b ) . It can be seen that if k is larger than 1 , the threshold reached by TKU is close to TKUBase . Table 10 shows the number of candidates generated by the algorithms during phase I . In this table , it can be seen that when k is larger than 1 , the reduction ratio is slightly larger than 1 . The reduction ratio decreases when k increases . Figure 6 ( c ) shows the runtime for phase II of the algorithms . The runtime for phase II of TKUnoSE is the worst among the algorithms . This is because , without the SE strategy , TKUnoSE needs to check all the candidates to determine which itemsets are top k HUIs . When k is set to 5,000 , the runtime of TKUnoSE is too long to be executed ( over 10,000 seconds ) . Finally , Figure 6 ( d ) shows the total runtime of the algorithms . We can conclude that although TKU is not as efficient as for the Foodmart dataset , it is still more efficient than TKUBase . Finally , we show the performance of the algorithms on Chainstore , a large dataset with over 1 million transactions . Because the runtime of TKUBase for this dataset is too long to be executed ( over 20 hours when k = 1 ) , we instead use UP Growth with a low minimum utility threshold ( 0.01 % ) as the baseline ( denoted as UPLow in the following experiments ) . The number of HUIs generated with min_util = 0.01 % is about 3800 . The results are shown in Figure 7 and Table 11 . Figure 7 ( a ) shows the runtime for phase I of the algorithms . Since the threshold of UPLow is fixed , its runtime remains the same . It can be seen that the runtime of TKU is worse than UPLow when k is larger than 200 . The reasons are that TKU needs to perform more computation for the strategies and it raises the threshold by the strategies step by step . Figure 7 ( b ) shows the runtime for phase II of the algorithms . Although the runtime for phase I of TKU is slightly worse than UPLow , the runtime for phase II of TKU is much faster than that of UPLow . The total runtimes ( the sum of the runtimes of phase I and phase II ) are shown in Figure 7 ( c ) . TKU is much faster than UPLow . Generally , overall runtime of TKU is close to UPOptimal . This is because UPLow needs to check all candidates in phase II ; on the other hand , TKU only needs to check some of them because it uses the SE strategy . Figure 7 ( d ) shows the number of candidates checked in phase II by each algorithm . It can be observed that although TKU generates much more candidates in phase I , the number of candidates that need to be checked by TKU is close to UPoptimal in phase II . This is because using the SE strategy , TKU avoids checking some candidates that do not need to be checked . In contrary , since all candidates are checked by TKUnoSE , its performance is worse than TKU and UPOptimal . Finally , we show the threshold changes after applying the strategies in phase I . The results are shown in Table 11 . In this table , it can be observed that the thresholds are raised higher when the strategies are applied . On the other hand , it can also be seen that the thresholds decrease when k increases . This is reasonable because the larger k is , the lower the thresholds are .
85 Overall , Table 11 shows the effectiveness of all proposed strategies in phase I .
100
Phase I Time
Phase II Time
6000
4500
3000
1500
) . c e S ( e m T i
) . c e S ( e m T i
80
60
40
20
0
TKU UP(Optimal ) UP(Low )
100
300
500 K
700
900
0
100
300
700
900
500
K
TKU UP(Optimal )
TKU(no SE ) UP(Low )
( a ) Phase I time ( b ) Phase II time
Number of Candidates
TKU(no SE ) TKU UP(Optimal )
Total Time
TKU UP(Optimal ) UP(Low )
6000
5000
4000
3000
2000
1000
) . c e S ( e m T i
0 100
300 e t a d i d n a C #
80000
60000
40000
20000
0
700
900
500 K
( c ) Total time ( d)Number of candidates checked in Phase II
100
300
700
900
500 K
Figure 7 . Performance of the algorithms on Chainstore Table 11 . Reached thresholds after each step in Phase I
K 100 200 300 400 500 600 700 800 900 1,000
PE
2254.35 1578.67 1307.68 1116.25 988.49 899.52 826.38 758.63 712.97 677.37
NU
7509.38 3929.84 2728.92 2158.83 1739.42 1457.85 1270.27 1117.47 1015.57 915.22
MD
7509.38 3929.84 2804.48 2382.52 2050.96 1820.28 1650.04 1515.24 1412.70 1334.82
MC
7509.38 5324.16 4346.16 3803.76 3438.30 3145.21 2899.80 2734.67 2588.88 2469.60
In general , the experimental results show that TKU outperforms TKUBase and UPLow . Moreover , the performance of TKU is close to UPOptimal . The reasons are listed as follows . First , strategies PE , NU , MD and MC in phase I effectively raise the threshold step by step in phase I . Thus the number of candidates that need to be checked in phase II is less and the search space in phase I is successfully reduced . Second , the SE strategy in phase II effectively reduces the number of candidates that need to be checked in phase II . Therefore , TKU is shown to be efficient with a performance that is close to that of the optimal case of the state of the art utility mining algorithm UP Growth . 5 . CONCLUSION In this paper , we have proposed an efficient algorithm named TKU for mining top k high utility itemsets from transaction databases . TKU guarantees there is no pattern missing during the mining process . We develop four strategies for phase I to raise the border minimum utility threshold and reduce the search space and number of generated candidates . Moreover , a strategy is designed for phase II to decrease the number of checked candidates . The mining performance is enhanced significantly since both the search space and the number of candidates are effectively reduced by the proposed strategies . In the experiments , different types of real datasets are used to evaluate the performance of our algorithm . The experimental results show that TKU outperforms the baseline algorithms substantially and the performance of TKU is close to the optimal case of the state of the art utility mining algorithm . ACKNOWLEDGMENTS This research was supported in part by National Science Council , Taiwan , ROC under grant no . NSC100 2631 H 006 002 , US NSF through grants DBI 0960443 and OISE 1129076 , and Google Mobile 2014 Program . REFERENCES [ 1 ] R . Agrawal and R . Srikant . Fast algorithms for mining association rules . In Proc . of the 20th Int'l Conf . on Very Large Data Bases , pp . 487 499 , 1994 .
[ 2 ] C . F . Ahmed , S . K . Tanbeer , B S Jeong and Y K Lee . Efficient Tree Structures for High utility Pattern Mining in Incremental Databases . In IEEE Transactions on Knowledge and Data Engineering , Vol . 21 , Issue 12 , pp . 1708 1721 , 2009 . [ 3 ] R . Chan , Q . Yang and Y . Shen . Mining high utility itemsets . In Proc . of Third
IEEE Int'l Conf . on Data Mining , pp . 19 26 , Nov . , 2003 .
[ 4 ] Y . L . Cheung , A . W . Fu , Mining frequent itemsets without support threshold : with and without item constraints . IEEE Transactions on Knowledge and Data Engineering , Vol . 16 , No . 6 , pp . 1052 1069 , 2004 .
[ 5 ] K . Chuang , J . Huang , M . Chen , Mining Top K Frequent Patterns in the Presence of the Memory Constraint , The VLDB Journal , Vol . 17 , pp . 1321 1344 , 2008 . [ 6 ] A . Erwin , R . P . Gopalan and N . R . Achuthan . Efficient Mining of High utility
Itemsets from Large Datasets . In PAKDD 2008 , LNAI 5012 , pp . 554 561 , 2008 .
[ 7 ] A . W . Fu , R . W . Kwong and J . Tang , Mining N Most Interesting Itemsets , In
[ 8 ]
[ 9 ]
Proc . of ISMIS’00 , 2000 . J . Han , J . Pei and Y . Yin . Mining frequent patterns without candidate generation . In Proc . of the ACM SIGMOD Int'l Conf . on Management of Data , pp . 1 12 , 2000 . J . Han , J . Wang , Y . Lu and P . Tzvetkov , “ Mining Top k Frequent Closed Patterns without Minimum Support , ” In Proc . of ICDM , 2002 .
[ 10 ] Y . Hirate , E . Iwahashi and H . Yamana , TF2P Growth : An Efficient Algorithm for
Mining Frequent patterns without any Thresholds , In Proc . of ICDM 2004 . [ 11 ] H F Li , H Y Huang , Y C Chen , Y J Liu , S Y Lee . Fast and Memory
Efficient Mining of High Utility Itemsets in Data Streams . In Proc . of the 8th IEEE Int'l Conf . on Data Mining , pp . 881 886 , 2008 .
[ 12 ] Y . Liu , W . Liao , and A . Choudhary . A fast high utility itemsets mining algorithm .
In Proc . of the Utility Based Data Mining Workshop , 2005 .
[ 13 ] Y C Li , J S Yeh and C C Chang . Isolated Items Discarding Strategy for Discovering High utility Itemsets . In Data & Knowledge Engineering , Vol . 64 , Issue 1 , pp . 198 217 , 2008 .
[ 14 ] S . Ngan , T . Lam , R . C . Wong and A . W . Fu , Mining N most Interesting Itemsets without Support Threshold by the COFI Tree , Int . J . Business Intelligence & Data Mining , Vol . 1 , No . 1 , pp . 88 106 , 2005 .
[ 15 ] J . Pisharath , Y . Liu , B . Ozisikyilmaz , R . Narayanan , W . K . Liao , A . Choudhary and G . Memik , NU MineBench version 2.0 dataset and technical report , http://cucisecenorthwesternedu/projects/DMS/MineBenchhtml
[ 16 ] T . M . Quang , S . Oyanagi , and K . Yamazaki , ExMiner : An Efficient Algorithm for Mining Top K Frequent Patterns , ADMA 2006 , LNAI 4093 , pp . 436 – 447 , 2006 .
[ 17 ] L . Shen , H . Shen , P . Pritchard and R . Topor , Finding the N Largest Itemsets , in
Proc . Int’l Conf . on Data Mining , pp . 211 222 , 1998 .
[ 18 ] B E Shie , V . S . Tseng , and P . S . Yu . Online Mining of Temporal Maximal
Utility Itemsets from Data Streams . In Proc . of the 25th Annual ACM Symposium on Applied Computing ( ACM SAC 2010 ) , 2010 .
[ 19 ] V . S . Tseng , C W Wu , B E Shie , and P . S . Yu . UP Growth : an efficient algorithm for high utility itemset mining . In Proc . of Int'l Conf . on ACM SIGKDD , pp . 253–262 , 2010 .
[ 20 ] V . S . Tseng , C . J . Chu , and T . Liang . Efficient mining of temporal high utility itemsets from data streams . In ACM KDD Workshop on Utility Based Data Mining Workshop , 2006 .
[ 21 ] B . Vo , H . Nguyen , T . B . Ho , and B . Le . Parallel Method for Mining High utility Itemsets from Vertically Partitioned Distributed Databases . In KES 2009 , Part I , LNAI 5711 , pp . 251 260 , 2009 .
[ 22 ] J . Wang and J . Han , TFP : An Efficient Algorithm for Mining Top K Frequent
Closed Itemsets , IEEE Transactions on Knowledge and Data Engineering , Vol . 17 , No . 5 , pp . 652 664 , May 2005 .
[ 23 ] H . Yao , H . J . Hamilton , L . Geng , A unified framework for utility based measures for mining itemsets . In Proc . of ACM SIGKDD 2nd Workshop on Utility Based Data Mining , pp . 28 37 , 2006 .
[ 24 ] J S Yeh , C Y Chang and Y T Wang . Efficient Algorithms for Incremental
Utility Mining . In Proc . of the 2nd Int'l Conf . on Ubiquitous information management and communication , pp . 212 217 , 2008 .
[ 25 ] S J Yen and Y S Lee . Mining High utility Quantitative Association Rules . In
Proc . of 9th Int'l Conf . on Data Warehousing and Knowledge Discovery ( DaWaK'2007 ) , Lecture Notes in Computer Science ( LNCS ) 4654 , pp . 283 292 , 2007 .
[ 26 ] Frequent itemset mining implementations repository , http://fimicshelsinkifi/ [ 27 ] FoodMart2000 , Microsoft Developer Network ( MSDN ) , http://msdnmicrosoftcom/en us/library/aa217032(v=sql80)asp
86
