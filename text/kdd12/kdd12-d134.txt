Mining Recent Temporal Patterns for Event Detection in
Multivariate Time Series Data
Iyad Batal
Dept . of Computer Science
University of Pittsburgh iyad@cspittedu
Dmitriy Fradkin
Siemens Corporate Research dmitriyfradkin@siemenscom
James Harrison
Dept . of Public Health
Sciences
University of Virginia jamesharrison@virginiaedu
Fabian Moerchen
Siemens Corporate Research fabianmoerchen@siemenscom
Milos Hauskrecht
Dept . of Computer Science
University of Pittsburgh milos@cspittedu
ABSTRACT Improving the performance of classifiers using pattern mining techniques has been an active topic of data mining research . In this work we introduce the recent temporal pattern mining framework for finding predictive patterns for monitoring and event detection problems in complex multivariate time series data . This framework first converts time series into time interval sequences of temporal abstractions . It then constructs more complex temporal patterns backwards in time using temporal operators . We apply our framework to health care data of 13,558 diabetic patients and show its benefits by efficiently finding useful patterns for detecting and diagnosing adverse medical conditions that are associated with diabetes .
Categories and Subject Descriptors I26 [ LEARNING ] : General
Keywords Temporal Pattern Mining , Temporal Abstractions , Time interval Patterns , Event Detection , Patient Classification .
1 .
INTRODUCTION
Advances in data collection and data storage technologies led to emergence of complex temporal datasets , where the data instances are traces of complex behaviors characterized by time series of multiple variables . Designing algorithms capable of learning classification models from such data is one of the most challenging topics of data mining research .
The majority of existing classification methods that work with temporal data [ 12 , 6 , 4 , 24 , 8 , 28 ] assume that each data instance ( represented by a single or multiple time series ) is associated with a single class label that affects its entire behavior . That is , they assume that all temporal observations are equally useful for classification .
However , the above assumption is not the best when considering monitoring and event detection problems . In this case , the class label denotes an event that is associated with a specific time point ( or a time interval ) in the instance , not necessarily in the entire instance . The goal is to learn a model that can accurately identify the occurrence of events in unlabeled instances ( a monitoring task ) . Examples of such problems are the detection of adverse medical events ( eg drug toxicity ) in clinical data [ 10 ] , detection of the equipment malfunction [ 9 ] , fraud detection [ 23 ] , environmental monitoring [ 16 ] , intrusion detection [ 7 ] and others .
Given that class labels are associated with specific time points ( or time intervals ) , each instance can be annotated with multiple labels1 . Consequently , the context in which the classification is made is often local and affected by the most recent behavior of the monitored instances .
The focus of this paper is to develop a pattern mining technique that takes into account the local nature of decisions for monitoring and event detection problems . We propose the Recent Temporal Pattern ( RTP ) mining framework , which mines frequent temporal patterns backward in time , starting from patterns related to the most recent observations . Applying this technique , temporal patterns that extend far into the past are likely to have low support in the data and hence would not be considered for classification . Incorporating the concept of recency in temporal pattern mining is a new research direction that , to the best of our knowledge , has not been previously explored in the pattern mining literature .
We study our RTP mining approach by analyzing temporal data encountered in Electronic Health Record ( EHR ) systems . In EHR data , each record ( data instance ) consists of multiple time series of clinical variables collected for a specific patient , such as laboratory test results and medication orders . The record may also provide information about patient ’s diseases and adverse medical events over time . Our objective is to learn classification models that can accurately detect adverse events and apply it to monitor future patients . The task of temporal modeling for EHR data is challenging because the data are multivariate and the time series for clinical variables are irregularly sampled in time ( measured asynchronously at different time moments ) . Therefore , most existing times series classification methods [ 6 , 24 ] , time series similarity measures [ 29 , 20 ] and time series feature extraction methods [ 4 , 13 ] cannot be directly applied on the raw EHR data .
This paper proposes a temporal pattern mining approach that can
1In the clinical domain , a patient may be healthy at first , then develop an adverse medical condition , then be cured and so on .
280 handle complex data such as EHR . The key step for this approach is defining a language that can adequately represent the temporal dimension of the data . Our approach relies on 1 ) temporal abstractions [ 21 ] to convert numeric time series variables to time interval sequences and 2 ) temporal relations [ 3 ] to represent temporal interactions among the variables . For example , this allows us to define complex temporal patterns ( time interval patterns ) such as “ the administration of heparin precedes a decreasing trend in platelet counts ” .
After defining patterns from temporally abstracted data , we need to design an efficient mining algorithm for finding patterns that are useful for event detection . Mining time interval data is a relatively young research field that extends sequential pattern mining [ 2 , 31 , 18 , 30 ] to the more complex case of time interval pattern mining2 . Most existing methods mine frequent patterns in an unsupervised way in order to find temporal association rules [ 22 , 11 , 17 , 14 , 26 , 27 , 15 ] . Our objective is different because we are interested in mining temporal patterns that are potentially important for the event detection task . To address this , we present an efficient algorithm for mining RTPs ( see above ) from time interval data .
We test and demonstrate the usefulness of our framework on real world EHR data collected for 13,558 diabetes patients . Our task is to learn classification models that can correctly diagnose disorders associated with diabetes , such as cardiological , renal or neurological disorders . We first show that incorporating the temporal dimension is beneficial for this task . In addition , we show the following advantages of our framework :
1 . RTP mining focuses the search on temporal patterns that are potentially more useful for classification .
2 . The number of frequent RTPs is much smaller than the number of frequent temporal patterns . This can facilitate the process of reviewing and validating the mined patterns by human experts .
3 . Our mining algorithm is much more efficient than other temporal pattern mining approaches and it can scale up much better to large datasets .
2 . PROBLEM DEFINITION
Let D = {< xi , yi >}n i=1 be a training dataset such that xi ∈ X is a multivariate temporal instance up to some time ti and yi ∈ Y is a class label associated with xi at time ti . The objective is to learn a function f : X → Y that can label unlabeled instances . This general setting is applicable to different monitoring and event detection problems , such as the ones described in [ 23 , 7 , 9 , 16 ] .
In this work , we test our method on data from electronic health records ( EHR ) , hence we will use the EHR application as example throughout the paper . For this task , every data instance xi is a record for a specific patient up to time ti and the class label yi denotes whether or not this patient is diagnosed with an adverse medical condition ( eg , renal failure ) at ti . Figure 1 shows a graphical illustration of an EHR instance with 3 clinical temporal variables . The objective is to learn a classifier that can predict well the studied medical condition and apply it to monitor future patients .
Learning the classifier directly from EHR data is very difficult because the instances consist of multiple irregularly sampled time series of different length . Therefore , we want to apply a space transformation ψ : X → X ′ that maps each instance xi to a fixed size feature vector x′ i , while preserving the predictive temporal characteristics of xi as much as possible .
2Sequential pattern mining is a special case of time interval pattern mining , in which all intervals are instantaneous ( with zero durations ) .
Figure 1 : An example of an EHR data instance with three temporal variables . The black dots represent their values over time .
One approach to define ψ is to represent the data using a predefined set of features and their values ( a static transformation ) as in [ 10 ] . Examples of such features are “ most recent platelet measurement ” , “ most recent platelet trend ” , “ maximum hemoglobin measurement ” , etc . Our approach is different and we learn transformation ψ from the data using temporal pattern mining ( a dynamic transformation ) . This is done by applying the following steps :
1 . Convert the numeric time series variables into time interval sequences using temporal abstraction .
2 . Mine recent temporal patterns from the time interval data . 3 . Transform each instance xi into a binary indictor vector x′ i using the patterns obtained in step 2 .
After applying transformation ψ , we can use a standard machine learning method ( eg support vector machines , decision tree , or logistic regression ) on {<x′ i=1 to learn function f . i , yi >}n
In the following , we explain in details each of these steps .
3 . TEMPORAL ABSTRACTION PATTERNS
3.1 Temporal Abstraction
The goal of temporal abstraction [ 21 ] is to transform the numeric time series variables to a high level qualitative form . More specifically , each clinical variable ( eg , series of white blood cell counts ) is transformed into an interval based representation hv1[s1 , e1 ] , , vn[sn , en]i , where vi ∈ Σ is an abstraction that holds from time si to time ei and Σ is the abstraction alphabet that represents a finite set of permitted abstractions .
For the EHR data , we segment all laboratory variables based on their values into the following abstract states : Very Low ( VL ) , low ( L ) , Normal ( N ) , High ( H ) and Very High ( VH ) , ie , Σ = {VL , L , N , H , VH} . We use the 10th , 25th , 75th and 90th percentiles of the lab values to define these 5 states : a value below the 10th percentile is very low ( VL ) , a value between the 10th and 25th percentiles is low ( L ) , and so on .
3.2 Multivariate State Sequences
Let a state be an abstraction for a specific variable . We denote a state S by a pair ( F , V ) , where F is a temporal variable and V ∈ Σ is an abstraction value . Let a state interval be a state that holds during an interval . We denote a state interval E by a 4 tuple ( F , V , s , e ) , where F is a temporal variable , V ∈ Σ is an abstraction value , and s and e are the start time and end time ( respectively ) of the state interval ( E.s ≤ Ee)3 For example , assuming the time granularity is days , ( glucose , H , 5 , 10 ) represents high glucose values from day 5 to day 10 .
After abstracting all time series variables , we represent every instance xi in the database D as a Multivariate State Sequence ( MSS ) Zi . Let Zi .end denote the end time of the instance .
3If E.s = E.e , state interval E corresponds to a time point .
281 For notational convenience , we represent an MSS Zi as a series of state intervals that are sorted according to their start times4 :
Zi = h E1 , E2 , , El i : Ej.s ≤ Ej+1.s : j ∈ {1 , , l−1}
Note that we do not require Ej.e to be less than Ej+1.s because the state intervals are obtained from different temporal variables and their intervals may overlap .
EXAMPLE 1 . Figure 2 shows an MSS Zi with two temporal variables : creatinine ( C ) and glucose ( G ) . Assuming the time granularity is days , this MSS represents 24 days of the patient ’s record ( Zi.end = 24 ) . For instance , we can see that the creatinine values are normal from day 2 until day 14 , then become high from day 15 until day 24 . We represent Zi as : h E1 = ( G , H , 1 , 5 ) , E2 = ( C , N , 2 , 14 ) , E3 = ( G , N , 6 , 9 ) , E4 = ( G , H , 10 , 13 ) , E5 = ( C , H , 15 , 24 ) , E6 = ( G , VH , 16 , 23 ) i .
Figure 2 : An MSS representing 24 days of a patient record . In this example , there are two temporal variables ( creatinine and glucose ) .
3.3 Temporal Relations
The temporal relation between two instantaneous events ( time points ) can be easily described using three relations : before , at the same time and after . However , when the events have time durations ( state intervals ) , the relations become more complex . Allen [ 3 ] described the temporal relation between two state intervals using 13 possible relations ( Figure 3 ) . But it suffices to use the following 7 relations : before , meets , overlaps , is finished by , contains , starts and equals because the other relations are simply their inverses . Allen ’s relations have been introduced in artificial intelligence for temporal reasoning and have been used later in the fairly young research of time interval data mining [ 22 , 11 , 17 , 26 , 15 ] .
Figure 3 : Allen ’s temporal relations .
As we can see , most of these relations require equality of one or two of the intervals’ end points . That is , there is only a slight difference between overlaps , is finished by , contains , starts and equals relations . When the time information in the data is noisy , which is the case for EHR data , using Allen ’s relations may cause the problem of pattern fragmentation5 [ 14 ] . 4If two state intervals have the same start time , we sort them by their end time . If they also have the same end time , we sort them by lexical order ( see [ 11] ) . 5Having many different temporal patterns that describe a very similar situation in the data .
Therefore , we opt to use only two temporal relations : before ( b ) and co occurs ( c ) , which we define as follows : Given two state intervals Ei and Ej :
• Ei is before Ej , denoted as b(Ei , Ej ) , if Ei.e < Ej .s
( same as Allen ’s before ) .
• Ei co occurs with Ej , denoted as c(Ei , Ej ) , if Ei.s ≤ Ej.s ≤ Eie That is , Ei starts before Ej and there is a nonempty time period where both Ei and Ej occur . Note that this relation covers the following Allen ’s relations : meets , overlaps , is finished by , contains , starts and equals .
3.4 Temporal Patterns
In order to obtain temporal descriptions of the data , basic states are combined using temporal relations to form temporal patterns ( time interval patterns ) . In the previous section , we defined the relation between two states to be either before ( b ) or co occurs ( c ) . In order to define relations between k states , we use Höppner ’s representation of temporal patterns [ 11 ] .
DEFINITION 1 . ( Temporal Pattern ) A temporal pattern is defined as P = ( hS1 , , Ski , R ) where Si is the ith state of the pattern and R is an upper triangular matrix that defines the temporal relations between each state and all of its following states : i ∈ {1 , , k −1} ∧ j ∈ {i+1 , , k} : Ri,j ∈ {b , c} specifies the relation between Si and Sj .
The size of a temporal pattern P is the number of states it contains . If P contains k states , we say that P is a k pattern . Hence , a single state is a 1 pattern ( a singleton ) . We also denote the space of all temporal patterns of arbitrary size by TP .
Figure 4 shows a graphical representation of a 4 pattern hS1 = ( C , H ) , S2 = ( G , N ) , S3 = ( B , H ) , S4 = ( G , H)i , where the states are abstractions of temporal variables creatinine ( C ) , glucose ( G ) and BUN ( Blood Urea Nitrogen ) ( B ) . The half matrix on the right represents the temporal relations between every state and the states that follow it . For example , the first state S1 co occurs with the third state S3 : R1,3 = c .
Figure 4 : A temporal pattern with states h(C , H ) , ( G , N ) , ( B , H ) , ( G , H)i and temporal relations R1,2 = c , R1,3 = c , R1,4 = b , R2,3 = c , R2,4 = b and R3,4 = c .
DEFINITION 2 . Given an MSS Z = h E1 , E2 , , El i and a temporal pattern P = ( hS1 , , Ski , R ) , we say that Z contains P , denoted as P ∈ Z , if there is an injective mapping π from the states of P to the state intervals of Z such that :
∀i ∈ {1 , , k} : Si.F = Eπ(i).F ∧ Si.V = Eπ(i).V ∀i ∈ {1 , , k − 1} ∧ j ∈ {i+1 , , k} : Ri,j `Eπ(i ) , Eπ(j)´
The definition says that checking whether an MSS contains a k pattern requires : 1 ) matching all k states of the pattern and 2 ) checking that all k(k − 1)/2 temporal relations are satisfied . As an example , the MSS in Figure 2 contains the temporal pattern P = ( h ( C , N ) , ( G , N ) i , R1,2 = c ) ( normal creatinine co occurs with normal glucose ) . To improve readability , we usually write 2patterns of the form ( hS1 , S2i , R1,2 ) simply as S1 R1,2 S2 . That is , we can write P = ( C , N ) c ( G , N ) .
282 4 . MINING RECENT TEMPORAL PATTERNS
PROPOSITION 1 . Given an MSS Z and temporal patterns P
4.1 Recent Temporal Patterns
In the event detection setting , each training temporal instance xi ( eg an electronic health record ) is associated with class label yi at time ti ( eg whether or not a medical condition is detected ) . Consequently , recent measurements of the variables of xi ( close to ti ) are usually more predictive than distant measurements , as was shown in [ 25 ] for clinical data . In the following , we present the definitions of recent state intervals and recent temporal patterns .
DEFINITION 3 . Given an MSS Z = h E1 , E2 , , El i and a maximum gap parameter g , we say that Ej ∈ Z is a recent state interval in Z , denoted as rg ( Ej , Z ) , if any of the following two conditions are satisfied :
• 6 ∃Ek ∈ Z : Ek.F = Ej.F ∧ k > j
• Z.end − Ej.e ≤ g
The first condition is satisfied if Ej is the most recent state interval in its variable ( Ej.F ) and the second condition is satisfied if Ej is less than g time units away from the end of the MSS ( Zend ) Note that if g = ∞ , any Ej ∈ Z is considered to be recent .
DEFINITION 4 . ( RTP ) Given an MSS Z = hE1 , E2 , , Eli and a maximum gap parameter g , we say that temporal pattern P = ( hS1 , , Ski , R ) is a Recent Temporal Pattern ( RTP ) in Z , denoted as Rg ( P , Z ) , if all the following conditions are satisfied :
1 . P ∈ Z with a mapping π from the states of P to the state intervals of Z
2 . Sk matches a recent state interval in Z : rg(Eπ(k ) , Z )
3 . ∀i ∈ {1 , , k − 1} , Si and Si+1 match state intervals not more than g away from each other : Eπ(i+1).s − Eπ(i).e ≤ g
The definition says that in order for temporal pattern P to be an RTP in MSS Z , 1 ) P should be contained in Z ( Definition 2 ) , 2 ) the last state of P should map to a recent state interval in Z ( Definition 3 ) , and 3 ) any pair of consecutive states in P should map to state intervals that are “ close to each other ” . This forces the pattern to be close to the end of Z and to have a limited temporal extension in the past . Note that g is a parameter that specifies the restrictiveness of the RTP definition . If g = ∞ , any pattern P ∈ Z would be considered to be an RTP in Z . When an RTP contains k states , we call it a k RTP .
EXAMPLE 2 . Let Zi be the MSS in Figure 2 and let the maximum gap parameter be g = 5 days . Temporal pattern P1 = ( C , N ) b ( G , VH ) is an RTP in Zi because P1 ∈ Zi , ( G , VH , 16 , 23 ) is a recent state interval in Zi , and ( C , N , 2 , 14 ) is “ close to ” ( G , VH , 16 , 23 ) ( 16−14 ≤ g ) . On the other hand , P2 = ( G , H ) b ( G , N ) is not an RTP in Zi because ( G , N , 6 , 9 ) is not a recent state interval .
DEFINITION 5 . ( Suffix ) Given temporal patterns P = ( hS1 , , k2 i , R′ ) with k1 ≤ k2 , we say that
Sk1 i , R ) and P ′ = ( hS ′ P is a suffix subpattern of P ′ , denoted as Suffix(P , P ′ ) , if :
1 , , S ′
∀i ∈ {1 , , k1} ∧ j ∈ {i+1 , , k1} :
Si = S ′ i+k2−k1 ∧ Ri,j = R′ i+k2−k1,j+k2−k1
If P is a suffix subpattern of P ′ , we say that P ′ is a backward extension superpattern of P . and P ′ , Rg(P ′ , Z ) ∧ Suffix(P , P ′ ) ⇒ Rg(P , Z )
The proof directly follows from Definition 4 .
EXAMPLE 3 . Assume that P = ( hS1 , S2 , S3i , R1,2 , R1,3 , R2,3 ) is an RTP in Z . Proposition 1 says that its suffix subpattern ( hS2 , S3i , R2,3 ) must also be an RTP in Z . However , this does not imply that ( hS1 , S2i , R1,2 ) must be an RTP ( the second condition of Definition 4 may be violated ) nor that ( hS1 , S3i , R1,3 ) must be an RTP ( the third condition of Definition 4 may be violated ) .
DEFINITION 6 . ( Frequent RTP ) Given a dataset D of MSS , a maximum gap parameter g and a minimum support threshold σ , we define the support of an RTP P as RTP supg ( P , D)= | {Zi : Zi ∈ D ∧ Rg(P , Zi)} | . We say that P is a frequent RTP in D given σ if RTP supg(P , D ) ≥ σ .
Note that Proposition 1 implies the following property of RTPsup , which we will use in our algorithm for mining frequent RTPs .
∀P , P ′ ∈ TP , Suffix(P , P ′ ) ⇒ RTP supg(P , D ) ≥ RTP supg(P ′ , D )
4.2 The Mining Algorithm
In this section , we present the algorithm for mining frequent RTPs . We chose to utilize the class information and mine frequent RTPs from each class label separately using local minimum supports as opposed to mining frequent RTPs from the entire data using a single global minimum support . The approach is reasonable when pattern mining is applied in the supervised setting because 1 ) for unbalanced data , mining frequent patterns using a global minimum support threshold may result in missing many important patterns in the rare classes and 2 ) mining patterns that are frequent in one of the classes ( hence potentially predictive for that class ) is more efficient than mining patterns that are globally frequent .
The algorithm takes as input Dy : the MSS from class y , g : the maximum gap parameter and σy : the local minimum support threshold for class y . It outputs all temporal patterns that satisfy :
{P ∈ TP : RTP supg(P , Dy ) ≥ σy}
The mining algorithm performs a level wise search . It first scans the database to find all frequent 1 RTPs ( recent states ) . Then it extends the patterns backward in time to find more complex temporal patterns . For each level k , the algorithm performs the following two phases to obtain the frequent ( k+1) RTPs :
1 . The candidate generation phase : Generate candidate ( k+1 ) patterns by extending frequent k RTPs backward in time .
2 . The counting phase : Obtain the frequent ( k+1) RTPs by removing the candidates with RTP sup less than σy .
This process repeats until no more frequent RTPs can be found .
In the following , we describe in details the candidate generation algorithm . Then we proposed techniques to improve the efficiency of candidate generation and counting .
421 Backward Candidate Generation
We generate a candidate ( k+1) pattern by appending a new state ( 1 pattern ) to the beginning of a frequent k RTP . Let us assume that we are backward extending pattern P = ( hS1 , , Ski , R ) with state Snew to generate candidates of the form ( hS ′ k+1i , R′ ) . First of all , we set S ′ i+1 = Si for i ∈ {1 , , k} and R′ i+1,j+1 = Ri,j for i ∈ {1 , , k − 1} ∧ j ∈ {i + 1 , , k} . This way , we know that every candidate P ′ of this form is a backwardextension superpattern of P : Suffix(P , P ′ ) .
1 = Snew , S ′
1 , , S ′
283 1 and states S ′
In order to fully define a candidate , we still need to specify the temporal relations between the new state S ′ k+1 , ie , we should define R′ 1,i for i ∈ {2 , , k + 1} . Since we have two possible temporal relations ( before and co occurs ) , there are 2k possible ways to specify the missing relations , resulting in 2k different candidates . Let L denote all possible states and let Fk denote all frequent k RTPs , generating the ( k+1) candidates naively in this fashion results in 2k × |L| × |Fk| different candidates .
2 , , S ′
This large number of candidates makes the mining algorithm computationally very expensive and limits its scalability . Below , we describe the concept of incoherent patterns and introduce a method that generates fewer candidates without missing any real pattern from the mining results .
422 Improving the Efficiency of Candidate Gener ation
DEFINITION 7 . A temporal pattern P is incoherent if there does not exist any valid MSS that contains P .
Clearly , we do not have to generate and count incoherent candidates because we know that they will have zero support in the data . We introduce the following two lemmas to avoid generating incoherent candidates when specifying the relations R′ 1,i : i ∈ k+1i , R′ ) . {2 , , k+1} in candidates of the form P ′ = ( hS ′
1 , , S ′
LEMMA 1 . P ′ = ( hS ′
1 , , S ′ k+1i , R′ ) is incoherent if ∃i ∈
{2 , , k+1} : R′
1,i = c and S ′
1.F = S ′ i.F .
Two state intervals from the same temporal variable cannot cooccur because temporal abstraction segments each variable into non overlapping state intervals .
LEMMA 2 . P ′ = ( hS ′
1 , , S ′ k+1i , R′ ) is incoherent if ∃i ∈
{2 , , k+1} : R′
1,i = c ∧ ∃j ∈ {2 , , i−1} : R′
1,j = b .
PROOF . Let us assume that there exists an MSS Z = hE1 , , Eli where P ′ ∈ Z . Let π be the mapping from the states of P ′ to the state intervals of Z . The definition of temporal patterns and the fact that state intervals in Z are ordered by their start values implies that the matching state intervals hEπ(1 ) , , Eπ(k+1)i are also ordered by their start times : Eπ(1).s ≤ ≤ Eπ(k+1)s Hence , Eπ(j).s ≤ Eπ(i).s since j < i . We also know that Eπ(1).e < Eπ(j).s because R′ 1,j = b . Therefore , Eπ(1).e < Eπ(i)s However , since R′ 1,i = c , then Eπ(1).e ≥ Eπ(i).s , which is a contradiction . Therefore , there is no MSS that contains P ′ .
2 = ( C , H ) , S ′
3 = ( G , N ) , S ′
EXAMPLE 4 . Assume we want to extend P = ( hS1 = ( C , H ) , S2 = ( G , N ) , S3 = ( B , H ) , S4 = ( G , H)i , R ) in Figure 4 with state Snew = ( G , H ) to generate candidates of the form ( hS ′ 1 = ( G , H ) , S ′ 5 = ( G , H)i , 1 and S ′ R′ ) . The relation between S ′ 2 is allowed to be either before or co occurs : R′ 1,2 = b or R′ 1,2 = c . However , according to Lemma 1 , R′ 1 and S ′ 1,3 6= c because both S ′ 3 belong to the same temporal variable ( G ) , which in turn implies that R′ 1,5 6= c according to Lemma 2 . By removing incoherent patterns , we reduce the number of candidates that result from adding ( G , H ) to 4 RTP P from 24 = 16 to only 2 .
1,4 6= c and R′
4 = ( B , H ) , S ′
THEOREM 1 . There are at most k + 1 coherent candidates that result from backward extending a single k RTP with a new state .
PROOF . We know that every candidate P ′ = ( hS ′ k+1i , R′ ) corresponds to a specific assignment of R′ 1,i ∈ {b , c} for i ∈ {2 , k + 1} . When we assign the temporal relations , once a relation becomes before , all the following relations have to be before as well according to Lemma 2 . We can see that the relations can be
1 , , S ′ co occurs in the beginning of the pattern , but once we see a before relation at point q ∈ {2 , , k + 1} in the pattern , all subsequent relations ( i > q ) should be before as well :
R′
1,i = c : i ∈ {2 , , q−1} ; R′
1,i = b : i ∈ {q , , k+1}
Therefore , the total number of coherent candidates cannot be more than k + 1 , which is the total number of different combinations of consecutive co occurs relations followed by consecutive before relations .
In some cases , the number of coherent candidates is less than k + 1 . Assume that there are some states in P ′ that belong to the same variable as state S ′ j be the first such state ( j ≤ k + 1 ) . According to Lemma 1 , R′ 1,j 6= c . In this case , the number of coherent candidates is j −1 < k+1 .
1 . Let S ′
Algorithm 1 illustrates how to extend a k RTP P with a new state Snew to generate coherent candidates ( without violating Lemmas 1 and 2 ) .
ALGORITHM 1 : Extend backward a k RTP P with a state Snew .
Input : A k RTP : P = ( hS1 , , Ski , R ) ; a new state : Snew Output : Coherent candidates : C i+1 = Si : i ∈ {1 , , k} ;
1 = Snew ; S ′ i+1,j+1 = Ri,j : i ∈ {1 , , k − 1} , j ∈ {i + 1 , , k} ; 1,i = b : i ∈ {2 , , k + 1} ;
P ′ = ( hS ′
1 , , S ′ k+1i , R′ ) ;
1 S ′ 2 R′ 3 R′ 4 C = {P ′} ; 5 for i=2 to k+1 do 1.F = S ′ 6 break ; 7 8 9 if ( S ′ else
10 i.F ) then
1,i = c ;
R′ C = C ∪ {P ′} ;
P ′ = ( hS ′
1 , , S ′ k+1i , R′ ) ; end
11 12 end 13 return C
COROLLARY 1 . Let L denote all possible states and let Fk denote all frequent k RTPs . The number of coherent ( k+1) candidates is always less or equal to ( k + 1 ) × |L| × |Fk| .
423 Improving the Efficiency of Counting
Even after eliminating incoherent patterns , the mining algorithm is still computationally expensive because for every candidate , we need to scan the entire database in the counting phase to determine its RTP sup . The question we try to answer in this section is whether we can omit portions of the database that are guaranteed not to contain the candidate we want to count . The proposed solution is inspired by [ 32 ] that introduced the vertical format for itemset mining and later applied it for sequential pattern mining [ 31 ] .
Let us associate every frequent RTP P with a list of identifiers for all MSS that have P as an RTP ( Definition 4 ) :
P.RTP list = hi1 , i2 , , ini : Zij ∈ Dy ∧ Rg(P , Zij )
Clearly , RTP supg(P , Dy ) = |PRTP list| Let us also associate every state S with a list of identifiers for all
MSS that contain S ( Definition 2 ) :
S.list = hq1 , q2 , , qmi : Zqj ∈ Dy ∧ S ∈ Zqj
Now , when we generate candidate P ′ by backward extending RTP P with state S , we define the potential list ( p RTP list ) of P ′ as follows :
P ′.p RTP list = P.RTP list ∩ S.list
284 PROPOSITION 2 . Let P ′ be a backward extension of RTP P
5 . EXPERIMENTAL EVALUATION with state S : P ′.RTP list ⊆ P ′.p RTP list
PROOF . Assume Zi is an MSS such that Rg(P ′ , Zi ) . By definition , i ∈ P ′RTP list We know that Rg(P ′ , Zi ) ⇒ P ′ ∈ Zi ⇒ S ∈ Zi ⇒ i ∈ Slist Also , we know that Suffix(P , P ′ ) ( Definition 5 ) ⇒ Rg(P , Zi ) ( Proposition 1 ) ⇒ i ∈ PRTP list Therefore , i ∈ P.RTP list ∩ S.list = P ′.p RTP list
Putting it all together , we compute the RTP lists in the counting phase ( based on the true matches ) and the p RTP lists in the candidate generation phase . The key idea is that when we count candidate P ′ , we only need to check the instances in its p RTP list because according to Proposition 2 : i 6∈ P ′.p RTP list ⇒ i 6∈ P ′.RTP list ⇒ P ′ is not an RTP in Zi . This offers a lot of computational savings because the p RTP lists get smaller as the size of the patterns increases , making the counting phase much faster .
Algorithm 2 outlines the candidate generation . Line 4 generates coherent candidates using Algorithm 1 . Line 6 computes the p RTP list for each candidate . Note that the cost of the intersection is linear because the lists are always sorted according to the order of the instances in the database . Line 7 applies an additional pruning to remove candidates that are guaranteed not to be frequent according to the following implication of Proposition 2 :
|P ′.p RTP list| < σy =⇒ |P ′.RTP list| = RTP supg(P , Dy ) < σy
ALGORITHM 2 : A high level description of candidate generation .
Input : All frequent k RTPs : Fk ; all frequent states : L Output : Candidate ( k+1) patterns : Cand , with their p RTP lists foreach S ∈ L do
1 Cand = Φ ; 2 foreach P ∈ Fk do 3 4 5 6 7 8 9 end
C[q].p RTP list = P.RTP list ∩ S.list ; if ( | C[q].p RTP list | ≥ σy ) then
Cand = Cand ∪ {C[q]} ;
C = extend_backward(P , S ) ; for q = 1 to | C | do
( Algorithm 1 )
10 end end
11 12 end 13 return Cand
4.3 Learning the Classifier
In this section , we summarize our approach for learning classification models for event detection problems . Given a training dataset {< xi , yi >}n i=1 , where xi is a multivariate time series instance up to time ti and yi is a class label at ti , apply the following steps :
1 . Convert every instance xi to an MSS Zi using temporal ab straction .
2 . Mine the frequent RTPs from the MSS of each class label separately and combine the class specific RTPs to obtain the final result Ω .
3 . Convert every MSS Zi into a binary vector x′ i of size equal i,j corresponds to a specific pattern Pj ∈ Ω to |Ω| , where x′ and its value is 1 if Rg(Pj , Zi ) ; and 0 otherwise .
4 . Learn the classification model on the transformed binary rep resentation of the training data {< x′ i , yi >}n i=1 .
In this section , we present our experiments on large scale electronic health record ( EHR ) data collected for diabetic patients . We test our approach on the problem of detecting various types of disorders that are frequently associated with diabetes .
5.1 Dataset
The diabetes dataset consists of 13,558 records of adult diabetic patients ( both type I and type II diabetes ) . Each patient ’s record consists of time series of 19 different lab values , including blood glucose , creatinine , glycosylated hemoglobin , blood urea nitrogen , liver function tests , cholesterol , etc . In addition , we have access to time series of ICD 9 diagnosis codes reflecting the diagnoses made for the patient over time . Overall , the database contains 602 different ICD 9 codes . These codes were grouped by our medical expert into nine major categories : cardiovascular disease , renal disease , peripheral vascular disease , neurological disease , metabolic disease , inflammatory disease , ocular disease , cerebrovascular disease and hypertension . These disease categories are frequently associated with diabetes . Our objective is to learn models that are able to accurately diagnose these diseases . More specifically , at any point in time , we are interested in assigning a label for the disorder the patient with the diabetes suffers from . We omit the hypertension category from the analysis because it occurred in almost all patients , making it difficult to find negative examples .
5.2 Experimental Setup
The experiments are performed separately for each of the 8 major diagnosis categories ( diseases ) . For each category , we divide the data into cases ( positives ) and controls ( negatives ) as follows :
• The cases are records of patients with the target disease that include clinical variables up to the time the disease was first diagnosed .
• The controls are selected randomly from the remaining patients ( without the target disease ) and they include clinical variables up to a randomly selected time point in the patient ’s record .
To avoid having uninformative training data , we discard instances that contain less than 10 lab measurements or that span less than 3 months ( short instances ) . We choose the same number of controls as the number of cases for each category to make the datasets balanced . Table 1 shows the number of cases for each diagnosis category ( the number of controls is the same ) .
To construct the features , we consider both the laboratory tests and the diagnosis codes . Note that the diagnosis of one or more disease categories may be predictive of the ( first ) occurrence of another disease , so it is important to include them as features . Laboratory tests are represented as numeric time series . We abstract them using value abstraction ( see Section 31 ) Diagnosis categories , when used as features , are represented as intervals that start at the time of the diagnosis and extend until the end of the record .
5.3 Classification Performance
In this section , we test the ability of our RTP mining framework to represent and capture temporal patterns important for the prediction task . In particular , we compare the classification performance of the following feature construction methods :
1 . Last_values : The features are formed from the most recent values of each clinical variable6 .
6The features are numeric for the laboratory variables ( eg , last creatinine value is 2.2 ) and binary for the disease categories ( whether or not the disease was diagnosed ) .
285 Peripheral vascular disease
Dx code Description CARDI RENAL Renal disease PERIP NEURO Neurological disease METAB Metabolic disease INFLM Inflammatory ( infectious ) disease OCULR Ocular ( ophthalmologic ) disease CEREB
Cardiovascular disease
Cerebrovascular disease
# cases 2,743 3,355 3,370 2,193 968 2,394 2,245 2,824
Dataset CARDI RENAL PERIP NEURO METAB INFLM OCULR CEREB
Last_values
TP
TP_sparse
67.41 77.71 66.82 64.66 72.83 64.6 65.83 65.21
71.82 76.38 68.55 68.95 74.64 66.73 70.8 66.64
71.62 76.66 68.38 68.33 73.61 66.69 70.71 66.7
RTP 71.82 78.08 70.01 69.18 73.3 67.5 68.82 67.93
RTP_sparse
71.98 78.33 69.91 69.68 73.09 67.94 69.22 66.98
Table 1 : The eight major diagnosis categories ( diseases ) used in the diabetes study and the number of cases for each category . The number of controls is set to be the same as the number of cases .
Table 2 : The classification accuracy for the different feature representation methods ( SVM is used for classification ) .
2 . TP : The features correspond to all frequent temporal pat terns .
3 . TP_sparse : The features correspond to the top 50 discriminative temporal patterns that are selected using a sparse linear model . These features are obtained by adjusting the cost parameter of an L1 regularized support vector machine ( SVM ) classifier until at most 50 patterns are used for classification ( features corresponding to other patterns are zeroed out ) .
4 . RTP : The features correspond to all frequent RTPs .
5 . RTP_sparse : The features correspond to the top 50 discriminative RTPs that are selected using a sparse linear model ( similar to 3 ) .
The first method is atemporal and only considers the most recent values for defining the classification features ( a static transformation ) . On the other hand , methods ( 2 5 ) use temporal patterns ( built using temporal abstractions and temporal relations ) as their features ( a dynamic transformation ) . For TP ( TP_sparse ) , the feature value is one if the corresponding temporal pattern occurs anywhere in the instance ( Definition 2 ) , and zero otherwise . For RTP ( RTP_sparse ) , the feature value is one if the corresponding temporal pattern occurs recently in the instance ( Definition 3 ) , and zero otherwise .
For methods ( 2 5 ) , we set the local minimum supports ( σy ) to 15 % of the number of instances in the class . For the RTP mining methods ( 4 5 ) , we set the maximum gap parameter ( g ) to 6 months . The reason for including methods 3 and 5 is to test the ability of TP and RTP to represent the target disease using only a limited number of temporal patterns ( 50 patterns in our case ) .
We judged the quality of the different feature representations in terms of their induced classification performance . More specifically , we use the features extracted by each method to build a linear SVM classifier and evaluate its performance using the classification accuracy and the area under the ROC curve ( AUC ) . We did not compare against other time series classification methods because most methods [ 24 , 6 , 28 , 4 ] cannot be directly applied on multivariate irregularly sampled time series data .
Below , we show the classification accuracy ( Table 2 ) and the AUC ( Table 3 ) for each feature representation method on each classification task ( major disease ) . All classification results are reported using averages obtained via 10 folds cross validation .
The results show that features based on temporal patterns are beneficial for the classification task , since they outperform features based on most recent values ( see for example the NEURO , OCLUR and CARDI datasets ) . The results also show that RTP and RTP_sparse mostly outperform TP and TP_sparse . It is important to note that although patterns generated by TP subsume the ones generated by RTP ( by definition , every frequent RTP is also a frequent TP ) , the induced binary features are often different . For
Dataset CARDI RENAL PERIP NEURO METAB INFLM OCULR CEREB
Last_values
TP
TP_sparse
75.1 85.45 74.38 72.25 80.64 71.04 72.12 72.23
80.13 84.8 76.08 76.43 82.67 73.62 78.34 73.46
79.61 84.97 75.95 75.81 81.66 73.43 78.28 74.42
RTP 80.18 86.13 77.88 77.34 82.52 74.39 76.11 75.37
RTP_sparse
80.52 86.23 78.31 76.98 82.97 74.92 76.85 75.18
Table 3 : The area under the ROC curve ( AUC ) for the different feature representation methods ( SVM is used for classification ) . instance , a pattern that is not discriminative when considered in the entire records may become more discriminative when considered as a recent pattern . This can be seen clearly for the RENAL dataset , where TP and TP_sparse perform poorly because the discriminative signal is mostly contained in the recent values .
5.4 Knowledge Discovery
Figure 5 compares the number of temporal patterns that are extracted by frequent temporal pattern mining ( TP ) and by frequent RTP mining ( RTP ) . Similar to the previous setting , we set the local minimum supports for both methods to 15 % and we set the maximum gap parameter for RTP to 6 months .
The results show that the number of temporal patterns mined by RTP is at least an order of magnitude smaller than the number of patterns mined by TP for all datasets . This can facilitate the process of reviewing and validating the patterns by human experts .
Figure 5 : The number of temporal patterns of TP and RTP on all major diagnosis datasets ( minimum support is 15% ) .
Table 4 shows some of the top predictive RTPs according to their
286 precision ( confidence)7 . The first three RTPs ( P1 , P2 and P3 ) are predicting renal ( kidney ) disease . These patterns relate the risk of renal problems with very high values of the BUN test ( P1 ) , an increase in creatinine levels from normal to high ( P2 ) , and high values of BUN co occurring with high values of creatinine ( P3 ) . P4 shows that an increase in glucose levels from high to very high may indicate a metabolic disease . Finally , P5 indicates that patients who were previously diagnosed with cardiovascular disease and exhibit an increase in glucose levels are prone to develop a cerebrovascular disease . These patterns , extracted automatically from data without incorporating prior clinical knowledge , are in accordance with the medical diagnosis guidelines . prec RTP P1 : BUN=VH ⇒ Dx=RENAL 0.97 P2 : Creat=N before Creat=H ⇒ Dx=RENAL 0.96 P3 : BUN=H co occurs Creat=H ⇒ Dx=RENAL 0.95 P4 : Gluc=H before Gluc=VH ⇒ Dx=METAB 0.79 P5 : Dx=CARDI co occurs ( Gluc=N before recall 0.17 0.21 0.21 0.24
Gluc=H ) ⇒ Dx=CEREB
0.71
0.22
Table 4 : Predictive RTPs with their precision ( prec ) and recall . Abbreviations : Dx : diagnosis code ( one of the 8 major categories in Table 1 ) ; BUN : Blood Urea Nitrogen ; Creat : creatinine ; Gluc : blood glucose . Abstractions : BUN=VH : > 49 mg/dl ; BUN=H : > 34 mg/dl ; Creat=H : > 1.8 mg/dl ; Creat=N : [ 08 18 ] mg/dl ; Gluc=VH : > 243 mg/dl ; Gluc=H:> 191 mg/dl .
5.5 Mining Efficiency
In this section , we study the efficiency of different temporal pattern mining methods . In particular , we compare the running time of the following methods :
1 . TP_Apriori : Mine frequent temporal patterns by extending the Apriori algorithm [ 1 , 2 ] to the time interval domain . This method applies the Apriori pruning in the candidate generation phase to prune any candidate k pattern if it contains an infrequent ( k 1) patterns .
2 . RTP_no lists : Mine frequent RTPs backward in time as described in this paper . However , this method does not apply the technique we propose in Section 423 to speed up the counting phase . This means that it scans the entire dataset for each candidate in order to compute its RTP sup .
3 . TP_lists : Mine frequent temporal patterns by extending the vertical format [ 32 , 31 ] to the time interval domain as described in [ 5 ] . This method applies the Apriori pruning [ 1 ] in candidate generation and use id lists to speed up the counting .
4 . RTP_lists : Our proposed method for mining frequent RTPs .
To make the comparison fair , all methods apply the techniques we propose in Section 422 to avoid generating incoherent candidates . Note that if we do not remove incoherent candidates , the execution time for all methods greatly increases .
The experiments are conducted on a Dell PowerEdge R610 server with an Intel Xeon 3.3GHz CPU and 96GB of RAM . Similar to the previous settings , we set the local minimum supports to 15 % and the maximum gap parameter to 6 months ( unless stated otherwise ) .
7Most of the highest precision RTPs are predicting the RENAL category because it is the easiest prediction task . So to diversify the patterns , we show the top 3 predictive RTPs for RENAL and the top 2 predictive RTPs for other categories .
Figure 6 shows the execution time ( in seconds ) of the above methods on all major diagnosis datasets . We can see that our proposed RTP_lists method is much more efficient the other methods . For instance , on the INFLM dataset , RTP_lists is around 5 times faster than TP_lists , 10 times faster than RTP_no lists and 30 times faster than TP_Apriori .
Figure 6 : The mining time ( in seconds ) of TP_Apriori , RTP_no lists , TP_lists and RTP_lists on all major diagnosis datasets ( minimum support is 15% ) .
Figure 7 compares the execution time ( in seconds ) of the methods on the CARDI dataset for different minimum support thresholds . Note that the difference in the execution time between RTP_lists and the other methods becomes larger when the minimum support is low ( 10% ) .
Figure 7 : The mining time ( in seconds ) of TP_Apriori , RTP_no lists , TP_lists and RTP_lists on the CARDI dataset for different minimum support values .
Finally , let us examine the effect of the maximum gap parameter ( g ) on the efficiency of recent temporal pattern mining . Figure 8 shows the execution time ( in seconds ) of all methods on the CARDI dataset for different values of g ( the execution time of TP_Apriori and TP_lists does not depend of g ) .
Clearly , the execution time of both RTP_no lists and RTP_lists increases with g because the search space becomes larger ( more temporal patterns become RTPs ) . The figure shows that when the maximum gap is 21 months , RTP_no lists becomes slower than TP_Apriori . The reason is that for large values of g , applying the Apriori pruning [ 1 ] in candidate generation becomes more efficient ( generates less candidates ) than the backward extension of temporal patterns ( see Example 3 ) . On the other hand , RTP_lists increases much slower with g and maintains its efficiency advantage over TP_lists for larger values of g .
287 [ 7 ] V . Chandola , E . Eilertson , L . Ertoz , G . Simon , and V . Kumar . Data Warehousing and Data Mining Techniques for Computer Security , chapter :Data Mining for Cyber Security . Springer , 2006 .
[ 8 ] T . P . Exarchos , M . G . Tsipouras , C . Papaloukas , and D . I . Fotiadis . A two stage methodology for sequence classification based on sequential pattern mining and optimization . Data and Knowledge Engineering , 66:467–487 , 2008 .
[ 9 ] S . Guttormsson , I . Marks , RJ , M . El Sharkawi , and I . Kerszenbaum . Elliptical novelty grouping for on line short turn detection of excited running rotors . IEEE Transactions on Energy Conversion , 1999 .
[ 10 ] M . Hauskrecht , M . Valko , I . Batal , G . Clermont , S . Visweswaram , and G . Cooper . Conditional outlier detection for clinical alerting . In Proceedings of AMIA , 2010 .
[ 11 ] F . Höppner . Knowledge Discovery from Sequential Data . PhD thesis ,
Technical University Braunschweig , Germany , 2003 .
[ 12 ] G . Ifrim and C . Wiuf . Bounded coordinate descent for biological sequence classification in high dimensional predictor space . In Proceedings of the international conference on Knowledge Discovery and Data mining ( SIGKDD ) , 2011 .
[ 13 ] L . Li , B . A . Prakash , and C . Faloutsos . Parsimonious linear fingerprinting for time series . PVLDB , 3:385–396 , 2010 .
[ 14 ] F . Moerchen . Algorithms for time series knowledge mining . In
Proceedings of SIGKDD , pages 668–673 , 2006 .
[ 15 ] R . Moskovitch and Y . Shahar . Medical temporal knowledge discovery via temporal abstraction . In Proceedings of AMIA , 2009 .
[ 16 ] S . Papadimitriou , J . Sun , and C . Faloutsos . Streaming pattern discovery in multiple time series . In Proceedings of VLDB , 2005 .
[ 17 ] P . Papapetrou , G . Kollios , and S . Sclaroff . Discovering frequent arrangements of temporal intervals . In Proceedings of ICDM , 2005 .
[ 18 ] J . Pei , J . Han , B . Mortazavi asl , H . Pinto , Q . Chen , U . Dayal , and
M . chun Hsu . Prefixspan : Mining sequential patterns efficiently by prefix projected pattern growth . In Proceedings of the 17th International Conference on Data Engineering ( ICDE ) , 2001 .
[ 19 ] J . Pei , J . Han , and W . Wang . Constraint based sequential pattern mining : the pattern growth methods . Journal of Intelligent Information Systems , 28:133–160 , 2007 .
[ 20 ] C . Ratanamahatana and E . J . Keogh . Three myths about dynamic time warping data mining . In Proceedings of the SIAM International Conference on Data Mining ( SDM ) , 2005 .
[ 21 ] Y . Shahar . A Framework for Knowledge Based Temporal
Abstraction . Artificial Intelligence , 90:79 133 , 1997 .
[ 22 ] P . shan Kam and A . W . chee Fu . Discovering temporal patterns for interval based events . In Proceedings of the DaWaK , 2000 .
[ 23 ] A . Srivastava , A . Kundu , S . Sural , and A . Majumdar . Credit card fraud detection using hidden markov model . IEEE Transactions on Dependable and Secure Computing , 2008 .
[ 24 ] D . L . Vail , M . M . Veloso , and J . D . Lafferty . Conditional random fields for activity recognition . In Proceedings of the international joint conference on Autonomous agents and multiagent systems ( AAMAS ) , 2007 .
[ 25 ] M . Valko and M . Hauskrecht . Feature importance analysis for patient management decisions . In Proceedings of MedInfo , 2010 .
[ 26 ] E . Winarko and J . F . Roddick . Armada an algorithm for discovering richer relative temporal association rules from interval based data . Data and Knowledge Engineering , 63:76–90 , 2007 .
[ 27 ] S Y Wu and Y L Chen . Mining nonambiguous temporal patterns for interval based events . IEEE Transactions on Knowledge and Data Engineering , 19:742–758 , 2007 .
[ 28 ] X . Xi , E . Keogh , C . Shelton , L . Wei , and C . A . Ratanamahatana . Fast time series classification using numerosity reduction . In Proceedings of the International Conference on Machine Learning ( ICML ) , 2006 .
[ 29 ] K . Yang and C . Shahabi . A pca based similarity measure for multivariate time series . In Proceedings of the international workshop on Multimedia databases , 2004 .
[ 30 ] M . yen Lin and S . yin Lee . Fast discovery of sequential patterns through memory indexing and database partitioning . Journal Information Science and Engineering , 21:109–128 , 2005 .
[ 31 ] M . Zaki . Spade : An efficient algorithm for mining frequent sequences . Machine Learning , 42:31–60 , 2001 .
[ 32 ] M . J . Zaki . Scalable algorithms for association mining . IEEE
Transactions on Knowledge and Data Engineering , 2000 .
Figure 8 : The mining time ( in seconds ) of TP_Apriori , RTP_no list , TP_lists and RTP_lists on the CARDI dataset for different maximum gap values ( in months ) . The minimum support is 15 % .
6 . CONCLUSION
The increasing availability of large temporal datasets prompts the development of scalable and more efficient temporal pattern mining techniques . Methods for mining sequential ( time point ) data were first introduced in the literature starting in the mid 1990 [ 2 , 31 , 18 , 30 ] . Since then , these methods have been extended to mining time interval data [ 22 , 11 , 17 , 14 , 26 , 27 , 15 ] . Unfortunately , mining the entire set of temporal patterns ( sequential patterns or time interval patterns ) from large scale datasets is inherently a computationally expensive task . To alleviate this problem , temporal constraints ( eg , restricting the total pattern duration or restricting the permitted gap between consecutive events in a pattern ) have been proposed to scale up the mining [ 19 ] .
In this paper , we proposed a new class of temporal constraints for finding Recent Temporal Patterns ( RTPs ) , which are particularly important for monitoring and event detection problems . We presented an efficient algorithm that mines time interval patterns backward in time , starting from patterns related to the most recent observations . Our experimental evaluation on EHRs for diabetes patients showed that the RTP framework is very useful to efficiently find patterns that are important for predicting various types of disorders associated with diabetes .
7 . ACKNOWLEDGMENTS
This work was supported by grants 1R21LM009102 01A1 , 1R01LM010019
01A1 , 1R01GM088224 01 and T15LM007059 24 from the NIH . Its content is solely the responsibility of the authors and does not necessarily represent the official views of the NIH .
8 . REFERENCES [ 1 ] R . Agrawal and R . Srikant . Fast algorithms for mining association rules in large databases . In Proceedings of VLDB , 1994 .
[ 2 ] R . Agrawal and R . Srikant . Mining sequential patterns . In
Proceedings of ICDE , 1995 .
[ 3 ] F . Allen . Towards a general theory of action and time . Artificial
Intelligence , 23:123 154 , 1984 .
[ 4 ] I . Batal and M . Hauskrecht . A supervised time series feature extraction technique using dct and dwt . In Proceedings of ICMLA , 2009 .
[ 5 ] I . Batal , H . Valizadegan , G . F . Cooper , and M . Hauskrecht . A pattern mining approach for classifying multivariate temporal data . In Proceedings of the IEEE international conference on bioinformatics and biomedicine ( BIBM ) , 2011 .
[ 6 ] S . Blasiak and H . Rangwala . A hidden markov model variant for sequence classification . In Proceedings of the International Joint Conferences on Artificial Intelligence ( IJCAI ) , 2011 .
288
