On Nested Palindromes in Clickstream Data
Michel Speiser†‡ msp@zurichibmcom
Juliana Sutanto‡ jsutanto@ethz.ch
Gianluca Antonini† gan@zurichibmcom †Dept . of Mathematical & Computational Sciences IBM Research Zurich
Säumerstrasse 4
8803 Rüschlikon , Switzerland
Abderrahim Labbi† abl@zurichibmcom ‡Dept . of Management ,
Technology , and Economics
ETH Zürich
Weinbergstrasse 56/58 8092 Zürich , Switzerland
ABSTRACT In this paper we discuss an interesting and useful property of clickstream data . Often a visit includes repeated views of the same page . We show that in three real datasets , sampled from the websites of technology and consulting groups and a news broadcaster , page repetitions occur for the majority as a very specific structure , namely in the form of nested palindromes . This can be explained by the widespread use of features which are available in any web browser : the “ refresh ” and “ back ” buttons . Among the types of patterns which can be mined from sequence data , many either stumble if symbol repetitions are involved , or else fail to capture interesting aspects related to symbol repetitions . In an attempt to remedy this , we characterize the palindromic structures , and discuss possible ways of making use of them . One way is to pre process the sequence data by explicitly inserting these structures , in order to obtain a richer output from conventional mining algorithms . Another application we discuss is to use the information directly , in order to analyze certain aspects of the website under study . We also provide the simple linear time algorithm which we developed to identify and extract the structures from our data .
Categories and Subject Descriptors H28 [ Database Management ] : Database Applications— Data Mining ; E.m [ Data ] : Miscellaneous
General Terms Algorithms , Measurement
Keywords palindrome , web usage mining , backtrack , refresh
1 .
INTRODUCTION
The motivation of this research was to discover patterns in clickstream data . In this Section , we first give an insight into what clickstream data are , and how they can be obtained . We then briefly discuss some of the relevant patterns which were studied in data mining literature , and describe their difficulties in dealing with the specific structural property of palindromicity .
In Section 2 we describe why nested palindromes can be anticipated with normal web browsing behavior , and provide a simple algorithm which extracts these structures in linear time ( proof of correctness is provided in the appendix ) . In Section 3 we briefly describe the clickstream datasets studied , and show how the methods can be used for finer analysis . Finally , conclusions are given in Section 4 .
1.1 Mining Clickstream Data
A clickstream , or visit , is defined as a sequence of URLs visited from a single device ( and presumably by a single individual ) within a single session . The notion of visit is necessarily arbitrary , since it corresponds to some form of contiguity in time ; the scale of this contiguity is then a required parameter . In standard practice , if two consecutive web server log entries belonging to the same user are separated by a time lapse greater than 30 minutes , they are considered to belong to two distinct visits . A visits database can be obtained by transforming web server logs through a process called sessionization ( see eg [ 5 , 15] ) . Nowadays many tools exist to feed such databases in an ongoing manner , by incorporating active elements in the pages of the website , which is usually referred to as page tagging .
[ 13 , 24 ] .
Since a visit can be seen as a sequence of pages , we can apply a host of data mining techniques designed for sequence data , namely frequent pattern mining . For an overview see eg In line with the usual vocabulary , given a pattern and a collection of sequences , we say that a sequence supports a pattern if the pattern occurs in the sequence . We call the number of sequences in the collection which support the pattern the support of the pattern . Furthermore , we say that a pattern is frequent if its support is at least min sup ( a user defined threshold ) , and a pattern is closed if it has no superpattern of equal support .
Two basic patterns which can be mined from a database of sequences are “ frequent subsets ” and “ association rules ” [ 1 , 18 ] , both of which capture sets of symbols which frequently co occur in the database . Classic Apriori type algorithms readily provide these [ 1 ] . Another well studied pattern is the “ sequential pattern ” [ 2 , 23 , 20 ] which , in its simplest form , is a frequent ( not necessarily contiguous ) subsequence of maximal length . Among others , an efficient algorithm called PrefixSpan was proposed to extract such patterns [ 20 ] .
1460 The partial order pattern ( partially ordered set , also called poset ) was also studied [ 17 , 4 , 21 ] . It occurs in a sequence if all symbols of the poset are present , and they occur in an order which is compatible with the partial order defined by the poset . More general graph patterns can also be mined . For instance , one can extract from a set of graphs all frequent common subgraphs [ 8 ] .
Each of these pattern types runs into some problems in capturing aspects of clickstream data which we hold to be important . The frequent subset discards ordering information , which we deem to be essential for the purpose at hand , since our objective is to study traffic flow , which intuitively includes the notion of direction . The sequential pattern is thus a closer fit , but it has a drawback in that it treats a symbol repetition in a rather neutral manner – essentially as just another symbol . The strength drawn from disregarding the contiguity of symbols can turn into a weakness for clickstreams , as we shall see . Symbol repetitions are downright problematic for partial orders , and indeed one of the hypotheses of the Frecpo [ 21 ] algorithm is that the sequences in the database are repetition free . A similar problem affects the subgraph pattern ; in the general case , for sequences containing symbol repetitions ( which translate to cycles in graph representations ) , chronological precedence is ambiguous . Thus , it seems that none of these patterns is ideally suited to describe data in which repetitions carry a particular importance , as in our clickstream data which will be described in Section 21 We will now argue why this is to be expected , and what shape these repetitions take on .
2 . NESTED PALINDROMES IN
CLICKSTREAM DATA
Loosely speaking , a palindrome is a word which is the same whether it is read from left to right or from right to left , such as level or redder . It is a sequence with a central symmetry . Palindromes have been the subject of countless human expressions and inquiries since ancient Greece , attracting artistic and mathematical curiosity . Palindromes are investigated in biology ; DNA segments often contain palindromic structures which are thought to have certain functional implications , like self repair . Properties of palindromicity have also been investigated in proteins [ 11 ] . As far as computer science is concerned , palindromes are a classic example of an important language type in the Chomsky hierarchy [ 6 ] . The set of all palindromes on a given alphabet of symbols is context free but not regular – no finite state machine can accept the language ; at least a pushdown automaton is required .
We argue that palindromes are relevant to web usage mining , and we make this case both by arguing in terms of expected outcome of standard behavior , as well as by showing the patterns observed in real datasets . Imagine the following browsing experience . Catherine knows that the company Pumpkin Umbrellas will launch its new product line today , and lands on the website by typing the URL pumpkinumbrellas.com into her browser . When the page is displayed , an announcement about membership with Pumpkin Umbrellas catches her eye , but she clicks on the “ press releases ” link instead , to find that the information she was expecting has not been published yet . She gets out of her chair to get a cup of coffee , comes back ten minutes later and hits the “ refresh ” button on her browser . Now the news item is displayed ; she clicks on the link to see the press release . When she is done reading it , she hits the “ back ” button twice , and clicks on the membership promotion link she had seen earlier . However , membership looks too complicated , so she grows disinterested and walks away from her computer .
Stripping away the narrative , we are left with the sequence of pages through which the user navigated : Main , Press Releases , Press Releases , Product Launch , Press Releases , Main , Membership . We can encode this as the symbol sequence ABBCBAD , and visualize it as the graph in Figure 1 ; each node represents a symbol , and the arcs are labelled in chronological order of the symbols’ appearance in the sequence . A page refresh always translates into a reflexive arc ( eg B → B ) , and a backtrack always translates into a pair of opposite arcs ( eg {A → B , B → A} ) .
3
4
C
A
1
6
5
2
B
D
Figure 1 : Graph of the sequence ABBCBAD .
Looking at the sequence ABBCBAD , we notice that there are three repetitions in this sequence ; the symbol B is repeated twice and the symbol A is repeated once . We also see two contiguous subsequences which are palindromes , BB and BCB , corresponding to the page refresh and to the first backtrack , respectively . They overlap on their outermost symbol B . Next , we make the less obvious observation that ABBCBA is “ almost ” a palindrome – it would be a palindrome if BB were replaced by a single B . Finally , notice that if we take the sequence ABBCBAD and iteratively replace the first ending palindrome by its outermost symbol , the resulting sequence AD does not contain any repetitions ( see Table 1 for the steps ) . In other words , the repetitions in this sequence are all accounted for by short palindromes . These intuitions form the basis of our approach . sequence
1st palindrome “ compressed ”
ABBCBAD ABCBAD
ABAD
AD
ABCBAD
ABAD
AD AD
Table 1 : Successively replacing the first ending palindrome transforms the sequence ABBCBAD into the sequence AD , which contains no repetitions .
Many efficient ( linear time ) algorithms exist to extract different kinds of palindromes from sequences , eg maximal palindromes , palindromes with gaps , etc ( see eg [ 14 , 12] ) . However , we are not aware of an algorithm which performs the process we describe above . It is captured formally in the algorithm extract pals , listed as Algorithm 1 . For a proof of correctness , please see the appendix . The algorithm transforms the graph in a straightforward way . It iteratively
1461 1
8
1
7
1
5
7
B
2
6
4
5
( a ) ABCCBDBBA
6
B
2
5
3
4
( b ) ABCBDBBA
4
B
2
3
( c ) ABDBBA
1
3
1
2
2
B
( d ) ABBA
B
( e ) ABA
3
C
D
C
D
C
D
C
C
B
( f ) A
C
A
A
A
A
A
A
Figure 2 : Successive removals of the first ending palindrome in ABCCBDBBA reduce the sequence to a single symbol .
Input : A sequence s Output : The list ( refreshes , backtracks , leftover ) R = empty set B = empty set T = empty stack for i = 1 to length(s ) do if the top of T equals s[i ] then
R = R ∪ {s[i]} #refresh else if the symbol under the top of T equals s[i ] then
B = B ∪ {(T.top , s[i])} #backtrack T.pop( ) else
T.push(s[i ] ) #no palindrome end end return ( R , B , T )
Algorithm 1 : extract pals
R i T ∅ 1 A ∅ 2 AB 3 ABC ∅ 4 ABC {C} {C} 5 AB 6 ABD {C} {C} 7 AB {C , B} 8 AB {C , B} 9 A
B ∅ ∅ ∅ ∅ {(C , B)} {(C , B)} {(C , B ) , ( D , B)} {(C , B ) , ( D , B)} {(C , B ) , ( D , B ) , ( B , A)}
Table 2 : Steps of extract pals for ABCCBDBBA .
B
2
1
3
A
C
Figure 3 : Graph of the sequence ABCA . removes the first ( and earliest in a chronological sense ) of the following :
• a reflexive arc
• a pair of opposite arcs with consecutive label numbers
The complexity of the algorithm is linear in the sum of the lengths of the sequences in the database . The process is illustrated for the more complex sequence ABCCBDBBA ; the successive steps are shown in Table 2 and represented graphically in Figure 2 . Notice that here again , all repetitions are accounted for by palindromes .
This need of course not be the case for every sequence , for instance the sequence ABCA , shown in Figure 3 , contains a repetition but no palindromes . If a sequence contains at least one repetition which is not accounted for by palindromes , we will call it unaccounted . Otherwise we will say that the sequence is accounted . In the next section , we will show that in our datasets , unaccounted sequences are a minority .
1462 2.1 Evidence of Nested Palindromes
We now turn to real data , to show that palindromes are indeed a characteristic feature of clickstreams . We analyze three different datasets , the two first of which we will call Blue and Orange for anonymity purposes . The datasets are collections of visits to the websites of two distinct groups of a large technology and consulting company , from the year 2011 , collected by a page tagging solution . The third dataset is a database of visits to msnbc.com on September 28 , 1999 , gathered from an IIS log , which we obtained from the UCI Machine Learning Repository [ 10 ] . It differs from the first two datasets in that the level of granularity is coarser ; while Blue and Orange consist of sequences of URLs , a visit in the MSNBC dataset is given as a sequence of news categories . For example , if a user read an article about French politics , another on the tour de France , an opinion piece about doping in cycling , a second tour de France article , and finally the weather forecast , the corresponding visit was recorded as “ frontpage , sports , opinion , sports , weather ” . In this study , we simply treat the categories as pages1 .
The sample sizes are 3.1 · 105 , 3.2 · 105 and 9.9 · 105 visits , over about 1.8·103 pages , 8.8·103 pages , and seventeen categories , respectively ( see Table 3 for a summary ) . Most visits are made up of very few pageviews , but a small percentage range into a length of several hundreds . Our goal is to study human behavior , and most likely very long visits were made by crawlers or similar programs . For this reason , and also to make the presentation of results easier , we remove from the databases all visits with length above 20 pageviews , since they correspond to a low proportion of 0.16 % , 0.53 % and 2.8 % of the visits , respectively . The visit length distributions are shown as log log plots in Figure 4 . The first two datasets look quite regular in this respect , and visually they seem to be approximately Zipf distributed , although goodness of fit tests such as the Kolmogorov Smirnoff test ( cf . [ 7 ] ) fail quite unequivocally . The MSNBC visits are a bit less regular in their length distribution , however clearly all datasets share the characteristic that visit lengths are rather heavy tailed .
Applying our extraction algorithm , we obtain for each sequence the set of refreshes and the set of backtracks it contains , as well as the “ leftover ” sequence – the sequence that remains after all palindromes have been compressed . Notice that a sequence is unaccounted if and only if the leftover sequence contains at least one repetition . We find that the proportion of unaccounted sequences is as low as 0.86 % , 1.6 % and 5.4 % , respectively . Of course , to be fair , it should be said that the shortest sequence which can be unaccounted2 has length 4 ( such as the one in Figure 3 ) . However , even if we consider only the sequences which both contain repetitions and are of length ≥ 4 , the proportion of unaccounted sequences remains low ; the values are then 14 % , 18 % and 83 %
1It should be noted that in this dataset , the number of actual refreshes will be over estimated , since any intra category transition will look like a refresh . Likewise , the backtracks will be both under estimated ( for the same reason ) and overestimated because “ Skiing , Banking crisis , Basketball ” , will turn into “ sports , finance , sports ” and be interpreted as a backtrack . It should also be noted that this log based dataset is likely more susceptible to caching effects . 2A sequence which contains no repetitions is trivially accounted .
In order to get a more complete picture of this characteristic in our datasets , in Figure 5 we categorize visits by the number of refreshes and backtracks they contain . The blobs are sized according to the number of visits in the category , and the black spokes indicate the proportion of accounted sequences in each category – a vertical spoke means that the proportion is 1 , while a horizontal spoke means that the proportion is 0 . As can be seen , the proportion is large in most categories . For instance , in the Blue dataset , among the visits containing 3 page refreshes and 4 backtracks ( ie 7 repetitions explained by palindromes ) virtually none contain a repetition of another form . On the whole , in our data , it seems that palindromes account for the lion ’s share of repetitions all around .
Taking a slightly different approach , if we look at counts of non palindromic repetitions ( as opposed to counts of visits containing non palindromic repetitions ) , we find that out of all repetitions , those explained by palindromes make up 95 % , 92 % and 96 % of the respective datasets . The “ palindromicity ” throughout our data is thus confirmed from quite a few different angles . The strength of the presence of this property , and the independence of the datasets , together suggest that the same structure may be found in other clickstream databases as well .
3 . APPLICATIONS
Being confident in the strong presence of palindromes in our datasets , we can now turn to discussing possible ways of making use of it . We identify at least two simple applications of the presented material . Firstly , it can be used in a pre processing step to ensure richer output of existing algorithms . Secondly , we sketch how one can make a direct use of the extracted features in order to analyze navigational properties of a website .
3.1 Pre processing for Sequence Mining
Recall the sequence ABBCBAD studied above , which contains one refresh and two backtracks . This sequence is easily transformed to ABXBCYBZAD , where we have inserted the new symbols X , Y and Z to specifically mark the places where the behaviors of interest occur ; for instance , Y stands for “ backtrack from C to B ” . The set of sequential patterns obtained from such a transformed dataset will be strictly richer than the set obtained from the original dataset ; no information is lost , however the extra information can be put to good use . For instance , imagine the pattern ABCY B is found to be frequent . Obviously , if we had run the algorithm on the original sequences , the pattern ABCB would have been reported as frequent . However , ABCY B contains more information , because it tells us that a backtrack from C to B occurs , whereas ABCB could correspond to backtracks as well as sequences like ABCDEB . Thus , rather than reporting ABCB we can report eg A\BCB .
The same concept holds for the partial order pattern . In order to quantify the ” enrichment ” of the result set , we run the Frecpo algorithm on the three pre processed datasets , setting the support thresholds so as to obtain a few hundred frequent patterns , and observe how many of them contain at least one of the added symbols . The proportions are quite high : 193/418 ( 46% ) , 313/339 ( 92 % ) and 317/437 ( 73% ) . This means that in our data , refreshes and backtracks are not only frequent as a general feature , but furthermore , spe
1463 ( 1 ) 72.7 % / 72.7 %
●
( 2 ) 14.95 % / 87.64 %
●
( 3 ) 5.19 % / 92.83 %
●
( 4 ) 2.6 % / 95.43 %
●
( 5 ) 1.48 % / 96.91 %
●
( 6 ) 0.92 % / 97.83 %
●
( 7 ) 0.6 % / 98.43 %
●
105
104.5
104 t n u o c
103.5
( 1 ) 72.75 % / 72.75 %
●
( 2 ) 11.74 % / 84.49 %
●
( 3 ) 5.81 % / 90.3 %
●
( 4 ) 2.89 % / 93.2 %
●
( 5 ) 1.93 % / 95.13 %
●
( 6 ) 1.2 % / 96.33 %
●
( 7 ) 0.87 % / 97.19 %
●
105
104.5 t n u o c
104
103.5
103
102.5
102
100
100.2
( 8 ) 0.38 % / 98.82 %
( 9 ) 0.29 % / 99.11 %
●
●
( 10 ) 0.22 % / 99.33 %
●
●
●
●
●
●
●
● ●
● ●
103
102.5
( 8 ) 0.62 % / 97.81 %
( 9 ) 0.48 % / 98.29 %
●
●
( 10 ) 0.37 % / 98.66 %
●
●
●
●
●
●
●
●
●
●
●
104
( 1 ) 38 % / 38 %
●
105.5
105
( 2 ) 15.97 % / 53.98 %
●
( 3 ) 10.14 % / 64.12 %
●
( 4 ) 7.29 % / 71.41 %
●
( 5 ) 5.85 % / 77.26 %
● t n u o c
104.5
( 6 ) 4.58 % / 81.84 %
●
( 7 ) 3.53 % / 85.38 %
●
( 8 ) 2.82 % / 88.2 %
●
( 9 ) 2.25 % / 90.45 %
●
( 10 ) 1.84 % / 92.29 %
●
●
●
●
●
●
●
●
●
●
●
101
101.2
101.4
100.4
100.6
100.8 visit length
101
101.2
101.4
100
100.2
100.4
100.6
100.8 visit length
101
101.2
101.4
100
100.2
100.4
100.6
100.8 visit length
( a ) Blue dataset
( b ) Orange dataset
( c ) MSNBC dataset
Figure 4 : Distribution of visit lengths , in number of pageviews . The values next to points are the length ( in parentheses ) , the proportion of sequences of that length , and the cumulative proportion .
9
8
7
6 k c a 5 r t k 4 c a b 3
2
1
0
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
9
8
7
6 k c a 5 r t k 4 c a b 3
●
●
# of visits 1 10 100 ● ● 1000 ● 10000 1e+05
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
0
1
●
●
2
●
●
●
●
●
●
●
●
●
●
4
3 5 refresh
6
7
8
( a ) Blue dataset
2
1
0
●
●
●
●
●
1
0
●
9
●
●
●
●
●
3
2 4 refresh
5
6
●
●
# of visits 1 10 100 ● ● 1000 ● 10000 ● 1e+05
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
7
6
5 k c a 4 r t k c 3 a b
2
1
0
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
0
1
●
2
●
●
4
3 refresh
●
●
5
●
●
●
6
●
●
7
●
●
# of visits 1 10 100 ● ● 1000 ● 10000 ● 1e+05
( b ) Orange dataset
( c ) MSNBC dataset
Figure 5 : Visits are categorized by the number of refreshes and backtracks they contain . The blob sizes represent the number of visits in the category . The black spokes show the proportion of accounted sequences in the category ( vertical means 100 % , horizontal means 0 ) . statistic sample size distinct items visits over length 20 ( removed ) unaccounted visits among all visits unaccounted visits among visits of length ≥ 4 containing repetitions proportion of palindromic repetitions frequent closed partial orders containing added symbols
Blue
3.1 · 105
1822 0.16 % 0.86 % 14 % 95 %
Orange 3.2 · 105
8822 0.53 % 1.6 % 18 % 92 %
MSNBC 9.9 · 105
17
2.8 % 5.4 % 8.3 % 96 %
193/418 ( 46 % )
313/339 ( 92 % )
317/437 ( 73 % )
Table 3 : Summary view of the dataset statistics . cific instances are also frequent , and part of larger frequent browsing patterns . For an example of how to graphically incorporate the additional information in a partial order pattern , see Figure 6 .
One caveat which should be mentioned about our procedure of enriching sequences is that it may result in aggravating the redundancy in the result set , which is a muchreported problem in frequent pattern mining . Fortunately a lot of excellent research is being done to manage this redundancy ( see eg [ 3 , 16] ) .
3.2 Direct Interpretation for Web Analytics
Surely the tendencies of a page to be refreshed , or backtracked from , or backtracked to , are features of direct interest for anyone who aims to understand the dynamics of a website . In order to achieve these insights , we extract the palindromic patterns previously discussed . Here we opt for finding the support of the palindromes , rather than the occurrence count . This means that if a given backtrack ( B , A ) occurs n ≥ 1 times during a single visit , we count 1 rather than n . This approach is popular in data mining , and from
1464 A
B
D
C
A
C
B
D
( a ) Original data
( b ) Pre processed data
Figure 6 : Comparison of partial order patterns without and with pre processing . From the original data ( a ) , an example of pattern obtained is read as “ A before D and A before B and B before C ” . With pre processed data ( b ) , a pattern can additionally express information like “ refresh of D and backtrack from B to A ” . a statistical robustness viewpoint a good choice . Indeed , the breakdown point3 of the occurrence count is 1/N ( where N is the number of sequences ) since a single “ bad ” sequence with a large number of occurrences can perturb the statistic by an arbitrary amount . By contrast , the support statistic has no breakdown point , because it is always contained in the interval [ 0 , N ] ; any observation can only perturb the statistic by 1/N .
We provide an adaptation of Algorithm 1 to extract the support of all refreshes and backtracks from a visits database . It is called sup pals and listed as Algorithm 2 . Notice that unlike in the case of frequent pattern algorithms , no threshold parameter is required as input . The support supre(x ) equals the number of visits in which at least one refresh of x occurs , while supports supbf ( x ) and supbt(x ) equal the number of visits containing at least one backtrack from and to x , respectively . Using these supports , we can now derive some quite informative metrics about web pages .
One straight forward such metric is the refresh rate REF ( x ) of page x , defined as
REF ( x ) = supre(x ) sup(x )
( 1 ) which is contained between 0 and 1 . Depending on the intended function of a page x within a website , different values of REF ( x ) may be desirable . For example , if an active newsfeed page has a high refresh rate , this can be taken as a good sign , since the implication is that many of the visitors are eager for more news items . If however a static page has a high refresh rate , it may indicate that the page often displays poorly in users’ browsers for some reason , and should be checked by a webmaster for possible malfunction . It also bears mentioning that some pages reload automatically by design , which then needs to be kept in mind when analyzing the results . We further define the cul de sac rate CDS(x ) of page x as
CDS(x ) = supbf ( x ) sup(x )
( 2 ) which is also contained between 0 and 1 . This metric reflects the tendency of the page ’s visitors to return to an earlier page . Here again , different values may be desirable depending on the context . A help page , for instance , will hopefully have a high CDS , indicating that visitors returned
3The breakdown point of a statistic is defined as the largesample proportion of contaminated observations needed to change the value of a statistic by an arbitrarily large amount [ 9 ] . For a survey of the field of robust statistics see [ 19 ] .
Input : A sequence database S Output : The supports supre , supbf and supbt . foreach sequence s ∈ S do
R = empty set B = empty set T = empty stack for i = 1 to length(s ) do if T.top equals s[i ] then
R = R ∪ {s[i]} #refresh else if T.undertop equals s[i ] then
B = B ∪ {(T.top , s[i])} #backtrack T.pop( ) else
T.push(s[i ] ) #no palindrome end end foreach symbol x in R do add 1 to supre(x ) end foreach pair ( x , y ) in B do add 1 to supbf ( x ) add 1 to supbt(y ) end end return ( supre , supbf , supbt )
Algorithm 2 : sup pals to the website , presumably because they found the help they needed on the help page . Conversely , if an “ index ” page designed to act as a hub has a high CDS , the page may need a redesign . Similarly , let us define the pivot rate P IV ( x ) of a page as
P IV ( x ) = supbt(x ) sup(x )
( 3 ) which again falls into the interval [ 0 , 1 ] . This metric indicates the tendency of visitors to return to the page , possibly in order to proceed elsewhere . An “ index ” page should probably have a relatively high P IV , whereas if a page in the checkout/ordering workflow of an online retailer has high P IV , it is probably indicative of a malfunction or of a problem in the web design . If for some page x , both CDS(x ) and P IV ( x ) are high , ie visitors backtrack both from and to that page a lot , it could be indicative of some kind of “ corridor ” which visitors need to follow in order to get from A to B . Perhaps a direct link would be more convenient ; it is also worthwhile to investigate whether x should be merged with
1465 ( a ) Blue dataset
( b ) Orange dataset
Figure 7 : Each point stands for a top 200 page in the website . There seem to be many low PIV , high CDS pages in the top Blue pages , while there are many high PIV , high CDS pages in the Orange pages . a page people frequently backtrack to ( from x ) , in order to spare visitors a click .
While it may be difficult to decide which absolute values are desirable , one can turn to a comparative analysis ; are there outliers ? Do the pages look like they are in their proper place in the distribution ? Note that if additionally to the page sequences , we also had access to the time at which each click was made , we could incorporate this information to allow for a more precise interpretation – if a page refresh occurs after several minutes spent on the page , it is arguably a better sign than if it occurs shortly after the preceding view of the page .
Combined outlier analysis can also be of interest for diagnostics purposes . For instance , a plot of P IV vs CDS in Figure 7 simultaneously shows both tendencies of backtracking from and to a page . Here we plot only the top 200 pages ( in terms of support ) of the sites Blue and Orange . We can notice that in the Blue dataset , there are quite many lowPIV , high CDS pages – 31 points in the delimited region , versus 9 in the same region in the Orange dataset . On the other hand , there are quite many high PIV , high CDS pages in the Orange dataset – 50 pages in the region vs 15 in the same region in the Blue dataset . Accordingly , the owner of the Blue website may wish to examine all those “ dead ends ” , while the owner of the Orange website might want to investigate why it has so many “ corridors ” .
4 . CONCLUSIONS
We have illustrated that nested palindromes are strongly present in clickstream data ; we first argued that standard browsing behavior generates clickstreams containing such structures . A simple stack based algorithm was derived to extract such patterns ( in linear time ) , and used to confirm the presence of palindromicity in three independent datasets of real data . We showed how sequence data can be preprocessed by insert new symbols which explicitly mark the phenomena in question , and illustrated ways in which the resulting patterns become richer . Furthermore , we showed examples of metrics which can be derived from the results , and how those can be interpreted . Such information is helpful to people in charge of designing and/or analyzing the usage of the website . In particular , it can be used to detect whether a page is failing in its intended function .
4.1 Limitations and Future Work
Our considerations in this work are limited to “ first order ” palindromes , for instance for the sequence ABCBA we produce backtracks ( C , B ) and ( B , A ) . In some applications it may be of interest to know that there was an uninterrupted return from C to A , which would require extracting ( C , B , A ) or something similar .
In future work , we intend to use the discovered features to produce more accurate generative models which could improve the results of approaches such as we described eg in [ 22 ] . We are also in the process of developing website optimizations utilizing these results , and of validating the practical use of the findings with the websites’ stakeholders . Our approach was studied with web navigation in mind , but could in principle be useful in analyzing data arising from other processes with a similar structure . In particular , studies of navigation of all kinds could benefit , for instance , if the dataset consists in descriptions of daily itineraries , such as sequences of stations/stops in a public transportation network , or of areas in a roads network traversed by car .
1466 5 . REFERENCES [ 1 ] R . Agrawal and R . Srikant . Fast algorithms for mining association rules . In VLDB , pages 487–499 , 1994 .
[ 2 ] R . Agrawal and R . Srikant . Mining sequential patterns . Data Engineering , International Conference on , 0:3 , 1995 .
[ 3 ] T . Calders and B . Goethals . Mining all non derivable frequent itemsets . In Proceedings of the 6th European Conference on Principles of Data Mining and Knowledge Discovery , PKDD ’02 , pages 74–85 , London , UK , UK , 2002 . Springer Verlag .
[ 4 ] G . Casas Garriga . Summarizing sequential data with closed partial orders . In Proceedings of the Fifth SIAM International Conference on Data Mining , pages 380–390 , 2005 .
[ 5 ] S . Chakrabarti . Mining the Web : Discovering
Knowledge from Hypertext Data . Morgan Kauffman , 2002 .
[ 6 ] N . Chomsky . Three models for the description of language . Information Theory , IRE Transactions on , 2(3):113 –124 , september 1956 .
[ 7 ] A . Clauset , C . R . Shalizi , and M . E . J . Newman . Power law distributions in empirical data . SIAM Reviews , June 2007 .
[ 8 ] D . J . Cook and L . B . Holder . Mining Graph Data .
John Wiley & Sons Inc . , 2007 .
[ 9 ] A . Davison . Statistical Models . Cambridge University
Press , The Pitt Building , Trumpington Street , Cambridge , UK , 2003 .
[ 10 ] A . Frank and A . Asuncion . UCI machine learning repository , 2010 .
[ 11 ] M . Giel Pietraszuk , M . Hoffmann , S . Dolecka ,
J . Rychlewski , and J . Barciszewski . Palindromes in proteins . Journal of Protein Chemistry , 22:109–113 , 2003 . 101023/A:1023454111924
[ 12 ] D . Gusfield . Algorithms on strings , trees , and sequences : computer science and computational biology . Cambridge University Press , New York , NY , USA , 1997 .
[ 13 ] J . Han , H . Cheng , D . Xin , and X . Yan . Frequent pattern mining : Current status and future directions . Data Mining and Knowledge Discovery , 14(1 ) , 2007 . [ 14 ] R . Kolpakov and G . Kucherov . Searching for gapped palindromes . In P . Ferragina and G . Landau , editors , Combinatorial Pattern Matching , volume 5029 of Lecture Notes in Computer Science , pages 18–30 . Springer Berlin / Heidelberg , 2008 .
[ 15 ] B . Liu . Web Data Mining : Exploring Hyperlinks ,
Contents , and Usage Data ( Data Centric Systems and Applications ) . Springer Verlag New York , Inc . , Secaucus , NJ , USA , 2006 .
[ 16 ] M . Mampaey , N . Tatti , and J . Vreeken . Tell me what i need to know : succinctly summarizing data with itemsets . In KDD , pages 573–581 , 2011 .
[ 17 ] H . Mannila and C . Meek . Global partial orders from sequential data . In KDD ’00 : Proceedings of the sixth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining , pages 161–168 . ACM , 2000 .
[ 18 ] H . Mannila , H . Toivonen , and I . Verkamo . Efficient algorithms for discovering association rules . pages 181–192 . AAAI Press , 1994 .
[ 19 ] S . Morgenthaler . A survey of robust statistics .
Statistical Methods & Applications , 16:171–172 , 2007 . [ 20 ] J . Pei , J . Han , B . Mortazavi Asl , J . Wang , H . Pinto ,
Q . Chen , U . Dayal , and M C Hsu . Mining sequential patterns by pattern growth : The prefixspan approach . IEEE Transactions on Knowledge and Data Engineering , 16(11):2004 , 2004 .
[ 21 ] J . Pei , H . Wang , J . Liu , K . Wang , J . Wang , and P . S .
Yu . Discovering frequent closed partial orders from strings . IEEE Transactions on Knowledge and Data Engineering , 18:1467–1481 , November 2006 .
[ 22 ] M . Speiser , G . Antonini , and A . Labbi . Ranking web based partial orders by significance using a markov reference model . In IEEE 11th International Conference on Data Mining ( ICDM ) , 2011 .
[ 23 ] X . Yan , J . Han , and R . Afshar . Clospan : Mining closed sequential patterns in large datasets . In In SDM , pages 166–177 , 2003 .
[ 24 ] M . Zaki , N . Parimi , N . De , F . Gao , B . Phoophakdee ,
J . Urban , V . Chaoji , M . Hasan , and S . Salem . Towards generic pattern mining . In B . Ganter and R . Godin , editors , Formal Concept Analysis , volume 3403 of Lecture Notes in Computer Science , pages 1–20 . Springer Berlin / Heidelberg , 2005 .
APPENDIX
A . MINING PALINDROMIC STRUCTURES If s is a sequence , then given integers i ≤ j we denote by s[i : j ] the contiguous subsequence of s from position i to position j . A subsequence s[i : i ] of length 1 can also be written as s[i ] , and s[i : j ] with i > j is interpreted as the empty sequence . We denote by ρ(s ) the reversed sequence ( the symbols in reverse order ) , and we say that s is a palindrome if it has length > 1 and s = ρ(s ) . If s1 , s2 , sn are n sequences , we denote by s1s2sn the sequence obtained by their concatenation . Now , for a sequence s , let
ω = min{j : ∃α < j : s[α : j ] = ρ(s[α : j])}
( 4 )
If such an ω exists , then α is unique , that is , s[α : ω ] is the unique first ending palindrome of s . Indeed , suppose that α is not unique , ie that the statement holds for two different values α1 < α2 . Since we have s[α1 : ω ] = ρ(s[α1 : ω ] ) and s[α2 : ω ] = ρ(s[α2 : ω ] ) it follows that s[α1 : α1 + ω − α2 ] = ρ(s[α1 : α1 + ω − α2] ) , ie there is a palindrome ending at α1 + ω − α2 < ω , which contradicts the definition of ω . This means that we can unambiguously define the function CF P as follows . If α and ω of equation ( 4 ) exist ,
CF P ( s ) = s[1 : α]s[ω + 1 : ℓ ] otherwise ,
CF P ( s ) = s .
( 5 )
( 6 )
In words , CF P , which stands for Compress First Palindrome , is a function which takes as input a sequence s , and returns a sequence identical to s , except that the first ending palindrome in s ( if it exists ) is replaced by its outermost symbol – we say that the palindrome is compressed . Table 2 shows a few examples of CF P preimages and images .
Notice that we know the lengths of palindromes compressed by CF P : if a sequence s contains a palindrome , the first ending palindrome is of length 2 or 3 . Indeed , suppose
1467 that s has a first ending palindrome of length ℓ > 3 . Let α be the starting index of the palindrome , and ω = α + ℓ − 1 its end index . Since s[α : ω ] is a palindrome , then so is s[α + 1 : ω − 1 ] , which has a length ℓ − 2 > 1 . But then , there is a palindrome ending at ω − 1 , ie before ω , which contradicts the hypothesis . As a consequence , CF P ( s ) either leaves the sequence s unchanged , or compresses a palindrome of length 2 or 3 . This is fortunate , because in terms of browsing behavior , CF P compresses either a page refresh ( palindrome of length 2 ) or a backtrack ( palindrome of length 3 ) , which are precisely the features of interest to us . Denote by CF P ∞(s ) the fixed point of CF P reached by successive applications of CF P to s , ie
CF P ∞(s ) = CF P ◦ CF P ◦ ◦ CF P ( s ) .
( 7 )
This fixed point exists for any sequence s of finite , positive length ; the image is either identical to the preimage or shorter than the preimage , and any sequence of length 1 is obviously a fixed point , so a fixed point is reached in a finite number of iterations . As an example , for the sequence s = ABCCBDBBA , Table 2 tells us that CF P ∞(s ) = A . We now turn our attention to exploiting this structural property in order to mine features of interest . As a first step , an algorithm which computes CF P ∞ is listed as Algorithm 3 . The algorithm ’s complexity is linear in the length of the sequence .
Input : A sequence s Output : The sequence CF P ∞(s ) T = empty stack for i = 1 to length(s ) do if the top of T equals s[i ] then
// Type #2 : palindrome of length 2 // do nothing else if the symbol under the top of T equals s[i ] then
// Type #3 : palindrome of length 3 T.pop( ) else
// Type #1 : no palindrome ( ” trivial type ” ) T.push(s[i ] ) end end return T
Algorithm 3 : rm pals
Theorem 1 . Given a sequence s , the algorithm rm pals computes CF P ∞(s ) .
We will prove a few intermediate steps first . During the execution of rm pals(s ) , we call the pair ( T , s[i : length(s) ] ) observed immediately after i is modified the state at i . We say that a loop iteration is called trivial if it is of type #1 ; otherwise , it is called non trivial .
Lemma 1 . The execution rm pals(s ) contains only type #1 iterations until iteration ω , where ω is the end index of the first ending palindrome of s .
Proof . Observe that while no non trivial iteration has occurred , T = s[1 : i − 1 ] . Now , suppose a non trivial iteration first occurs before ω , and consider the state for s before this iteration ; we have that either T.top = s[i ] or
T i 1 2 A 3 AB 4 ABC 5 ABC 6 AB 7 ABD 8 AB 9 AB s[i : length(s ) ] Type ABCCBDBBA #1 BCCBDBBA #1 CCBDBBA #1 CBDBBA #2 BDBBA #3 DBBA #1 BBA #3 BA #2 A #3
Table 4 : ABCCBDBBA .
Sequence of rm pals states for the sequence
In the first case s[i − 1 ] = s[i ] , that T.undertop = s[i ] . is s[i − 1 : i ] = ρ(s[i − 1 : i] ) , and in the second case s[i − 2 ] = s[i ] , that is s[i − 2 : i ] = ρ(s[i − 2 : i] ) . In either case , s contains a palindrome ending before ω , which contradicts the hypothesis .
Corollary 1 . For an input s which contains no palindromes , rm pals(s ) terminates using only trivial loop iterations , and hence the algorithm returns s .
Lemma 2 . If sequence s has a first ending palindrome of length ℓ , the first non trivial loop iteration of rm pals(s ) is of type #ℓ .
Proof . Observe that while only type #1 iterations have occurred , T = s[1 : i − 1 ] . Hence if the first ending palindrome s[α : ω ] is of length 2 , at iteration ω we have
T.top = s[α ] = s[ω ] = s[i ]
( 8 ) which results in type #2 . Conversely , if s[α : ω ] is of length 3 , this becomes
T.undertop = s[α ] = s[ω ] = s[i ]
( 9 ) which results in type #3 .
Lemma 3 . For an input sequence s with first ending palindrome s[α : ω ] , the state after the first non trivial iteration is ( s[1 : α ] , s[ω + 1 : length(s)] ) .
Proof . The first non trivial loop iteration occurs at ω . If the first ending palindrome has length 2 , we have a type #2 iteration and the stack remains unchanged from the last iteration , ie T = s[1 : ω − 1 ] . If the palindrome has length 3 , we have a type #3 iteration and the top element is popped from the stack , yielding T = s[1 : ω − 2 ] . In both events , the resulting stack is T = s[1 : α ] , and the remaining sequence is s[ω + 1 : length(s) ] .
Lemma 4 . For a sequence s with first ending palindrome s[α : ω ] , the execution rm pals(CPF(s ) ) reaches the state ( s[1 : α ] , s[ω + 1 : length(s) ] ) using only trivial loops .
Proof . First , notice that CF P ( s)[1 : α ] = s[1 : α ] . Since the right hand side can not contain a palindrome , all loop iterations until α are of type #1 . Finally , recall that CF P ( s ) = s[1 : α]s[ω + 1 : length(s) ] .
Theorem 1 , which states that the algorithm is correct , easily follows from Corollary 1 and Lemmas 3 and 4 .
1468
