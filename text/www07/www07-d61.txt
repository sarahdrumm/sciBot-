Priv´e : Anonymous Location Based Queries in
Distributed Mobile Systems
Gabriel Ghinita
Dept . of Computer Science
National University of
Singapore
1Panos Kalnis
1Dept . of Computer Science
1National University of
Singapore ghinitag@compnusedusg
1kalnis@compnusedusg
Spiros Skiadopoulos Dept . of Computer Science University of Peloponnese ,
Greece spiros@uop.gr
ABSTRACT Nowadays , mobile users with global positioning devices can access Location Based Services ( LBS ) and query about points of interest in their proximity . For such applications to succeed , privacy and confidentiality are essential . Encryption alone is not adequate ; although it safeguards the system against eavesdroppers , the queries themselves may disclose the location and identity of the user . Recently , there have been proposed centralized architectures based on K anonymity , which utilize an intermediate anonymizer between the mobile users and the LBS . However , the anonymizer must be updated continuously with the current locations of all users . Moreover , the complete knowledge of the entire system poses a security threat , if the anonymizer is compromised .
In this paper we address two issues : ( i ) We show that existing approaches may fail to provide spatial anonymity for some distributions of user locations and describe a novel technique which solves this problem . ( ii ) We propose Priv´e , a decentralized architecture for preserving the anonymity of users issuing spatial queries to LBS . Mobile users selforganize into an overlay network with good fault tolerance and load balancing properties . Priv´e avoids the bottleneck caused by centralized techniques both in terms of anonymization and location updates . Moreover , the system state is distributed in numerous users , rendering Priv´e resilient to attacks . Extensive experimental studies suggest that Priv´e is applicable to real life scenarios with large populations of mobile users .
Categories and Subject Descriptors C24 [ Computer Communication Networks ] : Distributed Systems—Distributed Applications ; H27 [ Database Management ] : Database Administration—Security , integrity , and protection
General Terms Design , Experimentation , Security
Keywords Privacy , Anonymity , Spatial Databases , Peer to Peer
Copyright is held by the International World Wide Web Conference Committee ( IW3C2 ) . Distribution of these papers is limited to classroom use , and personal use by others . WWW 2007 , May 8–12 , 2007 , Banff , Alberta , Canada . ACM 978 1 59593 654 7/07/0005 .
1 .
INTRODUCTION
The increased popularity of mobile communication devices with embedded positioning capabilities ( eg , GPS ) has triggered the development of location based applications . General Motor ’s OnStar navigation system , for example , combines the vehicle ’s position with real time information to avoid traffic jams , and automatically alerts the authorities in case of an accident . More applications based on the users’ location are expected to emerge with the arrival of the latest gadgets ( eg , iPAQ hw6515 , Mio A701 ) which combine the functionality of a mobile phone , PDA and GPS receiver .
Consider the following scenario : Bob uses his GPS enabled mobile phone to ask the query “ Find the nearest hospital to my present location ” . This query can be answered by a Location Based Service ( LBS ) in a public server ( eg , Google Maps ) , which is not trusted . To preserve his privacy , Bob does not contact the LBS directly . Instead he submits his query via an intermediate trusted server which hides his ID ( services for anonymous web surfing are commonly available nowadays ) . However , the query still contains the exact coordinates of Bob . One may reveal sensitive data by combining the location with other publicly available information . If , for instance , Bob uses his mobile phone within his residence , the untrustworthy LBS may infer Bob ’s identity and speculate that he suffers from a medical condition .
In practice , users are reluctant to access a service that may disclose sensitive information ( eg , corporate , military ) , or their political/religious affiliations and alternative lifestyle . To preserve privacy in LBS , recent research focused on adapting the well established K anonymity technique to the spatial domain . K anonymity [ 19 , 21 ] has been used in statistical databases as well as for publishing census , medical and voting registration data . A dataset is said to be Kanonymized , if each record is indistinguishable from at least K−1 other records with respect to certain identifying attributes . In the LBS domain , a similar idea is to employ spatial cloaking [ 9 , 10 ] to conceal user locations : instead of reporting the exact coordinates to the LBS , an Anonymizing Spatial Region ( K ASR ) is constructed , which encloses the locations of K−1 additional users . Ref . [ 13 , 17 ] extend this method and also address processing of anonymized queries . Most existing approaches utilize a centralized anonymizer : a trusted server that acts as an intermediate tier between the users and the LBS . All users subscribe to the anonymizer and continuously report their location while they move . Each user sends his query to the anonymizer , which constructs the
WWW 2007 / Track : Pervasive Web and MobilityMay 8 12 , 2007 . Banff , Alberta , Canada371 appropriate K ASR and contacts the LBS . The LBS computes the answer based on the K ASR , instead of the exact user location ; thus , the response of the LBS is a superset of the answer . Finally , the anonymizer filters the result from the LBS and returns the exact answer to the user .
Our work is motivated by the following shortcomings of existing approaches : ( i ) The centralized anonymizer is a bottleneck due to handling query requests , frequent updates of user locations and result post processing . Moreover , the anonymizer is a single point of failure ; the system cannot function without it . ( ii ) The complete knowledge of the locations and queries of all users is a serious security threat , if the anonymizer is compromised . Even if there is no attack , the centralized anonymizer may be subject to governmental control , and may be banned or forced to disclose sensitive user information ( similar to the legal case of the Napster file sharing service ) . ( iii ) Independent of the centralized architecture , the hierarchical partitioning method for K ASR construction [ 10 , 17 ] fails to provide anonymity under certain conditions ( see Section 3 ) .
We propose Priv´e , a distributed architecture for anonymous location based queries , which addresses the problems of existing systems . Our contributions are : ( i ) We develop a superior K ASR construction mechanism based on the Hilbert space filling curve , that guarantees query anonymity even if the attacker knows the locations of all users . ( ii ) We introduce a distributed protocol used by mobile entities to self organize into a fault tolerant overlay network . The structure of the network resembles a distributed B+ tree ( each mobile user corresponds to a data point ) , with additional annotation to support efficiently the Hilbert based KASR construction . In Priv´e , K ASRs are built in a decentralized fashion , therefore the bottleneck of the centralized server is avoided . Moreover , since the state of the system is distributed , Priv´e is resilient to attacks . ( iii ) We also conduct an extensive experimental evaluation . The results confirm that Priv´e achieves efficient anonymization and load balancing with low maintenance overhead , while being faulttolerant . Therefore , it is scalable to large numbers of mobile users .
The rest of the paper is organized as follows : Section 2 discusses the architecture of Priv´e . Section 3 introduces spatial K anonymity concepts and highlights the limitations of existing solutions . In Section 4 , we introduce our Hilbertbased K ASR construction mechanism and in Section 5 we describe the distributed protocol of the overlay network . Section 6 presents the experimental evaluation of our system . A brief survey of the related work is included in Section 7 . Finally , Section 8 concludes the paper and discusses directions for future work .
2 . SYSTEM ARCHITECTURE
Fig 1 depicts the architecture of Priv´e . We assume a large number of users who carry mobile devices ( eg , mobile phones , PDAs ) with embedded positioning capabilities ( eg , GPS ) . The devices have processing power and access the network through a wireless protocol such as WiFi , GPRS or 3G . Moreover , each device has a unique network identity ( eg , IP address ) and can establish point to point communication ( eg , TCP/IP sockets ) with any other device in the system through a base station ( ie , the two devices do not need to be within communication range of each other ) . For security reasons , all communication links are encrypted .
Pseudonym services
Location Based Service
Certification
Server
C4 u2 u0
C1 u1 u3 u4 u6 u5
C2 u8 u7
C3 u9
Figure 1 : Architecture of Priv´e
In addition , we assume the existence of a trusted central Certification Server ( CS ) , where users are registered . Prior to entering the system , a user u must authenticate against the CS and obtain a certificate . Users having a certificate are trusted by all other users . Typically , a certificate is valid for a few hours ; it can be renewed by recontacting the CS . Apart from the certificate , the CS returns to u the IP addresses of some users who are currently in the system . u uses this list to identify an entry point to the distributed network . Note that the CS does not know the locations of the users and does not participate in the anonymization process . Therefore the workload of the CS is low ( ie , no location updates ) ; moreover it does not store any sensitive information .
Each user corresponds to a peer . Peers are grouped into clusters , according to their location . Within each cluster , peers elect a cluster head , and the set of heads is grouped recursively to form a tree . To achieve load balancing , cluster heads are rotated in a round robin manner . By definition , cluster heads belong to multiple levels of the tree . In Fig 1 , for instance , there is a two level hierarchy , where users u2 , u3 , u8 are the heads of cluster C1 , C2 and C3 , respectively ; also , u8 is the head of the upper layer cluster C4 .
Typically users ask Range or Nearest Neighbor ( NN ) queries with respect to their location . For example , user u1 in Fig 2 , may ask : “ Find the nearest hospital to my present location ” ( the answer is h2 ) . Such queries reveal the exact location of u1 . To achieve anonymity , Priv´e requires users to set a degree of anonymity K ( note that K is based on individual criteria and may vary among queries ) . In our example , u1 chooses K = 3 . Priv´e identifies an appropriate set of three users ( ie , u1 , u2 and u3 ) in a distributed manner and constructs the corresponding K ASR ( ie , the rectangle which encloses the three users ) . Next , the transformed query is sent to LBS by u1 . In order to hide his IP address , u1 uses a pseudonym . To obtain a pseudonym , any existing service for anonymous web surfing can be used1 . Note that the pseudonym service does not know the location of any user . Moreover , the auxiliary users inside the K ASR collaborate only to hide the location , but do not know the exact query of u1 ; therefore , a single point of attack is avoided .
Priv´e can collaborate with various untrustworthy spatial databases providing LBS . The only requirement for the LBS is to support NN queries of regions ( ie , K ASRs ) as opposed to points . Intuitively , the nearest neighbors of a region are all the data objects inside the region plus the NN of every
1Since each user can access his preferred pseudonym service , that service is not a bottleneck or a single point of failure .
WWW 2007 / Track : Pervasive Web and MobilityMay 8 12 , 2007 . Banff , Alberta , Canada372 h5 h4 u1 u1 h3 h3 u3 u3 u2 h1 h2 h1 h2 h5 h4 u1 h3 u3 u2 K ASR
Figure 2 : Example : “ Find the nearest hospital ” ( users are shown as black dots ) . point in the perimeter of the region . In our example ( Fig 2 ) , the NN of the K ASR are {h2 , h3 , h4} ; the set is filtered by u1 to obtain the actual answer h2 . The cardinality of the NN set ( thus the processing and communication cost ) depends on the K ASR ; therefore we aim to minimize the size of the K ASR . Query processing at the LBS [ 11 , 13 , 17 ] is orthogonal to our work , but outside the scope of this paper .
3 . SPATIAL K ANONYMITY A user u who issues a location based query is considered to be K anonymous if his identity is indistinguishable from that of K−1 other users [ 10 ] . Formally : Definition [ Spatial K anonymity ] Let H be a set of K distinct user entities with locations enclosed in an arbitrary spatial region K ASR . A user u ∈ H is said to possess Kanonymity with respect to K ASR if the probability of distinguishing2 u among the other users in H does not exceed 1/K . We refer to K as the required degree of anonymity .
Note that : ( i ) The definition assumes a snapshot of user locations . Although Priv´e supports user mobility , K anonymity is undefined across multiple snapshots . ( ii ) Spatial K anonymity does not depend on the size of the K ASR . In the extreme case , the K ASR can degenerate to a point , if K users are at the same location . In general , we prefer small K ASRs , in order to minimize the processing cost at the LBS and the communication cost between the LBS and the mobile user . Nevertheless , some applications impose a lower bound on the size of the K ASR [ 17 ] . In such a case , the KASR can be trivially enlarged to satisfy the lower bound , by symmetrical scaling in all directions . The same procedure can also be used to avoid having users on the perimeter of the K ASR . A na¨ıve K ASR construction algorithm would choose a random K ASR . However , if the K ASR is too small it may contain fewer than K users , whereas if it is larger than necessary , it will affect the query cost . Constructing the K ASR in the neighborhood of the querying user u ( eg , using the K nearest neighbors of u ) is also inappropriate , because u tends to be closest to the center of the K ASR , thus easily identified . Moreover , we cannot pick randomly K−1 auxiliary users and send K independent NN queries to the LBS , because we would disclose the exact locations of K users ; this is undesirable in any anonymization method .
2Note that , we address location anonymity ; attacks based on background knowledge ( eg user medical history ) are outside the scope of this work
Figure 3 : K ASR Reciprocity Example , K=5 We identify the following property that is sufficient for a K ASR construction technique in order to preserve user privacy : Definition [ K ASR Reciprocity ] Consider a user uq issuing a query and its associated K ASR Aq . Aq satisfies the reciprocity property iff there exists a set of users AS lying in Aq such that ( i ) |AS| ≥ K , ( ii ) uq ∈ AS and ( iii ) every user u ∈ AS lies in the K ASRs of all other users in AS .
Fig 3 shows an example with ten users . For K=5 , the KASR of users u1 , u3 , u4 , u8 , u10 is area A1 an the K ASR of users u2 , u5 , u6 , u7 , u9 is area A2 . In this example , K ASRs of all users satisfy the reciprocity property . For instance , for user u1 , if we set AS = {u1 , u3 , u4 , u8 , u10} , we may easily verify that AS satisfies all the requirements of the reciprocity property .
Theorem 31 For a given snapshot of user locations , and regardless of the query distribution among users , a KASR construction technique guarantees spatial K anonymity if every generated K ASR satisfies the reciprocity property . Proof . We assume the worst case scenario , where an attacker knows the exact location of all users in the system ( from an outside source ) . The attacker intercepts a set A of K ASRs associated to user queries . Consider K ASR Aq ∈ A . The attacker attempts to infer the user uq that constructed Aq . Since Aq satisfies the reciprocity property , there exists a set of users AS ( lying in Aq ) such that ( i ) |AS| ≥ K , ( ii ) uq ∈ AS and ( iii ) every user u ∈ AS lies in the K ASRs of all other users in AS . Moreover , since every K ASR satisfies the reciprocity property , it follows that when the attacker inspects any K ASR that includes uq , he will observe the same set of users AS . Therefore , for all users u in AS , the probability Pu of being the query issuer is :
Pu = Puq =
1|AS| ≤ 1K
Hence , the K anonymity property is satisfied .
In view of this property , an optimal K ASR construction algorithm would partition the user population into K ASRs that possess the reciprocity property , such that the sizes of the resulting K ASRs are minimized . However , optimal K anonymity is an NP Hard problem [ 16 ] . A number of onthe fly K ASR construction techniques have been proposed , which attempt to achieve anonymity and reduce the K ASR size . In the following , we briefly survey these solutions and highlight their drawbacks . 3.1 Drawbacks of Existing Approaches
The anonymization technique of Ref . [ 10 ] indexes user locations in a PR Quad tree . When user u issues a query , the
WWW 2007 / Track : Pervasive Web and MobilityMay 8 12 , 2007 . Banff , Alberta , Canada373 Figure 4 : Limitations of QUADASR , K=3
Quad tree is traversed until a quadrant which contains u and less than K−1 other users is found . The parent of that quadrant is returned as the K ASR . A similar idea is used in Ref . [ 17 ] . We refer to this technique as quadASR .
There are two drawbacks of quadASR : ( i ) It may fail to achieve anonymity for some user distributions . Consider the example of Fig 4 . Each user resides in his own quadrant identified by its lower left and upper right coordinates . When any of the users u1 , u2 or u3 issues a query with degree of anonymity K=3 , the quadrant q2 = ( (0 , 2 ) , ( 2 , 4 ) ) which encloses u13 will be returned as the K ASR . On the other hand , when the isolated user u4 issues a query with K=3 , the larger quadrant q1 = ( (0 , 0 ) , ( 4 , 4 ) ) is returned . Note that if 1 < K ≤ 3 , the only reason to return quadrant q1 is that u4 issued a query . If an attacker knows the locations of the users in the area3 , he will be able to pinpoint u4 as the query origin . This vulnerability is the result of the fact that quadASR does not satisfy the reciprocity property ( ie u13 belong to the K ASR associated to u4 , but not the other way around ) . ( ii ) A second drawback of quadASR is that due to the non uniform distribution of user locations , the number of users enclosed by a K ASR may grow much larger than K ( as for u4 in the previous example ) . This corresponds to larger spatial extent of the K ASR , hence higher processing cost .
Recently , a P2P system has been proposed that performs distributed query anonymization for location based queries ; we refer to it as cloakP2P [ 7 ] . cloakP2P uses a technique similar to iterative deepening [ 23 ] to construct K ASRs . The query source initiates a K ASR request by contacting all peers within a given physical radius r , which is a fixed system parameter . If the set of peers S0 found in the initial iteration is larger than K , the nearest K of them are chosen to form the K ASR ; otherwise , the process continues , and all peers in S0 issue a request to all peers within radius r . The process stops when K or more users have been found . Intuitively , cloakP2P determines a query K ASR by finding the K −1 users nearest to the query source . Unfortunately , this simple heuristic fails to achieve anonymity in many cases , since the query issuer tends to be near the center of the K ASR . In Section 6 , we show experimentally the vulnerability of cloakP2P .
None of the existing methods satisfies the reciprocity property . Next , we describe our hilbASR algorithm , which overcomes the aforementioned drawbacks .
4 . THE hilbASR ALGORITHM
Our hilbASR algorithm guarantees that the probability of identifying the query initiator is always bounded by 1/K , even if the attacker knows the locations of all users . hilbASR uses the Hilbert [ 6 ] ordering to group users into 3By triangulation , phone companies can estimate the location of a user within 50 300 meters , as required by the US authorities ( E911 ) . fl
Figure 5 : Hilbert Curve ( Left : 4 × 4 ; Right : 8 × 8 ) .
Figure 6 : HILBASR , K=3 and K=4 buckets of K . The Hilbert space filling curve is a continuous fractal which maps each region of a multi dimensional space to an integer . In our case , the 2D coordinates of user locations are mapped to a 1D value . With high probability , if two points are close in the 2D space , they will also be close in the Hilbert transformation . Fig 5 , for instance , shows the curve for a 4× 4 and 8× 8 space partitioning ; the granularity of the regions can be arbitrary small . To compute the K ASR , hilbASR employs a partitioning scheme that supports user mobility and varying K with minimal overhead . Intuitively , hilbASR computes and sorts the Hilbert values of all users . Then , the algorithm conceptually groups the sorted Hilbert values into K buckets that contain K users , except from the last one which may contain up to 2·K−1 users . Let us consider a user u asking a query with anonymity degree K . To compute the K ASR of u , hilbASR computes the Hilbert value H(u ) of u and finds the K bucket that H(u ) belongs to . The minimum bounding rectangle ( MBR ) of all the users in the K bucket corresponds to the K ASR .
For example , in Fig 6 , we illustrate the locations of ten users and their sorted Hilbert values . To compute the 3 ASR of user u9 , hilbASR first finds the K bucket which H(u9 ) belongs to . In our case , this consists of four users , u8 , u9 , u10 and u7 . Then , hilbASR returns the MBR of these users . Thus , the 3 ASR of user u9 is area A3 . Similarly , the 4 ASR of user u5 is area A4 . Note that for a given snapshot , hilbASR returns the same K ASR for all users in the K bucket . This makes the K users of the K bucket indistinguishable from each other . Thus , the probability of identifying the query initiator is bounded by 1/K .
Lemma 41 For a snapshot of user locations , hilbASR guarantees query source anonymity against location based attacks .
Proof . hilbASR satisfies the reciprocity property , so from Theorem 3.1 immediately results that hilbASR guarantees spatial K anonymity .
In general , techniques that use fixed buckets suffer from lack of flexibility in accommodating queries with varying K . Our method overcomes this limitation by avoiding to materialize the K buckets . Instead , it maintains a balanced
WWW 2007 / Track : Pervasive Web and MobilityMay 8 12 , 2007 . Banff , Alberta , Canada374 Figure 7 : HILBASR with Annotated B+ tree sorting tree , which indexes the Hilbert values of user locations . Let user u initiate a query with anonymization degree Ku . Our algorithm performs a search for H(u ) in the index and computes ranku , which corresponds to the position of H(u ) in the in order traversal of the tree . From ranku , we calculate the start and end positions defining the K bucket which includes H(u ) , as 4 : start = ranku − ( ranku mod Ku ) end = start + Ku − 1
( 1 )
To compute ranku efficiently , we use an annotated B+tree ( similar to the aR tree [ 18] ) , where each tree node stores the number of leaf nodes in each of its subtrees . Consider the example in Fig 7 . For each internal node entry e , we store the number of leaf entries that are rooted at e ; annotation counters are shown in parenthesis . Assume we want to determine a K ASR for entry 37 , with K=6 . First , we compute the rank of entry 37 ( Fig 7a ) : we follow the path in the tree from root to the leaf that contains 37 , and at each internal node we add to the rank value the sum of all counters in the node situated at the left of the followed pointer . At the leaf layer , we add to the rank the local rank value of key 37 in its leaf , and obtain rank 8 ( ranks start from 0 ) . Then , we calculate the bucket delimiters using Eq ( 1 ) , and obtain the interval [ 611 ] Next ( Fig 7b ) , we perform a range search to locate the entries with ranks [ 611 ] Observe that this operation uses the annotation , rather that the B+ tree keys . Sub ranges at each level are determined by splitting the initial range based on subtree sizes ; the offset for the recursive call at entry e is determined as the initial start value minus the sum of counters of all entries in the node preceding e . The resulting K ASR is highlighted in the diagram . The data structure is scalable , since the complexity of constructing the K ASR is O(log N + K ) , whereas search , insert and delete cost is O(log N ) . Therefore , hilbASR is applicable to large numbers of mobile users who update their position frequently and have varying requirements for the degree of anonymity K .
5 . ANONYMIZATION IN Priv´e
In this section , we introduce Priv´e , a distributed protocol which supports decentralized query anonymization using the hilbASR algorithm . Priv´e mimics the functionality of a B+ tree in a distributed setting . Each mobile user u has
4For the last ( incomplete ) bucket , start and end are adjusted accordingly
Figure 8 : Distributed Index Structure , α=2 an associated index entry consisting of an ID ( eg , IP address ) , and the Hilbert value H(u ) of his location as index key . A node ( leaf or internal ) in the B+ tree corresponds to a cluster of users , with size bounded between α and 3α , where α is a fixed system parameter . We use the terms cluster and index node interchangeably . The maximum cluster size is 3α , instead of the usual 2α for B+ trees , to prevent cascading splits and merges ( ie , a split followed by a user departure ) , which are costly in the distributed environment . Every user belongs to a leaf level cluster ( level 0 ) , and the contents of each cluster are disjoint ( see Fig 8 ) . The users of each cluster C elect a leader called head(C ) . The head ( marked with an asterisk ) handles all index operations on behalf of the users in the cluster . Cluster heads are recursively grouped to form a tree ; therefore , they belong to multiple levels of the tree . We denote by C i u , the level i cluster which includes user u . In our example , user ua is the head of cluster C 0 a at level 0 , and also the head of clusters C 1 a and C 2 a ; therefore , it belongs to every level of the tree . There is a single cluster at the top of the hierarchy , denoted as top . The cluster head of top is denoted by root ( ua in the example ) . In our protocol description , we use remote procedure call convention to specify interactions between users . The notation u.f unc(params ) denotes the invocation of subroutine f unc with parameters params at user u .
Each cluster is associated with its state information . The state of a leaf level cluster consists of an ordered list of ( IP address , H(u ) ) pairs ( user coordinates can be derived from the H(u ) value ) . The state of an upper layer cluster with m elements consists of a list of m user addresses , separated by m − 1 key values used to direct the search ; the process is similar to a B+ tree , with the role of memory pointers fulfilled by the IP addresses of users . Each internal node entry is annotated with a counter ( depicted in parenthesis ) representing the total number of users at the subtree under the entry . Only the head needs to know the state of the cluster . However , in our implementation , we replicate the state on every user within the cluster , to improve fault tolerance ( in Section 6 , we discuss the tradeoff between fault tolerance and maintenance cost ) . The Priv´e hierarchy has at most logα N layers , where N is the total number of users . Since the cluster size is bounded and a user may belong to at most one cluster at each level , there is an upper bound of O(α logα N ) on the membership state stored at a user . 5.1 The index supports four operations : join , departure , relocation and K request ( ie , a request for a K ASR with anonymization degree K ) . We establish two performance metrics for Priv´e : ( i ) latency : the number of hops an in
Index Operations
WWW 2007 / Track : Pervasive Web and MobilityMay 8 12 , 2007 . Banff , Alberta , Canada375 Figure 9 : User Join and Relocation , α=2
Figure 11 : K request , α=2 , K=6 u).Relocate(u , Hu,0 ) u.Relocate(relocated user,H,l ) u.RelocateMyself( ) /*executed by moving user*/ determine new key value Hu = Hilbert(u.x , u.y ) call head(C0 if ( H in indexed key range at level l ) if ( l = 0 ) add relocated user to leaf user list ; return else let n be the next hop for H call n.Relocate(relocated user , H,l − 1 ) else call head(parent(Cl u)).Relocate(relocated user , H,l + 1 )
Figure 10 : User Relocation dex operation requires to complete . The latency is equal to the longest tree path followed as a result of the operation . Multiple paths may be followed in parallel during an operation . ( ii ) communication cost : the number of messages generated by an index operation . Join . User join corresponds to a B+ tree insertion operation . Newly joining users authenticate at the certification server and receive the address of a user already inside the system . Without loss of generality , we assume that joining users know the root , since the root can be reached from any user in O(logα N ) cost . We stress that since we require an index structure with annotation ( in order to determine the absolute ranks of users ) , all joins must occur through the root . To avoid overloading the root , we devise a loadbalancing mechanism ( Section 52 ) User join has O(logα N ) complexity in terms of latency and O(logα N + α ) communication cost ; the second term is for updating the cluster state in all the users of the affected cluster . Consider user uy with Hilbert value H(uy ) = 46 that joins the index of Fig 8 : uy contacts ua ( at the root level ) who forwards the join request to ub and updates ub ’s annotation counter in C 2 a to 14 . ub then forwards the request to uh , whose annotation counter in C 1 b is updated to 4 . Fig 9(a ) shows the join outcome . User join may trigger a cluster split , handled similarly to a B+ tree node split ; the head initiating the split leads one of the resulting clusters , and appoints a random initial cluster node to lead the other . Departure ( informed ) . User departure is similar to a B+ tree deletion . The effect of deletion must be propagated to root to update the annotation counters . Deletion has O(logα N ) latency and O(logα N + α ) communication cost . If the cluster size decreases below α , the head triggers a merge operation with the neighbor leaf level cluster that has fewer members ( to avoid a cascaded split ) . The head of the resulting cluster can be any of the initial heads , except if one of them ( eg , ua ) is also head at the higher level . If so , ua will be chosen as leader , to minimize membership changes . Relocation . User mobility is treated as an entry update , which in a B+ tree translates into a deletion and an inser tion . Since users are likely to change location often , we optimize this process by performing local reassignment of users to nearby clusters . Due to the good locality properties of Hilbert ordering , the number of clusters involved in relocation is likely to be small . Annotation counter updates are only performed by affected clusters ; this way , updates are not propagated all the way to the root . The upper bound on relocation latency is O(logα N ) , but in most cases relocation only involves a few clusters , at the low layers of the index . The pseudocode for user relocation is given in Fig 10 .
Consider user us from Fig 8 who relocates to a new position with Hilbert value 60 . He forwards the request to ua = head(C 0 s ) . ua cannot keep us within the same leaf entry , since the new value is outside the interval [ 4955 ] Since ua = head(C 1 a ) , with no additional message , ua decides that us can be relocated to C 0 f , forwards the request to uf and updates the annotation counters of ua and uf accordingly . Fig 9(b ) illustrates the relocation outcome . K request . This operation corresponds to the hilbASR algorithm described in Section 4 . Consider the example in Fig 11 , where user um issues a K request with K=6 . The request follows the path : um → ud → ub → ua ( solid arrows in Fig 11(a) ) . The root ua determines the K bucket ( ie , start = 6 , end = 11 ) and sends a K ASR request to ub ( dotted arrows in Fig 11(a) ) . ub sends in parallel requests for partial K ASRs with ranges [ 66 ] , [ 79 ] and [ 1011 ] to ud , ue and uh , respectively . ub , which is the head of the lowestlayer cluster that completely covers the K bucket ( shown hashed in Fig 11(b ) ) collects the partial K ASRs , assembles the final query K ASR and sends it back to the query issuer on the reverse path of the request . Note that , the cluster head that covers the K bucket sustains the highest load among all other users involved in the query . This potential load imbalance issue is addressed in Section 52 A K request has O(logα N )+O(logα K ) latency and O(logα N )+O(K/α ) communication cost . The pseudocode for K request is shown in Fig 12 . Once the K ASR is constructed , the query issuer ( ie , um ) can send the anonymized query to the LBS through a pseudonym service , as explained in Section 2 . 5.2 Fault Tolerance and Load Balancing
Priv´e implements a soft state based mechanism to deal with user failures or disconnections without notification . Each cluster leader sends periodically ( ie , every δt seconds ) a membership update message to all cluster members . The message contains the membership list of the current cluster C and that of parent(C ) . Cluster members respond to these messages ; if a cluster member does not respond to two consecutive messages , it is considered disconnected and removed from the cluster . The change is broadcast by the cluster head to the remaining cluster members .
WWW 2007 / Track : Pervasive Web and MobilityMay 8 12 , 2007 . Banff , Alberta , Canada376 u.K request( ) /*executed by query source*/ determine key value Hu = Hilbert(u.x , u.y ) call head(C0 u.ForwardRequest(H , count , l ) u).ForwardRequest(Hu , 0 , 0 ) if ( l = 0 ) count = rankH in leaf entry else count+ = sum of annotation counters of keys < H if ( u is root ) compute start and end using eq ( 1 ) K ASR = root.f indM BR(start , end , root height ) else call head(C u ).ForwardRequest(H , count , l + 1 ) l+1 u.findMBR(start,end,l ) if ( l = 0 ) /*leaf level*/ return MBR of members with local rank in [ start,end ] find set of next hops U for range [ start,end ] M BR = ∅ ∈ U for u M BR = M BR ∪ u return M BR
.findMBR(startu , endu , l − 1 )
Figure 12 : K request
If a non head cluster member u does not receive a membership update from its head for a 2δt period , it initiates a leader election process . Alternatively , when u attempts to initiate a operation , such as query or relocation , but cannot contact the cluster head for two consecutive attempts , it triggers the leader election protocol without waiting for the timer to expire . u checks the membership it had at the last update , and chooses as leader ( ie , new head ) the user with the smallest identifier . It then sends a transfer head message to new head , which in turn sends a membership update message to all cluster users and also contacts head(parent(C ) ) to notify the change in leadership . new head will replace the old head in all layers where the latter was leader before disconnection .
The hierarchical structure can cause significant differences between the load sustained by cluster heads and ordinary cluster members , as well as among cluster heads at different layers of the hierarchy . To alleviate the inherent imbalance , we propose a cluster head rotation mechanism , where users take turns in fulfilling the cluster head role . Since the promotion to cluster head translates into presence at a higher layer of the hierarchy , the rotation also ensures that users equally share the load at different layers .
Rotation is triggered when a node reaches a certain load threshold , denoted by load unit . In wireless devices , the communication cost is dominant . It is also important from the user ’s perspective , since mobile phone operators charge by the amount of transferred data . Therefore , in Priv´e the load is best represented by the number of messages sent and received by the user .
When user u reaches one load unit , it triggers a head rotation in all the clusters it currently heads , starting with its highest layer . For each node along the path to its level 0 cluster , the member with the least load is appointed as new head . Note that , since u stores the membership state about all clusters it belongs to at different layers , the appointment of a new leader can be done directly by u , without the need for a complex protocol or additional messages . Choosing the cluster member with the lowest load prevents the newly appointed head to start a fresh rotation soon after promotion . Fig 13 illustrates the rotation mechanism . For simplicity , all clusters have size 2 . Assume all queries originate at user ud with K=4 . After ua reaches one load unit , it hands over the root role to ue ( at layer 2 ) from the right hand subtree . Also , at layer 1 , uc becomes the head and is automatically promoted to layer 2 . Similarly , at layer 0 , ub
Figure 13 : Load Balancing Mechanism becomes the head and is promoted to layer 1 ; the result is shown in Fig 13(b ) . Next , uc reaches its load unit , because more requests pass through it ( it must inject queries and collect partial K ASRs ) . uc triggers a rotation at level 1 and appoints ub as cluster head ( see Fig 13(c) ) . Subsequently , ub may be the next one to reach the load threshold , and start a new rotation in the left subtree . Observe that at step ( d ) , the left subtree has already performed a complete rotation round , whereas the right subtree has only performed one change . Hence , our rotation mechanism alleviates hotspots ( an entire subtree shares the load generated by ud ) and at the same time provides a degree of fairness , not allowing a localized hotspot to affect a large partition of the index .
The granularity of load unit choice is important in practice , in order to achieve a good tradeoff between load balancing and communication cost , since a rotation may incur a number of messages as large as O(α logα N ) . We further discuss this issue in Section 6 .
6 . EXPERIMENTAL EVALUATION
To evaluate Priv´e , we have implemented an event driven packet level simulator in C++ . Since we are mostly interested in the overlay layer performance , we consider a full mesh topology with lossless 500ms round trip time links between any pair of users . Our workload consists of user locations and movement patterns , and is generated using the Network based Generator of Moving Objects [ 5 ] , which models user movement on public road networks . We consider user velocities ranging from 18 to 68km/h . We present our results for a data set consisting of the San Francisco bay area ( Fig 16(a) ) , with number of users N varying from 1000 to 10000 . We vary the anonymization degree K from 10 to 160 . We consider both uniform and Zipfian distributions of queries over the set of users . Anonymity Strength . In Section 4 , we have proved that hilbASR guarantees anonymity against location based attacks , under any query distribution . We illustrate this property in comparison with cloakP2P[7 ] and quadASR[10 ] . We assume that an attacker knows ( from an external source ) the locations of all users , and employs a simple strategy which infers the query source as uc , the user who is nearest to the center of the K ASR . We consider a 10000 users scenario in which 10000 random queries are issued . In Fig 14 we plot the identification success probability ( ie of uc being the query source ) , for various values of K . The dotted line represents the value 1/ K , the ideal performance for an anonymization algorithm . In the case of cloakP2P , for K=40 , the probability of uc being the query source is 10 % , four times the 1/K=2.5 % maximum allowed bound . For larger values of K , the situation gets worse , as the number of users included in the K ASR increases . The users are likely to come uniformly from all directions ; hence , uc is disclosed as the query source . On the other hand , hilbASR achieves the required anonymity degree K at all times . Due to its poor anonymization strength , we omit cloakP2P from our further discussion . quadASR has lower probability of identification for this particular type of attack . However , this
WWW 2007 / Track : Pervasive Web and MobilityMay 8 12 , 2007 . Banff , Alberta , Canada377 ) e c r u o S y f i t n e d I ( P
0.2
0.15
0.1
0.05
0
1/K HILBASR CloakP2P QUADASR
20 40 60 80 100 120 140 160
K
Figure 14 : Anonymity Strength hilbASR quadASR
Area
Area
100K
80K
60K
40K
20K
0 hilbASR quadASR
20 40 60 80 100 120 140 160
Κ
( a ) Varying K , 10k users
300K
250K
200K
150K
100K
50K
0
1K 2K 3K 4K 5K 6K 7K 8K 9K 10K
( b ) K=80 , varying N
Ν
Figure 15 : K ASR area does not mean that it provides stronger anonymization than hilbASR : the ideal probability is given by the 1/K bound . quadASR includes an excessively large number of users in the K ASR , yielding high query processing cost ; furthermore , it is still vulnerable to attacks such as those described in Section 3.1 , while hilbASR provides anonymity guarantees under all circumstances . K ASR Size . In this experiment , we compare hilbASR against quadASR in terms of spatial extent ( ie , area ) of the generated K ASR . We consider a snapshot of user locations and generate a number of queries equal to the population size N . Each query is initiated by a random user . Fig 15(a ) shows the results for varying K and 10K users . hilbASR is better in all cases . In Fig 15(b ) we set K=80 and vary the number of users . The decrease in K ASR size with increasing N is explained by the higher user density in the same dataspace ( ie , K users can be located in a smaller region ) . hilbASR again outperforms quadASR in terms of K ASR extent . Recall that smaller K ASR translates into reduced execution cost at the LBS and communication cost between the LBS and the user . Note that quadASR has been proposed only for centralized anonymization . Still , the size of the resulting K ASR is independent of whether it is constructed in a centralized or distributed setting . Nevertheless , hilbASR outperforms quadASR in terms of both K ASR size and anonymity strength ( recall from Section 3.1 that quadASR may fail for certain user distributions ) . The only other system that considers anonymization in a decentralized setting is cloakP2P , but we have shown that it fails to provide anonymity by a large margin . Hence , hilbASR is the only protocol that guarantees anonymity . Furthermore , it can be deployed in decentralized environments , and outperforms existing methods in terms of K ASR size . We further investigate the performance of Priv´e , which implements hilbASR in a decentralized fashion . Join and Departure . In a system with N users , we perform 0.1N random user joins , followed by 0.1N random user departures . Fig 16(b ) shows the join latency measured as hop count from the time a user issues a join request until he receives a join response message from its leaf level head . We observe that the latency is lower than the theoretical 1 + logα N , as a user may appear in multiple levels and can avoid sending redundant messages to himself . The communication cost ( ie , total messages ) per join and departure operation ( Fig 16(c ) ) varies linearly with α , since every join/departure translates into a membership update broadcast message within one leaf level cluster . Note the role of α in the latency cost tradeoff : an increase of α decreases latency as logα N , but triggers a linear cost increase in membership notification . A larger α also increases the cost of periodic cluster membership maintenance . K request . Fig 16(d ) and 16(e ) show the K request latency and communication cost for varying α , where K=40 . Larger α decreases the latency as the height of the index decreases . The communication cost also decreases , as fewer leaf level cluster heads need to be contacted to build the KASR . However , α cannot grow very large from index maintenance considerations . Fig 16(f ) and 16(g ) show the latency and communication cost variation with anonymization degree K , α = 5 . Latency is only marginally affected by K ( the dominant factor in latency is logα N , since in practice Kff N ) , while the communication cost grows linearly with K . The percentage of the user population involved in answering a single K request operation is shown in Fig 16(h ) and 16(i ) . For small N values , at most 2 % of all users are needed to answer a K request , while for larger N , less than 0.5 % of the users are required . Relocation . Priv´e addresses user mobility by using an index update algorithm that attempts to resolve relocation at the lower levels of the hierarchy , in order to reduce both latency and communication cost . In our simulated scenario , we consider 10000 users across 20 consecutive time frames , with half of the indexed users moving at each time frame . We consider three velocities : 68 , 40 and 18km/h . Fig 16(j ) and 16(k ) show that relocation is efficiently handled : for the moderate α = 10 value , the relocation is done on average in 2.5 hops for fast moving users and 1.5 hops for slowmoving users . The dominant communication cost is that of the membership change propagation ; for α = 10 this cost is roughly a quarter compared to the cost of an index deletion followed by insertion for the 68km/h case , and 1/8 for 18km/h . Fig 16(l ) shows the frequency of relocations completed at various levels of the hierarchy for a 6 level , α = 3 , 10000 users system . Most relocations are solved at the low levels of the hierarchy : for slow movement , 70 % are solved at the leaf level and 86 % at levels 0 and 1 ; for fast movement , 32 % of relocations are completed at the leaf level , 63 % at levels 0 and 1 , and 86 % at levels 0 , 1 or 2 . Fault tolerance . Starting with a system having correct cluster membership , we fail simultaneously 10 , 20 or 30 % of the nodes . We use maintenance timer values of 30 seconds for refreshing cluster membership and 60 seconds for purging a failed member . Fig 16(m ) shows the evolution of membership state correctness over time ( 1 represents completely correct state ) . The system recovers to a correct state within 3 purge cycles ( 138 sec ) for 10 % failure and 4 purge cycles ( 197 sec ) for 30 % failure . Load balancing . We measure the load incurred by each user for a 10000 users system , α = 5 , K=80 , load unit = 200 messages and a simulated time of 1 hour , during which an average of 8 queries/user were generated . We consider both uniform and skewed ( Zipf 0.8 ) query source distribution . Fig 16(n ) shows the cumulative distribution function
WWW 2007 / Track : Pervasive Web and MobilityMay 8 12 , 2007 . Banff , Alberta , Canada378 7 6 5 4 3 2 1 0
Latency
N=10000 N=1000 N=100
5
10 α
15
20
Cost
50
40
30
20
10
0
14 12 10 8 6 4 2 0
N=10000 N=1000 N=100
5
10 α
15
20
Latency
N=10000 N=1000 N=100
5
10 α
15
20
Cost
35 30 25 20 15 10 5 0
N=10000 N=1000 N=100
5
10 α
15
20
( a ) San Francisco Bay
( b ) Join Latency vs α
( c ) Join/Leave Cost vs α
( d ) Query Latency vs α
( e ) Query Cost vs α
Latency
N=10000 N=3000 N=1000
9 8 7 6 5 4 3 2 1 0
Cost
N=10000 N=3000 N=1000
45 40 35 30 25 20 15 10 5 0
20 40 60 80 100 120 140 160
( f ) Query Latency vs K
Κ
20 40 60 80 100 120 140 160
( g ) Query Cost vs K
Κ
20 40 60 80 100 120 140 160
( h ) Percentage vs K
Κ
20 18 16 14 12 10 8 6 4
Cost 68km/h 40km/h 18km/h
5
10 α
15
20
( k ) Relocation Cost
0.8 0.7 0.6 0.5 0.4 0.3 0.2 0.1 0
Frequency
68km/h 40km/h 18km/h
0
1
2
3
4
5
Level
( l ) Relocation Level
Membership Correctness
10 % 20 % 30 %
Nodes( % )
N=10000 N=3000 N=1000
2
1.5
1
0.5
0
1.1
1
0.9
0.8
0.7
0.6
1.6 1.4 1.2 1 0.8 0.6 0.4 0.2 0
1
0.8
0.6
0.4
0.2
Nodes( % )
N=10000 N=3000 N=1000
5
10 α
15
20
5.5 5 4.5 4 3.5 3 2.5 2 1.5 1
Latency
68km/h 40km/h 18km/h
5
10 α
15
20
( i ) Percentage vs α
( j ) Relocation Latency
Load CDF
350 300 250 200 150 100 50 0
Absolute Load
Uniform Zipf(0.8 )
0
2K
4K
Ν
6K
8K
10K
0
50
100
150
200
Time(sec )
0
0
No Rotation Rotation unif Rotation Zipf(0.8 ) Ideal
2K
4K
Ν
6K
8K
10K
( m ) Failure Recovery
( n ) Node Load CDF
( o ) Absolute Node Load
Figure 16 : Priv´e Experimental Evaluation
( CDF ) of sorted user loads . The load is highly unbalanced if no rotation is performed , with 10 % of users sustaining more than 80 % of the load . With rotation , for uniform query distribution , the load is close to the ideal one ( ie , diagonal line ) . For skewed query distribution , most of the users share equal load , while part of the users ( roughly 10 % ) share a slightly higher load , as dictated by the fairness requirement discussed in Section 52 This is illustrated better in Fig 16(o ) which shows the absolute load of each user .
7 . RELATED WORK
K anonymity was first discussed in relational databases where published statistical data ( eg , census , medical ) should not be linked to specific persons . Samarati and Sweeney [ 19 , 21 ] proposed the following definition : A relation satisfies K anonymity if every tuple in the relation is indistinguishable from at least K−1 other tuples with respect to a set of quasi identifier attributes . Quasi identifiers are sets of attributes ( eg , date of birth , gender , zip code ) which can be linked to publicly available data to uniquely identify individuals . Two techniques are used to transform a relation to a K anonymized one : suppression , where some of the attributes or tuples are removed , and generalization , which involves replacing specific values ( eg , phone number ) with more general ones ( eg , only area code ) . Both techniques result in information loss . Ref . [ 4 ] and Ref . [ 14 ] discuss efficient algorithms for anonymizing an entire relation while preserving as much information as possible . In Ref . [ 22 ] the authors consider the case where each individ ual requires a different degree K of anonymity , while Aggarwal [ 1 ] shows that anonymizing a high dimensional relation results to unacceptable loss of information due to the dimensionality curse . Finally , Machanavajjhala et al . [ 15 ] propose fi diversity , an anonymization method which protects against disclosure of sensitive attribute values . K anonymity has also been adopted in the LBS domain : in Ref . [ 9 , 10 ] , the location of the user is concealed by constructing an Anonymizing Spatial Region ( K ASR ) which encloses the locations of the query source and K−1 additional users . However , their methods of K ASR construction are inefficient , and anonymization may fail for some data distributions . Ref . [ 13 , 17 ] extend further these ideas and present a framework for the entire process of anonymization and query processing at the LBS . Nevertheless , the aforementioned methods assume a centralized anonymizer , which may constitute a bottleneck or a single point of attack . Prior to our work , the only decentralized solution was a P2P based system , presented in Ref . [ 7 ] . However , that system fails to achieve anonymity in many situations ( see Section 6 ) .
Key and range search has been studied extensively in distributed environments . Several structured Peer to Peer systems ( e.g , Chord [ 20 ] ) support distributed key search with O(log N ) complexity . The drawback of such systems is that they cannot support efficiently node annotation . Without node annotation , the communication cost for satisfying the reciprocity property ( which guarantees K anonymity ) is O(N ) ; this cost is too high for large scale systems ( recall
WWW 2007 / Track : Pervasive Web and MobilityMay 8 12 , 2007 . Banff , Alberta , Canada379 that Priv´e needs only O(logaN ) messages ) . Closer to our work is the P tree [ 8 ] , which supports range queries by embedding a B+ tree on top of an overlay network . No global index is maintained ; instead each node maintains its own B+ tree like structure . BATON [ 12 ] also addresses range queries , by embedding a balanced tree onto an overlay network . It uses additional cross links to prevent hotspots , and achieves O(log N ) complexity for search and maintenance . Similar to Chord , these systems cannot support efficiently node annotation .
Hierarchical clustering in distributed environments has been an active research topic in recent years . In Ref . [ 3 ] , a hierarchical clustering routing protocol for wireless networks is presented . The NICE project [ 2 ] proposes a scalable application layer multicast protocol , based on delivery trees built on top of a hierarchically connected control topology . Nodes participating in a multicast group are organized into a multi layer hierarchy of clusters with bounded size . NICE trees obtain delays in the order of O(log N ) , where N is the size of the multicast group , and there is an upper bound of O(log N ) in terms of control state maintained per node . Priv´e also uses hierarchical clustering of mobile users , but the requirements of total ordering and annotation impose particular challenges that have not been addressed by existing research .
8 . CONCLUSIONS
In this paper we introduced Priv´e , a distributed system for query anonymization in LBS . In Priv´e , mobile users who issue location based queries organize themselves into a hierarchical overlay network and anonymize queries in a fully decentralized fashion . Priv´e supports our hilbASR anonymization technique , which guarantees anonymity under any user distribution . We show experimentally that our system is efficient , scalable , fault tolerant and achieves load balancing .
LBS for mobile users are already a reality in some countries ( eg , Japan ) , where new mobile phones are equipped with a positioning device , and high speed wireless networks are common . As such applications gain popularity , privacy and confidentiality concerns are expected to rise . In the future , we plan to address anonymity of continuous spatial queries , and extend our algorithm to trajectories , as opposed to points . We also plan to deploy Priv´e in infrastructureless environments , such as ad hoc wireless networks ( Wi Fi , Bluetooth ) , without point to point links between all users .
9 . REFERENCES [ 1 ] C . C . Aggarwal . On k Anonymity and the Curse of Dimensionality . In Proc . of VLDB , pages 901–909 , 2005 .
[ 2 ] S . Banerjee , B . Bhattacharjee , and C . Kommareddy .
Scalable application layer multicast . In Proc . of ACM SIGCOMM , pages 205–217 , 2002 .
[ 3 ] S . Banerjee and S . Khuller . A Clustering Scheme for
Hierarchical Control in Wireless Networks . In Proc . of IEEE INFOCOM , pages 1028–1037 , 2001 .
[ 4 ] R . Bayardo and R . Agrawal . Data Privacy through Optimal k Anonymization . In Proc . of ICDE , pages 217–228 , 2005 .
[ 5 ] T . Brinkhoff . A Framework for Generating
Network Based Moving Objects . Geoinformatica , 6(2):153–180 , 2002 .
[ 6 ] A . R . Butz . Alternative Algorithm for Hilbert ’s
Space Filling Curve . IEEE Trans . on Computers , 20(4):424–426 , 1971 .
[ 7 ] C Y Chow , M . F . Mokbel , and X . Liu . A
Peer to Peer Spatial Cloaking Algorithm for Anonymous Location based Services . In In Proc . of ACM GIS , pages 171–178 , 2006 .
[ 8 ] A . Crainiceanu , P . Linga , J . Gehrke , and
J . Shanmugasundaram . Querying P2P Networks using P trees . In Proc . of WebDB , pages 25–30 , 2004 .
[ 9 ] B . Gedik and L . Liu . Location Privacy in Mobile
Systems : A Personalized Anonymization Model . In Proc . of ICDCS , pages 620–629 , 2005 .
[ 10 ] M . Gruteser and D . Grunwald . Anonymous Usage of
Location Based Services Through Spatial and Temporal Cloaking . In Proc . of USENIX MobiSys , pages 31–42 , 2003 .
[ 11 ] H . Hu and D . L . Lee . Range Nearest Neighbor Query .
IEEE TKDE , 18(1):78–91 , 2006 .
[ 12 ] H . V . Jagadish , B . C . Ooi , and Q . H . Vu . BATON : a
Balanced Tree Structure for P2P networks . In Proc . of VLDB , pages 661–672 , 2005 .
[ 13 ] P . Kalnis , G . Ghinita , K . Mouratidis , and
D . Papadias . Preventing Location Based Identity Inference in Anonymous Spatial Queries . Technical Report TRB6/06 , National Univ . of Singapore , 2006 .
[ 14 ] K . LeFevre , D . J . DeWitt , and R . Ramakrishnan . Incognito : Efficient Full Domain K Anonymity . In Proc . of ACM SIGMOD , pages 49–60 , 2005 .
[ 15 ] A . Machanavajjhala , J . Gehrke , D . Kifer , and
M . Venkitasubramaniam . l Diversity : Privacy Beyond k Anonymity . In Proc . of ICDE , pages 24–35 , 2006 .
[ 16 ] A . Meyerson and R . Williams . On the Complexity of
Optimal K anonymity . In Proc . of ACM PODS , pages 223–228 , 2004 .
[ 17 ] M . F . Mokbel , C . Y . Chow , and W . G . Aref . The New
Casper : Query Processing for Location Services without Compromising Privacy . In Proc . of VLDB , pages 763–774 , 2006 .
[ 18 ] D . Papadias , P . Kalnis , J . Zhang , and Y . Tao .
Efficient OLAP Operations in Spatial Data Warehouses . In Proc . of SSTD , pages 443–459 , 2001 .
[ 19 ] P . Samarati . Protecting Respondents’ Identities in Microdata Release . IEEE TKDE , 13(6):1010–1027 , 2001 .
[ 20 ] I . Stoica , R . Morris , D . Liben Nowell , D . R . Karger ,
M . F . Kaashoek , F . Dabek , and H . Balakrishnan . Chord : a Scalable Peer to Peer Lookup Protocol for Internet Applications . IEEE/ACM Transactions on Networking , 11(1):17–32 , 2003 .
[ 21 ] L . Sweeney . k Anonymity : A Model for Protecting
Privacy . Int . J . of Uncertainty , Fuzziness and Knowledge Based Systems , 10(5):557–570 , 2002 .
[ 22 ] Y . Tao and X . Xiao . Personalized Privacy
Preservation . In Proc . of ACM SIGMOD , pages 229–240 , 2006 .
[ 23 ] B . Yang and H . Garcia Molina . Improving Search in
Peer to Peer Networks . In Proc . of ICDCS , pages 5–14 , 2002 .
WWW 2007 / Track : Pervasive Web and MobilityMay 8 12 , 2007 . Banff , Alberta , Canada380
