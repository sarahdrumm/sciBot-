2012 IEEE 12th International Conference on Data Mining 2012 IEEE 12th International Conference on Data Mining
Active Evaluation of Classifiers on Large Datasets
Namit Katariya
IIT Bombay namitk@cseiitbacin
Arun Iyer*
Yahoo! Research aruniyer@cseiitbacin
Sunita Sarawagi
IIT Bombay sunita@cseiitbacin
Abstract—The goal of this work is to estimate the accuracy of a classifier on a large unlabeled dataset based on a small labeled set and a human labeler . We seek to estimate accuracy and select instances for labeling in a loop via a continuously refined stratified sampling strategy . For stratifying data we develop a novel strategy of learning r bit hash functions to preserve similarity in accuracy values . We show that our algorithm provides better accuracy estimates than existing methods for learning distance preserving hash functions . Experiments on a wide spectrum of real datasets show that our estimates achieve between 15 % and 62 % relative reduction in error compared to existing approaches . We show how to perform stratified sampling on unlabeled data that is so large that in an interactive setting even a single sequential scan is impractical . We present an optimal algorithm for performing importance sampling on a static index over the data that achieves close to exact estimates while reading three orders of magnitude less data .
Keywords Accuracy estimation , active evaluation , hash functions . learning
I . INTRODUCTION
In this paper we address the problem of evaluating the accuracy of a classifier C(x ) when deployed on a very large unlabeled dataset D . We are given a small labeled test set L . We consider situations where D is so large in comparison to L that the average accuracy over L is unlikely to be a reliable estimate of the classifier ’s real performance on the deployment data D . We present a method for more reliable accuracy estimates of C(x ) on D using the given labeled set L , and a method for selecting additional instances to be labeled to further refine the estimate .
This problem has applications in many modern systems that rely on the output of imperfect classifiers . Consider a concrete example . A search engine needs to deploy a classifier C(x ) to label if a Web page x is a homepage . Since the label is used to decide on the rank of a web page in a search result , it is important to calibrate reliably the accuracy of the classifier on a general web corpus D . Typically , editors hand pick a set of instances L , label them as homepage or not , and measure the accuracy of C(x ) on L . This method is likely to be flawed because the Web is so diverse and huge that it is difficult for humans to select a representative set while keeping L small . Other examples of the use of classifiers on large datasets include , classifying
* Work performed as an external PhD student at IITB
1550 4786/12 $26.00 © 2012 IEEE 1550 4786/12 $26.00 © 2012 IEEE DOI 101109/ICDM2012161 DOI 101109/ICDM2012161
895 329
In spite of the practical text snippets to an entity node in Wikipedia ( 1 ) , classifying Web table columns to semantic types in an Ontology ( 2 ) , and classifying the polarity of emotion in a tweet ( 3 ) . All these examples share the property that a classifier is deployed on a very large dataset most of which is available in unlabeled form at the time of evaluating the classifier , and labeled data is scarce because human effort is required for labeling data . importance of the problem , existing work on the topic is surprisingly limited . The standard practice in classifier evaluation is to use a fixed labeled test set to evaluate a classifier which is then deployed for predictions on ’future’ instances . Can we improve this process when the deployment set is available in unlabeled form ? The use of unlabeled data for learning a classifier has received a lot of attention in the context of topics like active learning , semi supervised , and transductive learning . However , the task of learning a classifier is very different from the task of evaluating a given classifier . The only existing work on selecting instances for evaluating a classifier are : ( 4 ) which presents a new proposal distribution for sampling , and ( 5 ; 6 ) which use stratified sampling ( 7 ) . Both these methods assume that the classifier C(x ) is probabilistic and their selection is based solely on the classifier ’s Pr(y|x ) scores . Our focus is more general . We wish to evaluate the accuracy of any classifier : be it a set of manually developed rules , a learned generative model with uncalibrated Pr(y|x ) scores , or a non probabilistic method like a decision tree — none of these can be handled by the methods in ( 4 ; 5 ; 6 ) . Our method is founded on the principles of stratified sampling like in ( 5 ; 6 ) but with important differences . Instead of fixing a stratification , we learn a stratification in terms of a generic feature space and the strategy evolves as more data gets labeled . For stratifying data , we use hashing instead of conventional clustering based approaches as the latter do not scale well . We design a novel algorithm for learning hash functions that cluster instances with similar accuracies more effectively than existing learning techniques for distance preserving hashing(8 ; 9 ; 10 ; 11 ; 12 ) . Also , none of the existing estimation methods consider the case where the dataset D is so large that even a single sequential scan over it will take hours . Our method is designed to perform accuracy estimation and instance selection on D which can only be accessed via an index .
Our experiments cover an interesting range of classifica tion tasks : table annotation , homepage and spam scoring of Web pages , and DNA classification ; and range in size from 0.3 million to 50 million instances . We achieve upto 62 % reduction in relative error over existing methods , and are able to match within 0.5 % the estimates of exact methods based on full scan while sampling just 2500 instances from indexed D .
The rest of the paper is organized as follows . We present a formal statement of our problem and discuss existing approaches in Section II . In Section III we present an overview of our framework for active accuracy estimation . In Section IV we present a novel algorithm for using the labeled data to learn a stratification strategy . We empirically evaluate our method and contrast with existing techniques in Section V . In Section VI we present how we scale our algorithm to the case where the unlabeled data D is very large .
II . PROBLEM STATEMENT AND EXISTING SOLUTIONS We present a formal description of our problem and discuss existing approaches for tackling it . A . Problem statement Given a classifier C(x ) , a large unlabeled dataset D = x1 , . . . , xN , a function a(yi , C(xi ) ) .→ R that measures the accuracy of prediction C(xi ) when the ( unknown ) true label is yi , we define the true accuracy μ of C over D as
.N
1
μ =
Z(D , C ) i=1 a(yi , C(xi ) )
( 1 ) where Z(D , C ) is any normalizer that can be calculated using only C and D and is independent of the unknown yi . Many popular accuracy measures such as 0/1 accuracy , square error , and precision can be expressed in this format through appropriate choice of the a( ) and Z( ) functions . We use ai for a(yi , C(xi ) ) when the context is clear and overload N for Z(D , C ) because it is the most common case and it simplifies presentation . Our implementation handles the general case and our experiments are over three kinds of measures . We are given an initial labeled test set L that may or may not be representative of D . Let n ' N denote the size of L . We are allowed to augment L with additional instances selected sequentially from D and labeled by a human oracle . Our problem is to select additional instances to be labeled from D and provide an estimate ˆμ of the true quantity μ such that for a fixed number of additional labels , we minimize the square error ( μ − ˆμ)2 .
We next present existing approaches for solving this task .
B . Simple baseline
A baseline method for selecting instances for labeling and adding to L is sampling uniformly randomly from D . Thereafter , the accuracy of the classifier is measured on L using the standard method of averaging as :
.
ˆμR =
1 n ai i∈L
( 2 )
896330
The square error of this estimate can be easily analyzed for the case where the entire L is chosen uniformly randomly from D . Since the choice of L is randomized , we analyze the expectation of the square error ( μ− ˆμR)2 over different uniform samples L of size n . We denote this quantity as Err(ˆμR ) . As shown in ( 7 ) and many other text books on n where σ2 denotes the statistical sampling , its value is σ variance of the ai values over D . Thus , the error of the estimate is more when the accuracy values exhibit high variance in D , and the error reduces inversely with the size of the labeled set . We next discuss two techniques for achieving smaller error for the same number of additional instances labeled .
2
C . Stratified sampling
A simple idea to reduce the estimation error is to stratify D into strata D1 , . . . , DB such that within each stratum the true variance in ai is likely to be small . Then perform stratified sampling ( 7 ) where we first select a stratum based on a policy to be discussed later in Section III and within each stratum select instances uniformly randomly . Let Lb be the set of labeled instances sampled in stratum b , nb be the size of Lb , and ˆμb be the estimated accuracy measured over Lb using straight averaging as in Equation 2 . The estimated accuracy is a weighted sum of accuracy in each stratum : ai b=1 pb b=1 fi b p2 b
ˆμS = pb ˆμb =
( 3 ) where pb denotes the fraction of instances in stratum Db . Unlike the estimator ˆμR that is calculated on the basis of only the labeled data L , the estimator ˆμS depends on both the labeled data L ( for estimating ˆμb ) and the unlabeled data D ( for pb ) . i∈Lb
2 σ b nb
The expected square error Err(ˆμS ) of this estimate can . This means that if we can be shown ( 7 ) to be somehow achieve perfect stratification such that within each stratum all instances have the same accuracy , just one sample from each stratum is sufficient to guarantee zero error! The other extreme is where the variance of all stratum are the same — in this case stratified sampling achieves the same error as uniform sampling when nb ∝ pb . In all other cases , the expected error of ˆμS is lower than ˆμR ( 7 ) .
Therefore , the key to the success of this estimate is a stratification strategy that puts instances with similar accuracy values in the same stratum . Two recently proposed methods ( 5 ; 6 ) attempt to achieve this by assuming that C(x ) is probabilistic and its confidence score ˆp(y|x ) is correlated with the accuracy of prediction y on x . They use the prediction scores to stratify the data D into equal sized bins . Thus , the goodness of this method totally hinges on the reliability of these scores .
.B
.B
.
1 nb
D . Proposal distribution
Another independently developed technique for selecting instances is based on using a proposal distribution q(x ) for sampling instances ( 4 ) . The accuracy over an L sampled via q(x ) is estimated as : ˆμq =
1fi
.
( 4 )
1 i∈L q(xi ) i∈L ai q(xi ) q(x ) ∝
Like in ( 5 ; 6 ) , the classifier C(x ) is assumed to be probabilistic and capable of outputting reliable values for ˆp(y|x ) . These scores are used to define q(x ) as :
'ff ( a(y , C(x ) ) − μC)2 ˆp(y|x)dy fi
1 N x∈D
( 5 ) a(y , C(x))ˆp(y|x)dy . Although where μC is the formula looks complicated , it can be easily derived by solving for the value of q(x ) that minimizes the expected square error between ˆμq and μ , and then substituting ˆp(y|x ) for the unknown true distribution Pr(y|x ) and μC for the unknown true accuracy μ ( 4 ) . Thus , the method is crucially dependent on the goodness of these approximations .
E . Limitations of existing work
We highlight two limitations of the above two methods that we seek to remove in our work .
First , since our goal is to evaluate arbitrary classifiers , we want a method that does not so centrally depend on a single ˆp(y|x ) score output by the classifier . As mentioned earlier , our classifier might be a manually developed script , or a non probabilistic method like decision trees . Even for trained probabilistic classifiers , a recent study ( 13 ) has shown that most classifier families do not provide well calibrated scores . Second , we are aware of no existing methods for handling very large amounts of unlabeled data in the evaluation task . Even methods that depend on a few sequential scans of the whole data are not practical on such datasets . Our method can use any available index partition of the unlabeled data to avoid sequential scans as we elaborate in Section VI .
III . OUR APPROACH
The basis of our method is stratified sampling described in Section II C . The key steps in this method are : choose a stratification strategy , use that to stratify the unlabeled data D and labeled data L , estimate accuracy ˆμS using formula 3 on the stratified data , perform stratified sampling to select more examples to label , label them , and add to L . This process is continued in a loop .
The first challenge in the above process is choosing a stratification strategy . As discussed earlier this approach is better than random sampling only if the instances within a stratum are homogeneous . Existing adaptation ( 5 ; 6 ) of this process for the accuracy estimation problem , have assumed a fixed stratification of data based on the classifier ’s ˆp(y|x ) values . In contrast , we learn a stratification strategy from L and our stratification strategy constantly evolves as more labeled data gets added . The second challenge is performing these steps when D is so large that stratifying the entire D is not practical . In the first part of the paper we concentrate on learning the stratification strategy and in Section VI we discuss how to manage the scalability challenge .
Algorithm 1 outlines the overall process . We next de scribe each of the steps in the algorithm . Algorithm 1 Loop for active accuracy estimation 1 : Input L , D , k , R , B 2 : repeat 3 :
Learn stratification function h(f|w1r ) .→ [ 1 . . . B ] if ≥ R instances added to L since last training . Stratify L via h( . ) & compute {ˆμb : 1 ≤ b ≤ B} Stratify D via h( . ) & compute {pb : 1 ≤ b ≤ B} Display accuracy estimates : ˆμS = fi of k instances from D Stratified sample set L For each xi ∈ L
4 : 5 : 6 : 7 : fi , get label yi , and add ( xi , yi ) to L . 8 : 9 : until accuracy ˆμS not converged and labeler not bored . b pb ˆμb . fi
10 : Return ˆμS
Learning the stratification function : First , we use L to learn to stratify D into B disjoint parts such that instances within a stratum have similar accuracy values . We learn the stratification in terms of a feature vector F(x , C(x ) ) defined over an instance x and the result of applying the classifier on x . Let d denote the number of features in this feature vector . A component feature Fj(x , C(x ) ) ( 1 ≤ j ≤ d ) is a real value representing either one of the original attributes xj input to the classifier , or any score output by the classifier ( for example , its ˆp(y|x ) value if available ) , or the predicted label itself or any other user designed property like the fraction of missing attributes in x and the prior probability of the predicted label . In the rest of the paper we will use fi to denote the feature vector F(xi , C(xi) ) .
Once we transform each instance to a point in a d dimensional space , our problem can be recast as follows . Given N points in d dimensional space , where a small subset of size n of them are associated with an accuracy value ai , partition the N points into B parts such that points in the same part are likely to have similar accuracy values .
A standard technique to perform such partitioning is supervised data clustering . The n labeled points are used to learn a distance function ( 14 ; 15 ) on the d features so that points with similar accuracy values have small distances in the f space . This learned distance function is used to cluster the N points into B parts using one of the many existing clustering algorithms . However , such clustering approaches do not scale well and in our setting , not only is N large , but as we get more labeled points , the distance function learning and clustering have to be repeated .
We instead propose to learn a hashing function using L such that we can independently hash each instance in D to one of B strata . This problem has recently gotten prominence ( 8 ; 9 ; 10 ; 11 ) in machine learning , because of the growing need to handle Web scale data . Following the practice in this literature , we model our hash function as a
897331 r . concatenation of r = log B hash functions h1 , . . . , hr such that each hj(fi ) maps an instance i to 0 or 1 . A popular choice for hj(f ) is sign(wj.f ) that maps an instance based on the side1 of the hyperplane wj on which it lies in Rd . Let w1r denote the r hyperplanes w1 , . . . , wr . Our proposed stratification function h(fi|w1r ) .→ [ 1 . . . B ] is then h(fi|w1r ) =
2j−1sign(wj.fi ) j=1
( 6 ) where sign(x ) = 0 if x ≤ 0 and 1 otherwise . We will often drop w1r from h if the context makes it clear . Our task now reduces to learning the parameters w1 , . . . , wr such that instances with similar accuracy values have the same h value . Section IV discusses how we solve this problem . Estimating accuracy of a stratum : In step 4 of the algorithm we use the labeled data to assign an estimate ˆμb of the true accuracy μb in each stratum b . The straightforward estimate based on averaging accuracy of instances in Lb is prone to overfitting . We therefore smooth these estimates based on labeled data in neighboring buckets . Let fi ) denote the Hamming distance between the binary Ham(b , b fi . The contribution of neighboring representations of b and b buckets to the smoothing constant diminishes exponentially with the Hamming distance with the neighbor . Let β denote b denotes the number the exponential decay constant . Let n of instances with ai = 1 in b , Our smoothed estimate for the accuracy of b is
+ fi fi fi fi
In the above equation , γ is another parameter that can be used to control the relative importance of the observed counts over the smoothing constant . We used γ = 5 , and β = 0.1 for our experiments . The method reduces to Lidstone smoothing when β = 1 . A second technique we use to guard against over fitting is to disjoint partition L two ways . Use one part for learning h( ) and the second part for estimating μb within a stratum of h( ) . Estimating weight of each stratum : Next , we need to find the fraction pb of instances from D that lie in each stratum b . For this we need to hash partition D as per the fi learned function h(f ) . With a single sequential pass over the data we can assign each instance in D to a bucket b i∈D[[h(fi ) = b] ] . Later in Section VI and compute pb = 1 when we present techniques for scaling our algorithm we will discuss how this step can be performed without a full scan on D . Selecting instances for labeling : The optimal method of sampling stratified data is to first select a bucket b with probability proportional to pbˆσb and then select an instance
N
1Without loss of generality we assume that the feature space includes a constant feature so that we do not need to separately model the bias .
ˆμb =
+ b + γ n nb + γ r d=1 βd r d=1 βd
.:Ham(b,b b .:Ham(b,b b
+ . .)=d n b . .)=d nb
( 7 ) b where E(S ) = uniformly randomly within b ( 7 ) . Once D has been hash partitioned via the step above , the implementation of such a sampling is easy . Later , in Section VI we show how to perform this sampling without stratifying the entire D .
The above operations are performed in a loop until the accuracy converges or until the labeling budget is exhausted .
IV . LEARNING HYPERPLANES
Our goal is to learn the r hyperplanes w1 , . . . , wr of d dimensions each , used to parameterize our stratification function h(f ) as per Equation 6 . We first characterize the optimal objective for finding w1 . . . wr , then in Section IV A describe existing algorithms for solving such objectives , and present our algorithm in Section IV B . fi b p2
The optimal w1r is one which when used to stratify the labeled data L and unlabeled data D minimizes the expected square error of the estimated accuracy ˆμS . From Section II C where pb is the fraction we know that this error is of D for which h(f|w1r ) = b , Lb is the subset of L for which h(f|w1r ) = b , ˆσ 2 b is the estimated variance over Lb , and nb is the size of Lb . For simplicity we assume that L and D distribute in similar proportions over the strata , that is , nb ∝ pb . This allows us to express the error in terms of 2 b . Further substituting the labeled data L alone as n2 ˆσ nb 2 for the value of variance ˆσ b , and a little bit of manipulation we get the optimal values of w1r as E({i ∈ L : h(fi|w1r ) = b} )
1r = argminw1r
. fi
ˆσ2 b nb b wopt b
. i,j∈S
( ai − aj)2
|S|
( 8 )
This expresses the objective in terms of the sum of square differences in accuracy of pairs of instances within a stratum . The main challenge in optimizing the objective is that the sign function in h( ) is non differentiable in w1r Even if we upper bound the sign function with a smooth convex function following the practice of classification algorithms , the objective remains non convex because multiple hyperplanes have to be learned . However , by expressing the objective in this term we can relate it to the recent exciting research on learning distance preserving hash functions ( 8 ; 9 ; 10 ; 11 ) . We will review the main techniques that have been developed to tackle such objectives in this literature .
A . Review : Hash Function Learning The existing techniques are all based on using different smooth relaxations of the sign(· ) function and different strategies for incrementally solving the resultant smooth , non convex objective .
We first discuss a large margin technique proposed recently in ( 12 ) . This technique uses a hinge like loss function to penalize large Hamming distances between similar points and small Hamming distances between dissimilar points . The corresponding objective function is smoothed by a
898332 piece wise linear upper bound , much like in max margin structured learning ( 16 ) . The resultant smooth , non convex objective is minimized using stochastic subgradient descent . The technique is appealing , but when we used it for our problem of minimizing square distance between accuracies of instances within a bucket , we got poor results . The local minimas were so bad that the stochastic gradient optimizer could not progress beyond the initial step with both random and all zero initialization of the w values .
We next turn to methods that attempt to learn the hash hyperplanes through optimization strategies with better guarantee of progress . In ( 10 ) the hash function is specified in a kernel form and the parameters to be learned are the coefficients of these kernels . The objective continues to be non smooth and non convex . The paper proposes to solve it in a co ordinate descent loop where each step optimally solves for a single parameter keeping all others fixed . The sequential hyperplane learning method of ( 11 ) smooths the sign function with signed magnitude . The resultant objective is solved by sequentially updating one hyperplane at a time while keeping the others fixed . Under their relaxation , a single hyperplane can be found optimally by the first Eigen vector of a transformed data matrix . The paper then proposes to re weight misclassified pairs from previously learned hyperplanes when learning the current hyperplane .
Our method also follows the policy of updating a single hyperplane at a time as in ( 11 ) , but we use a very different strategy for smoothing the objective . All existing hash function learning literature seek to approximate either a Euclidean or a black box distance measure . Our distance measure is over a scalar accuracy value , which in the common case takes 0/1 values . We exploit this common case to design a relaxation that is both more accurate and leads to a more efficient algorithm .
We next present our algorithm for learning hash functions that we call Signed Logistic Hashing .
B . Signed Logistic Hashing
We start with an initial set of hyperplanes , and update a single hyperplane at a time on a re weighted set of instances until a local minima is reached . We first present a novel algorithm for updating a single hyperplane and then present our re weighting strategies .
Let [ wt
1 , . . . , wt r ] denote the hyperplanes at time t when we are trying to improve wt j . Based on the fixed value of the remaining hyperplanes , the training data L is hard B/2 . Using wj , our partitioned into B/2 groups Lt 1 , . . . , Lt goal is to bisect each group Lt k into two parts so that the sum of the error over the new B buckets is minimized . Accordingly we can rewrite objective 8 keeping all but wj fixed as :
E({i ∈ Lt k : sign(w · fi ) = s} )
( 9 )
899333
B/2 .
. k=1 s=0,1 wopt j = min w
For solving this objective we consider the common case where accuracy values are binary . For binary values of ais , E(S ) = |S|fS(1 − fS ) where fS denotes the fraction of labeled instances i in S with ai = 1 . Even for binary values , the objective is non differentiable and non convex . However , for this case , we propose a tractable upper bound . Upper bounding objective 9 : k ) denote the part of objective 9 within the first summation over k . For ease of notation we rewrite this term as
Let E(w , Lt k ) = n1f1(1 − f1 ) + n0f0(1 − f0 ) E(w , Lt ( 10 ) where ns denotes the number of instances in Lt k with sign(w · fi ) = s and fs denotes the fraction of these with a = 1 . We next present a relaxation of the objective that allows us to harness the mature area of learning binary classifiers under the loss regularization framework . Let loss(ai , w · fi ) denote a convex upper bound to the 0/1 loss [ [sign(w · fi ) )= ai ] ] where [ [z ] ] is 1 if z is true and 0 otherwise . Examples of such loss functions include the popular Hinge loss and Logistic loss . Theorem 4.1 E(w , Lk ) ≤ min( loss(1−ai , w·fi ) , loss(ai , w·fi ) )
.
. i∈Lk i∈Lk
Proof : E(w , Lk ) = n1f1(1 − f1 ) + n0f0(1 − f0 ) ≤ min(n1f1 + n0(1 − f0 ) , n1(1 − f1 ) + n0f0 ) Consider the first term in the min . The number of instances in i ∈ Lk with a = 1 and sign(w · fi ) = 1 is n1f1 and with a = 0 and sign(w · fi ) = 0 is n0(1 − f0 ) . Their sum is the 0/1 loss [ [sign(w · fi ) )= 1 − ai ] ] which in turn is less than loss(1 − ai , w · fi ) . Similarly we can prove that the second term in the min is less than loss(ai , w · fi ) . The above theorem converts a non smooth objective to a minimum of two convex objectives . Also , it converts the objective to a form that is additive over single instances rather than over pairs of instances . This provides significant benefits in terms of both running time and memory requirements over existing hash learning methods . We next elaborate on how we solve our relaxed objective . Optimizing the upperbound : Intuitively , we are claiming that within each group our goal is to use w to partition the data into a positive and negative side . If we had just one group it would not matter whether we use a = 1 to denote the positive or negative side . But since we have multiple groups , we need to allow each group to choose the side which it wants to call positive . Our overall objective now is : loss(ai , w · fi ) ) ( 11 ) We solve the above objective using a EM like algorithm . If for each group k , we knew zk a function on a that is either loss(1 − ai , w · fi ) ,
B/2 .
.
. min w i∈Lk i∈Lk min( k=1
.B/2
. the identity function ( Pos(a ) = a ) or an inverting function ( Neg(a ) = 1 − a ) , we can solve this objective loss(zk(ai ) , w · fi ) k=1 i∈Lk min w
( 12 ) using standard classification techniques . So , we start with some initial guess of zk = Pos and find a w . For a fixed w , we find the optimal zk for each group that minimizes loss of that group , and continue until convergence to a local minima as shown in Algorithm 2 . Algorithm 2 Signed Logistic Hashing
Input L , r 1 ··· w0 w0 r = Initial hyperplanes while estimated error reduces do for j = 1 to r do ui = calculated weight of instance i ( Section IV B ) . zk =Pos for all B/2 groups of L while objective improves do fi wj = argminw
B/2 k=1 i∈Lk uiloss(zk(ai ) , w·fi ) lossk(z(ai ) , wj · fi ) fi fi zk = argminz=Pos,Neg i∈Lk
Initial hyperplanes : The initial set of hyperplanes are chosen via a hierarchical partitioning of the data as follows . Initially , the entire data is in a single group . We find the hyperplane that partitions the group so as to minimize loss( ) on the group . We then repeat the following in a loop B − 1 times . Find the largest m groups and for each group g invoke the binary classifier to minimize loss( ) on g . Pick the best of these m hyperplanes where best is calculated by summing error over all current buckets in the data . Weighting instances : We need to ensure that r hyperplanes are as different from each other as possible . We borrow ideas from boosting for re weighting input instances to achieve this effect . When learning hyperplane wj we reweight instances in each group Lk as follows . Let minor(Lk ) be the minority class in Lk and ek denote the fraction of instances in i ∈ Lk for which ai = minor(Lk ) . We interpret ek as the error incurred on Lk from the previous set of hyperplanes that we seek to correct via wj . As in Adaboost , we assign weights ui to each instance i ∈ Lk as if ai = minor(Lk ) else ui = 1 . Since ek ≤ 1 ui = 1−ek 2 by definition , this weighs the minority instances higher than majority . Our strategy for re weighting is similar in spirit to re weightings used in ( 11 ; 9 ) but one crucial difference is that we re weight instances and not instance pairs . ek
In summary , we have developed an algorithm for hash function learning that solves for a single hyperplane at a time using an algorithm that is a small extension of the classification algorithms used in a loss regularization framework . Although in this section we have restricted to 0/1 values for accuracy , similar reductions to regression models can be used to handle arbitrary real valued accuracies . We defer the details to an extended version of the paper .
V . EXPERIMENTS
We first present an overall comparison of our active accuracy estimation method with other methods of selecting instances and estimating accuracy discussed in Section II . We then compare with different data stratification strategies discussed in Section IV A .
We selected the following set of five datasets covering a wide spectrum of real life classification tasks . TableAnnote . Our first dataset is created out of a classification task to annotate columns of noisy Web tables to one of the 250 thousand type nodes in an Ontology ( 17 ) . Our dataset ( D ) consists of 12 million Web table columns , and a seed labeled set ( L ) of 541 table columns obtained from authors of ( 17 ) . For our experiments in this paper , we needed true labels on all 12 million columns , which was impractical . Therefore , we setup our evaluation task as that of comparing two algorithms : one based on the state of art graphical model algorithm of ( 17 ) and called these true label , and second based on a ’classifier’ that assigns a predicted label based on majority support . We compared these on 0/1 accuracy . The accuracy on the seed set was 56.4 % whereas the accuracy of D was 165 % This shows the significant editorial bias in selecting the seed set . F(x , C ) consisted of 42 features including numerical properties of the column like percentage of text/number cells , size , average width , and the type node in the Ontology , and other features mentioned in ( 17 ) . The majority rule classifier had no explicit confidence score . To compare with score based methods , we trained prediction scores using a Sigmoid function with the 0/1 accuracy values as the class label and all 42 features as input . Spam . This dataset from the LibSVM dataset collection2 is for classifying Web pages as spam or not . The data consists of 350,000 instances and 16 million features , which we projected using random hyperplanes to 1000 following ( 18 ) . This dataset included true labels . The classifier evaluated was a linear SVM trained on 5000 instances on LibSVM with default parameters , and class weights inversely proportional to the skew of the two classes in the train set . In this data , a separate seed set was not naturally available . So , we created one by simulating a committee based active learning process . We created a committee of k SVMs . ( We chose k = 7 ) by sampling a different labeled dataset for training each SVM . We then sampled a seed set of 5000 instances by weighting each instance by the disagreement in predictions by the k SVMs . Since the dataset was highly skewed , we evaluated a weighted accuracy measure on the dataset with the weights of 0.1 and 0.9 for predicted majority class and predicted minority class instances respectively . The classifier scores used were the probability scores output by LibSVM . DNA . This dataset from the Pascal Large Scale Learning
2http://wwwcsientuedutw/ cjlin/libsvmtools/datasets/binary.html#webspam
900334
ϯϬй
Ϯϱй
ϮϬй
ϭϱй
ϭϬй
ϱй
Ϭй
,ŽŵĞ'ƌŽƵŶĚ
ϱϬϬ
ϭϬϬϬ
ϭϱϬϬ ϭϮй
ϭϬй
ϴй
ϲй
ϰй
Ϯй
Ϭй dĂďůĞ ŶŶŽƚĞ
^ĐŽƌĞ ŝŶƐ ZĂŶĚŽŵ ^ůŽŐŝƐƚŝĐ WƌŽƉ^ĂŵƉůĞ
ϰϱй ϰϬй ϯϱй ϯϬй Ϯϱй ϮϬй ϭϱй ϭϬй ϱй Ϭй
^ƉĂŵ
^ĐŽƌĞ ŝŶƐ ZĂŶĚŽŵ ^ůŽŐŝƐƚŝĐ WƌŽƉ^ĂŵƉůĞ
ϳй ϲй ϱй ϰй ϯй Ϯй ϭй Ϭй
^ĐŽƌĞ ŝŶƐ ZĂŶĚŽŵ ^ůŽŐŝƐƚŝĐ WƌŽƉ^ĂŵƉůĞ
ϮϬϬϬ
ϮϱϬϬ
,ŽŵĞWƌĞĚŝĐƚĞĚ
ϮϬϬϬ
E
ϮϱϬϬ
ϱϬϬ
ϭϬϬϬ
ϭϱϬϬ
ϮϬϬϬ
ϮϱϬϬ
^ĐŽƌĞ ŝŶƐ ZĂŶĚŽŵ ^ůŽŐŝƐƚŝĐ WƌŽƉ^ĂŵƉůĞ
ϱϬϬ
ϭϬϬϬ ^ĐŽƌĞ ŝŶƐ ZĂŶĚŽŵ ^ůŽŐŝƐƚŝĐ WƌŽƉ^ĂŵƉůĞ
ϭϱϬϬ ϳй ϲй ϱй ϰй ϯй Ϯй ϭй Ϭй
ϱϬϬ
ϭϱϬϬ
ϮϱϬϬ
ϯϱϬϬ
ϰϱϬϬ
ϯϱϬϬϬ
ϯϱϱϬϬ
ϯϲϬϬϬ
ϯϲϱϬϬ
ϯϳϬϬϬ
Figure 1 : Absolute error ( on the Y axis ) of different estimation algorithms against increasing number of labeled instances ( on the X axis ) . The five graphs correspond to the five different datasets as shown in the graph ’s title .
Challenge3 is for a binary DNA classification task . The data consists of 50 million instances and 800 binary features . Other details about the classifier , the seed selection , accuracy measure , and scores used are the same as that of the Spam dataset ; only the sizes of training and seed data are 100K instances each . HomeGround and HomePredicted . The source of these datasets is Yahoo!4 . Each instance is a ( entity , web page ) tuple and the classifier has to decide if the web page was a homepage for the entity . F(x , C ) consisted of 66 numerical features which includes ranking features , entity match features and static web page features . The entire data consisted of 14 million instances but an editorial process selected and assigned labels only to 22 thousand of them . The company used a gradient boosted decision tree ( GBDT ) classifier for the task . We created two datasets out of this source : the first called HomeGround was restricted to the 22 thousand with editorial label as true labels and GBDT labels as predicted , the second called HomePredicted over all 14 million with GBDT labels as true labels and the output of a trained linear SVM as predicted labels . For this task precision is more important than accuracy , so in HomeGround only instances with predicted label true were relevant . The final dataset had 514 points in training and 1060 in test . For HomePrediction , we retained all 14 million instances for scalability experiments , therefore we measured weighted accuracy as in Spam . This measure can be treated as an approximation to precision because it gives more importance to instances with predicted label 1 ( minority class ) .
In Table I we present a summary of the five datasets .
3ftp://largescalemltu berlinde/largescale/dna/ 4All experiments on these datasets were performed by A . Iyer at Yahoo!
Dataset
TableAnnote Spam DNA HomeGround HomePredicted
#
Features 42 1000 800 66 66
Seed(L ) 541 5000 100,000 514 8658
Size
Unlabeled(D ) 11,954,983 350,000 50,000,000 1060 13,951,053
Accuracy ( % )
Seed(L ) 56.4 86.4 72.2 50.4 83.2
True(D ) 16.5 93.2 77.9 32.8 93.9
Table I : Summary of Datasets
A . Overall comparison
We compare our overall algorithm of active evaluation in Section III ( Slogistic ) with existing alternatives that we discussed in Section II including , 1 ) Random sampling ( Random ) 2 ) Proposal sampling as in ( 4 ) ( PropSample ) 3 ) Stratified sampling with scores as in ( 5 ; 6 ) ( ScoreBins ) All numbers are averaged over 10 random seeds and we compare different methods on the absolute difference between the estimated and true accuracy . We set the default number of strata to 16 , that is , r = 4 .
In Figure 1 we show the absolute difference in accuracy estimates with increasing number of instances labeled . We select k = 5 instances in one round , and restratify after 100 labels ( R = 100 ) . Every dot in the figure denotes the error in estimated accuracy after the retraining . These graphs help us make the following important observations :
1 ) The estimation error reduces significantly as we select more instances from D and add to the labeled set L . For some cases , example TableAnnote , the difference is quite substantial going from 15 % to less than 1 % after adding 1000 selected instances . This establishes the practical importance of the problem we are addressing . 2 ) The best results are obtained with Slogistic . Even the starting seed set error is lowest for Slogistic proving that the stratified estimate ˆμS that uses both L and D is more accurate than simple averaging using only L .
901335
3 ) While stratified sampling based on scores ( ScoreBins ) performs better than non stratified methods like Random and PropSample , ScoreBins is much worse than Slogistic . This establishes the superiority of featurebased learned stratification over classifier score based stratification . The PropSample method is even worse affected by unreliable scores because its accuracy estimate does not involve D unlike the ScoreBins method . 4 ) Even when the initial accuracies are the same , as in the HomePredicted dataset , with more labeled data Slogistic performs much better than ScoreBins . This establishes the importance of evolving the stratification with increasing labeled data , instead of keeping it fixed as in the ScoreBins method .
B . Evaluating stratification methods
We next compare our Signed Logistic algorithm ( Slogistic hash ) for learning hyperplanes with two state ofart alternatives discussed in Section IV A : the Sequential projection method of ( 11 ) ( SeqProj hash ) and the Kernelbased approach of ( 10 ) ( BRE hash ) . For reference , we also compare with simple averaging ( NoStratify ) and ScoreBins . Figure 2 plots the absolute difference between the true accuracy and estimated accuracy for different number of hash bits and labeled data sizes . The experiments in this section helped us make the following observations :
1 ) On all datasets and all combinations of training sizes and hash bits , hyperplanes learned via the Slogistic algorithm provide much better stratification than SeqProj hash . This shows that our relaxation based on the logistic function that exploits the special nature of 0/1 accuracies is more effective than the signed magnitude relaxation of SeqProj hash .
2 ) BRE hash is worse than SeqProj hash ; this validates the conclusions made in ( 11 ) , and establishes that the general strategy of solving for a single hyperplane at a time is better than co ordinate ascent methods .
3 ) Although we do not separately plot running times here due to lack of space , we found that Slogistic was on average 2 times faster than SeqProj hash and 3 times faster than BRE Hash . The main reason is that the objectives in these methods are defined in terms of pairs of points unlike ours . The pairwise objective also blows up the memory requirements of these methods ; both of which could not scale to our experiments on the DNA dataset with more than 40000 points .
VI . SCALING UP OUR ALGORITHM
In this section we describe how we scale our entire accuracy estimation process ( Algorithm 1 ) when the unlabeled data D is very large . Since labeled data is expensive to obtain , we assume that L is small and our learning algorithm for h(f ) is not a bottleneck . Unlabeled data is accessed in two steps of Algorithm 1 : First , in step 5 for calculating the fraction pb of instances in each bucket b which in turn are used to estimate accuracy in step 6 . Second , in step 7 for selecting the k instances to be labeled . An exact method for these steps requires a sequential scan over D every time h(f ) is retrained . An easy option is to replace D with a smaller uniform sample of D . We will show that this option is suboptimal compared to the methods we propose here .
We assume that the unlabeled data D is indexed so as to partition the data into disjoint parts D1 , . . . , DU where for each partition u we can ( a ) get its size Nu in terms of number of instances , and ( b ) generate a uniform random sample of instances within the partition . All indexing strategies that we are aware of can support these capabilities easily . In Sections VI A and VI B we show how these capabilities are exploited to intelligently sample from D , and in Section VI C we show empirically how effective they are in approximating the exact method based on full scan .
A . Assigning bucket weights
ˆμS =
.
We discuss how to sample D so as to accurately estimate ˆμS defined in Equation 3 . With a slight rewrite of that equation , we express ˆμS as 1 N
( 13 ) Our goal is to approximate ˆμS without making a full pass of D , which can be extremely large . If we use a uniform random sample U from D to get an estimate ˆμSU = the expected square difference between − ˆμS)2/m where i∈U ˆμh(fi)/m ,
ˆμSU and ˆμS can be shown to be m is the size of sample U .
ˆμh(fi ) i∈D b pb(ˆμb fi fi
Is it possible to perform better than uniform random sampling given the limited ways in which we can access D ? Instead of a uniform sample , suppose we get a sample Q from a proposal distribution q(i ) for i ∈ D and estimate accuracy as :
⎛ ⎝ 1
. m i∈Q
⎞ ⎠
ˆμh(fi ) q(i )
ˆμSq =
1 N
( 14 )
Without any restriction on the way unlabeled data can be sampled , an optimal choice is q(i ) ∝ ˆμh(fi ) . With this choice , the error between ˆμSq and ˆμS is zero . But , performing this sampling is impossible without first assigning each i ∈ D to a bucket of h(. ) , which is what we are trying to avoid in the first place . The only q(i ) we are allowed is the one which assigns the same probability to all instances i within a index partition Du of D . We next provide an optimal choice of such a q(i ) . Theorem 6.1 When q(i ) is restricted so that all instances within a partition Du are sampled with the same probability qu , the expected squared error between ˆμSq and ˆμS Eq ff ( ˆμSq − ˆμS)2 fi
' . is minimized when bp(b|u ) qu ∝ 2 ˆμ
( 15 ) b
902336
EŽ^ƚƌĂƚŝĨǇ
^ĐŽƌĞ ŝŶƐ
^ĞƋWƌŽũͺŚĂƐŚ
Z ͺŚĂƐŚ
^ůŽŐŝƐƚŝĐͺŚĂƐŚ dĂďůĞ ŶŶŽƚĞ
EŽ^ƚƌĂƚŝĨǇ
ϱϬй ϰϱй ϰϬй ϯϱй ϯϬй Ϯϱй ϮϬй ϮϬй ϭϱй ϭϬй ϱй Ϭй
ƌ Ž ƌ ƌ Ğ Ğ ƌ Ă Ƶ Ƌ ^
^ĐŽƌĞ ŝŶƐ
^ĞƋWƌŽũͺŚĂƐŚ
Z ͺŚĂƐŚ
^ůŽŐŝƐƚŝĐͺŚĂƐŚ
^ƉĂŵ ϵй ϴй ϳй ϲй ϱй ϰй ϰй ϯй Ϯй ϭй Ϭй
ƌ Ž ƌ ƌ Ğ Ğ Ğ ƌ Ă Ƶ Ƌ ^
EŽ^ƚƌĂƚŝĨǇ
^ĐŽƌĞ ŝŶƐ
^ĞƋWƌŽũͺŚĂƐŚ
Z ͺŚĂƐŚ
^ůŽŐŝƐƚŝĐͺŚĂƐŚ
Ϯ
ϱ
ϳ
Ϯ
ϮϱϬ
,ŽŵĞWƌĞĚŝĐƚĞĚ
ϱ
ϱϬϬ
ϳ
EƵŵ ďŝƚƐ dƌĂŝŶ ^ŝǌĞ
Ϯ
ϱ
ϮϱϬ
ϳ
Ϯ
EŽ^ƚƌĂƚŝĨǇ
^ĐŽƌĞ ŝŶƐ
^ĞƋWƌŽũͺŚĂƐŚ
Z ͺŚĂƐŚ
^ůŽŐŝƐƚŝĐͺŚĂƐŚ
ϱ
ϱϰϭ
ϳ
EƵŵ ďŝƚƐ dƌĂŝŶ ƐŝǌĞ
Ϯ
ϱ
ϭϱϬϬ
ϳ
Ϯ
ϳ
ϱ
ϱϬϬϬ
EŽ^ƚƌĂƚŝĨǇ
^ĐŽƌĞ ŝŶƐ
^ůŽŐŝƐƚŝĐͺŚĂƐŚ
E ϳй ϲй ϱй ϰй ϯй ϯй Ϯй ϭй Ϭй
ƌ Ž ƌ ƌ Ğ Ğ Ğ ƌ Ă Ƶ Ƌ ^
Ϯ
ϱ
ϳ
Ϯ
ϱ
ϳ
Ϯ
ϱ
ϳ
Ϯ
ϱ
ϳ
Ϯ
ϱ
ϳ
Ϯ
ϱ
ϳ
ϭϬϬϬ
ϭϱϬϬ
ϰϬϬϬ
EƵŵ ďŝƚƐ dƌĂŝŶ ƐŝǌĞ
ϰϬϬϬϬ
ϱϬϬϬϬ
ϲϬϬϬϬ
Figure 2 : Error of different stratification methods against increasing training sizes and for different number of bits . The five methods compared : No stratify , ScoreBins , SeqProj hash , BRE hash , Slogistic hash are presented in this order in each group of bars . For the DNA dataset SeqProj hash and BRE hash could not be completed because of memory problems . where p(b|u ) is the fraction of i ∈ Du with h(fi ) = b . ff ffi fi
,ŽŵĞ'ƌŽƵŶĚ
ƌ Ž ƌ ƌ Ğ Ğ ƌ Ă Ƶ Ƌ ^
ϯϱй ϯϬй Ϯϱй ϮϬй ϮϬй ϭϱй ϭϬй ϱй Ϭй EƵŵ ďŝƚƐ dƌĂŝŶ ƐŝǌĞ
ϭϲй ϭϰй ϭϮй ϭϬй ϴй ϲй й ϰй Ϯй Ϭй
ƌ Ž ƌ ƌ Ğ Ğ ƌ ƌ Ă Ƶ Ƌ ^
EƵŵ ďŝƚƐ dƌĂŝŶ ƐŝǌĞ fl . .
( i
Proof : ( ˆμSq − ˆμS)2
Eq
(
=
=
Eq
.
1 m 1 m 1 m
ˆμh( . ) − ˆμS)2 N q( . ) ˆμh(fi ) − ˆμS)2 q(i ) N q(i ) p(b|u)puqu − ˆμS)2 ˆμb N qu In order to get a distribution we require N qupu = 1 where pu is the fraction of instances in data partition Du . The value of pu = Nu N is known to us exactly from the index . From the is minimized last expression we get that Eq by the following constrained objective :
( ˆμSq − ˆμS)2 ff fi
=
( u b p(b|u)pu st
2 ˆμ b qu
N puqu = 1
( 16 )
This objective is convex in the q s and can be solved in closed form to get the optimal solution as in Equation 15 . To calculate qu we need an estimate of p(b|u ) . We use the following strategy to obtain these estimates . Initially , we depend on the labeled data and a small static sample to estimate p(b|u ) . As the algorithm progresses and more instances are sampled from any Du , we use these to continuously refine p(b|u ) . We show empirically that in spite of depending on an estimate of p(b|u ) , these values of qu do better than uniform sampling .
.
. u b min q1,,qU
. u
B . Selecting instances
In this step we need to sample k instances from D such that the probability g(i ) of including sample i is proportional to ˆσh(fi ) ; and we have to do this without evaluating h(fi ) over each i ∈ D . Our only option is to use a proposal
903337
.
.
. min q1,,qU fflfflfflffl ˆσb pup(b|u ) distribution q(i ) that is restricted to choose the same q(i ) for each i in data partition Du . Using q(i ) we sample a set S of size larger than k , and from S we sample the k instances by weighting each instance as g(i)/q(i ) . The sampling is efficient if q(i ) is close to g(i ) . We find the best q(i ) by solving for the unlabeled bucket weights q1 , . . . , qU for which the expected L1 distance between g(i ) and q(i ) is minimized . Under the restriction imposed on q(i ) , this goal can be formulated as the following linear program : fflfflfflffl st fi ( 17 ) where Zg denotes the normalizer for the g(i ) distribution u pup(b|u ) . In the which we approximate as Zg = − qu| is the difference between the sampling above , | ˆσb probability of an instance that belongs to Du and has h(f ) = b . The term pup(b|u ) estimate the fraction of such instances . Thus , the objective above estimates the L1 distance between g(i ) and q(i ) under the constraint that the qu values define a distribution . This objective can be easily solved as a linear program using any off the shelf package . C . Empirical evaluation
− qu fi
N puqu = 1 b ˆσb
Zg
Zg u u b
Here we show that with well designed sampling methods we can obtain accuracy estimates that are close to those obtained via the exact method based on sequential scan while reading orders of magnitude less data .
We perform these experiments on the three largest datasets : TableAnnote , HomePredicted , and DNA from Section V consisting of 12 million , 14 million , and 50 million instances respectively . We created indices on each of the data by hashing on a seven bit signature . The hyperplanes for the signature were obtained by first projecting the data onto the top seven Eigen vectors of a sample of size 0.1 million from
2XU 8QLIRUP
Q D F V
O O
X
I
K
W L
Z H F Q H U H
I I L
'
7DEOH$QQRWH
+RPH3UHGLFWHG 'DWD VDPSOH VL]H
'1$
Figure 3 : Comparing methods of sampling from indexed data for estimating bucket weights the data D . Then sequentially we choose a hyperplane for hashing by finding the bias and Eigen vector that achieves the greatest reduction in variance while achieving at least a one third/two thirds split of the data . The data was thus divided into 27 = 128 partitions . The maximum size of a partition was 5 % of the data showing a fairly good balance among partitions .
We evaluate our method of sampling D for estimating accuracy ( discussed in Section VI A ) by comparing against a baseline where a uniform random sample on D is used to estimate pb . We measure error by comparing the estimated accuracy with the estimate obtained via a full scan . In Figure 3 we compare the two methods for varying budgets on the number of instances to be sampled for each dataset . We see that as the amount of data sampled is increased , both estimates get closer to exact estimates from full scan . With just 2500 sampled instances , the estimated accuracy is within 0.5 % of the optimal , and with 20,000 it is within 02 % Our method performs much better than uniform for small sample sizes . As expected , the difference diminishes as the sample size grows .
We performed similar experiments comparing our algorithm for instance selection in Section VI B with uniform selection . Due to space limitations we cannot show those graphs . These experiments also support the above finding that that it is possible to perform stratified sampling on indexed unlabeled datasets ; and an intelligent sampling strategy provides significant gains over uniform random sampling .
VII . CONCLUSIONS
In this paper we addressed an important challenge arising in real life deployments of classification models — calibrating a classifier ’s accuracy on large unlabeled datasets given only a few labeled instances and a human labeler . We proposed a method based on stratified sampling theory that provides better estimates than straight averaging and better selection of instances for labeling than random sampling . We proposed a stratification method based on hashing on r learned hyperplanes . We relate our problem to the recent exciting literature on learning distance preserving hash functions , and propose a novel formulation that leads
904338 to an efficient learning algorithm . Experiments on a wide spectrum of real datasets show that our estimates achieve between 15 % and 62 % relative reduction in error compared to existing approaches . We make our algorithm scalable by proposing optimal sampling strategies for accessing indexed unlabeled data directly . We show that our strategies achieve close to optimal performance while reading three orders of magnitude fewer instances on datasets of upto 50 million instances .
Future work include estimating accuracy of structured learning tasks such as sequential labeling where predicted labels within a sequence are not iid , and handling accuracy measures like F1 where the denominator depends on the unknown true label . Acknowledgment : This work was partly supported by research grants from the Indo German Max Planck Centre for Computer Science ( IMPECS ) and from Yahoo! Research .
REFERENCES
[ 1 ] S . Kulkarni , A . Singh , G . Ramakrishnan , and S . Chakrabarti , “ Collective annotation of wikipedia entities in web text , ” in SIGKDD , 2009 .
[ 2 ] P . Venetis , A . Y . Halevy , J . Madhavan , M . Pasca , W . Shen , F . Wu , G . Miao , and C . Wu , “ Recovering semantics of tables on the web , ” PVLDB , vol . 4 , no . 9 , 2011 .
[ 3 ] D . Davidov , O . Tsur , and A . Rappoport , “ Enhanced sentiment learning using twitter hashtags and smileys , ” in COLING ( Posters ) , 2010 , pp . 241–249 .
[ 4 ] C . Sawade , N . Landwehr , S . Bickel , and T . Scheffer , “ Active risk estimation , ” in ICML , 2010 .
[ 5 ] P . N . Bennett and V . R . Carvalho , “ Online stratified sampling : evaluating classifiers at web scale , ” in CIKM , 2010 .
[ 6 ] G . Druck and A . McCallum , “ Toward interactive training and evaluation , ” in CIKM , 2011 .
[ 7 ] W . G . Cochran , Sampling Techniques , 3rd ed . Wiley , 1977 . [ 8 ] Y . Weiss , A . Torralba , and R . Fergus , “ Spectral hashing , ” in
NIPS , 2008 .
[ 9 ] H . Xu , J . Wang , Z . Li , G . Zeng , S . Li , and N . Yu , “ Complementary hashing for approximate nearest neighbor search , ” in ICCV , 2011 .
[ 10 ] B . Kulis and T . Darrell , “ Learning to hash with binary reconstructive embeddings , ” in NIPS , 2009 .
[ 11 ] J . Wang , S . Kumar , and S . Chang , “ Sequential projection learning for hashing with compact codes , ” in ICML , 2010 .
[ 12 ] M . Norouzi and D . Fleet , “ Minimal loss hashing for compact binary codes , ” in ICML , 2011 .
[ 13 ] A . Niculescu Mizil and R . Caruana , “ Predicting good proba bilities with supervised learning , ” in ICML , 2005 .
[ 14 ] K . Weinberger and L . Saul , “ Fast solvers and efficient imple mentations for distance metric learning , ” in ICML , 2008 .
[ 15 ] J . Davis , B . Kulis , P .
Jain , S . Sra , and I . Dhillon ,
“ Information theoretic metric learning , ” in ICML , 2007 .
[ 16 ] I . Tsochantaridis , T . Joachims , T . Hofmann , and Y . Altun , “ Large margin methods for structured and interdependent output variables , ” JMLR , vol . 6 , pp . 1453–1484 , 2005 .
[ 17 ] G . Limaye , S . Sarawagi , and S . Chakrabarti , “ Annotating and searching web tables using entities , types and relationships , ” in Proc . of the 36th Int’l Conference on Very Large Databases ( VLDB ) , 2010 .
[ 18 ] P . Li and A . C . K¨onig , “ b bit minwise hashing , ” in WWW ,
2010 .
