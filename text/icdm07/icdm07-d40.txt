On Appropriate Assumptions to Mine Data Streams : Analysis and Practice
†
Jing Gao
‡
Wei Fan
Jiawei Han
†
†
‡
University of Illinois at Urbana Champaign
IBM T . J . Watson Research Center jinggao3@uiuc.edu , weifan@usibmcom , hanj@csuiucedu
Abstract
Recent years have witnessed an increasing number of studies in stream mining , which aim at building an accurate model for continuously arriving data . Somehow most existing work makes the implicit assumption that the training data and the yet to come testing data are always sampled from the “ same distribution ” , and yet this “ same distribution ” evolves over time . We demonstrate that this may not be true , and one actually may never know either “ how ” or “ when ” the distribution changes . Thus , a model that fits well on the observed distribution can have unsatisfactory accuracy on the incoming data . Practically , one can just assume the bare minimum that learning from observed data is better than both random guessing and always predicting exactly the same class label . Importantly , we formally and experimentally demonstrate the robustness of a model averaging and simple voting based framework for data streams , particularly when incoming data “ continuously follows significantly different ” distributions . On a real streaming data , this framework reduces the expected error of baseline models by 60 % , and remains the most accurate compared to those baseline models .
1 . Problems and Motivations
Classification on stream data has been extensively studied in recent years with many important algorithms developed . Much of the previous work focuses on how to effectively update the classification model when stream data flows in [ 1 , 4 , 6 ] . The old examples can be either thrown away after some period of time or smoothly faded out by decreasing their weights as time elapses . Alternatively , other researchers explore some sophisticated methods to select old examples to help train a better model rather than just using the most recent data alone [ 10 , 2 , 9 , 7 , 8 ] . These algorithms select either old examples or old models with respect to how well they match the current data . Hence , they also implicitly make the assumption that the current training distribution is considerably close to the unknown distribution that produces future data . Among these methods , the weighted ensemble approaches [ 2 , 7 , 8 , 9 ] were demonstrated to be highly accurate , when the “ stationary distribution assumption ” holds true . Formally , we denote the feature vector and class label as x and y respectively . Data stream could be defined as an infinite sequence of ( xi , yi ) . Training set D and test set T are two sets of sequentially adjacent examples drawn from the data stream . The labels in T are not known during classification process and will only be provided after some period of time . The assumption held by existing algorithms is stated as follows :
Assumption 1 ( Shared Distribution Stationary Distribution ) Training D and test data T are assumed to be generated by the same distribution P ( x , y ) = P ( y|x ) · P ( x ) no matter how P ( x , y ) evolves as time elapses .
Given this assumption , one would ask : “ what is the difference between stream mining and traditional mining problems ? ” The most significant difference from traditional “ static ” learning scenarios is that this shared distribution between training and testing data ( abbreviated as “ shared distribution ” in the rest of paper ) evolves from time to time in three different ways [ 3 ] : ( 1 ) feature changes , ie , the changes of the probability P ( x ) to encounter an example with feature vector x ; ( 2 ) conditional changes , ie , the changes of the conditional probability P ( y|x ) to assign class label y to feature vector x ; and ( 3 ) dual changes , ie , the changes in both P ( x ) and P ( y|x ) . An illustration with a real world intrusion dataset can be found later in this section .
Under the “ shared distribution assumption ” , the fundamental problems that previous works on stream mining focus on are mainly the following areas : 1 ) How often the shared distribution changes ? It could be continuous or periodical , and fast or slow ; 2 ) How much data is collected to mine the “ shared distribution ” ? It could be sufficient , insufficient or “ just don’t know ” ; 3 ) What is this “ shared distri x 10−5
1.6
1.4
1.2
1
0.8
0.6
0.4
0.2
) y ( P true P(y ) Batch Update Real Time Update
Time Stamp
1
Time Stamp
11
Time Stamp
21
0 0
1
2
3
4
Time
5 x 105
Figure 1 . Evolution of P ( y )
0
0.25 0
0.25 0
0.25
Figure 2 . Evolution of P ( x ) and P ( y|x ) bution ” ? It could be balanced or skewed , binary or multiclass , and etc . ; 4 ) How the shared distribution evolves ? There could be conditional change , feature change , or dual change ; and 5 ) How to detect the changes in shared distribution ? Some methods do not detect them at all and always keep the models up to date whereas others only trigger model reconstruction if a change is suspected . Obviously , the validity of some of these problems relies on the “ shared distribution assumption ” , which we challenge below . Interestingly , given “ stationary distribution assumption ” , stream learning would still be effectively the same as traditional learning if the set of training examples collected to mine the “ shared distribution ” is sufficiently large so that additional examples cannot construct a more accurate model [ 2 ] .
Realistic Assumption The implicitly held assumption ( Assumption 1 ) may not always be true for data streams . As an example , let us consider the KDDCUP’99 “ intrusion detection ” dataset that is widely used in the stream mining literature . We plot the evolution on the percentage of intrusions using “ averaged shifted histogram ( ASH ) ” in Figure 1 . The true probability P ( y ) to encounter an intrusion is shown in thick solid line . Obviously , P ( y ) is very volatile . As time elapses , P ( y ) continues to change and fluctuate . At some period , the change is more significant than others . Except for the flat area between time stamps 2×105 and 3×105 , P ( y ) from the past is always different from that of the future examples . Under “ shared distribution ” assumption , the training distribution ought to be accurately modeled as the ultimate target . However , it may not precisely match future testing distribution due to continuous change . The fluctuation in P ( y ) comes from changes in P ( y|x ) or P ( x ) . Let + denote intrusions . By definition , P ( y = + ) = P ( x ) is fixed for a given period , then P ( y ) ∝ P ( x , y ) = P ( y|x)·P ( x ) . Thus , the change in P ( y ) has to come from P ( y|x ) , or P ( x ) , or possibly both P ( y|x ) and P ( x ) . Unless the dataset is synthesized , one
P ( x,y=+ )
P ( x ) and normally does not know which of these three cases is true , either before or after mining . Because of this , a model constructed from the training data may not be highly accurate on the incoming data . This can particularly be an issue if the changes are attributed to conditional probability P ( y|x ) . As follows , we illustrate how P ( x ) and P ( y|x ) change using the same intrusion detection example .
Figure 2 shows the histograms of the percentage of intrusions and normal connections given the feature ‘srv diff host rate’ in three different time periods , where gray represents intrusions and black indicates normal connections . The range of this feature , or the percentage of connections to different hosts , remains within [ 0,1 ] . Due to the space limit , we only show the histograms between 0 and 025 Most bars between 0.25 and 1 have heights close to 0 and do not reveal much useful information . It is obvious that the distribution of this feature , or visually the relative height of each bar in the histogram representing the percentage of connections , is different among these three time periods . This obviously indicates the change in P ( x ) as data flows in . In addition , the probability distribution to observe intrusions given this feature is quite different among these three periods . For example , in the first time period , P ( y = +|x ∈ [ 0.095 , 0.105 ] ) = 0 but it later jumps to around 0.7 at the last time stamp . In the following , we will discuss how the “ shared distribution ” assumption affects learning when the actual data evolves in the manner described above . It is worth noting that some stream mining algorithms [ 10 , 6 , 2 , 9 , 7 , 12 , 8 ] discuss about the concept drifts in streams and recognize the changes in the distribution that generates the data . However , they still make some assumptions about the forms of concept drifts . For example , most of them assume that the most recent training data is drawn from the distribution which is considerably close to that generates the test data [ 6 , 2 , 9 , 7 , 8 ] .
Depending on when labeled training data becomes available , existing stream classification algorithms belong to two main categories . The first group [ 1 , 4 ] updates the training distribution as soon as labeled example becomes available and flows in , and at the same time , obsolete examples are either discarded or “ weighted ” out . Under the “ shared distribution ” assumption , such method obviously assumes that the distribution of the next moment is the same as those observed data in memory . Visually , it assumes a “ shifted ” or “ delayed ” P ( y ) as the distribution of the future , as shown by the “ Real Time Update ” curve in Figure 1 . To be precise , when either the number of examples kept in memory is not sufficiently large or the fading weights are not set properly , P ( y ) may not only be shifted but also carry a “ different shape ” from the plot constructed by average shifted histogram . The second family of stream classification algorithms [ 2 , 9 , 7 , 8 ] normally receives labeled data in “ chunks ” , and assumes that the most recent chunk is the closest to the future distribution . Thus , they concentrate on learning from the most recent data accurately as well as some old examples that are similar to the current distribution . Due to the changing P ( y ) , we observe both “ shift ” and “ flattening ” of the assumed future distribution , shown in the “ Batch Update ” curve in Figure 1 . “ Flattening ” is due to chunking and is hard to avoid since labeled data may arrive in chunks . As a summary , for both families of methods , “ shifting ” is not desirable and ought to be resolved .
In fact , “ shift ” or “ delay ” is inevitable under the “ shared distribution assumption ” , since the culprit is the assumption itself : the future data is not known and can change in different ways from the current data , but they are implicitly assumed to be the same . In order to overcome the “ delaying ” problem , the main question is how one should judiciously use what is known in order to optimally match the unknown future , with the least surprise and disappointment . Existing algorithms have obviously taken the road to accurately match the training distribution with the hope that it will perform well on the future data . However , from the above example as well as detailed experiments on this example in Section 3 , they could perform poorly when the future is quite different from the current . By this token , we could see that the commonly held “ shared distribution assumption ” may not be appropriate , and stream classification algorithms ought to consider situations where training and testing distributions are different . Thus , we take this difference into consideration and suggest a relaxed and realistic assumption as follows :
Assumption 2 ( Learnable Assumption ) The training and testing distributions are similar to the degree that the model trained from the training set D has higher accuracy on the test set T than both random guessing and predicting the same class label .
The core of this new assumption is that it does not assume to know any exact relationship between current training and future test distribution , but simply assume that they are similar in the sense that learning is still useful . As commonly understood , this is the bare minimum for learning . It should bility distribution of feature vectors . where the value of yi is known after a certain time period . sent the joint distribution over X − Y space at time t .
( cid:127 ) x is feature vector from feature space X and P ( x ) is the proba(cid:127 ) y is the class label from space Y and P ( y ) is the prior class probability . ( cid:127 ) P ( x , y ) is the joint probability of having feature vector x and class label y , and P ( y|x ) is the conditional probability for x to have label y . ( cid:127 ) Stream data is an infinite sequence of X − Y pairs , {(xi , yi)} ( cid:127 ) Since P ( x , y ) is evolving in streams , we use Pt(x , y ) to repre(cid:127 ) Training set D and test set T contain sequentially adjacent examples drawn from the stream data . The true values of yi in T is not known at the time of learning . ( cid:127 ) Training set D is drawn from distribution Pa(x , y ) , and test set T is drawn from Pe(x , y ) . a < e , and Pa(x , y ) and Pe(x , y ) are different . ( cid:127 ) Pa(x , y ) and Pe(x , y ) are similar in the sense that the model trained on D and evaluated on T is more accurate than random guessing and fixed prediction .
Figure 3 . Notations and Assumptions be noted that this assumption is made concerning the inductive learning problem . Mining data streams from other perspectives , such as clustering , association mining , may require other appropriate assumptions . All the notations and assumptions we made in the paper are summarized in Figure 3 . With the relaxed assumption , we first elaborate the idea that one should only match the training distribution to a certain degree , then we shall provide a straightforward framework that can maximize the chance for models to succeed on future data with different distributions .
2 . A Robust and Extensible Framework
In Section 1 , we illustrate that when learning from stream data , it is unlikely that training and testing data always come from the same distribution . This phenomenon hurts existing algorithms that are based upon such an assumption . Some stream mining work has investigated the change detection problem [ 5 ] or utilized the concept change in model construction [ 12 ] . However , since there are only unlabeled examples available in the test data set , the “ change detection ” could at most detect feature change . It is rather difficult to detect the change in P ( y|x ) before class labels are given . The moral of the relaxed assumption ( Assumption 2 ) ought to be understood in the way that “ strong assumptions are no good for stream mining ” . To carry this understanding one step further , any single learning method on data streams also makes assumptions one way or the other on how to match the training distribution effectively and still perform well on testing distribution , and these assumptions can also fail for a continuously changing data stream . Instead , we use a naive model averaging based approach that does not depend specifically on any single technique but combines multiple techniques wherever and whenever available . Formally , suppose k models {M1 , M2 , . . . , Mk} are trained ( eg using different learning algorithms ) and each of them outputs an estimated posterior probability P ( y|x , Mi ) for each test example x . We k use simple averaging to combine the probability outputs , i=1 P ( y|x , Mi ) , and its optimality is thus f A(x ) = 1 k discussed below .
. M∈ΘM
. ( x,y)∈T
P ( x , y)(P ( y|x ) − P ( y|x , M))2
. ( x,y)∈T
P ( x , y)(P ( y|x ) − P ( y|x , M))2
Performance Guarantee As described above , we generate k models and each model Mi outputs an estimated probability P ( y|x , Mi ) for x . For the sake of simplicity , we use M to denote any of the k models Mi and use ΘM to represent the collection of the k models . Then any base model M ’s expected mean squared error is the difference between its predicted probability and the true probability integrated over all test examples : ErrM = = EP ( x,y)[P ( y|x)2 − 2P ( y|x)P ( y|x , M ) + P ( y|x , M)2 ] Suppose each model M has probability P ( M ) on the test set , then the expected error incurred by randomly choosing a base streaming model to do prediction is the above error ErrM integrated over all models : ErrS = = EP ( M ),P ( x,y)[P ( y|x)2 − 2P ( y|x)P ( y|x , M ) + P ( y|x , M)2 ] It should be noted that the above equation only evaluates the general performances of base streaming models , but the predictions of test examples are not averaged . Now , we come to the analysis of ensemble where the predictions are averaged . As introduced before , we make the following “ model averaging ” prediction : f A(x ) = EP ( M )[P ( y|x , M) ] . Then the expected error of this ensemble should be the error integrated over the universe of test examples : ErrA=
. P ( x , y)(P ( y|x ) − EP ( M )[P ( y|x , M)])2 ( x,y)∈T =EP ( x,y)[P ( y|x)2 − 2P ( y|x)EP ( M )[P ( y|x , M ) ] +EP ( M )[P ( y|x , M)]2 ] ≤EP ( x,y)[P ( y|x)2 − 2P ( y|x)EP ( M )[P ( y|x , M ) ] +EP ( M )[P ( y|x , M)2 ] ]
The inequality holds since E[f(x))]2 ≤ E(f(x)2 ] ( in this case , EP ( M )[P ( y|x , M)]2 ≤ EP ( M )[P ( y|x , M)2 ] . Therefore , ErrA ≤ ErrM , ie , probability averaging of multiple
AP
M1
M2
M3
WE
Time Stamp
A
Time Stamp
B
Training Error
Test Error
Figure 4 . Error Comparison models is superior to any base streaming model chosen at random with respect to reduction in expected errors on all possible examples .
We are not claiming that model averaging is more accurate than any single model at any given time . As a simple illustration , Figure 4 shows the errors of three models at time A and time B . At a specific time stamp , a single model M that fits current distribution well could have much better performances on test data than other models , eg , M2 at time A and M1 at time B . At this same time stamp , the probability averaging of three models ( shown as AP ) may not necessarily be more accurate than using a specific model . However , in stream learning problems , it is hard to find a single model that works well on all possible training test pairs drawn independently from continuously changing distributions . Since it is unknown which single model could be optimal at each and every time stamp , the current practice is to select a method and hope it will perform the best at any time stamp . However , this could be risky . In the above example , the most accurate model M2 at time stamp A turns out to be the least accurate at time stamp B . On the other hand , the model averaging approach could reduce the probability of surprises and guarantee the most reliable performance . The above analysis formally proves the expected error incurred by randomly choosing a single model is greater than model averaging . Therefore , unless we know exactly which model is always the best , unrealistic in a constantly changing stream environment , we could expect model averaging to have the best expected performance .
∗
Optimality of Uniform Weights The next question is how to decide P ( M ) , or the probability of model M be∗ ) = 1 where ing optimal . The simplest way is to set P ( M is the most accurate model and set other model ’s probM ability as 0 . This is one of the common practice adopted by some stream mining algorithms where the model itself is fixed but its parameters are re estimated as labeled data flows in . As discussed above , the expected performance of a single model could be low , when the distribution is con tinuously evolving . Another more sophisticated approach is introduced in [ 9 ] , where each model is assigned a weight that is reversely proportional to its error estimated using training data . That is to say , P ( M ) is higher if the model M incurs less errors when cross validated using the training data . This weighting scheme is problematic because : 1 ) the training examples may be insufficient to reflect the true accuracy of model M , thus the weights may not represent the true P ( M ) ; and 2 ) more importantly , the training and testing distributions may not be the same as previous methods have assumed , thus the weights derived from the training data would be essentially inappropriate for the test data . As illustrated in Figure 4 , when training and test data have different distributions , P ( M ) calculated using training data may be off from its true value , thus leading to the unsatisfactory performance of weighted ensemble ( denoted as WE ) as compared with the simple model averaging ( AP ) . As follows , we formally illustrate why simple averaging with uniform weights beats other non uniform weighting schemes . Suppose the weights of k models are {w1 , w2 , . . . , wk} , k each of which is from [ 0,1 ] and satisfies the constraint i=1 wi = 1 . Ideally , the weight of model Mi(1 ≤ i ≤ k ) ought approximate its true probability P ( Mi ) as well as possible . We use the following measure to evaluate the difference between the assigned weights and the true weights : k .
D(w ) =
( P ( Mi ) − wi)2
( 1 ) i=1
Let Θi be the hypothesis space where Mi is drawn , which has a uniform distribution with a constant density C i . In other words , we don’t have any prior knowledge about the optimality of a model for a constantly changing stream . This is a valid assumption since the choice of optimal model is changing with the evolving distribution . The test distribution is somewhat revealed by the training distribution , however , which model fits the distribution the best remains unknown . Another clarification is that P ( Mi ) '= P ( Mj)(i '= j ) on a specific pair of training and test sets given in time . This means that we cannot have preference for some model over others , since the preference needs to change continu k ously considering all possible training and test sets in time . i=1 P ( Mi ) = 1 should also be satisfied . The constraint As an example , suppose there are two models , M1 and M2 . Then P ( M1 ) and P ( M2 ) are both uniformly distributed within [ 0,1 ] . At one evaluation point , P ( M1 ) = 0.8 and P ( M2 ) = 0.2 , but at another time , P ( M1 ) = 0.3 and P ( M2 ) = 07 It is clear that both M1 and M2 would be preferred at some time but it is unknown when and how this preference is changing . As another example , look at Figure 4 again , it is clearly shown that M2 and M1 are the best models with lowest test errors at time A and B respectively . However , since the labels of test examples are not known in advance , we could never know this changing preference before mining .
Integrating the distance measure in Eq 1 over all possi ble Mi , we could obtain the expected distance as :
E[D(w)]= fi k .
Θi fi i=1 k .
= i=1
Θi
C i(P ( Mi ) − wi)2dMi
C i(P ( Mi)2 − 2P ( Mi)wi + w2 i )dMi
The aim is to minimize E[D(w ) ] wrt w . Eliminating irrelevant items , the above could be simplified to : k . k .
E[D(w ) ] = C1 − C2 wi + C3 w2 i i=1 i=1 where {C1 , C2 , C3} are positive constants . k i=1 wi = 1 , the problem is transformed to :
( 2 )
Since k . k .
Minimize w2 i Subject to wi = 1 and 0 ≤ wi ≤ 1 i=1 i=1
The closed form solution to this constrained optimization k ( 1 ≤ i ≤ k ) . Therefore , when we problem is : wi = 1 have no prior knowledge about each model , equal weights are expected to be the closest to true model probabilities on the test data over some period of time , thus giving the best performances on average . This is particularly true in the stream environment where the distribution is continuously changing . As shown in the following experiments , the best model on current data may have bad performances on future data , in other words , P ( M ) is changing and we could never estimate the true P ( M ) and when and how it would change . Hence non uniform weights could easily incur over fitting , and relying on a particular model should be avoided . Under such circumstances , uniform weights for the models are the best approximate of the true P ( M ) .
3 . Experiments
We conduct an extensive performance study using both synthetic and real data sets , where training and testing distributions are explicitly generated differently , to demonstrate the effectiveness of the averaging ensemble against change . As discussed below in detail , this empirical study validates the following claims : 1 ) ensemble based on model averaging would reduce expected errors compared with single models , thus is more accurate and stable ; and 2 ) previous weighted ensemble approach is less effective than ensemble based on simple voting or probability averaging .
31 Experiment Setup
Synthetic Data Generation We describe how to generate synthetic data and simulate its concept changes , rephrased from [ 3 ] . Form of P ( x ) . x follows a Gaussian distribution , ie , P ( x ) ∼ N(µ , Σ ) , where µ is the mean vector and Σ is the covariance matrix . The feature change is simulated through the change of the mean vector where µi is changed to µisi(1 + t ) for each data chunk . t is between 0 to 1 , representing the magnitude of changes , and si ∈ {−1 , 1} specifies the direction of changes and could be reversed with a probability of 10 % . Form of P ( y|x ) in deterministic problems . In binary problems , d the boundary between two classes is defined using function i=1 aixixd−i+1 − a0 where a is the weight vecg(x ) = tor . Then the examples satisfying g(x ) < 0 are labeled positive , whereas other examples are labeled negative . ai is initialized by a random value in the range of [ 0,1 ] and the value of a0 is set based on the values of r and {a1 , . . . , ad} . In multi class problems , suppose there are l classes and the count of examples in each class is {C1 , C2 , . . . , Cl} . We calculate the value of g(x ) for each x using the definition given in binary problems . All the examples are ranked in ascending order of g(x ) . Then the top C1 examples are given class label 1 , examples with ranks C1 + 1 to C1 + C2 are assigned to class 2 , and so on . In both problems , the concept change is represented by the change in weight ai , which is changed to aisi(1 + t ) for every data chunk . The parameters t and si are defined in the same way as in the feature change . Form of P ( y|x ) in stochastic problems . We use a sigmoid function to model the posterior distribution of positive class : P ( +|x ) = 1/(1 + exp(g(x)) ) . The concept changes are also realized by the changes of weights as illustrated in the deterministic scenario .
The distribution within a data chunk is unchanged whereas between data chunks , the following changes may occur : 1 ) each data chunk could either be deterministic or stochastic ( in binary problem ) ; 2 ) in each chunk , the Gaussian distribution of the feature values may either have diagonal variance matrix or non diagonal one ; 3 ) either one of the three concept changes ( feature change , conditional change and dual change ) may occur ; 4 ) the number of dimensions involved in the concept change is a random number from 2 to 6 ; and 5 ) the magnitude of change in each dimension is randomly sampled from {10 % , 20 % , . . . , 50%} . Since lots of random factors are incorporated into the simulated concept change , it is guaranteed that training and testing distributions are different and evolving quickly .
Real World Data Sets We test several models on KDD Cup’99 intrusion detection data set , which forms a real data stream . This data set consists of a series of TCP connection records , each of which can either correspond to a nor mal connection or an intrusion . We construct three data streams from the 10 % subset of this data set : Shuffling . Randomly shuffle the data and partition it into 50 chunks with varying chunk size from 5000 to 10000 . Stratified Sampling . Put the data into class buckets : One for normal connections and one for intrusions . Generate 50 chunks as follows : 1 ) choose an initial P ( y ) , 2 ) sample without replacement from each bucket to form a chunk that satisfies P ( y ) , 3 ) evolve P ( y ) and sample from the remaining data in the buckets as the next chunk , and finally , 4 ) put data sampled in step 2 back to the buckets and repeat steps 2 and 3 . The chunk size is also varied from 5000 to 10000 . Merging . Partition the data into chunks and maintain its original order . Both normal connections and intrusions should account for at least 5 % in each chunk , if this is not satisfied , merge the chunk with the next chunk until the percentage is above the threshold . In the experiments , we discard one large data chunk with only normal examples and there are altogether 22 chunks with chunk size varying from 1069 to 32122 . We construct these three data sets because the original data set does not have explicit time stamps and there are chunks of intrusions followed by chunks of normal examples . Each chunk may only contain examples of one class and this is a non learnable problem . On the other hand , the three data streams we constructed have the following properties : 1 ) each chunk is ensured to have examples from both classes ; and 2 ) the distributions of two consecutive data chunks are different and evolve in different ways in three streams . Upon such datasets , we could validate our claims of stream mining upon the relaxed assumption .
Measures and Baseline Methods For a data stream with chunks T1 , T2 , . . . , TN , we use Ti as the training set to classify Ti+1 and the distribution of the test set Ti+1 is not necessarily the same as that of Ti . We evaluate the accuracy of each model . For the classifier having posterior probability as the output , the predicted class label is the class with the highest posterior probability under zero one loss function . Another measure is mean squared error ( MSE ) , defined as the averaged difference between estimated probability and true posterior probability P ( y|x ) . In problems where we are only exposed to the class labels but do not know the true probability , we set P ( y|x ) = 1 if y is x ’s true class label , otherwise P ( y|x ) = 0 . We are comparing the following algorithms : single models built using Decision Tree ( DT ) , SVM , Logistic Regression ( LR ) and ensemble approaches including Weighted Ensemble ( WE ) , Simple Voting ( SV ) and Averaging Probability ( AP ) . Different from averaging ensemble framework , the weighted ensemble approach assigns a weight to each base model which reflects its predictive accuracy on the training data ( obtained by tenfold cross validation ) and the final prediction outputs are combined through weighted averaging . In previous work ,
Table 1 . Performance Comparison on Synthetic Stream Data
Measure
Aacc Amse AR SR #W #L
Measure
Aacc Amse AR SR #W #L
DT
0.7243 0.2731 2.2323 0.8902
30 53
DT
0.5111 0.1745 2.3636 0.8263
22 58
SVM 0.7591 0.2387 1.6465 0.6898
47 12
SVM 0.5295 0.1413 1.9293 0.7986
35 28
Chunk Size 100 LR WE
0.7346 0.2625 2.1111 0.8193
28 39
0.7461 0.1889 1.8889 0.7544
34 23
Chunk Size 100 LR WE
0.5298 0.1272 1.9798 0.7822
31 29
0.5301 0.1210 1.8283 0.5159
23 6
Binary Stream Data
SV
0.7595 0.2379 1.5152 0.5414
AP
0.7690 0.1752 1.4848 0.5414
DT
0.8424 0.1540 2.1313 0.9757
50 2
41 54 Multi Class Stream Data
53 2
SV
0.5320 0.1872 1.8788 0.6589
28 16
AP
0.5314 0.1208 1.7273 0.6197
36 9
DT
0.4991 0.1764 2.0202 0.8919
38 40
SVM 0.8318 0.1649 1.8485 0.8732
46 31
SVM 0.4939 0.1461 2.2626 0.8758
28 54
Chunk Size 2000 LR WE
0.8366 0.1601 1.6869 0.8765
58 27
0.8339 0.1262 1.7980 0.8687
49 29
Chunk Size 2000 LR WE
0.4920 0.1322 2.2424 0.9045
31 55
0.5130 0.1246 1.6667 0.4949
34 1
SV
0.8370 0.1597 1.5455 0.7460
60 15
SV
0.4950 0.2020 2.1111 0.9023
35 46
AP
0.8369 0.1242 1.5455 0.7460
60 15
AP
0.5139 0.1244 1.4040 0.5330
61 2 such weighted ensembles are shown to be effective when the “ shared distribution ” assumption holds true . In our experiments , we evaluate its performances upon the relaxed assumption . For all the base learning algorithms , we use the implementation in Weka package [ 11 ] with parameters set to be the default values . In the averaging ensemble framework , either SV or AP , the base streaming models could be chosen arbitrarily . We test the framework where base models are constructed from either different learning algorithms or different samples of the training sets .
For a learning algorithm Ah , we build a model based on Ti and evaluate it on Ti+1 to obtain its accuracy pih and MSE eih . There are altogether N − 1 models and we report its average accuracy ( Aacc ) and average MSE ( Amse ) . Furthermore , in each of the N −1 runs , we compare the performances of all algorithms and decide the winner and loser in the following way : if pih is within m % of maxh pih , algorithm Ah is a winner in that run , similarly , if pih is within m % of minh pih , it is a loser . In other words , we tolerate some small difference between two algorithms , if their accuracies are the same with respect to the “ margin tolerance rate ” m , we regard their performances as the same . We report the number of wins and loses for each algorithm ( #W and #L ) . With winners ranking the first , losers ranking the third and all other algorithms occupying the second position , we give N − 1 ranks to each algorithm and obtain the mean and standard deviation of the ranks ( AR and SR ) . A good algorithm will have a higher accuracy , a lower MSE and average rank closer to 1 . If it has a lower standard deviation in the ranks , the learning algorithm is more stable .
32 Empirical Results
We report the experimental results comparing the two ensemble approaches ( SV , AP ) with single model algo rithms ( DT , SVM , LR ) as well as weighted ensemble method ( WE ) . As discussed below in detail , the results clearly demonstrate that on the stream data where training and testing distributions are different and fast evolving , the two ensemble approaches have the best performances on average with higher accuracy and lower variations . Therefore , when facing unknown future , the ensemble framework is the best choice to minimize the number of bad predictions .
Test on Concept Drifting Stream Data We generate four synthetic data streams , each of which is either binary or multi class and has chunk size 100 or 2000 . Each data set has 10 dimensions and 100 data chunks . The margin tolerance rate is set to be 001 From Table 1 , it is clear that the two ensemble approaches ( SV and AP ) have better performances ( best are highlighted in bold font ) regardless of the measures we are using , the problem type ( binary or multi class ) and the chunk size . Take the binary problem with chunk size 100 as an example . AP proves to be the most accurate and stable classifier with the highest accuracy ( 0.7690 ) , lowest MSE ( 0.1752 ) , 53 wins and only 2 loses . SV is quite comparable to AP with 50 wins and 2 loses . The best single classifier SVM wins 47 times and loses 12 times and WE approach seems to suffer from its training set based weights with only 34 wins but 23 loses . These results suggest the following : when the “ same distribution ” between training and testing data does not exist : 1 ) there are no uniformly best single classifiers , even decision tree , which has the worst average performance , still wins 30 times among all 99 competitions . The large variabilities of single models result in their high expected errors ; 2 ) on average , ensemble approaches , simple voting or probability averaging , are the most capable of predicting on future data with unknown distributions ; 3 ) assigning a weight to each
Table 2 . Data Steam with Shared Distribution
Aacc Amse AR SR #W #L
DT
0.7366 0.2369 2.3030 0.8506
25 55
SVM 0.7756 0.1980 1.7071 0.6739
41 12
LR
0.7604 0.2052 2.1010 0.8143
28 38
WE
0.7704 0.1427 1.7879 0.7460
40 19
SV
0.7772 0.1939 1.6768 0.5312
35 3
AP
0.7797 0.1254 1.6364 0.5431
39 3 base learner even hurts the predictive performances on testing data since the distribution it tries to match is different from the true one .
For binary streams , we also record the results on the first 40 chunks to see how the concept evolution affects the classification performances . The results indicate that even within the same data stream , the best single classifier for the first 40 chunks is different from the best one on the whole data set . Take the stream data with chunk size 100 as an example . At first , LR has 18 wins , compared with DT ( 4 wins ) and SVM ( 14 wins ) , it appears to be the best on average . However , later , SVM takes the first place with 47 wins ( DT 30 and LR 28 ) . This clearly indicates that in a stream whose distribution evolves , a model which performs well on current data may have poor performances on future data . Since we never know when and how the distribution changes , depending on one single classifier is rather risky . On the other hand , ensemble based on averaged probability is more robust and accurate , which is the winner for classifying data streams with regard to the average performance ( ranks around 1.5 while others rank more than 2 on average ) . Ensemble based on simple voting ( SV ) produces results similar to that of AP in binary stream problems , but is not that competitive in multi class problems . The reason may be that two class problems are easier for prediction tasks , so the probability outputs of a classifier may be rather skewed , greater than 0.9 or less than 01 So there isn’t much difference between simple voting and averaging probability in this case . However , when the number of classes grows large , it is quite unlikely that the predicted probability is skewed . The strengths of probability averaging over simple voting is therefore demonstrated on multiclass problems . As for the weighted ensemble approach , it sometimes increases the predictive accuracy , but sometimes gives even worse predictions compared with single models . Whether it performs good or not is dependent on how the training and testing distributions match . In this sense , the other two simple ensemble methods are more robust since they are not based on the assumption that training and testing data come from the same distribution .
We also compare all the methods on data streams where training and testing distributions are identical , as assumed by previous stream mining algorithms . Two data streams
Table 3 . Ensemble on Real Data
Shuffling
DT
0.9961 0.0039 1.9592 0.8406
18 16
DT
0.9720 0.0280 1.6531 0.9026
31 14
SVM 0.9941 0.0059 2.5306 0.7665
8 34
LR
0.9957 0.0043 1.9388 0.8013
17 14
WE
0.9964 0.0028 1.6939 0.7959
25 10
Stratified Sampling
SVM 0.9744 0.0256 1.5510 0.7654
30 8
LR
0.9699 0.0301 1.6122 0.8854
32 13
WE
0.9707 0.0259 1.5306 0.8191
33 10
SV
0.9975 0.0025 1.0000
0 49 0
SV
0.9755 0.0245 1.2245 0.4684
39 1
AP
0.9975 0.0024 1.0000
0 49 0
AP
0.9755 0.0232 1.2245 0.4684
39 1
Aacc Amse AR SR #W #L
Aacc Amse AR SR #W #L are generated , where the first one is used as the training set and the second one is the testing data . They have “ evolving shared distribution ” in the sense that the corresponding chunks of training and testing streams are sampled from the same distribution , but this shared distribution is evolving in the way we have described in Section 31 Each stream has 100 data chunks with 100 examples in each chunk . Since the training examples may be far from sufficient due to the small training size , it may not obtain an accurate model even if the training and testing distributions are the same . As indicated in Table 2 , again , ensemble could help reduce the classification errors on such data sets ( from around 0.2 to 012 ) AP has obtained the highest accuracy , the lowest mean squared error and the highest rank on average . Weighted ensemble wins 40 times , which appears to be competitive , but worse than AP in terms of loses ( 19 versus 2 ) . Therefore , even if the “ shared distribution ” assumption holds true , simple averaging or simple voting are still more effective than weighted ensemble because the training samples may be insufficient and training errors derived from such data sets are unreliable . We could safely conclude that the averaging ensemble framework could maximize the chance of matching the true distribution , thus return the most satisfactory prediction results in general .
Test on KDD Cup’99 Data In Section 3.1 , we describe the three data streams we generate from the KDD Cup’99 intrusion detection data set and how the training and testing distributions are made different explicitly . Also , as illustrated in Section 1 , both P ( x ) and P ( y|x ) undergo continuous and significant changes in this stream data . Results of various methods on streams generated by “ Shuffling ” and “ Stratified Sampling ” are summarized in Table 3 where margin tolerance rate is set to be 0001 Similar to earlier results on simulated streams , the advantage of the ensemble framework is clearly demonstrated . The two ensemble
1 i i n o s c e r P d e z i l a m r o N
0.99
DT SVM LR WE AP
0
10
20
30
40
50
Chunk ID
E S M d e z i l a m r o N
1.1
1
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
DT SVM LR WE AP
10
20
30
40
50
Chunk ID
Figure 5 . Accuracy and MSE on Real Data approaches not only increase the accuracy of single models but also occupy the first place in most of the evaluations . The most significant improvements could be observed on the data set generated by shuffling , where accuracy goes up from 0.9961 to 0.9975 and the number of wins increases from 18 to 49 after combining outputs of multiple models . The performances of SV and AP are almost the same for these two data sets . As discussed in the synthetic data experiments , SV and AP are expected to have similar predictions when the estimated probabilities of each class are skewed in binary problems . Another observation is that the weighted ensemble approach could improve over a single model but the improvements are less significant compared with simple averaging . This phenomenon again shows that the weighting scheme cannot survive the relaxed assumption where training and testing distributions could be different since it fits the training data too “ tightly ” .
Figure 5 reveals some detailed information about the evaluation results ( Accuracy and MSE wrt Chunk ID ) on the first data set where data records are randomly shuffled . To exclude the effects of different scales , we normalize the measures by the maximal value . It is obvious that the probability averaging ensemble ( AP ) is the most accurate classifier in general with normalized accuracy close to 1 and mean squared error below 05 Also , as shown in both plots , as measures of single models fluctuate within a wide range , the performances of probability averaging ensemble are much more stable . This clearly shows the benefits of us
Table 4 . Ensemble on Data Set with Merging
Aacc Amse AR SR #W #L
DT
0.8508 0.1492 1.95 0.8256
7 6
SVM 0.8193 0.1807 1.65 0.7452
10 3
LR
0.7869 0.2131 2.55 0.6048
1 12
WE
0.8182 0.1801 1.65 0.5871
8 1
SV
0.8218 0.1782 1.65 0.6708
9 2
AP
0.8218 0.1559 1.65 0.6708
9 2
Table 5 . Ensemble of Multiple Samples
Aacc Amse AR SR #W #L
DT
0.8508 0.1492 2.25 0.9665
7 12
SVM 0.8193 0.1807 2.05 0.8256
6 7
WE
0.8182 0.1801
1.9
0.7182
6 4
AP
0.8218 0.1559 1.85 0.7452
7 4
APS 0.8579 0.1301 1.65 0.7452
10 3 ing our ensemble framework when the testing distribution is unknown and departed from the training distribution . On average , the ensemble would approximate the true distribution more accurately than single models , with least number of loses . The weighted ensemble could achieve higher accuracy than single model classifier but still has larger variance and worse average performance compared with AP . For example , the highest normalized MSE of AP is only around 0.6 , but over 0.8 for weighted ensemble approach .
In Table 4 , the results on the third data stream where the original order is maintained are reported . It seems that logistic regression is consistently worse than the other two base learners , which wins only once , whereas DT and SVM win 7 and 10 times respectively . In general , the ensemble approaches ( SV and AP ) still predict well , win 9 times and lose twice . Unlike the synthetic stream where distribution evolves quickly and no uniformly best classifier could be derived , this data set may have certain characteristics that favor one classifier over another . This property could be observed and analyzed from the data set and regarded as prior knowledge . We could incorporate such knowledge into each base learner and further improve a single model . In this case , if we know that logistic regression is not suitable for this data and expected to perform bad , we could construct an ensemble based on multiple samples from the training data using decision tree and SVM as the base learners . In this experiment , we build 10 base models from 10 samples of the original data and combine their outputs by averaging the probabilities . As shown in Table 5 , the ensemble based on multiple samples ( denoted as APS ) , boosts the accuracy from 0.8508 ( accuracy of the best single classifier ) to 0.8579 and reduces the MSE from 0.1492 down to 01301 When counting the number of wins and loses , APS is the best compared with single models and other ensemble approaches . It should be noted that we are not against the ensemble based on multiple learning algorithms . Logistic regression is not working on this data set but may perform good on others , when we know nothing about the data set , ensemble based on multiple learning algorithms is the safest way for prediction . The key point here is that ensemble demonstrates its strengths no matter we know nothing or something about the stream data . Regardless of the baseline models , the averaging ensemble framework is expected to generate the best estimate of the true target function from the limited information conveyed by training examples .
4 . Related Work
Sample selection bias [ 13 ] investigates the effect on learning accuracy when the training data is a “ biased ” sample of the true distribution . Although the true target function to be modeled , P ( y|x ) , does not “ explicitly ” change , its value can be wrong in various ways in the biased training data . Previously , decision tree based model averaging has been shown to be helpful to correct feature bias or the bias where the chance to sample an example into the training set is independent on y given x [ 13 ] . The most important difference of our work from these previous studies is : ( 1 ) P ( y|x ) in our problem is allowed to explicitly change and can change significantly , ( 2 ) changes in P ( y|x ) are combined with changes in P ( x ) . To consider the significance of our work under sample selection bias formulation , our comprehensive results significantly extend the previous work and demonstrate that model averaging can reliably correct sample selection bias where biased conditional probability is quite different from unbiased testing data .
5 . Conclusions
We demonstrate that assuming training and testing data follow the same distribution , as commonly held by much existing work , is inappropriate for practical streaming systems . On the contrary , the distributions on both feature vector and class label given feature vector can evolve in some unknown manner , and models matching training distribution well may perform poorly in continuously changing distributions . As a result , the difference between training and testing distributions needs to be taken into account . We also argue that , contrary to common practice , in order to design robust and effective stream mining algorithms against changes , an appropriate methodology is not to overly match the training distribution , such as by weighted voting or weighed averaging where the weights are assigned according to training distribution . On these basis , we use both model averaging of conditional probability estimators and simple voting of class labels as a robust framework “ against change ” and argue that weighted averaging/voting are inappropriate . We demonstrate both formally and empirically such a framework can reduce expected errors and give the best performance on average when the test data does not follow the same distribution as the training data . Among many experiments , in a test on KDDCup’99 intrusion detection dataset , the framework ’s predictions are the most accurate in 49 out of 49 competitions , whereas the best baseline model is the most accurate only 18 times . The baseline models are not limited to those used in the empirical evaluations and other more sophisticated methods can be plugged in . Since the property of expected error reduction is proved formally , the framework is expected to have robust and better performance regardless of chosen baseline models . Nonetheless , for stream mining research in general , practitioners and researchers ought to clearly specify the training and testing assumptions made in the algorithms , and evaluation benchmarks ought to be designed with these assumptions clearly considered .
References
[ 1 ] C . Aggarwal , J . Han , J . Wang , and P . S . Yu . On demand classification of data streams . In Proc . KDD’04 , pages 503– 508 .
[ 2 ] W . Fan . Systematic data selection to mine concept drifting data streams . In Proc . KDD’04 , pages 128–137 .
[ 3 ] J . Gao , W . Fan , J . Han , and P . Yu . A general framework for mining concept drifting data streams with skewed distributions . In Proc . SDM’07 .
[ 4 ] G . Hulten , L . Spencer , and P . Domingos . Mining time changing data streams . In Proc . KDD’01 , pages 97–106 .
[ 5 ] D . Kifer , S . Ben David , and J . Gehrke . Detecting change in data streams . In Proc . VLDB’04 , pages 180–191 .
[ 6 ] R . Klinkenberg and T . Joachims . Detecting concept drift In Proc . ICML’00 , pages with support vector machines . 487–494 .
[ 7 ] J . Kolter and M . Maloof . Using additive expert ensembles to cope with concept drift . In Proc . ICML’05 , pages 449–456 . [ 8 ] M . Scholz and R . Klinkenberg . An ensemble classifier for drifting concepts . In Proc . ECML/PKDD’05 Workshop on Knowledge Discovery in Data Streams .
[ 9 ] H . Wang , W . Fan , P . Yu , and J . Han . Mining concept drifting data streams using ensemble classifiers . In Proc . KDD’03 , pages 226–235 .
[ 10 ] G . Widmer and M . Kubat . Learning in the presence of concept drift and hidden contexts . Machine Learning , 23:69– 101 , 1996 .
[ 11 ] I . Witten and E . Frank . Data Mining : Practical machine learning tools and techniques . Morgan Kaufmann , 2005 .
[ 12 ] Y . Yang , X . Wu , and X . Zhu . Combining proactive and reactive predictions for data streams . In Proc . KDD’05 , pages 710–715 .
[ 13 ] B . Zadrozny . Learning and evaluating classifiers under sam ple selection bias . In Proc . ICML’04 .
