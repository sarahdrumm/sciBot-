Scalable Histograms on Large Probabilistic Data
Mingwang Tang and Feifei Li
School of Computing , University of Utah , Salt Lake City , USA
{tang , lifeifei}@csutahedu
ABSTRACT Histogram construction is a fundamental problem in data management , and a good histogram supports numerous mining operations . Recent work has extended histograms to probabilistic data [ 5–7 ] . However , constructing histograms for probabilistic data can be extremely expensive , and existing studies suffer from limited scalability [ 5–7 ] . This work designs novel approximation methods to construct scalable histograms on probabilistic data . We show that our methods provide constant approximations compared to the optimal histograms produced by the state of the art in the worst case . We also extend our methods to parallel and distributed settings so that they can run gracefully in a cluster of commodity machines . We introduced novel synopses to reduce communication cost when running our methods in such settings . Extensive experiments on large real data sets have demonstrated the superb scalability and efficiency achieved by our methods , when compared to the state ofthe art methods . They also achieved excellent approximation quality in practice .
1 .
INTRODUCTION
In many applications , uncertainty naturally exists in the data due to a variety of reasons . For instance , data integration and data cleaning systems produce fuzzy matches [ 10 , 21 ] ; sensor/RFID readings are inherently noisy [ 4 , 9 ] . Numerous research efforts were devoted to represent and manage data with uncertainty in a probabilistic database management system [ 18,21 ] . Many interesting mining problems have recently surfaced in the context of uncertain data eg , mining frequent pattern and frequent itemset [ 1 , 3 , 24 ] . In the era of big data , along with massive amounts of data from different application and science domains , uncertainty in the data is only expected to grow with larger scale .
Histograms are important tools to represent the distribution of feature(s ) of interest ( eg , income values ) [ 15 , 19 ] . Not surprisingly , using the possible worlds semantics [ 8 , 21 ] , histograms are also useful tools in summarizing and working
1 with probabilistic data [ 5–7 ] . Given that answering queries with respect to all possible worlds is in #P complete complexity [ 8 ] , obtaining a compact synopsis or summary of a probabilistic database is of essence for understanding and working with large probabilistic data [ 5–7 ] . For example , they will be very useful for mining frequent patterns and itemsets from big uncertain data [ 1 , 3 , 24 ] .
Cormode and Garofalakis were the first to extend the wellknown V optimal histogram ( a form of bucketization over a set of one dimension values ) [ 15 ] , and wavelet histogram [ 16 ] to probabilistic data [ 6,7 ] , followed by the work by Cormode and Deligiannakis [ 5 ] . Note that histogram construction can be an expensive operation , even for certain data , eg , the exact algorithm for building a V optimal histogram is based on a dynamic programming formulation , which runs in O(Bn2 ) for constructing B buckets over a domain size of n [ 15 ] . Not surprisingly , building histograms on probabilistic data is even more challenging . Thus , existing methods [ 5–7 ] do not scale up to large probabilistic data , as evident from our analysis and experiments in this work .
Thus , this work investigates the problem of scaling up histogram constructions in large probabilistic data . Our goal is to explore quality efficiency tradeoff , when such tradeoff can be analyzed and bounded in a principal way . Another objective is to design methods that can run efficiently in parallel and distributed fashion , to further mitigate the scalability bottleneck using a cluster of commodity machines . Overview . A probabilistic database characterizes a probability distribution of an exponential number of possible worlds , and each possible world is a realization ( deterministic instance ) of the probabilistic database . Meanwhile , the query result on a probabilistic database essentially determines a distribution of possible query answers across all possible worlds . Given the possible worlds semantics , especially for large probabilistic data , approximate query answering based on compact synopsis ( eg , histogram ) is more desirable in many cases , eg , cost estimations in optimizers and approximate frequent items [ 3 , 5–7 , 21 , 24 , 26 ] .
Conventionally , histograms on a deterministic database seek to find a set of constant bucket representatives for the data distribution subject to a given space budget of buckets and an error metric . Building histograms on deterministic databases has been widely explored and understood in the literature . In probabilistic databases , building the corresponding histograms need to address the following problems : ( I ) how to combine the histograms on each possible world ; ( II ) how to compute the histogram efficiently without explicitly instantiating all possible worlds .
One meaningful attempt is building histograms that seek to minimize the expected error of a histogram ’s approximation of item frequencies across all possible worlds , using an error metric , which was first proposed in [ 6 , 7 ] . One concrete application example might be estimating the expected result size of joining two probabilistic relations based on the corresponding histograms , or evaluating queries asking for an expected value approximately .
It is important to note that for many error metrics , this histogram is not the same as simply building a histogram for expected values of item frequencies ; and the latter always provides ( much ) worse quality in representing the probabilistic database with respect to a number of commonly used error metrics , as shown in [ 6 , 7 ]
Based on this definition , a unified dynamic programming ( DP ) framework of computing optimal histograms on the probabilistic data was proposed in [ 6 , 7 ] with respect to various kinds of error metrics . Specifically , for the widely used sum of square error ( SSE ) , it costs O(Bn2 ) time where B is the number of buckets and n is the domain size of the data . Immediately , we see that the optimal histogram construction suffers from quadratic complexity with respect to the domain size n . For a domain of merely 100 , 000 values , this algorithm could take almost a day to finish and render it unsuitable for many data sets in practice . Summary of contributions . Inspired by these observations , we propose constant factor approximations for histograms on large probabilistic data . By allowing approximations , we show that it is possible to allow users to adjust the efficiency quality tradeoff in a principal manner .
We propose a novel “ partition merge ” method to achieve this objective . We introduce “ recursive merging ” to improve the efficiency , while the histogram quality achieved will not significantly deviate from the optimal version . We also devise novel synopsis techniques to enable distributed and parallel executions in a cluster of commodity machines , to further mitigate the scalability bottleneck . To that end , • We review the problem of histogram constructions on probabilistic data in Section 2 , and highlight the limitations in the state of the art . • We design Pmerge in Section 3 , which gives constantfactor approximations and scales up the histogram construction on large probabilistic data . Pmerge uses a “ partition merge ” approach to realize efficiency quality It also admits “ recursive merging ” to allow tradeoff . further efficiency quality tradeoff . • We extend our investigation to distributed and parallel settings in Section 4 , and introduce novel synopsis methods to support computation and communicationefficient execution of our methods in distributed and parallel fashion in Section 5 . • We conduct extensive experiments on large datasets in Section 6 . The results suggest that our approximation methods have achieved significant ( orders of magnitude ) run time improvement compared to the state ofthe art approach . They do so without sacrificing the quality of the resulting histograms , compared to the optimal constructions .
In addition , we survey other related works in Section 7 and conclude the paper in Section 8 . Unless otherwise specified , proofs of theorems and lemmas were omitted due the space constraint and for brevity ; they are available in Appendix B of our online technical report [ 25 ] .
2
2 . BACKGROUND AND STATE OF THE ART Uncertain data models . Sarma et al . [ 20 ] describes various models of uncertainty , varying from the simplest basic model to the ( very expensive ) complete model that can describe any probability distribution of data instances .
Basic model is a over simplification with no correlations . Existing work on histograms on uncertain data [ 5–7 ] adopted two popular models that extend the basic model , ie , the tuple model and the value model , and compared their properties and descriptive abilities . The tuple and value models are two common extensions of the basic model in terms of the tuple and attribute level uncertainty [ 20 ] , that were extensively used in the literature ( see discussion in [ 5–7] ) . Without loss of generality , we consider that a probabilistic database D contains one relation ( table ) . We also concentrate on the one dimension case or one attribute of interest .
Definition 1 The tuple model was originally proposed in TRIO [ 2 ] . An uncertain database D has a set of tuples τ = {tj} . Each tuple tj has a discrete probability distribution function ( pdf ) of the form(tj1 , pj1 ) , . . . , ( tjj , pjj )ff , spec ifying a set of mutually exclusive ( item , probability ) pairs . Any tjk , for k ∈ [ 1 , j ] , is an item drawn from a fixed domain and pjk is the probability that tj takes the value tjk in the jth row of a relation .
When instantiating this uncertain relation to a possible world W , each tuple tj either draws a value tjk with probability pjk or generates no item with probability of 1 − k=1 pjk . The probability of a possible world W is sim j ply the multiplication of the relevant probabilities .
Definition 2 The value model is a sequence τ of independent tuples . Each tuple gives the frequency distribution of a distinct item of the form j : fj = ( (fj1 , pj1 ) , . . . , ( fjj , pjj ) ) . Here , j is an item drawn from a fixed domain ( eg , source IP ) and its associated pdf fj describes the distribution of j ’s possible frequency values . In particular , Pr[fj = fjk ] = pjk where fjk is a frequency value from a frequency value domain V ; fj is subject to jk pjk ≤ 1 for k ∈ [ 1 , j ] . When it the constraint that
1 −j is less than 1 , the remaining probability corresponds that the item ’s frequency is zero . When instantiating this uncertain relation to a possible world W , for an item j , its frequency fj either takes a frequency value fjk with probability pjk or takes zero as its frequency value with probability k=1 pjk . So the probability of a possible world W is computed as the multiplication of the possibilities of fj ’s taking the corresponding frequency in each tuple . 2.1 Histograms on probabilistic data Without loss of generality , in both models , we consider the items are drawn from the integer domain [ n ] = {1 , , n} and use W to represent the set of all possible worlds . Let N be the size of a probabilistic database , ie , N = |τ| . For an item i ∈ [ n ] , gi is a random variable for the distri bution of i ’s frequency over all possible worlds , i.e , gi = {(gi(W ) , Pr(W ))|W ∈ W} ,
( 1 ) where gi(W ) is item i ’s frequency in a possible world W and Pr(W ) is the possibility of W .
Example 1 Consider an ordered domain [ n ] with three items {1 , 2 , 3} for both models , ie , n = 3 . 2 )} in the tuple 3 ) , ( 2 , 1
The input τ = {(1 , 1
2 ) , ( 3 , 1 model defines eight possible worlds :
4 ) , ( 3 , 1
W
Pr(W )
∅
1 24
1 1 8
2 1 24
3 1 6
1 , 2
1 , 3
2 , 3
3 , 3
1 8
1 4
1 12
1 6
The input τ = {1 : ( 1 , 1
3 ) , 3 : ( (1 , 1 in the value model defines eight possible worlds :
2 ) , 2 : ( 1 , 1
2 ) , ( 2 , 1
2 ))}
W
Pr(W )
3 1 6
1 , 3 2 , 3 3 , 3 1 , 2 , 3
1 , 3 , 3
2 , 3 , 3 1 , 2 , 3 , 3
1 6
1 12
1 6
1 12
1 6
1 12
1 12
3 ) , ( 1 , 1
2 ) , ( 2 , 1
Consider the tuple model example from above and denote the eight possible worlds ( from left to right ) as W1 , . . . , W8 . It ’s easy to see that g3(W ) = 1 for W ∈ {W4 , W6 , W7} , g3(W ) = 2 for W ∈ {W8} and g3(W ) = 0 on the rest . Thus , the frequency random variable g3 of item 3 is g3 = 6 )} with respect to W in this example . {(0 , 1 2 )} over Meanwhile , it ’s also easy to see g3 = {(1 , 1 W in the value model example from above . Definition 3 A B buckets representation partitions domain [ n ] into B non overlapping consecutive buckets ( sk , ek ) for k ∈ [ 1 , B ] , where s1 = 1 , eB = n and sk+1 = ek + 1 . Frequencies within each bucket bk are approximated by a single representativebk and we represent it as bk = ( sk , ek,bk ) .
2 ) , ( 2 , 1
The B buckets histogram achieving the minimal SSE error for approximating a deterministic data distribution is known as the V optimal histogram [ 14 ] . It can be found using a dynamic programming formulation in O(Bn2 ) time [ 15 ] , where n is the domain size of the underlying data distribution . We denote this method from [ 15 ] as the OptVHist method . To extend histogram definitions to probabilistic data , we first consider a single possible world W ∈ W for a probabilistic data set D , where W is a deterministic data set . Hence , the frequency vector of W is given by G(W ) = {g1(W ) , , gn(W )} ( recall that gi(W ) is item i ’s frequency in W ) . Given a B buckets representation for approximating G(W ) , the SSE of a bucket bk in the world W is given as :
SSE(bk , W ) = ek buckets representation in W is simplyB
( gj(W ) −bk)2 . The SSE of the B k=1 SSE(bk , W ) .
Cormode and Garofalakis have extended B buckets histogram to probabilistic data [ 6 , 7 ] by asking for the minimal expected SSE . Formally , Definition 4 Given the ( uncertain ) frequency sequence of random variables {g1 , . . . , gn} as defined in ( 1 ) , the problem seeks to construct a B buckets representation ( typically B n ) such that the expected SSE over all possible worlds is minimized , ie , the histogram with the value given by : j=sk k=1 j=sk k=1 j=sk
Consequently , the optimal histogram could be derived by a dynamic programming formulation as follows :
H(i , j ) = min 1≤<i
H( , j − 1 ) + minb
( 4 ) where H(i , j ) represents the minimal error from the optimal j buckets histogram on interval [ 1 , i ] ; minb( + 1 , i,b ) is the [ + 1 , i ] using a single representative valueb . minimal bucket error for the bucket spanning the interval
( + 1 , i,b ) ,
H(n , B ) = min{EW
 B ek
( gj −bk)2
EW
 B  =
B k=1 ek j=sk
}
( gj −bk)2  ek
 .
( gj −bk)2
EW
( 2 )
( 3 )
In ( 2 ) , the expectation of the sum of bucket errors is equal to the sum of expectations of bucket errors [ 6 , 7 ] , ie ,
Previous work [ 6 , 7 ] showed that the cost of the optimal histogram is O(Bn2 ) and minb(+1 , i,b ) could be computed in constant time using several precomputed prefix sum arrays which we will describe in the following subsection . We dub this state of art method from [ 7 ] the OptHist method . 2.2 Efficient computation of bucket error
Cormode and Garofalakis [ 7 ] show that , for SSE , the min imal error of a bucket b = ( s , e,b ) is achieved by setting the fi . The corresponding representativeb = 1 e−s+1 EW e
SSE(s , e,b ) = In order to answer the minb(s , e,b ) query in ( 4 ) for any bucket error is given by :
.e e − s + 1
( s , e ) values in constant time , prefix sum arrays of EW [ g2 i ] and EW [ gi ] in equation ( 5 ) are precomputed as follows ( details can be found in [ 7] ) : e
EW [ g2 i ] − i=s gi
EW [ gi]2 .
( 5 ) i=s i=s
1 e e i=1 i=1 i=1 i ] =
A[e ] =
EW [ g2
( VarW [ gi ] + EW [ gi]2 ) B[e ] = tuple model : EW [ gi ] = value model : EW [ gi ] = tj∈τ Pr[tj = i](1 − Pr[tj = i] ) . = Set A[0 ] = B[0 ] = 0 , then the minimal SSE minb(s , e,b )
( vj − EW [ gi])2 Pr[gi = vj ] tj∈τ Pr[tj = i ] and VarW [ gi ] = vj Pr[gi = vj ] and VarW [ gi ]
EW [ gi ] ( 6 ) vj∈V vj∈V for both models is computed as : e
A[e ] − A[s − 1 ] − ( B[e ] − B[s − 1])2
. e − s + 1
In both models , in addition to the O(Bn2 ) cost as shown in last subsection , it also takes O(N ) cost to compute the A , B arrays ( N = |τ| , number of probabilistic tuples ) .
3 . APPROXIMATE HISTOGRAMS
The state of the art OptHist method from [ 7 ] is clearly not scalable , when given larger domain size . A baseline method . A natural choice is to consider computing a B buckets histogram for the expected frequencies of all items . Note that this histogram is not the same as the desired histogram as defined in ( 2 ) and equation ( 3 ) since in general E[f ( X ) ] does not equal f ( E[X ] ) for arbitrary function f and random variable X .
However , we can show in our histogram , the SSE error of a bucket [ s , e ] usingb as its representative is : SSE(s , e,b ) = EW [
( gi −b)2 ] =
( EW [ g2 e e i ] − 2EW [ gi]b +b2 ) . i=s i=s e e
On the other hand , if we build a B buckets histogram over the expected frequencies of all items , the error of a bucket [ s , e ] using ¯b as its representative is : i=s i=s
SSE(s , e , ¯b ) =
Note that we if ask the two histograms to use the same bucket configurations ( ie , buckets from the two histograms
( (EW [ gi])2−2EW [ gi]¯b+¯b2 ) . ( EW [ gi]−¯b)2 = share the same boundaries and b = ¯b for every bucket ) , the two histograms differ by e e i ] − ( EW [ gi])2 ) = j=s VarW [ gi ] on a bucket [ s , e ] . Hence the overall errors j=s(EW [ g2
3 of the two histograms differ by constant , when using the same bucket configurations . i∈[n ] VarW [ gi ] which is a Given this and computing the expected frequencies of all items can be done in O(N ) time , computing the optimal Bbuckets histogram for them ( now a deterministic frequency vector ) still requires the OptVHist method from [ 15 ] , taking O(Bn2 ) for a domain of size n , which still suffers the same scalability issue .
A natural choice is to then use an approximation for the B buckets histogram on expected frequencies ( essentially a V optimal histogram ) , as an approximation for our histogram . The best approximation for a V optimal histogram is an ( 1 + ε) approximation [ 23 ] ( in fact , to the best of our knowledge , it is the only method with theoretical bound on approximation quality ) . But when using approximations , one cannot guarantee that the same bucket configurations will yield the same approximation bound with respect to both histograms . So its theoretical guarantee is no longer valid with respect to our histogram . Nevertheless , it is worth comparing to this approach as a baseline method , which is denoted as the EF Histogram method . 3.1 The Pmerge method
Hence , we search for novel approximations that can provide error guarantees on the approximation quality and also offer quality efficiency tradeoff , for the histograms from [ 6,7 ] as defined in ( 2 ) . To that end , we propose a constant approximation scheme , Pmerge , by leveraging a “ partition merge ” principle . It has a partition phase and a merge phase . Partition . The partition phase partitions the domain [ n ] into m equally sized sub domains , [ s1 , e1 ] , . . . , [ sm , em ] where s1 = 1 , em = n and sk+1 = ek + 1 . For the kth subdomain [ sk , ek ] , we compute the A , B arrays on this domain as Ak , Bk for k ∈ [ 1 , m ] . Ak and Bk are computed using [ sk , ek ] as an input domain and equation ( 6 ) for the value and the tuple models respectively , Next , for each sub domain [ sk , ek ] ( k ∈ [ 1 , m] ) , we apply the OptHist method from [ 7 ] ( as reviewed in Section 2.1 ) over the Ak , Bk arrays to find the local optimal B buckets histogram for the kth sub domain . The partition phase produces m local optimal B buckets histograms , which lead to mB buckets in total . Merge . The goal of the merge phase is to merge the mB buckets from the partition phase into optimal B buckets in terms of the SSE error using one merging step . To solve this as having ( e − s + 1 ) items with identical frequency value problem , naively , we can view an input bucket b = ( s , e,b ) b . Then , our problem reduces to precisely constructing an O(B(mB i=1 ( ei − si + 1))2 ) using the OptVHist method ,
V optimal histogram instance [ 15 ] . But the cost will be which is simply O(Bn2 ) .
A critical observation is that by using a weighted representation for each input bucket , we can effectively reduce the domain size while maintaining the same semantics . In particular , a bucket b = ( s , e,b ) can also be viewed as a single weighted frequencyb with a weight of ( e − s + 1 ) .
Formally , let Y = mB . A weighted frequency vector {f1 , f2 , . . . , fY } on an ordered domain [ Y ] has a weight wi for each fi . It implies wi items with a frequency fi at i . The weighted version of the V optimal histogram seeks to construct a B buckets histogram such that the SSE between these buckets and the input weighted frequency vector is
Figure 1 : An example of Pmerge : n = 16 , m = 4 , B = 2 . minimized . This problem is the same as finding :
Hw(Y , B ) = min{ B ek wj(fj −bk)2} , k=1 j=sk where s1 = 1 and eB = Y . The optimal B buckets can be derived by a similar dynamic programming formulation as that shown in equation ( 4 ) . The main challenge is to compute the optimal one bucket minb(s , e,b ) for any interval
[ s , e ] now in the weighted case . We show in Appendix A how to do this efficiently using several prefix sum arrays . Thus the weighted optimal B buckets histogram can be derived by filling a Y × B matrix , and each cell ( i , j ) takes O(Y ) time . Thus , the weighted B buckets histogram is computed in O(BY 2 ) = O(m2B3 ) time , which is much less than O(Bn2 ) since both B and m are much smaller than n . An example . An example of Pmerge is given in Figure 1 , where n = 16 , B = 2 , and m = 4 . To ensure clarity , we show only two possible worlds W1 ( blue circle ) and W2 ( green triangle ) from the set of possible worlds W of this database . In the partition phase , each sub domain of size 4 is approximated by 2 local optimal buckets . In total , the partition phase has produced 8 buckets in Figure 1 . In the merge phase , each input bucket maps to a weighted frequency as discussed above . For example , the first bucket covering frequencies in [ 1 , 2 ] represents a weighted frequency of 1.8 with weight 2 . These 8 buckets were merged into two buckets as the final output . Complexity analysis . In the partition phase , it takes linear time to compute the corresponding Ak , Bk arrays within each sub domain [ sk , ek ] for k ∈ [ 1 , m ] , following the results from [ 7 ] . The size of sub domain [ sk , ek ] is roughly n/m for k ∈ [ 1 , m ] . It takes O(Bn2/m2 ) to run the OptHist method on Ak , Bk to find the kth local optimal B buckets histogram . Next , the merge phase takes only O(B3m2 ) time as analyzed above . Hence ,
Lemma 1 Pmerge takes O(N + Bn2/m + B3m2 ) . 3.2 Approximation quality
In order to evaluate the absolute value of the histogram approximation error , we adopt the 2 distance ( square root of SSE error ) between the data distribution and the histogram synopsis . Next , we show the approximation quality of Pmerge compared to the optimal B buckets histogram found by OptHist in terms of the 2 distance . Theorem 1 Let H(n , B)2 and HPmerge(n , B)2 be the 2 norm of the SSE for the B buckets histogram produced by OptHist and Pmerge respectively a domain [ n ] . Then , HPmerge(n , B)2 < 3.17 · H(n , B)2 .
4
123116w=24bucketsub domainboundary:frequencyinW1:frequencyinW223w=20domainvalue12307:weightedfrequencyw=3w=1w=1w=3w=3w=1domainvalue5689101112131415partitionphasemergephase11642375689101112131415frequency m + B3
3.3 Recursive Pmerge
Note that the problem size of mB in the merge phase of Pmerge may still be too large to be handled efficiently by a DP method . Fortunately , we can further improve the efficiency by doing “ recursive merging ” as follows .
First of all , the partition phase will partition the input domain into m equal sized sub domains , instead of only m sub domains , for some integer ( user specified ) .
The merge phase now recursively merges the mB buckets from the partition phase into B buckets using iterations . Each iteration reduce the number of input buckets by a factor of m by applying a sequence of merging steps . Specifically , each merging step merges mB consecutive buckets ( from left to right ) from the current iteration into B buckets in the next iteration , which is done using the same merging step from the standard Pmerge method ( ie , using the weighted B buckets histogram idea ) . We dub the recursive Pmerge methods RPmerge .
Extending the analysis from Lemma 1 and Theorem 1 gives the following result , wrt the 2 norm of the SSE :
Theorem 2 Using O(N + B n2 i=1 m(i+1 ) ) time , the RPmerge method gives a 3.17 approximation of the optimal B buckets histogram found by OptHist .
It is important to note that the approximation bounds in both Theorems 1 and 2 reflect the worst case analysis . The extreme cases leading to the worst case bounds are almost impossible in real data sets . In practice , Pmerge and its recursive version RPmerge always provide ( very ) close to optimal approximation quality ( much better than what these worst case bounds indicate ) , as shown in our experiments .
4 . DISTRIBUTED AND PARALLEL Pmerge Pmerge allows efficient execution in a distributed and parallel framework . In the partition phase , each sub domain can be handled independently in parallel .
The recursive Pmerge offers even more venues for parallelism . In this case , its merge phase can also run in a distributed and parallel fashion , since each merging step from every iteration can be processed independently .
Next , we’ll address the challenge on computing the local Ak , Bk arrays efficiently for each subdomain [ sk , ek ] in a distributed and parallel setting . For both models , we assume that the underlying probabilistic database has been split into β chunks {τ1 , . . . , τβ} and stored in a distributed file system ( DFS ) . It is important to note that the input data is not necessarily sorted by the values of the items when stored into chunks in a DFS . 4.1 The partition phase in the value model
Recall that in the value model , fi is a pdf describing item i ’s possible frequency values and their associated probabilities . We first show that : Lemma 2 In the value model , Pr[gi = v ] = Pr[fi = v ] for any frequency value v ∈ V ( V is the domain of all possible frequency values ) .
Lemma 2 and equation ( 6 ) imply that :
A[j ] =j i ] , B[j ] =j i=1 E[f 2 i=1 E[fi ] .
Lemma 3 The A , B arrays for the value model also equal :
Without loss of generality , we assume β “ data nodes ( aka processes ) ” to consume the input data chunks , and also m
5
“ aggregate nodes/processes ” to produce the local optimal B buckets histograms . Each data chunk is processed by one data node in parallel . Each data node produces m partitions , each of which corresponds to a sub domain of size ( roughly ) n/m , using a partition function h : [ n ] → [ m ] , h(i ) = ( (cid:100)i/(cid:100)n/m ) .
The th data node processing chunk τ reads in tuples in τ in a streaming fashion . For each incoming tuple ( i , fi ) found in τ , it computes two values ( E[fi ] , E[f 2 i ] ) . It then writes a key value pair ( i , ( E[fi ] , E[f 2 i ] ) ) to the h(i)th partition . The h(i)th aggregate node will collect the h(i)th partitions from all β data nodes , the union of which forms the h(i)th subdomain of the entire data . Thus , the kth ( k ∈ [ 1 , m ] ) aggregate node will have all i ] ) ) for all i ∈ [ sk , ek ] in the the key value pairs ( i , ( E[fi ] , E[f 2 kth sub domain , if item i exists in the database ; otherwise it simply produces a ( i , ( 0 , 0 ) ) pair for such i ∈ [ sk , ek ] .
That said , the kth aggregate node can easily compute the Ak , Bk arrays for the kth sub domain using Lemma 3 . It then uses the OptHist method on Ak , Bk to produce the kth local optimal B buckets histogram . Clearly , all m aggregate nodes can run independently in parallel . 4.2 The partition phase in the tuple model
In the tuple model , the tuples needed to compute VarW [ gi ] and EW [ gi ] for each item i are distributed over β tuple chunks . Hence , we rewrite equation ( 6 ) for computing A , B arrays in the tuple model as follows :
Lemma 4 The A , B arrays in the tuple model can also be computed as :
A similar procedure as that described for the value model could then be applied . The difference is that the th data node processing chunk τ emits a key value pair ( i , ( EW,[gi ] , VarW,[gi] ) ) instead , for each distinct item i from the union of all possible choices of all tuples in τ . Thus , the kth aggregate node will reconstruct Ak , Bk arrays according to Lemma ( 4 ) and then use the OptHist method on Ak , Bk arrays to produce the local optimal B buckets histogram for the kth subdomain in the partition phase . 4.3 Recursive Pmerge and other remarks
The merge phase of the basic Pmerge method is a DP formulation and has to be executed in a centralized setting . But the recursive Pmerge method , RPmerge , offers more venues of parallelism . Specifically , we carry out the partition phase for each model using the method from Section 4.1 and Section 4.2 respectively . In the merge phase , we can easily invoke multiple independent nodes/processes to run all merging steps in one iteration in parallel .
In the remainder of this paper , we denote the distributed and parallel Pmerge and RPmerge methods as parallelPmerge and parallel RPmerge respectively .
5 . PARALLEL Pmerge WITH SYNOPSIS A paramount concern in distributed computation is the communication cost . The parallel Pmerge method may incur high communication cost for large domain size .
β
=1
A[j ] = j β where VarW,[gi ] = EW,[gi ] =
VarW,[gi ] + (
( =1 i=1 t∈τ t∈τ Pr[t = i ] . j
β
EW,[gi])2 ) B[j ] = EW,[gi ] , Pr[t = i](1 − Pr[t = i ] ) and
=1 i=1
This cost is O(n ) in the value model . Given a set τ of tuples in a value model database with size N = |τ| ; τ is stored in β distributed chunks in a DFS . Each tuple will produce a key value pair to be emitted by one of the data nodes . In the worst case N = n ( one tuple for each item of the domain ) , thus O(n ) cost . On the other hand , this cost is O(βn ) in the tuple mode . The worst case is when possible choices from all tuples in every distributed tuple chunk have covered all distinct items from the domain [ n ] .
There are only O(Bm ) bytes communicated in the merge phase of parallel Pmerge for both models , where every aggregate node sends B buckets to a single node for merging . Thus , the communication cost of parallel Pmerge is dominated by the partition phase .
We present novel synopsis to address this issue . The key idea is to approximate the Ak , Bk arrays at the kth aggre gate node ( k ∈ [ 1 , m ] ) with unbiased estimators Ak , Bk con structed by either samples or sketches sent from the data nodes . Since parallel Pmerge and parallel RPmerge share the same partition phase , hence , the analysis above and the synopsis methods below apply to both methods . 5.1 Sampling methods for the value model The VS method . One way of interpreting E[f 2 i ] and E[fi ] is treating each of them as an count of item i in the arrays Ak and Bk respectively . Then Ak[j ] and Bk[j ] in Lemma 3 can be interpreted as the rank of j , ie the number of appearance of items from [ sk , ek ] that are less than or equal to j in array Ak , Bk respectively . Using this view , we show how to construct an estimator Bk[j ] with the value model sampling method VS . The construction and results of Ak[j ] are similar .
Considering the th data node that processes the th tuple chunk τ , we first define T 1(i , ) = E[f 2 i ] and T 2(i , ) = E[fi ] respectively if ( i , fi ) ∈ τ ; otherwise we assign them as 0 . We then define Ak , , Bk , as follows , for every k ∈ [ 1 , m ] :
Ak,[j ] =
T 1(i , ) , Bk,[j ] = i=sk i=sk
T 2(i , ) , for any j ∈ [ sk , ek ] .
Using τ , the th data node can easily compute Ak , , Bk , locally for all k and j values . It ’s easy to get the following results at the kth aggregate node for any j ∈ [ sk , ek ] :
Ak[j ] =
Ak,[j ] , Bk[j ] =
=1
=1
Bk,[j ] , for any k ∈ [ 1 , m ] .
( 7 )
We view Bk,[j ] as the local rank of j from τ at the th data node . By ( 7 ) , Bk[j ] is simply the global rank of j that equals the sum of all local ranks from β nodes . We also let
Mk =ek
E[fj ] . j=sk
For every tuple ( i , fi ) from τ , data node unfolds ( con√ ceptually ) E[fi ] copies of i , and samples each i independently β/εMk ) , Θ(1/ε2Mk)} . with probability p = min{Θ( If a copy of i is sampled , it is added to a sample set Sk , where k = h(i ) , using the hash function in Section 41 If ci copies of i are sampled , we add ( i , 1 ) , . . . , ( i , ci ) into Sk , . The pairs of values in Sk , are sorted by the item values from the first term , and ties are broken by the second term . Data node sends Sk , to the kth aggregate node for k ∈ [ 1 , m ] .
We define the rank of a pair ( i , x ) in Sk,j as the number of pairs ahead of it in Sk,j , denoted as r((i , x) ) . For any j ∈ [ sk , ek ] and ∈ [ 1 , β ] , aggregate node k computes an
6 j
β j
β
=1
( 8 ) r((j , cj))/p + 1/p , if item j is present in Sk , . estimator Bk,[j ] for the local rank Bk,[j ] as : Bk,[j ] = of j in Sk , in terms of item values , then Bk,[j ] = Bk,[y ] + 1/p . If no predecessor exists , then Bk,[j ] = 0 .
If an item j ∈ [ sk , ek ] is not in Sk , , let y be the predecessor
Bk,[j ] .
It then estimates the global rank Bk[j ] for j ∈ [ sk , ek ] as :
β Bk[j ] = Lemma 5 Bk[j ] in ( 8 ) is an unbiased estimator of Bk[j ] and Var[Bk[e ] ] is O((εMk)2 ) . The communication cost is
,j p = O(min{√ β/ε , 1/ε2} ) for ∈ [ 1 , β ] and j ∈ [ sk , ek ] for aggregate node k in the √ worst case . Hence , the total communication cost in the parβ/ε , m/ε2} ) . tition phase of Pmerge with VS is O(min{m Note that {M1 , . . . , Mm} can be easily precomputed in O(mβ ) communication cost . 5.2 Sketching methods for the tuple model The TS ( tuple model sketching ) method . Observe that we can rewrite equations in Lemma 4 to get : j j We can view both j The challenge is to approximatej ( EW [ gi])2 , the second term of Ak[j ] in ( 9 ) . It is the second frequency moment ( F2 ) of {EW [ gsk ] , . . . , EW [ gj]} . Given that each EW [ gi ] is a
EW,[gi ] as a local rank of j in a separate local array computed from τ at the th data node . Thus , both the first term of Ak[j ] and the entire Bk[j ] in ( 9 ) become the same problem that can be effectively estimated by the VS method .
VarW,[gi ] and j
VarW,[gi ] +
β β
=1
EW,[gi])2
β
( =1 distributed sum and j varies over [ sk , ek ] , we actually need a distributed method to answer a dynamic F2 ( energy ) range query approximately on a sub domain [ sk , ek ] .
EW,[gi ] .
Bk[j ] = j i=sk
Ak[j ] =
=1 i=sk i=sk i=sk i=sk i=sk
( 9 )
Mk = ek
The key idea is to build AMS sketches [ 17 ] for a set of intervals from a carefully constructed binary decomposition on each sub domain locally at every data node . i=sk
For a sub domain [ sk , ek ] at the kth aggregate node , let ( EW [ gi])2 . The leaf level of the binary decomposition partitions [ sk , ek ] into 1/ε intervals , where each interval ’s F2 equals εMk . An index level ( recursively ) concatenates every two consecutive intervals from the level below to form a new interval ( thus , the height of this binary decomposition is O(log(cid:100 ) 1
ε ) . Figure 2(a ) illustrates this idea .
Figure 2 : Binary decomposition and local Q AMS . Once the ( 1
ε − 1 ) partition boundaries {αk,1 , . . . , αk , 1
ε −1} at the leaf level were found , aggregate node k sends them to all β data nodes . Each data node builds a set of AMS seF2=εM′′kF2=2εM′′kF2=M′′kEW[gαk,1]EW[gsk]EW[gek]EW,ℓ[gsk]EW,ℓ[gek]······(a)binarydecomposition(b)localQ AMSF2=εM′′kEW[gαk,1ε−1]EW,ℓ[gαk,1]EW,ℓ[gαk,1ε−1]F2=2εM′′k·········AMS·········AMSAMS sketches , one for each interval from the binary decomposition ( of all levels ) , over its local data . We denote it as the local Q AMS sketch ( Queryable AMS ) .
In other words , data node builds these AMS sketches using the following set of values {EW,[gsk ] , . . . , EW,[gek ]} as shown in Figure 2(b ) . Then data node sends its Q AMS sketch for [ sk , ek ] to the kth aggregate node , which combines the Q AMS sketches from all data nodes to obtain the global Q AMS sketch for the kth sub domain [ sk , ek ] , leveraging on the linearly mergeable property of each individual AMS sketch [ 12,17 ] . The global Q AMS sketch is equivalent to an directly ; recall that EW [ gi ] =β
Q AMS sketch that is built from {EW [ gsk ] , . . . , EW [ gek ]} For a query range ( s , e ) , sk ≤ s < e ≤ ek , we find the intervals that form the canonical cover of ( s , e ) in the global Q AMS sketch , and approximate ( EW [ gs])2 +···+(EW [ ge])2 by the summation of the F2 approximations ( from the AMS sketches ) of these intervals . If ( s , e ) is not properly aligned with an interval at the leaf level of an Q AMS sketch , we snap s and/or e to the nearest interval end point .
=1 EW,[gi ] .
δ ) [ 12 , 17 ] . Thus , we can show that :
The error from the snapping operation in the leaf level is at most O(εMk ) . By the property of the AMS sketch [ 17 ] , the approximation error of any AMS sketch in the global QAMS sketch is at most O(εF2(I) ) , with at least probability ( 1 − δ ) , for an interval I covered by that AMS sketch . Also F2(I ) ≤ Mk for any I in the global Q AMS sketch . Furthermore , there are at most O(log 1 ε ) intervals in a canonical cover since the height of the tree in Q AMS is log(cid:100 ) 1 ε . Hence , the approximation error for any range F2 query in the global Q AMS sketch is O(εMk log 1 ε ) with probability at least ( 1 − δ ) , for ε , δ ∈ ( 0 , 1 ) used in the construction of the Q AMS sketch . Finally , the size of an AMS sketch is O( 1 Lemma 6 Given the partition boundaries {αk,1 , . . . , αk , 1 ε −1} for a sub domain [ sk , ek ] , for any s , e such that sk ≤ s < e ≤ ek , Q AMS can approximate ( EW [ gs])2 + ( EW [ gs+1])2 + ···+(EW [ ge])2 within an additive error of O(εMk log 1 ε ) with probability ≥ ( 1 − δ ) using space of O( 1 Communication cost and partition boundaries . Each ε − 1 ) values per sub domain aggregate node needs to send ( 1 to all β data nodes , and there are m sub domains in total . So the communication cost of this step is O(mβ/ε ) . Then , each data node needs to send out m local Q AMS sketches , one for each sub domain . The communication cost of this step is O( mβ δ ) . Hence , the total communication is O( mβ ε3 ε3 log 1 δ ) , which caters for the worst case analysis . But the above method and analysis depend on the calcuε −1} for any lation of the partition boundaries {αk,1 , . . . , αk , 1 sub domain [ sk , ek ] , for k ∈ [ 1 , m ] . To calculate this exactly we need {EW [ gsk ] , . . . , EW [ gek ]} at the kth aggregate node , which obviously are not available ( unless using O(nβ ) total communication for m aggregate nodes for all sub domains , which defeats our purpose ) . Fortunately , recall that we can use VS to estimate Bk[j ] with an ε error efficiently ( in terms of both communication and computation ) . By ( 9 ) we can estimate EW [ gi ] at aggregate node k as ( Bk[i ] − Bk[i − 1] ) .
ε3 log 1
δ ) .
ε2 log 1 log 1 and parallel RPmerge methods ( with and without synopsis ) in distributed and parallel settings . The centralized experiments were executed over a Linux machine running a single Intel i7 3.2GHz cpu , with 6GB of memory and 1TB disk space . We then used MapReduce as the distributed and parallel programming framework and tested all methods in a Hadoop cluster with 17 machines ( of the above configuration ) running Hadoop 103 The default HDFS ( Hadoop distributed file system ) chunk size is 64MB . Datasets . We executed our experiments using the WorldCup data set and the SAMOS data set . The WorldCup data set is the access logs of 92 days from the 1998 World Cup servers , composed of 1.35 billion records . Each record consists of client id , file type and time of access etc . We choose the client id as the item domain , which has a maximum possible domain size of 2 , 769 , 184 . We vary the domain size of client ids from 10 , 000 up to 1 , 000 , 000 . Records in the entire access log are divided into continuous but disjoint groups , in terms of access time . We generate a discrete frequency distribution pdf for items within each grouping interval and assign the pdf to a tuple in the tuple model . For the value model , we derive a discrete pdf for each client id based on its frequency distribution in the whole log with respect to 13 distinct requested file types and assign the pdf to the tuple with that client id in the value model . The SAMOS data set is composed of 11.8 million records of various atmospheric measurements from a research vessel and we care about the temperature field , which has a domain size of about 10,000 ( by counting two digits after the decimal point of a fraction reading ) . In a similar way , we form the tuple model and value model data on the SAMOS data . Setup . The default data set is WorldCup . To accommodate the limited scalability of OptHist , we initially vary the value of n from 10 , 000 up to 200 , 000 and test the effects of different parameters . The default values of parameters are B = 400 and n = 100 , 000 . For RPmerge , the recursion depth is = 2 . We set m = 16 and m = 6 as the default values for Pmerge and RPmerge respectively . We then explore the scalability of our methods , up to a domain size of n = 1 , 000 , 000 . The running time of all methods are only linearly dependent on N , number of tuples in a database . Hence , we did not show the effect of N ; all reported running time are already start to end wall clock time .
In each experiment , unless otherwise specified , we vary the value of one parameter , while using the default values of other parameters . The approximation ratios of our approximate methods were calculated with respect to the optimal B buckets histogram produced by OptHist [ 6 , 7 ] . 6.1 Centralized environment
6 . EXPERIMENTS
( a ) m vs running time .
( b ) m vs approx . ratio .
We implemented all methods in Java . We test OptHist , EF Histogram , Pmerge and RPmerge methods in centralized environment without parallelism , and parallel Pmerge
Figure 4 : Vary m on the tuple model .
Effect of m . Figure 4 shows the running time and approximation ratio when we vary m from 4 to 20 on the tuple
7
468121620102103104valueofmTime(seconds ) PMergeRPMerge4681216201101102103valueofmApproximationratio PMergeRPMerge ( a ) Tuple model : running time . ( b ) Value model : running time . ( c ) Tuple model : approx . ratio . ( d ) Value model : approx . ratio .
Figure 5 : Approximation ratio and running time : vary n .
( a ) Tuple model : running time . ( b ) Value model : running time . ( c ) Tuple model : approx . ratio . ( d ) Value model : approx . ratio .
Figure 6 : Approximation ratio and running time : vary B . model data sets . Recall that Pmerge will produce m subdomains , while RPmerge will produce m sub domains , in the partition phase . Hence , RPmerge gives the same number of sub domains in the partition phase using a ( much ) smaller m value . For both methods , a larger m value will reduce the size of each sub domain in the partition phase , hence , reducing the runtime of the OptHist method within each sub domain and the overall cost of the partition phase . But a larger m value increases the cost of the merge phase . As a result , we expect to see a sweet point of the overall running time across all m values . Figure 4(a ) reflects exactly this trend and the same trend holds on the value model data set as well . They consistently show that m = 16 and m = 6 provide the best running time for Pmerge and RPmerge respectively . Note that this sweet point can be analytically analyzed , by taking derivative of the cost function ( partition phase + merge phase ) with respect to m .
Figure 4(b ) shows their approximation ratios on the tuple model data set . The approximation quality of both methods fluctuates slightly with respect to m ; but they both produce B buckets histograms of extremely high quality with approximation ratio very close to 1 . The quality is much better than their worst case theoretical bounds , as indicated by Theorems 1 and 2 respectively .
The results of varying m from the value model are very similarly , and have been omitted for brevity . Also , we have investigated the results of varying the recursive depth from 1 to 3 . They consistently show that = 2 achieves a nice balance between running time and approximation quality . For brevity , we ommited the detailed results . Effect of n . Figure 5 shows the results with respect to n on both value and tuple models . In both models , the running time of OptHist increases quadratically with respect to n . In contrast , both Pmerge and RPmerge are much more scalable , and have outperformed OptHist by at least one to two orders of magnitude in all cases . For example , in Figure 5(b ) , when n = 100 , 000 , OptHist took nearly 14 hours while RPmerge took only 861 seconds . RPmerge further improves the running time of Pmerge by about 2 3 times and is the most efficient method .
Meanwhile , both Pmerge and RPmerge achieve close to 1 approximation ratios across all n values in Figures 5(c ) and Figure 5(d ) . The approximation quality gets better ( approaching optimal ) as n increases on both models . Effect of B . We vary the number of buckets from 100 to 800 in Figure 6 . Clearly , RPmerge outperforms OptHist by two orders of magnitude in running time in both models , as see in Figures 6(a ) and 6(b ) . Figures 6(c ) and 6(d ) show the approximation ratios in each model respectively . The approximation ratio of both Pmerge and RPmerge slightly increases when B increases on both models . Nevertheless , the quality of both methods are still excellent , remaining very close to the optimal results in all cases .
( a ) Running time : WorldCup . ( b ) Approx . ratio : WorldCup .
( c ) Running time : SAMOS .
( d ) Approx . ratio : SAMOS .
Figure 7 : Comparison against the baseline method .
Comparison with the baseline . Lastly , we compare the running time and approximation ratios of our methods against the baseline EF Histogram method ( with ε = 0.1 , ε = 0.05 and ε = 0.01 respectively ) on two data sets . Our methods used their default parameter values on the WorldCup data set . For the SAMOS data set , we set n = 10 , 000 and B = 100 . Clearly , small ε values does help improve the approximation quality of EF Histogram as shown in Figure 7(b ) and Figure 7(d ) . But our methods have provided almost the same approximation quality on both data sets , while offering worst case bounds in theory as well . Note
8
1050100150200102104106domainsize:n(×103)Time(seconds ) OptHistPMerge RPMerge1050100150200102104106domainsize:n(×103)Time(seconds ) OptHistPMerge RPMerge10501001502001102104106108domainsize:n(×103)Approximationratio PMergeRPMerge1050100150200110001100021000310004domainsize:n(×103)Approximationratio PMergeRPMerge100200400600800102104numberofbuckets:BTime(seconds ) OptHistPMerge RPMerge100200400600800102104106numberofbuckets:BTime(seconds ) OptHistPMerge RPMerge1002004006008001101102103104105numberofbuckets:BApproximationratio PMergeRPMerge1002004006008001100011000210003numberofbuckets:BApproximationratio PMergeRPMerge102104106108Time Tuple ModelValue ModelPMergeRPMergeEF Histogram 01EF Histogram 005EF Histogram 0011101102Approximation ratio Tuple ModelValue ModelPMergeRPMergeEF Histogram 01EF Histogram 005EF Histogram 001246810Time Tuple ModelValue ModelPMergeRPMergeEF Histogram 01EF Histogram 005EF Histogram 00111000210004Approximation ratio Tuple ModelValue ModelPMergeRPMergeEF Histogram 01EF Histogram 005EF Histogram 001 ( a ) Tuple model : vary n .
( b ) Value model : vary n .
( c ) Tuple model : vary B .
( d ) Value model : vary B .
Figure 8 : Scalability of the parallel approximate methods . that EF Histogram only provides the ( 1 + ε ) approximation bound with respect to the B buckets histogram on expected frequencies , but not on the probabilistic histograms .
Meanwhile , the running time of EF Histogram increases significantly ( it is actually quadratic to the inverse of ε value , ie , 1/ε2 ) , especially on the much larger WorldCup data set . In all cases our best centralized method , RPmerge , has significantly outperformed the EF Histogram as shown in Figure 7(a ) and Figure 7(c ) . Furthermore , the distributed and parallel fashion of Pmerge and RPmerge further improves the efficiency of these methods , as shown next .
( a ) Tuple model .
( b ) Value model .
Figure 9 : Time : vary number of slave nodes .
6.2 Distributed and parallel setting Effect of size of the cluster . Figure 9 shows the running time of different methods when we vary the number of slave nodes in the cluster from 4 to 16 . For reference , we have included the running time of centralized Pmerge and RPmerge . We can see a ( nearly ) linear dependency between the running time and the number of slave nodes for both parallel Pmerge and parallel RPmerge methods . The speed up for both methods is not as much as the increasing factor of the number of slave nodes used . The reason is that Hadoop always includes some extra overhead such as job launching and tasks shuffling and IO cost of intermediate HDFS files , which reduces the overall gain from parallelism . Scalability . Next , we investigate the scalability of RPmerge ( the best centralized method ) , parallel Pmerge and parallel RPmerge on very large probabilistic data sets . We used all 16 slave nodes in the cluster , and varied either the values of n from 200,000 to 1000,000 when B = 400 , or the values of B from 100 to 800 when n = 600 , 000 . We omit OptHist and Pmerge methods in this study , since they are too expensive compared to these methods .
Figures 8(a ) and 8(b ) show that with recursive merging RPmerge can even outperform parallel Pmerge as n increases . But clearly parallel RPmerge is the best method and improves the running time of RPmerge by 8 times on the value model and 4 times on the tuple model when n = 1000 , 000 . It becomes an order of magnitude faster than parallel Pmerge in both models when n increases .
Figures 8(c ) and 8(d ) show the running time when we vary B and fix n = 600 , 000 . Running time of all methods increase with larger B values . This is because large B values increase the computation cost of the merging step , especially for recursive Pmerge . Nevertheless , parallel RPmerge significantly outperforms both parallel Pmerge and RPmerge in all cases on both models . 6.3 Distributed and parallel synopsis
Lastly , we study the communication saving and approximation quality of parallel Pmerge and parallel RPmerge with synopsis . The default values are n = 600 , 000 , B = 400 and ε = 0.002 for VS and ε = 0.1 for TS . We have omitted the results for the running time of Parallel Pmerge and Parallel RPmerge with synopsis , since they are very close to that of Parallel Pmerge and Parallel RPmerge respectively ( since the running time of all these methods are dominated by solving the DP instances in the partition and merging phases ) .
( a ) Communication .
( b ) Approximation ratio .
Figure 10 : Effects of using synopsis .
Comparing effects of synopsis in both models . Here we use parallel PmergeS ( parallel RPmergeS ) to denote a parallel Pmerge ( parallel RPmerge ) method with a synopsis in either model . In value model , the synopsis is VS ; and in tuple model , the synopsis is TS .
Figure 10(a ) shows that parallel PmergeS outperforms parallel Pmerge and parallel RPmerge by more than an order of magnitude in communication cost for both models . Parallel RPmergeS has much higher communication cost than parallel PmergeS since the sampling cost in the partition phase has increased by an order of m using m2 subdomains ( when = 2 ) . Nevertheless , it still saves about 2 3 times of communication cost compared to that of parallelPmerge and parallel RPmerge for both models .
Figure 10(b ) shows that parallel PmergeS and parallelRPmergeS have excellent approximation quality on the value model ( very close to optimal histograms ) . They give less optimal approximations in the tuple model , since Q AMS in the TS method has higher variances in its estimated A , B arrays in the tuple model , compared to the estimations on A , B arrays given by VS in the value model . Remarks . The communication cost of all of our synopsis methods are independent of n , whereas the communication
9
2004006008001000102103104105domainsize:n(×103)Time(seconds ) RPMergeParallel PMerge Parallel RPMerge2004006008001000102103104105domainsize:n(×103)Time(×102seconds ) RPMergeParallel PMerge Parallel RPMerge100200400600800102103104numberofbuckets:BTime(seconds ) RPMergeParallel PMerge Parallel RPMerge100200400600800102103104105numberofbuckets:BTime(seconds ) RPMergeParallel PMerge Parallel RPMerge481216100300500700900numberofslavenodesTime(seconds ) PMergeRPMerge Parallel PMergeParallel RPMerge481216100100020003000numberofslavenodesTime(seconds ) PMergeRPMerge Parallel PMergeParallel RPMerge105106107Communication ( bytes ) Value ModelTuple ModelParallel PMergeParallel RPMergeParallel PMergeSParallel RPMergeS115225Approximation ratio Value ModelTuple ModelParallel PMergeParallel RPMergeParallel PMergeSParallel RPMergeS cost of both parallel Pmerge and parallel RPmerge are linearly dependent on n , as shown from our analysis in Section 5 . This means the synopsis methods introduce even more savings when domain size increases . 7 . RELATED WORK
We have reviewed the most relevant related work in Section 2 . That said , extensive efforts were devoted to constructing histograms in deterministic data , motivated by the early work in [ 14–16,19 ] . An extensive survey for histograms on deterministic data is in [ 13 ] . There are also numerous efforts on modeling , querying , and mining uncertain data ; see [ 1 , 3 , 21 , 24 ] . A good histogram for large probabilistic data is very useful for many such operations , e.g , finding frequent items , patterns , and itemsets [ 1 , 3 , 24 , 26 ] .
However , little is known about histograms over probabilistic data till three recent studies [ 5–7 ] . Cormode and Garofalakis have extended the bucket based histogram and the wavelet histogram to probabilistic data by seeking to minimize the expectation of bucket errors over all possible worlds [ 6 , 7 ] . The details of which can be found in Section 2 . Cormode and Deligiannakis then extend the probabilistic histogram definition to allowing bucket with a pdf representation rather than a single constant value [ 5 ] . A main limitation of these studies is the lack of scalability , when the domain size of the probabilistic data increases .
Allowing some approximations in histogram construction is also an important subject on deterministic data , eg , [ 11 , 22 , 23 ] and many others . One possible choice is to run these methods on expected frequencies of all items , and simply use the output as an approximation to our histogram . But the theoretical approximation bound with respect to the deterministic data ( in our case , the expected frequencies of all items ) does not carry over to probabilistic histogram definition with respect to n random variables ( frequency distributions of every item i ) . To the best of our knowledge , the ( 1+ε ) approximation from [ 23 ] is the best method with theoretical guarantees for histograms over deterministic data ( in fact , to the best of our knowledge , other methods are mostly heuristic based approaches ) . We did explore this approach as a baseline method in our study . 8 . CONCLUSION
This paper designed novel approximation methods for constructing optimal histograms on large probabilistic data . Our approximations run much faster and have much better scalability than the state of the art . The quality of the approximate histograms are almost as good as the optimal histograms in practice . We also introduced novel techniques to extend our methods to distributed and parallel settings , which further improve the scalability . Interesting future work include but not limited to how to extend our study to probabilistic histograms with pdf bucket representatives [ 5 ] and how to handle histograms of other error metrics . 9 . REFERENCES [ 1 ] C . C . Aggarwal , Y . Li , J . Wang , and J . Wang . Frequent pattern mining with uncertain data . In SIGKDD , 2009 . [ 2 ] P . Agrawal , O . Benjelloun , A . D . Sarma , C . Hayworth ,
S . Nabar , T . Sugihara , and J . Widom . Trio : A system for data , uncertainty , and lineage . In VLDB , 2006 .
[ 3 ] T . Bernecker , H P Kriegel , M . Renz , F . Verhein , and
A . Zuefle . Probabilistic frequent itemset mining in uncertain databases . In SIGKDD , 2009 .
10
[ 4 ] R . Cheng , D . Kalashnikov , and S . Prabhakar . Evaluating probabilistic queries over imprecise data . In SIGMOD , 2003 .
[ 5 ] G . Cormode and A . Deligiannakis . Probabilistic histograms for probabilistic data . In VLDB , 2009 .
[ 6 ] G . Cormode and M . Garofalakis . Histograms and wavelets on probabilistic data . In ICDE , 2009 .
[ 7 ] G . Cormode and M . Garofalakis . Histograms and wavelets on probabilistic data . IEEE TKDE , 22(8):1142–1157 , 2010 .
[ 8 ] N . Dalvi and D . Suciu . Efficient query evaluation on probabilistic databases . In VLDB , 2004 .
[ 9 ] A . Deshpande , C . Guestrin , S . Madden , J . Hellerstein , and
W . Hong . Model driven data acquisition in sensor networks . In VLDB , 2004 .
[ 10 ] X . Dong , A . Y . Halevy , and C . Yu . Data integration with uncertainty . In VLDB , 2007 .
[ 11 ] P . B . Gibbons , Y . Matias , and V . Poosala . Fast incremental maintenance of approximate histograms . In VLDB , 1997 .
[ 12 ] M . G . Graham Cormode and D . Sacharidis . Fast approximate wavelet tracking on streams . In EDBT , 2006 .
[ 13 ] Y . E . Ioannidis . The history of histograms . In VLDB , 2003 . [ 14 ] Y . E . Ioannidis and V . Poosala . Balancing histogram optimality and practicality for query result size estimation . In SIGMOD , 1995 .
[ 15 ] H . V . Jagadish , N . Koudas , S . Muthukrishnan , V . Poosala ,
K . Sevcik , and T . Suel . Optimal histograms with quality guarantees . In VLDB , 1998 .
[ 16 ] Y . Matias , J . S . Vitter , and M . Wang . Wavelet based histograms for selectivity estimation . In SIGMOD , 1998 .
[ 17 ] Y . M . Noga Alon and M . Szegedy . The space complexity of approximating the frequency moments . In STOC , 1996 .
[ 18 ] J . Pei , M . Hua , Y . Tao , and X . Lin . Query answering techniques on uncertain and probabilistic data : tutorial summary . In SIGMOD , 2008 .
[ 19 ] V . Poosala , Y . E . Ioannidis , P . J . Haas , and E . J . Shekita .
Improved histograms for selectivity estimation of range predicates . In SIGMOD , 1996 .
[ 20 ] A . D . Sarma , O . Benjelloun , A . Y . Halevy , S . U . Nabar , and J . Widom . Representing uncertain data : models , properties , and algorithms . VLDBJ , 18(5):989–1019 , 2009 .
[ 21 ] D . Suciu , D . Olteanu , C . R´e , and C . Koch . Probabilistic
Databases . Synthesis Lectures on Data Management . 2011 .
[ 22 ] K . S . Sudipto Guha and J . Woo . Rehist : Relative error histogram construction algorithms . In VLDB , 2004 .
[ 23 ] N . K . Sudipto Guha and K . Shim . Approximation and streaming algorithms for histogram construction problems . TODS , 31(1):396–438 , 2006 .
[ 24 ] L . Sun , R . Cheng , D . W . Cheung , and J . Cheng . Mining uncertain data with probabilistic guarantees . In SIGKDD , 2010 .
[ 25 ] M . Tang and F . Li . Scalable histograms on large probabilistic data . In Technical report , http://wwwcsutahedu/∼lifeifei/papers/phpdf , 2014 . [ 26 ] Q . Zhang , F . Li , and K . Yi . Finding frequent items in probabilistic data . In SIGMOD , 2008 . e e k=s wkfk k=s wk and the corresponding bucket error for the
Appendix A : The Weighted Histogram Fast computation of bucket Error . We can show that in the weighted case the minb(s , e,b ) is achieved by setting b = bucket b is as follows : SSE(b,b ) =e j −b2 ) . The e Given these arrays , minb(s , e,b ) is computed as : j=s wj(f 2 prefix sum arrays need to be pre computed are : wj f 2 j , W [ e ] =
P [ e ] = wj fj , P P [ e ] = e i=1
P P [ e ] − P P [ s ] +
P [ e ] − P [ s ] W [ e ] − W [ s ]
. e i=1 wj . i=1
W ) . Clearly , we have Pr(gi = v ) =
Appendix B : Proofs Proof for Lemma 2 . Let Wi,v be the set of possible worlds in which gi(W ) = v ( recall gi(W ) is item i ’s frequency in Next , let τ = τ − ti ( τ is the set of tuples forming the database , and ti = {i , fi} is the ith tuple describing the possible frequency values for item i ) , and Wτ be the set of all possible worlds instantiated from τ . Clearly , for any W ∈ Wi,v , Pr[W ] = Pr[W in Wτ ] · Pr[fi = v ] where W = W − {all items i} . Hence , Pr(gi = v ) =
W∈Wi,v
Pr[W ] .
Pr[W ]
=
Pr[W ] · Pr[fi = v ] = Pr[fi = v ] .
Proof for Lemma 3 . The ith tuple ti = ( i , fi = {fi1 , . . . ,fii} ) of a value model tuple set τ specifies the possible frequency values of item i . When instantiating a possible world W from τ , gi(W ) must be in the set {fi1 , . . . , fii} or take a frequency of zero . Given this and Lemma 2 , we have
EW [ gi ] =
=
= gi(W ) Pr(W ) v Pr[gi = v ] = fij Pr[gi = fij ] fij Pr[fi = fij ] = E[fi ] .
Similarly , we can show EW [ g2 in equation ( 6 ) for the value model can be rewritten as : i ] . Hence , A , B arrays i ] = E[f 2
A[e ] =
E[f 2 i ] , B[e ] =
E[fi ] . i=1 i=1
Proof for Theorem1 . We denote the probabilistic frequency vector as F = {g1 , gn} ( from either the tuple or the value model ) . Letgi denote the representative of gi assigned by buckets from the OptHist method . Let ¯gi andgi be the representative of gi given by the buckets from the partition phase and the merge phase respectively in Pmerge . By definition , we have :
H(n , B ) =
HPmerge(n , B ) =
W∈W i=1 n ( gi(W ) −gi)2 Pr(W ) . n ( gi(W ) −gi)2 Pr(W ) .
W∈W i=1
Similarly , the histogram error for Pmerge is
By the optimality of the weighted histogram in the merge phase we must have n ( ¯gi −gi)2 ≤ n
( ¯gi −gi)2 .
( 11 ) i=1 i=1
Next , for any sub domain [ sk , ek ] ( k ∈ [ 1 , m ] ) in the partition phase , the optimality of the OptHist method [ 6 , 7 ] ensures that Pmerge always produces the optimal Bbuckets histogram for the probabilistic frequency vector Fk = {gsk , gsk+1 , . . . , gek} . On the other hand , there are at most
W∈Wi,v
W ∈Wτ
W∈W i v∈V j=1 e i j=1 e
B buckets falling into [ sk , ek ] to approximate Fk for the optimal B buckets histogram produced by running the OptHist method on the entire F . Thus , we have n ( gi(W ) − ¯gi)2 Pr(W ) ≤ n ( gi(W ) −gi)2 .
W∈W i=1
W∈W i=1
Finally , we also have :
Lemma 7 For any a , b , c ∈ R ,
( a − b)2 ≤ 2(a − c)2 + 2(c − b)2 .
( 12 )
( 13 )
Combining equations ( 11 ) , ( 12 ) , and ( 13 ) leads to : n ( gi(W ) −gi)2 Pr(W )
HPmerge(n , B)2
2 = i=1 i=1 i=1
W∈W
W∈W
W∈W
≤ n ( 2((gi(W ) − ¯gi)2 + ( ¯gi −gi)2 ) ) Pr(W ) by ( 13 ) n ≤ ( 2((gi(W ) − ¯gi)2 + ( ¯gi −gi)2 ) ) Pr(W ) by ( 11 ) n ≤ + 4(gi(W ) −gi)2 ) Pr(W ) n
( 6(gi(W ) − ¯gi)2 + 4(gi(W ) −gi)2 ) Pr(W ) n d(gi(W ),gi ) Pr(W )
( 2(gi(W ) − ¯gi)2 + 4(¯gi − gi(W )2
≤ 10 by ( 13 ) by ( 12 )
W∈W
W∈W i=1 i=1
=
W∈W i=1
= 10 · H(n , B)2 2 . Hence , HPmerge(n , B)2 < 3.17 · H(n , B)2 .
Proof for Theorem2 . We prove this by induction . When = 1 , this translates to the basic Pmerge method and the result from Theorem 1 implies the base case directly . Now assuming the theorem holds for some > 1 , We can show that the result also holds for ( + 1 ) . The derivation is similar to the machinery used in proving Theorem 1 , albeit subjecting to some technicalities , we omit the details . The running time analysis follows directly from its construction .
To that end , we denote gi and gi as the representative of gi assigned by the OptHist method and the recursive version of Pmerge of depth + 1 . We have :
H(n , B)2
2 =
HRPmerge(n , B ) = n
( gi(W ) −gi)2 Pr(W ) . n
( gi(W ) −gi)2 Pr(W ) . i=1
W∈W
Similarly , the histogram error for depth ( + 1 ) Pmerge is
W∈W i=1
For the ( + 1)th merge phase , it calls m instances of depth Pmerge methods , each with a sub domain of size n/m . Thus , we also use ¯gi and λi as the representative of gi assigned by the depth Pmerge and the OptHist methods on such sub domains . By induction assumption , n ( gi(W ) − ¯gi)2 ≤ 10 n
( gi(W ) − λi)2 . ( 14 )
W∈W i=1
W∈W i=1
11
By the optimality of the weighted DP formulation in the ( + 1)th merge phase we must have : i=1 i=1 n ( ¯gi −gi ) ≤ n n ( gi(W ) − λi)2 ≤ n
W∈W i=1
W∈W
( ¯gi −gi ) . n ( gi(W ) −gi)2 . i=1
( 15 )
( 16 )
Also , by the optimality of the OptHist method on each size n/m sub domain we must have
Combining equations ( 13 ) , ( 14 ) , ( 15 ) and ( 16 ) leads to :
2 =
W∈W i=1
W∈W i=1
W∈W i=1
W∈W i=1
HRPmerge(n , B)2 n n n n n n
( gi(W ) −gi)2 Pr(W ) ≤ 2((gi(W ) − ¯gi)2 + ( ¯gi −gi)2 ) Pr(W ) by ( 13 ) ≤ 2((gi(W ) − ¯gi)2 + ( ¯gi −gi)2 ) Pr(W ) by ( 15 ) ≤ ( 2(gi(W ) − ¯gi)2 + 4(¯gi − gi(W ))2 + 4(gi(W ) −gi)2 ) Pr(W ) by ( 13 )
( 6(gi(W ) − ¯gi)2 + 4(gi(W ) −gi)2 ) Pr(W ) ≤ ( 6 · 10(gi(W ) − λi)2 + 4(gi(W ) −gi)2 ) Pr(W ) by ( 14 ) ≤ ( 6 · 10(gi(W ) −gi)2 + 4(gi(W ) −gi)2 ) Pr(W ) by ( 16 ) ≤ 10(+1 ) n ( gi(W ) −gi)2 Pr(W ) = 10(+1)H(n , B)2
( gi(W ) −gi)2 Pr(W )
= ( 6 · 10 + 4 ) n
W∈W i=1
W∈W i=1
W∈W i=1
W∈W i=1
=
2 .
W∈W i=1
Hence , for levels , HPmerge(n , B)2 < 3.17 · H(n , B)2 .
12
