Reducing the Sampling Complexity of Topic Models
Aaron Q . Li
Amr Ahmed
CMU Language Technologies
Google Strategic Technologies
Pittsburgh , PA aaronli@cmu.edu
Sujith Ravi
Google Strategic Technologies
Mountain View , CA sravi@google.com
Mountain View , CA amra@google.com Alexander J . Smola CMU MLD and Google ST
Pittsburgh PA alex@smola.org
ABSTRACT Inference in topic models typically involves a sampling step to associate latent variables with observations . Unfortunately the generative model loses sparsity as the amount of data increases , requiring O(k ) operations per word for k topics . In this paper we propose an algorithm which scales linearly with the number of actually instantiated topics kd in the document . For large document collections and in structured hierarchical models kd k . This yields an order of magnitude speedup . Our method applies to a wide variety of statistical models such as PDP [ 16 , 4 ] and HDP [ 19 ] .
At its core is the idea that dense , slowly changing distributions can be approximated efficiently by the combination of a Metropolis Hastings step , use of sparsity , and amortized constant time sampling via Walker ’s alias method .
Keywords Sampling ; Scalability ; Topic Models ; Alias Method
1 .
INTRODUCTION
Topic models are some of the most versatile tools for modeling statistical dependencies . Given a set of observations xi ∈ X , such as documents , logs of user activity , or communications patterns , we want to infer the hidden causes motivating this behavior . A key property in topic models is that they model p(x ) via a discrete hidden factor , z via p(x|z ) and p(z ) . For instance , z may be the cluster of a document . In this case it leads to Gaussian and Dirichlet mixture models [ 14 ] . When z is a vector of topics associated with individual words , this leads to Latent Dirichlet Allocation [ 3 ] . Likewise , whenever z indicates a term in a hierarchy , it leads to structured and mixed content annotations [ 19 , 2 , 4 , 12 ] . 1.1 Sparsity in Topic Models One of the key obstacles in performing scalable inference is to draw p(z|x ) from the discrete state distribution associated Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page . Copyrights for components of this work owned by others than the author(s ) must be honored . Abstracting with credit is permitted . To copy otherwise , or republish , to post on servers or to redistribute to lists , requires prior specific permission and/or a fee . Request permissions from permissions@acmorg KDD’14 , August 24–27 , 2014 , New York , NY , USA . Copyright is held by the owner/author(s ) . Publication rights licensed to ACM . ACM 978 1 4503 2956 9/14/08 $1500 http://dxdoiorg/101145/26233302623756 with the data . A substantial improvement in this context was provided by [ 22 ] who exploited sparsity to decompose the collapsed sampler [ 9 ] for Latent Dirichlet Allocation . As a result the sampling cost can be reduced from O(k ) , the total number of topics to O(kd + kw ) , ie the number kw of topics occurring for a particular word w and kd for a particular document d . This insight led to an order of magnitude improvement for sampling topic models , thus making their implementation feasible at a large scale . In fact , the strategy is sufficiently robust that it can be extended to settings where the topic smoother depends on the words [ 15 ] . For small datasets the assumption kd +kw k is well satisfied . Unfortunately , as the number of documents grows , so does the number of topics in which a particular word occurs . In particular kw → k , since the probability of observing any particular topic for a given word is rarely nonzero : Assume that the probability of occurrence for a given topic for a word is bounded from below by δ . Then the probability of the topic occurring at least once in a collection of n documents is given by
1 − ( 1 − δ)n ≥ 1 − e
−nδ → 1 for n → ∞ .
From this it follows that kw = O(k ) for n = O(δ−1 log k ) . In other words , for large numbers documents the efficiencies discussed in [ 22 ] vanish . This is troubling , since in many industrial settings n can be in the order of billions to trillions . Consequently , with increasing amounts of data , the time to process individual documents increases due to loss of sparsity , thus leading to a superlinear increase in runtime .
On the other hand , the topic sparsity for a given document essentially remains unchanged , regardless of the total number of related documents that are available . This is due to the fact that the number of tokens per document is typically less than O(k ) . For instance , microblogs contain only dozens of words , yet admit to thousands of topics.1 This situation is exacerbated when it comes to hierarchical and structured topic models , since there the number of ( sub)topics can grow considerably more rapidly . Hence the use of sparsity is crucial in designing efficient samplers . 1.2 Metropolis Hastings Walker Sampling
The present paper proposes a new decomposition of the in conjunction with a collapsed conditional probability ,
1Obviously , this approach would not work to infer topics for Dostojevski ’s War and Peace . That said , a plain topic model is an unlikely candidate to represent very long documents .
891 Metropolis Hastings [ 7 ] scheme and the use of the alias method , introduced by Walker [ 20 , 13 ] , to amortize dense updates for random variables . This method is highly versatile . It defers corrections to the model and avoids renormalization . This allows us to apply it to both flat and hierarchical models . Experimental evaluation demonstrates the efficacy of our approach , yielding orders of magnitude acceleration and a simplified algorithm .
While we introduce our algorithm in the context of topic models , it is entirely general and applies to a much richer class of models . At its heart lies the insight that in many inference problems the model parameters only change relatively slowly during sampling . For instance , the location of cluster centers , the definition of topics , or the shape of autoregressive functions , only change relatively slowly . Hence , if we could draw from a distribution over k outcomes k times , Walker ’s alias method would allow us to generate samples in amortized constant time . At the same time , the Metropolis Hastings algorithm allows us to use approximations of the correct probability distribution , provided that we compute ratios between successive states correctly . Our approach is to draw from the stale distribution in constant time and to accept the transition based on the ratio between successive states . This step takes constant time . Moreover , the proposal is independent of the current state . Once k samples have been drawn , we simply update the alias table . In honor of the constitutent algorithms we refer to our technique as the Metropolis Hastings Walker ( MHW ) sampler .
2 . TOPIC MODELS
We begin with a brief introduction to topic models and the associated inference problems . This includes a short motivation of sampling schemes in the context collapsed samplers [ 9 , 18 ] and of stochastic variational models [ 21 ] . It is followed by a description of extensions to hierarchical models . 2.1 Latent Dirichlet Allocation
In LDA [ 3 ] one assumes that documents are mixture distributions of language models associated with individual topics . That is , the documents are generated following the graphical model below :
α
θd zdi wdi
ψk
β for all i for all k for all d
For each document d draw a topic distribution θd from a Dirichlet distribution with concentration parameter α
θd ∼ Dir(α ) .
( 1 )
For each topic t draw a word distribution from a Dirichlet distribution with concentration parameter β
ψt ∼ Dir(β ) .
( 2 ) For each word i ∈ {1 . . . nd} in document d draw a topic from the multinomial θd via zdi ∼ Discrete(θd ) .
( 3 )
Draw a word from the multinomial ψzdi via wdi ∼ Discrete(ψzdi ) .
( 4 )
The beauty of the Dirichlet multinomial design is that the distributions are conjugate . This means that the multinomial distributions θd and ψk can be integrated out , thus allowing one to express p(w , z|α , β , nd ) in closed form [ 9 ] . This yields a Gibbs sampler to draw p(zdi|rest ) efficiently . The conditional probability is given by p(zdi|rest ) ∝ ( n
−di td + αt)(n
−di tw + βw )
−di t + ¯β n
.
( 5 )
¯β :=
Here the count variables ntd , ntw and nt denote the number of occurrences of a particular ( topic,document ) and ( topic,word ) pair , or of a particular topic respectively . Moreover , the superscript ·−di denotes said count when ignoring −di the pair ( zdi , wdi ) . For instance , n tw is obtained when ignoring the ( topic,word ) combination at position ( d , i ) . Finally , w βw denotes the joint normalization .
At first glance , sampling from ( 5 ) appears to cost O(k ) time since we have k nonzero terms in a sum that needs to be normalized . [ 22 ] devised an ingenious strategy for exploiting sparsity by decomposing terms into
+ n
−di tw
−di n td + αt −di t + ¯β n p(zdi|rest ) ∝ βw
αt −di t + ¯β n
+ n
−di td
βw −di t + ¯β n first term is dense , and more specifically , can be computed from
As can be seen , for small collections of documents only the −di t + ¯β ) t αt/(nt + ¯β ) in O(1 ) time . That is , whenever both ntd and ntw are sparse , sampling from p(zdi|rest ) can be accomplished efficiently . The use of packed index variables and a clever reordering of ( topic,count ) pairs further improve efficient sampling to O(kw + kd ) . t αt/(n
Stochastic variational inference [ 11 ] requires an analogous sampling step . The main difference being that rather than to capture p(w|t ) one uses a natural parameter using ntw +βw nt+ ¯β ηtw associated with the conjugate variational distribution . Unfortunately this renders the model dense , unless rather careful precautions are undertaken [ 11 ] to separate residual dense and sparse components . Instead , we devise a sampler to draw from p(zdi|rest ) in amortized O(kd ) time . We accomplish this by using p(zdi|rest ) ∝ n
−di td
−di tw + βw n −di t + ¯β n
+
αt(n n
−di tw + βw ) −di t + ¯β
( 6 )
Here the first term is sparse in kd and we can draw from it in O(kd ) time . The second term is dense , regardless of the number of documents ( this holds true for stochastic variational samplers , too ) . However , the ’language model’ p(w|t ) does not change too drastically whenever we resample a single word . The number of words is huge , hence the amount of change per word is concomitantly small . This insight forms the basis for applying Metropolis Hastings Walker sampling . 2.2 Poisson Dirichlet Process
To illustrate the fact that the MHW sampler also works with models containing a dense generative part , we describe its application to the Poisson Dirichlet Process [ 4 , 16 ] . The model is given by the following variant of the LDA model :
892 α
θd zdi wdi
ψt
ψ0
β for all i for all d for all k
In a conventional topic model the language model is simply given by a multinomial draw from a Dirichlet distribution . This fails to exploit distribution information between topics , such as the fact that all topics have the same common underlying language . A means for addressing this problem is to add a level of hierarchy to model the distribution over t p(ψt|β ) . Such a t p(ψt|ψ0)p(ψ0|β ) rather than
ψt via model is depicted above .
The ingredients for a refined language model are a PitmanYor Topic Model ( PYTM ) [ 17 ] that is more appropriate to deal with natural languages . This is then combined with the Poisson Dirichlet Process ( PDP ) [ 16 , 4 ] to capture the fact that the number of occurences of a word in a natural language corpus follows power law . Within a corpus , the frequency of a word is approximately inversely proportional to its ranking in number of occurences . Each draw from a Poisson Dirichlet Process PDP(b , a , ψ0 ) is a probability distribution . The base distribution ψ0 defines the common underlying distribution shared across the generated distributions . Under the settings of Pitman Yor Topic Model , each topic defines a distribution over words , and the base distribution defines the common underlying common language model shared by the topics . The concentration parameter b controls how likely a word is to occur again while being sampled from the generated distribution . The discount parameter a prevents a word to be sampled too often by imposing a penalty on its probability based on its frequency . The combined model described explicityly in [ 5 ] :
θd ∼ Dir(α ) zdi ∼ Discrete(θd ) wdi ∼ Discrete ( ψzdi )
ψ0 ∼ Dir(β ) ψt ∼ PDP(b , a , ψ0 )
As can be seen , the document specific part is identical to LDA whereas the language model is rather more sophisticated . Likewise , the collapsed inference scheme is analogous to a Chinese Restaurant Process [ 6 , 5 ] . The technical difficulty arises from the fact that we are dealing with distributions over countable domains . Hence , we need to keep track of multiplicities , ie whether any given token is drawn from βi or β0 . This will require the introduction of additional count variables in the collapsed inference algorithm .
Each topic is equivalent to a restaurant . Each token in the document is equivalent to a customer . Each type of word corresponds each type of dish served by the restaurant . The same results in [ 6 ] can be used to derive the conditional probability by introducing axillary variables : restaurant t . Here t is the equivalent of a topic .
• stw denotes the number of tables serving dish w in • rdi indicates whether wdi opens a new table in the • mtw denotes the number of times dish w has been served in restaurant t ( analogously to nwk in LDA ) . restaurant or not ( to deal with multiplicities ) .
The conditional probability is given by : p(zdi = t , rdi = 0|rest ) ∝ αt + ndt bt + mt mtw + 1 − stw mtw + 1
Smtw +1 stw ,at Smtw stw ,at
( 7 ) if no additional ’table’ is opened by word wdi . Otherwise p(zdi = t , rdi = 1|rest ) ∝(αt + ndt ) bt + atst bt + mt stw + 1 mtw + 1
( 8 )
γ + stw ¯γ + st
Smtw +1 stw +1,at Smtw stw ,at
Here SN
M,a is the generalized Stirling number . It is given by
M−1,a + ( N − M a)SN
M,a = SN SN +1
[ 4 ] . Moreover we have mt = for M > N , and SN
M,a = 0
M,a and SN w mtw , and st = t stw .
0,a = δN,0 . A detailed analysis is given in
Similar to the conditional probability expression in LDA , these two expressions can be written as a combination of a sparse term and a dense term , simply by splitting the factor ( αt + ndt ) into its sparse component ndt and its dense counterpart αt . Hence we can apply the same strategy as before when sampling topics from LDA , albeit now using a twice as large space of state variables . 2.3 Hierarchical Dirichlet Process
To illustrate the efficacy and generality of our approach we discuss a third case where the document model itself is more sophisticated than a simple collapsed Dirichlet multinomial . We demonstrate that there , too , inference can be performed efficiently . Consider the two level topic model based on the Hierarchical Dirichlet Process [ 19 ] ( HDP LDA ) . In it , the topic distribution for each document θd is drawn from a Dirichlet process DP(b1 , θ0 ) . In turn , θ0 is drawn from a Dirichlet process DP(b0 , H(· ) ) governing the distribution over topics . In other words , we add an extra level of hierarchy on the document side ( compared to the extra hierarchy on the language model used in the PDP ) .
H
θ0
θd zdi wdi
ψk
β for all i for all k for all d
More formally , the joint distribution is as follows : ψt ∼ Dir(β )
θ0 ∼ DP(b0 , H(· ) ) θd ∼ DP(b1 , θ0 ) zdi ∼ Discrete(θd ) wdi ∼ Discrete ( ψzdi )
By construction , DP(b0 , H(· ) ) is a Dirichlet Process , equivalent to a Poisson Dirichlet Process PDP(b0 , a , H(· ) ) with the discount parameter a set to 0 . The base distribution H( . ) is often assumed to be a uniform distribution in most cases . At first , a base θ0 is drawn from DP(b0 , H(·) ) . This governs how many topics there are in general , and what their overall prevalence is . The latter is then used in the next level of the hierarchy to draw a document specific distribution θd that serves the same role as in LDA . The main difference is that unlike in LDA , we use θ0 to infer which topics are more popular than others .
It is also possible to extend the model to more than two levels of hierarchy , such as the infinite mixture model [ 19 ] . Similar to Poisson Dirichlet Process , an equivalent Chinese Restaurant Franchise analogy [ 6 , 19 ] exists for Hierarchical Dirichlet Process with multiple levels . In this analogy , each Dirichlet Process is mapped to a single Chinese Restau
893 rant Process , and the hierarchical structure is constructed to identify the parent and children of each restaurant .
The general ( collapsed ) structure is as follows : let Nj be the total number of customers in restaurant j and njt be the number of customers in restaurant j served with dish t . When a new customer ( a token ) enters restaurant j with the corresponding Dirichlet Process DP ( bj , Hj(·) ) , there are two types of seating arrangement for the customer :
• With probability njt bj +Nj the customer is served with dish ( topic ) t and sits at an existing table .
• With probability bj table served with a new dish t drawn from Hj(· ) . bj +Nj the customer sits at a new
In the event that the customer sits at a new table , a phantom customer is sent upstream the hierarchy to the parent restaurant of j , denoted by j , with corresponding Dirichlet Process DP ( bj , Hj ( ·) ) . The parent restaurant then decides the seating arrangement of the phantom customer under the same rules . This process repeats , until there is no more parent restaurant or any of phantom customer decides to sit in an existing table in any parent restaurant along the path .
We use the block Gibbs sampler given in [ 6 ] as it allows us to extend our approach for multi level Hierarchical Dirichlet Process , and performs better than the samplers given in [ 19 ] and the collapsed Gibbs sampler given in [ 4 ] , as measured in convergence speed , running time , and topic quality .
The key difference of [ 6 ] relative to [ 19 ] is that rather than keeping track of relative assignments of tables to each other ( and the resulting multiplicities and infrequent block moves ) it simply keeps track of the level within the hierarchy of restaurants at which an individual customer opens a new table . The advantage is that this allows us to factor out the relative assignment of customers to specific tables but rather only keep track of the dishes that they consume . The obvious downside being that a small number of customers can be blocked from moves if they opened a table at a high position of the hierarchy that other customers depend upon . Improving mixing in this context is subject to future work . In the setting studied above we only have a two level HDP : that of the parent DP tying all documents together and the DP within each document , governing its topic distribution . We use zdi ∈ N to denote the topic indicator of word i at position d and udi ∈ {0 , 1} to indicate whether a new table is opened at the root level ( ie udi = 1 ) . Moreover , define std to be the table counter for document d , ie the number of times a table serving topic t has been opened , and let st be the associated counter for the base DP , associated with t st be tables opened at the parent level . Finally , let s := the total number of tables opened at the root level .
Clearly the situation where st = 0 and udi = 0 is impossible since this would imply that we are opening a new table at document d while there is no matching table available at the root level . Hence for the collapsed sampler we only need to consider the following cases : have st and need to set udi = 1 .
• A new root topic is generated . That is , we currently • A new table is added at document d . In this case we require that st , ie that the topic exists at the root level . Moreover , obviously it requires that std = 0 since we are adding the first table to serve dish t . • No additional topic is introduced but we may be in troducing an additional table .
This amounts to the following ( unnormalized ) conditional probabilities . See [ 6 ] for further details . p ( zdi = t , udi = u|rest )
( 9 )

∝ βw + mtw ¯β + mt b0b1 b0+s b1s2 t
( st+1)(s+b0 ) if st = 0 and udi = 1 if st = 0 and std = 0
S ndt+1 sdt+1,0 S ndt sdt ,0 sdt+1 ndk+1 if st = 0 and std = 0
Expressions for the generalized form are analogous . Both forms contain a fraction with its numerator being the sum of a sparse term mtw and a dense term βw . Therefore , the conditional probability can be decomposed to a dense term multiplied by βw , and a sparse term multiplied by mtw . Applying the same methodology , the sampling complexity of a multi level HDP can be reduced to O(kw ) .
3 . METROPOLIS HASTINGS WALKER
We now introduce the key components for the MHW algorithm and how to use it in sampling topics . They consist of the alias method [ 20 , 13 ] and a simplified version of the Metropolis Hastings sampler [ 7 ] . 3.1 Walker ’s Alias Method
Typically , when drawing from a distribution over l outcomes , it is accepted that one would need to perform O(l ) work to generate a sample . In fact , this is a lower bound , since we need to inspect each probability at least once before we can construct the sampler . However , what is commonly overlooked is that there exist algorithms that allow us to draw subsequent samples from the same distribution in O(1 ) time . This means that drawing l samples from a distribution over l outcomes can be accomplished in O(1 ) amortized time per draw . We make extensive use of this fact . Denote by pi with i ∈ {1 . . . l} the probabilities of a distribution over l outcomes from which we would like to sample . The algorithm works by decomposing a distribution over l events into l bins of equal probability by pairing at most two events per bin . Since it ’robs’ from the probabilities pi > 1/l and adds to those with pi < 1/l it is also referred to as ’Robin Hood’ method [ 13 ] . The algorithm proceeds as follows : 1 : GenerateAlias(p , l ) 2 : Initialize L = H = ∅ and A = [ ] . 3 : for i = 1 to l do if pi ≤ l−1 then 4 : 5 : 6 : 7 : 8 : end if 9 : end for 10 : while L = ∅ do 11 : 12 : A ← [ A , ( i , h , pi ) ] 13 : 14 : 15 : 16 : 17 : 18 : end while 19 : return A
Extract ( i , pi ) from L and ( h , ph ) from H if ph − pi > l−1 then
H ← H ∪ {(h , ph − pi)} L ← L ∪ {(h , ph − pi)}
L ← L ∪ {(i , pi)} H ← H ∪ {(i , pi)} end if else else
894 This yields an array A containing triples ( i , h , ph ) with ph < l−1 . It runs in O(l ) time since at each step one event is removed from the list . And the probabilities remain unchanged , as can be seen by induction . All we need to do now is to draw a random element from A and flip a biased coin to accept h or i with probability lph and 1−lph respectively . 1 : SampleAlias(A , l ) 2 : bin = RandInt(l ) 3 : ( i , h , p ) = A[bin ] 4 : if lp > RandUnif(1 ) then 5 : 6 : else 7 : 8 : end if return h return i
Note that the alias method works since we are implicitly exploiting parallelism inherent in CPUs : as long as l does not exceed 264 are guaranteed that even an information theoretically inefficient code will not require more than 64 bit , which can be generated in constant time . 3.2 Sampling with Proposal Distributions
Whenever we draw l identical samples from p it is clear that the above algorithm provides an O(1 ) sampler . However , if p changes , it is difficult to apply the alias sampler directly . To address this , we use rejection sampling and Metropolis Hastings procedures . Rejection sampling proceeds as follows : 1 : Rejection(p , q , c ) 2 : repeat 3 : Draw i ∼ q(i ) 4 : until p(i ) ≥ cq(i)RandUnif(1 ) 5 : return i Here p is the distribution we would like to draw from , q is a reference distribution that makes sampling easy , and c ≥ 1 is chosen such that cq(i ) ≥ p(i ) for all i . We then accept with probability p(i ) cq(i ) . It is well known that the expected number of samples to draw via Rejection(p , q , c ) is c , provided that a good bound c exists . In this case we have the following :
Lemma 1 Given l distributions pi and q over l outcomes satisfying ciq ≥ pi , the expected amortized runtime complexity for drawing using SampleAlias(A , l ) and rejecting using Rejection(pi , q , ci ) is given by O l
1
. i=1 ci l
Proof . Preprocessing costs amortized O(1 ) time . Each rejection sampler costs O(ci ) work . Averaging over the draws proves the claim .
In many cases , unfortunately , we do not know ci , or computing ci is essentially as costly as drawing from pi itself . Moreover , in some cases ci may be unreasonably large . In this situation we resort to Metropolis Hastings sampling [ 7 ] using a stationary proposal distribution . As in rejection sampling , we use a proposal distribution q and correct the effect of sampling from the ’wrong’ distribution by a subsequent acceptance step . The main difference is that Metropolis Hastings can be considerably more efficient than Rejection sampling since it only requires that the ratios of probabilities are close rather than requiring knowledge of a uniform upper bound on the ratio . The drawback is that instead of drawing iid samples from p we end up with a chain of dependent samples from p , as governed by q . if RandUnif(1 ) < min
For the purpose of the current method we only need to concern ourselves with stationary distributions p and q , ie p(i ) = p(i|j ) and q(i ) = q(i|j ) , hence we only discuss this special case below . For a more general discussion see eg [ 8 ] . 1 : StationaryMetropolisHastings(p , q , n ) 2 : if no initial state exists then i ∼ q(i ) 3 : for l = 1 to n do 4 : Draw j ∼ q(j ) 5 : i ← j 6 : 7 : end if 8 : end for 9 : return i As a result , provided that p and q are sufficiently similar , the sampler accepts most of the time . This is the case , eg whenever we use a stale variant of p as the proposal q . Obviously , a necessary requirement is that q(i ) > 0 whenever p(i ) > 0 , which holds , eg whenever we incorporate a smoother . 3.3 MHW Sampling
1 , p(j)q(i ) p(i)q(j ) then n do
Sample j ∼ StationaryMetropolisHastings(p , A , n )
In combining both methods we arrive at , what we believe is a significant improvement over each component individually . It works as follows : 1 : Initialize A ← GenerateAlias(p , l ) 2 : for i = 1 to N 3 : Update q as needed 4 : 5 : end for Provided that the sampler mixes within n rounds of the MHprocedure , this generates draws from up to date versions of p . Note that a further improvement is possible whenever we can start with a more up to date draw from p , eg in the case of revisiting a document in a topic model . After burn in the previous topic assignment for a given word is likely to be still pertinent for the current sampling pass .
Lemma 2 If the Metropolis Hastings sampler over N outcomes using q instead of p mixes well in n steps , the amortized cost of drawing n samples from q is O(n ) per sample .
This follows directly from the construction of the sampler and the fact that we can amortize generating the alias table . Note that by choosing a good starting point and after burnin we can effectively set n = 1 .
4 . APPLICATIONS We now have all components necessary for an accelerated sampler . The trick is to recycle old values for p(wdi|zdi ) even when they change slightly and then to correct this via a Metropolis Hastings scheme . Since the values change only slightly , we can therefore amortize the values efficiently . We begin by discussing this for the case of ’flat’ topic models and extend it to hierarchical models subsequently . 4.1 Sampler for LDA
We now design a proposal distribution for ( 6 ) . It involves computing the document specific sparse term exactly and approximating the remainder with slightly stale data . Furthermore , to avoid the need to store a stale alias table A , we simply draw from the distribution and keep the samples . Once this supply is exhausted we compute a new table .
895 Alias table : Denote by
Likewise , the sparse document specific contribution is
 1 mtw−stw +1
S bt+mt mtw +1 mtw +1 stw ,at mtw stw ,at
S bt+atstw bt+mtw stw +1 mtw +1
β+stw ¯β+st
S mtw +1 stw +1,at S mtw stw ,at if r = 1 otherwise t
Qw :=
αt ntw + βw nt + ¯β and qw(t ) :=
αt Qw ntw + βw nt + ¯β pdw(t , r ) :=ndt the alias normalization and the associated probability distribution . Then we perform the following steps :
Pdw := pdw(t , r )
1 . Generate the alias table A using qw . 2 . Draw k samples from qw and store them in Sw . 3 . Discard A and only retain Qw and the array Sw .
Generating Sw and computing Qw costs O(k ) time . In particular , storage of Sw requires at most O(k log2 k ) bits , thus it is much more compact than A . Note , however , that we need to store Qw and qw(t ) . Metropolis Hastings proposal : Denote by
Pdw :=
−di td n
−di n tw + βw −di t + ¯β n and pdw(t ) :=
−di n td Pdw
−di n tw + βw −di t + ¯β n t the sparse document dependent topic contribution . Computing it costs O(kd ) time . This allows us to construct a proposal distribution q(t ) :=
Pdw
Pdw + Qw pdw(t ) +
Qw
Pdw + Qw qw(t )
( 10 )
To perform an MH step we then draw from q(t ) in O(kd ) amortized time . The step from topic s to topic t is accepted with probability min(1 , π ) where
π =
−di td + αt n −di sd + αs n
−di tw + βw −di sw + βw
· n n
· n−di s + ¯β −di t + ¯β n
· Pdwpdw(s ) + Qwqw(s ) Pdwpdw(t ) + Qwqw(t )
Note that the last fraction effectively removes the normalization in pdw and qw respectively , that is , we take ratios of unnormalized probabilities . Complexity : To draw from q costs O(kd ) time . This is so since computing Pdw has this time complexity , and so does the sampler for pdw . Moreover , drawing from qw(t ) is O(1 ) , hence it does not change the order of the algorithm . Note that repeated draws from q are only O(1 ) since we can use the very same alias sampler also for draws from pdw . Finally , evaluating π costs only O(1 ) time . We have the following :
Lemma 3 Drawing up to k steps in a Metropolis Hastings proposal from p(zdi|rest ) can be accomplished in O(kd ) amortized time per sample and O(k ) space .
4.2 Sampler for the Poisson Dirichlet Process Following the same steps as above , the basic Poisson Dirichlet Process topic model can be decomposed by exploiting the sparsity of ndt . The main difference to before is that we need to account for the auxiliary variable r ∈ {0 , 1} rather than just the topic indicator t . The alias table is : bt+mtw mtw +1 mtw−stw +1
S mtw +1 stw ,at mtw stw ,at
S bt+atst bt+mt stw +1 mtw +1
β+stw ¯β+st
S mtw +1 stw +1,at S mtw stw ,at if r = 1 otherwise
 αk
αk r,t qw(t , r ) qw(t , r ) :=
Qw := r,t
As previously , computing pdw(t , r ) only costs O(kd ) time , which allows a proposal distribution very similar to the case in LDA to be constructed : q(t , r ) :=
Pdw
Pdw + Qw pdw(t , r ) +
Qw
Pdw + Qw qw(t , r )
As before , we use a Metropolis Hastings sampler , although this time for the state pair ( s , t ) → ( s , t ) and accept as before by using the ratio of current and stale probabilities ( the latter given by q ) . As before in the context of LDA , the time complexity of this sampler is amortized O(kd ) . 4.3 Sampler for the HDP
Due to slight differences in the nature of the sparse term and the dense term , we demonstrate the efficacy of our approach for sparse language models here . That is , we show that whenever the document model is dense but the language model sparse , our strategy still applies . In other words , this sampler works at O(kw ) cost which is beneficial for infrequent words .
For brevity , we only discuss the derivation for the two level HDP LDA , given that the general multi level HDP can be easily extended from the derivation . Recall ( 9 ) . Now the alias table is now given by : qw(t , u ) :=p ( zdi = t , udi = u|rest ) , ¯β + mt
βw
Qw := qw(t , u ) and the exact term is given by pdw(t , u ) :=γwp(zdi = t , udi = u|rest)(¯γ + mt)mtw
Pdw := pdw(t , u ) t,u
As before , we engineer the proposal distribution to be a combination of stale and fresh counts . It is given by q(t , u ) := pdw(t , u ) +
Pdw
Pdw + Qw
Qw
Pdw + Qw qw(t , u )
Subsequently , the state transition ( t , u ) → ( t , u ) is accepted using straightforward Metropolis Hastings acceptance ratios . We omitted the subscript wdi = w for brevity . The same argument as above shows that the time complexity of our sampler for drawing from HDP LDA is amortized O(kw ) .
5 . EXPERIMENTS
To demonstrate empirically the performance of the alias method we implemented the aforementioned samplers in both their base forms that have O(k ) time complexity , as well as our alias variants which have amortized O(kd ) time complexity . In addition to this , we implemented the SparseLDA [ 22 ] algorithm with the full set of features including the sorted list containing a compact encoding of ntw and ndt , as well as dynamic O(1 ) update of bucket values . Beyond the standard implementation provided in MalletLDA t,u
896 Figure 1 : Runtime time comparison between LDA , HDP , PDP and their Alias sampled counterparts AliasLDA , AliasHDP and AliasPDP .
Figure 2 : Perplexity as a function of runtime ( in seconds ) for PDP , AliasPDP , HDP , and AliasHDP on GPOL ( left ) and Enron ( right ) .
Figure 3 : Runtimes of SparseLDA and AliasLDA on PubMedSmall ( left ) and NyTimes ( right ) . by [ 22 ] , we made two major improvements : we accelerated the sorting algorithm for the compact list of encoded values to amortized O(1 ) ; and we avoided hash maps which substantially improved the speed in general with small sacrifice of memory efficiency ( we need an inverted list of the indices and an inverted list of the indices of the inverted lists ) .
In this section these implementations will be referred as LDA which is O(k ) , SparseLDA which is O(kw + kd ) ,
RedState(4.5s per LDA iteration)GPOL(36s per LDA iteration)Enron(85s per LDA iteration)897 AliasLDA which is O(kd ) , PDP at O(k ) [ 5 ] , AliasPDP at O(kd ) , HDP at O(k ) [ 6 ] , and AliasHDP at O(kw ) . 5.1 Environment and Datasets
All our implementations are written in C++11 in a way that maximise runtime speed , compiled with gcc 4.8 with O3 compiler optimisation in amd64 architecture . All our experiments are conducted on a laptop with 12GB memory and an Intel i7 740QM processor with 1.73GHz clock rate , 4×256KB L2 Cache and 6MB L3 Cache . Furthermore , we only use one single sampling thread across all experiments . Therefore , only one CPU core is active throughout and only 256KB L2 cache is available . We further disabled Turbo Boost to ensure all experiment are run at exactly 1.73GHz clock rate . Ubuntu 13.10 64bit served as runtime .
We use 5 datasets with a variety in sizes , vocabulary length , and document lengths for evaluation , as shown in Table 1 . RedState dataset contains American political blogs crawled from redstate.com in year 2011 . GPOL contains a subset of political news articles from Reuters RCV1 collection.2 We also included the Enron Email Dataset,3 . NYTimes contains articles published by New York Times between year 1987 and 2007 . PubMedSmall is a subset of approximately 1 % of the biomedical literature abstracts from PubMed . Stopwords are removed from all datasets . Furthermore , words occurring less than 10 times are removed from NYTimes , Enron , and PubMedSmall . NYTimes , Enron , and PUBMED datasets are available at [ 1 ] . 5.2 Evaluation Metrics and Parameters
We evaluate the algorithms based on two metrics : the amount of time elapsed for one Gibbs sampling iteration and perplexity . The perplexity is evaluated after every 5 iterations , beginning with the first evaluation at the ending of the first Gibbs sampling iteration . We use the standard held out method [ 10 ] to evaluate test perplexity , in which a small set of test documents originating from the same collection is set to query the model being trained . This produces an estimate of the document topic mixtures ˜θdt for each test document d . From there the perplexity is then evaluated as :
−1 D
Nd
D nd k d=1
π(W|rest ) := p(wd|rest ) = log p(wd|rest ) where d=1 p(wi = w|zdi = t , rest)p(zdi = t|rest ) i=1 t=1
Here we obtain the estimate of p(wi = w|zdi = t , rest ) from the model being trained . To avoid effects due to variation in the number of topics , we hardcoded k = 1024 for all experiments except one ( GPOL ) where we vary k and observe the effect on speed per iteration . We use fixed values for hyperparameters in all our models , setting α = β = 0.1 for LDA , a = 0.1 , b = 10 , and γ = 0.1 for the PDP , and b0 = b1 = 10 , γ = 0.1 for the HDP . For alias implementations , we fix the number of Metropolis Hasting sampling steps at 2 , as we observed a satisfactory acceptance rate ( over 90 % ) at these settings . Only a negligible improvement in perplexity was observed by raising this value . Furthermore , we did not observe degraded topic quality even when Metropolis Hasting
2Reuters Vol . 1 , English language , 1996 08 20 to 1997 08 19 3Source : wwwcscmuedu/˜enron sampling step was reduced to n = 1 , and in all our experiments the perplexity almost perfectly converges at the same pace ( ie along number of iterations ) with the same algorithm without applying alias method ( albeit with much less time per iteration ) .
Dataset RedState GPOL Enron PubMedSmall NYTimes
V 12,272 73,444 28,099 106,797 101,636
L 321,699 2,638,750 6,125,138 35,980,539 98,607,383
D 2,045 14,377 36,999 546,665 297,253
T 231 1,596 2,860 2,002 2,497
L/V 26.21 35.9 218 337 970
L/D 157 183 165 66 331
Table 1 : Datasets and their statistics . V : vocabulary size ; L : total number of training tokens , D : number of training documents ; T : number of test documents . L/V is the average number occurrences of a word . L/D is the average document length .
5.3 Performance Summary
Figure 6 shows the overall performance of perplexity as a function of time elapsed when comparing SparseLDA vs AliasLDA on the four larger datasets . When k is fixed to 1024 , substantial performance in perplexity over running time on all problems with the exception of the Enron dataset , most likely due to its uniquely small vocabulary size . The gap in performance is increased as the datasets become larger and more realistic in size . The gain in performance is noted in particular when the average document length is smaller since our sampler scales with O(kd ) which is likely to be smaller for short documents .
Figure 2 gives the comparison between PDP , HDP and their aliased variants on GPOL and Enron . By the time AliasPDP and AliasHDP are converged , the straightforward sampler are still at their first few iterations . 5.4 Performance as a Function of Iterations
In the following we evaluate the performance in two separate parts : perplexity as a function of iterations and runtime vs . iterations . We first establish that the acceleration comes at no cost of degraded topic quality , as shown in Figure 6 . The convergence speed and converged perplexity of AliasLDA , AliasPDP , and AliasHDP almost perfectly match the non alias counterparts . This further shows that our choice of relatively small number of Metropolis Hasting steps ( 2 per sample ) is adequate .
The improved performance in running time of our alias implementations can be seen in all phases of sampling when compared to non alias standard implementations ( LDA , PDP , HDP ) . When compared to SparseLDA ( Figure 3 ) , the performance gain is salient during all phases on larger datasets ( except for the early stage in Enron dataset ) , and the performance is very close on small datasets ( 0.35s per iteration on AliasLDA vs . 0.25s per iteration on SparseLDA ) . As the size of the data grows AliasLDA outperforms SparseLDA without degrading topic quality , reducing the amount of time for each Gibbs iteration on NYTimes corpus by around 12 % to 38 % overall , on Enron corpus by around 30 % after 30 iterations , and on PubMedSmall corpus by 27% 60 % throughout the first 50 iterations . Compared to SparseLDA , the time required for each Gibbs iteration with AliasLDA grows at a much slower rate , and the benefits of reduced sampling complexity is particularly clear when the average length of each document is small .
898 34 % , 37 % , 41 % , 43 % respectively . In other words , it increases with the amount of data , which conforms our intuition that adding new documents increases the density of ntw , thus slowing down the sparse sampler much more than the alias sampler , since the latter only depends on kd rather than kd + kw .
Figure 4 : Comparison of SparseLDA and AliasLDA on GPOL when varying the number of topics for k ∈ {256 , 1024 , 2048 , 4096} .
Figure 5 : Average runtime per iteration when compared on {10 % , 20 % , 40 % , 75 % , 100%} of the PubMedSmall dataset for SparseLDA and AliasLDA .
The gap in performance is especially large for more sophisticated language modelsl such as PDP and HDP . The running time for each Gibbs iteration is reduced by 60 % to 80 % for PDP , and 80 % to 95 % for HDP , an order of magnitude on improvement . 5.5 Varying the number of topics
When the number of topics k increases , the running time for an iteration of AliasLDA increases at a much lower rate than SparseLDA , as seen from Figure 4 on dataset GPOL since kd is almost constant . Even though the gap between SparseLDA and AliasLDA may seem insignificant at k = 1024 , it becomes very pronounced at k = 2048 ( 45 % improvement ) and at k = 4096 ( over 100 % ) This confirms the observation above that shorter documents benefits more from AliasLDA in the sense that the average documents length L/D relative to the number of topics k becomes “ shorter ” as k increases . This yields a more sparse ndt and lower kd for a document d on average . 5.6 Varying the corpus size
Figure 5 demonstrates how the gap in running time speed scales with growing number of documents in the same domain . We measure the average runtime for the first 50 Gibbs iterations on 10 % , 20 % , 40 % , 75 % , and 100 % of PubMedSmall dataset . The speedup ratio for each subset is at 31 % ,
Figure 6 : Perplexity as a function of runtime ( left ) and number of iterations ( right ) for LDA , SparseLDA , and LDA , PDP and HDP , both with and without using the Alias method . We see considerable acceleration at unchanged perplexity .
6 . CONCLUSION
In this paper , we described an approach that effectively reduces sampling complexity of topic models from O(k ) to O(kd ) in general , and from O(kw+kd ) ( SparseLDA ) to O(kd ) ( AliasLDA ) for LDA topic model . Empirically , we showed that our approach scales better than existing state of theart method when the number of topics and the number of documents become large . This enables many large scale applications , and many existing applications which require a
Percentage of full PubMedSmall collectionSeconds per iterationPerplexity vs . RuntimeGPOLEnronPubMedSmallNYTimesPerplexity vs . Iterations899 scalable distributed approach . In many industrial applications where the number of tokens easily reaches billions , these properties are crucial and often desirable in designing a scalable and responsive service . We also demonstrated an order of magnitude improvement when our approach is applied to complex models such as PDP and HDP . With an order of magnitude gain in speed , PDP and HDP may become much more appealing to many applications for their superior convergence performance , and more sophisticated representation of topic distributions and language models .
For k = 1024 topics the number of tokens processed per second in our implementation is beyond 1 million for all datasets except one ( NYTimes ) , of which contains substantially more lengthy documents . This is substantially faster than many known implementations when measured in number of tokens processed per computing second per core , such as YahooLDA [ 18 ] , and GraphLab , given that we only utilise a single thread on a single laptop CPU core .
Acknowledgments : This work was supported in part by a resource grant from amazon.com , a Faculty Research Grant from Google , and Intel .
7 . REFERENCES [ 1 ] K . Bache and M . Lichman . UCI machine learning repository , 2013 .
[ 2 ] D . Blei , T . Griffiths , and M . Jordan . The nested chinese restaurant process and Bayesian nonparametric inference of topic hierarchies . Journal of the ACM , 57(2):1–30 , 2010 .
[ 3 ] D . Blei , A . Ng , and M . Jordan . Latent Dirichlet allocation . JMLR , 3:993–1022 , Jan . 2003 .
[ 4 ] W . Buntine and M . Hutter . A bayesian review of the poisson dirichlet process , 2010 .
[ 5 ] C . Chen , W . Buntine , N . Ding , L . Xie , and L . Du .
Differential topic models . In IEEE Pattern Analysis and Machine Intelligence , 2014 .
[ 6 ] C . Chen , L . Du , and W . Buntine . Sampling table configurations for the hierarchical poisson dirichlet process . In ECML , pages 296–311 , 2011 .
[ 7 ] J . Geweke and H . Tanizaki . Bayesian estimation of state space model using the metropolis hastings algorithm within gibbs sampling . Computational Statistics and Data Analysis , 37(2):151–170 , 2001 .
[ 8 ] W . R . Gilks , S . Richardson , and D . J . Spiegelhalter .
Markov Chain Monte Carlo in Practice . 1995 .
[ 9 ] T . Griffiths and M . Steyvers . Finding scientific topics .
PNAS , 101:5228–5235 , 2004 .
[ 10 ] G . Heinrich . Parameter estimation for text analysis .
Technical report , Fraunhofer IGD , 2004 .
[ 11 ] M . Hoffman , D . M . Blei , C . Wang , and J . Paisley .
Stochastic variational inference . In ICML , 2012 .
[ 12 ] W . Li , D . Blei , and A . McCallum . Nonparametric bayes pachinko allocation . In UAI , 2007 .
[ 13 ] G . Marsaglia , W . W . Tsang , and J . Wang . Fast generation of discrete random variables . Journal of Statistical Software , 11(3):1–8 , 2004 .
[ 14 ] R . M . Neal . Markov chain sampling methods for
Dirichlet process mixture models . University of Toronto , Technical Report 9815 , 1998 .
[ 15 ] J . Petterson , A . Smola , T . Caetano , W . Buntine , and S . Narayanamurthy . Word features for latent dirichlet allocation . In NIPS , pages 1921–1929 , 2010 . [ 16 ] J . Pitman and M . Yor . The two parameter poisson dirichlet distribution derived from a stable subordinator . A . of Probability , 25(2):855–900 , 1997 .
[ 17 ] I . Sato and H . Nakagawa . Topic models with power law using Pitman Yor process . In KDD , pages 673–682 . ACM , 2010 .
[ 18 ] A . J . Smola and S . Narayanamurthy . An architecture for parallel topic models . In PVLDB , 2010 .
[ 19 ] Y . Teh , M . Jordan , M . Beal , and D . Blei . Hierarchical dirichlet processes . JASA , 101(576):1566–1581 , 2006 .
[ 20 ] A . J . Walker . An efficient method for generating discrete random variables with general distributions . ACM TOMS , 3(3):253–256 , 1977 .
[ 21 ] C . Wang , J . Paisley , and D . M . Blei . Online variational inference for the hierarchical Dirichlet process . In Conference on Artificial Intelligence and Statistics , 2011 .
[ 22 ] L . Yao , D . Mimno , and A . McCallum . Efficient methods for topic model inference on streaming document collections . In KDD’09 , 2009 .
900
