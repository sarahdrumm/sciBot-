Scalable Diffusion Aware
Optimization of Network Topology
Elias Khalil lyes@gatech.edu
Bistra Dilkina bdilkina@ccgatechedu
Le Song lsong@ccgatechedu
School of Computational Science & Engineering
College of Computing
Georgia Institute of Technology
Atlanta , GA 30332 0765
ABSTRACT How can we optimize the topology of a networked system to bring a flu under control , propel a video to popularity , or stifle a network malware in its infancy ? Previous work on information diffusion has focused on modeling the diffusion dynamics and selecting nodes to maximize/minimize influence . Only a paucity of recent studies have attempted to address the network modification problems , where the goal is to either facilitate desirable spreads or curtail undesirable ones by adding or deleting a small subset of network nodes or edges . In this paper , we focus on the widely studied linear threshold diffusion model , and prove , for the first time , that the network modification problems under this model have supermodular objective functions . This surprising property allows us to design efficient data structures and scalable algorithms with provable approximation guarantees , despite the hardness of the problems in question . Both the time and space complexities of our algorithms are linear in the size of the network , which allows us to experiment with millions of nodes and edges . We show that our algorithms outperform an array of heuristics in terms of their effectiveness in controlling diffusion processes , often beating the next best by a significant margin . Categories and Subject Descriptors : H28 [ Database Management ] : Database Applications â€” Data Mining General Terms : Algorithms , Theory , Experimentation Keywords : diffusion networks ; network optimization ; supermodularity ; approximation
1 .
INTRODUCTION
The diffusion of physical , conceptual or digital substances over networks has been studied in many domains such as epidemiology [ 10 ] , social media [ 16 ] , and computer and mobile [ 19 ] networks . These studies have resulted in an array of models aiming to capture the diffusion dynamics , among which the most well known are the linear threshold ( LT ) model , the independent cascade ( IC ) model , and the Susceptible Infected Recovered ( SIR ) model . Starting with the work of Domingos and Richardson on viral marketing [ 6 ] , a lot of research has concentrated on how one can pick a small set of source nodes , whose initial adoption of a given substance would trigger maximal spread in the network . The seminal work of Kempe et al . [ 12 ] showed that source node selection for influence maximization is a submodular maximization problem under the IC and LT diffusion models , and therefore admits a simple greedy algorithm with approximation guarantees . Their result was followed by a whole line of research on source node selection in various related information diffusion contexts [ 4 , 7 , 9 ] .
In contrast to these previous works where the diffusion networks remain unchanged , we are rather interested in problems of modifying the topology of a diffusion network to either facilitate the spread of desirable substances , or curtail the spread of undesirable ones . One can consider deleting edges or nodes to minimize possible undesirable spread , such as that of a virus , disease or rumor , or one can consider adding edges or nodes to facilitate , for example , the spread of information or dispersal of endangered species . For instance , in disease control , authorities may consider disallowing travel between certain pairs of cities to curb the spread of a flu epidemic . On the other hand , social media websites can recommend to users additional information outlets to follow to increase the spread of ideas and memes . The modification setting is particularly relevant when the agent optimizing the topology does not have control over the sources of the spread , but is able to change some subset of the edges or nodes that he has access to . Hence , our setting is most relevant when the agent in question is looking to strategically design the topology , as opposed to reacting to a particular event . Thus , we will later assume that the set of nodes that are likely to be sources of diffusion are known , but which ones among them are the sources of a particular diffusion event follows some probability distribution ( eg uniform ) . For example , in an information network , we may know which popular news sites are typically the sources of viral news , but are uncertain as to which of these sites will be the source of a particular piece of news . Despite the broad practical relevance of the diffusion network modification problems , existing results are very limited , and lack in either formal optimality guarantees or in algorithmic efficiency .
Related work . Under the SIR model , some positive network optimization results exist : Tong et al . [ 22 ] address the edge deletion ( addition ) problem by approximately minimizing ( maximizing ) the eigenvalue of the adjacency matrix . In addition , methods have been designed to optimize surrogates for diffusion spread under SIR [ 8 , 20 ] . Instead of maximizing/minimizing the spread of substances directly , these methods typically optimize a static property of the network , in the hope of optimizing diffusion . For instance , Schneider et al . [ 20 ] proposed â€œ betweenness centrality â€ as a heuristic for immunizing nodes or removing edges under the SIR model , while â€œ degree centrality â€ was adopted in [ 8 ] to protect against virus propagation in email networks .
Under the IC model , existing results are negative : Sheldon et al.[21 ] study the problem of node addition to maximize spread , and provide a counter example showing that the objective function is not submodular . Thus , they resort to a principled but expensive approach based on sample average approximation and mixed integer programming , which provides provable optimality guarantees but cannot scale to large networks . Bogunovic [ 1 ] addresses the node deletion problem . For the edge deletion problem under the IC model , Kimura et al.[14 ] apply the greedy algorithm used by Kempe et al . [ 12 ] for source node selection , but do not provide any approximation guarantees . We note that the edge deletion objective that we consider is not supermodular under IC ; a simple counter example is provided in the extended version of this paper .
Network optimization under the LT model is still largely unexplored , and this paper seeks to fill that gap . The greedy approach has been used in [ 13 ] to delete edges under the LT model , albeit without any analysis of the supermodularity of the objective , nor formal approximation guarantees . More recently , Kuhlman et al . [ 15 ] propose heuristic algorithms for edge removal under a simpler deterministic variant of the LT model . In contrast , we describe principled algorithms for edge deletion and addition by exploiting supermodularity of the objectives under the more general stochastic LT model . Most related are [ 3 , 9 ] , where node deletion under the â€œ competitive â€ LT model ( a variant of stochastic LT ) is addressed using supermodularity . The node deletion problem can be considered a special case of the â€œ influence blocking maximization â€ problem described in [ 3 , 9 ] . However , the supermodularity results in those works are limited to node deletion , whereas our theoretical framework leads to supermodularity results for edge deletion and addition , node deletion and addition .
Our contributions . In this paper , we will address network topology optimization for diffusion under the linear threshold model . We will focus on two network modification problems involving the deletion of edges for minimizing spread and the addition of edges for maximizing spread 1 :
Edge deletion problem : Given a set of source nodes X , find a set of k edges to remove st the spread of a certain substance is minimized .
Edge addition problem : Given a set of source nodes X , find a set of k edges to add st the spread of a certain substance is maximized .
Proof techniques used in the source node selection literature are inadequate for our more complex network modification problems . Instead , we propose a novel theoretical framework ( Section 3 ) that yields surprising results , namely that the objective function in both problems is supermodular , a property that has positive algorithmic implications . In particular , minimization of a supermodular function under cardinality constraints , although typically an NP hard problem , admits a greedy algorithm with approximation guarantees [ 18 ] . Similarly , cardinality constrained supermodular 1 One can also consider the analogous node deletion and addition problems , and our theoretical and algorithmic results on the finer scale edge problems can be extended trivially . maximization has recently been shown to admit a simple modular approximation scheme [ 11 ] . Our finding , combined with these combinatorial optimization results allows , for the first time , the design of efficient diffusion aware algorithms with approximation guarantees for the network modification problems under the LT model , filling a gap in the existence research literature on this topic .
We address several challenges in transforming the two general supermodular approximation algorithms into efficient and practical approaches for our setting . Directly implementing the supermodular optimization algorithms is impractical , since evaluating the objective function given a set of source nodes is #P hard in general [ 4 ] . We exploit the correspondence between the LT model and the â€œ live edge graph â€ construction [ 12 ] , and estimate the objective function using a sample of random live edge graphs . Nevertheless , a naive application of the supermodular approximation schemes to the sample of random live edge graphs will result in runtime quadratic in the network size , an approach that does not scale to modern problems with millions of nodes and edges . To tackle this issue , we design two data structures , the descendant count trees for the edge deletion problem , and the neighbor counting graphs for the edge addition problem , in order to support approximate evaluation of the objective function . These data structures can be constructed in time linear in the network size , and queried in constant time , allowing us to scale the supermodular optimization algorithms to networks with millions of nodes .
Finally , we evaluate our algorithms on both synthetic and real world diffusion networks and compare the quality of the solutions to scalable alternative approaches , based on optimizing structural properties of the networks . Our algorithms can lead to as large as 10 20 % additional efficacy for edge deletion , and up to 100 % for edge addition , compared to the other approaches . In terms of scalability , our algorithms can scale to large networks with millions of nodes and edges .
2 . LINEAR THRESHOLD MODEL
In this section , we will provide background on the linear threshold ( LT ) model for diffusion processes [ 12 ] , which will be at the center of this study . This model is well suited for representing threshold behavior , where entities in a network have a â€œ tipping point â€ in terms of the fraction of neighboring nodes that have to adopt the diffusing substance , beyond which they would adopt it themselves . For instance , in a social setting , an individual may refrain from voicing his opinion , until a significant fraction ( eg half ) of his friends have voiced a similar opinion . 2.1 Cascade Generative Process
Underlying the LT model is a weighted directed graph G = ( V , E , w ) , called the influence graph , where V is a set of n nodes and E is a set of m directed edges , and w : V Ã— V â†’ [ 0 , 1 ] is a weight function . For edges ( u , v ) /âˆˆ E we ignore the value of w(u , v ) . We further require that u:(u,v)âˆˆE w(u , v ) â‰¤ 1 for each node v . Starting from a source node ( or an initially activated node ) S0 = {a} , a cascade then proceeds in discrete time steps t = 0 , 1 , 2 , . . . as follows : ( 1 ) at t = 0 , every node v first independently selects a threshold Î¸v uniformly at random in the range [ 0 , 1 ] , reflecting the uncertainty as to usersâ€™ true thresholds ; ( 2 ) subsequently , an inactive node v becomes activated at time u:uâˆˆSt,(u,v)âˆˆE w(u , v ) â‰¥ Î¸v where St is the set of t + 1 if nodes activated up to time t ; ( 3 ) finally , the process terminates if no more activations are possible .
Given an influence graph G = ( V , E , w ) , the influence function Ïƒ(a , G ) of a source node a âˆˆ V is defined as the expected number of active nodes at the end of the diffusion process , Ïƒ(a , G ) = EÎ¸v [ |Sâˆ| ] , where the expectation is taken with respect to the randomness of the node thresholds Î¸v . 2.2 Live Edge Graph Representation
Kempe et al . [ 12 ] showed that the influence function can be computed in an alternative way using what is referred to as â€œ live edge graphs â€ , a construction that is more amenable to mathematical analysis . More specifically , a random liveedge graph X is generated as follows : Independently for each node v âˆˆ V , at most one of its incoming edges is selected with probability w(u , v ) , and no edge is selected with probu:(u,v)âˆˆE w(u , v ) . Note that the set of nodes of X is equal to V , the set of â€œ live â€ ( or sampled ) edges EX of X is a subset of E , ie , EX âŠ† E , and these edges are unweighted . Then , the influence function can be alternatively computed as ability 1 âˆ’
Pr[X|G ] Â· r(a , X ) ,
Ïƒ(a , G ) = EX [ r(a , X ) ] =
( 1 ) where XG is the space of all possible live edge graphs based on G , Pr[X|G ] is the probability of sampling a particular live edge graph X , and r(a , X ) is the set of all reachable nodes in X from source a . If we define function if âˆƒu : ( u , v ) âˆˆ EX
XâˆˆXG fl w(u , v ) , 1 âˆ’ u:(u,v)âˆˆE w(u , v ) , otherwise p(v , X , G ) := which is the probability of the configuration of incoming edges for node v in X ; then , the probability of a particular live edge graph X is vâˆˆV
Pr[X|G ] = p(v , X , G ) .
( 2 )
3 . SPACE OF LIVE EDGE GRAPHS
We will show that the objective functions of the edge deletion and addition problems are supermodular in the next section . However , the proofs require some properties beyond those used in [ 12 ] . Thus , we will first give some intuition as to why these properties are needed . We will denote the modification of an influence graph G by deleting or adding a set of edges S respectively by
G \ S := ( V , E \ S , w ) , and G âˆª S := ( V , E âˆª S , w ) .
Consider the monotonicity of the influence function as defined in Eq ( 1 ) , with respect to the set of source nodes A : Ïƒ(A âˆª a , G ) âˆ’ Ïƒ(A , G ) is a sum over XG , and so proving that Pr[X|G ] Â· r(A âˆª a , X ) âˆ’ Pr[X|G ] Â· r(A , X ) â‰¥ 0 for the single live edge graph X âˆˆ XG suffices to prove monotonicity , in this case . In contrast , consider the monotonicity of the influence function , with respect to the set of edges in the graph : Ïƒ(a , G\ S)âˆ’ Ïƒ(a , G\ ( Sâˆª{e}) ) . The issue here lies in that the former function sums over XG\S , whereas the latter sums over XG\(Sâˆª{e} ) : since the set of live edge graphs and the associated probabilities involved in the computation of the influence function will change as edges are deleted , it is not obvious that this function is monotone at all . Similar difficulties apply to proving supermodularity .
In this section , we will prove four properties related to the space of live edge graphs , which will form the basis of our later analysis . More specifically , we are concerned with
â€¢ a subset S of the edge set E in the original influence â€¢ two distinct edges e = ( u , v ) âˆˆ E \ S and g = ( u , v ) âˆˆ graph G , ie , S âŠ† E ; and E \ S outside S , where v may or may not equal v .
Deleting a set S from E will result in a new influence graph G \ S , which will generate a new space of live edge
Figure 1 : Four properties of the space of live edge graphs : ( 1 ) within space mapping , ( 2 ) space inclusion , ( 3 ) across space mapping , and ( 4 ) across space probability mapping . graphs , XG\S , and the associated live edge graph probabilities , Pr[X|G \ S ] . Furthermore , we will divide the space XG\S , according to the edge e , into three disjoint partitions ( see Fig 1(left) ) :
â€¢ X e â€¢ X Â¯e â€¢ X âˆ…
G\S , the set of live edge graphs where incoming edge e = ( u , v ) is selected for node v ;
G\S , the set of live edge graphs where a different in coming edge Â¯e = ( y , v ) is selected for node v ;
G\S , the set of live edge graphs where no incoming edge is selected for v .
Note that the probabilities of a live edge graph X common to both XG and XG\{e} may or may not change . Specifically , if node v has another incoming edge g = ( u , v ) in X , then
Pr[X|G ] âˆ’ Pr[X|G \ {e} ] = 0 .
Otherwise , if node v has no incoming edge in X , then , X , G )
Pr[X|G ] âˆ’ Pr[X|G \ {e} ] = âˆ’w(u , v )
( 3 ) since all terms in Eq ( 2 ) for Pr[X|G ] and Pr[X|G \ {e} ] concerning nodes v = v are exactly the same , and p(v , X , G ) = 1 âˆ’
, v ) âˆ’ w(u , v ) v=v w(u p(v u:(u,v)âˆˆE\{e}
= p(v , X , G \ {e} ) âˆ’ w(u , v ) .
G\S .
We establish the following four relations between the spaces of live edge graphs , and defer their proofs to the appendix . See Fig 1 for illustrations . 3.1 Within Space Mapping the elements in partition X e
Our first result establishes a one to one mapping between
G\S and X âˆ…
G\S , G\S , and
Proposition 1 . For every live edge graph X âˆˆ X âˆ… there exists a corresponding live edge graph X âˆˆ X e vice versa . If X = ( V , EX ) , then X = ( V , EX âˆª {e} ) . G\S and X âˆ…
3.2 Space Inclusion G\S of the space XG\S , to the space XG\(Sâˆª{e} ) . We note that this second space of live edge graphs , XG\(Sâˆª{e} ) , is generated from the influence graph G \ ( S âˆª {e} ) with an additional edge e deleted from G \ S . This result also shows that the space XG\(Sâˆª{e} ) is included in the space XG\S .
Our second result relates partitions X Â¯e
Proposition 2 . XG\(Sâˆª{e} ) âŠ† XG\S , and furthermore
XG\(Sâˆª{e} ) = X Â¯e
G\S âˆª X âˆ…
G\S .
Xğº\Sğ‘’ Xğº\Sğ‘’ Xğº\Sâˆ… Xğº\(ğ‘†âˆªğ‘’ ) Î¦ğ‘– Î¦ğ‘— Xğº\(ğ‘†âˆªğ‘”)ğ‘’ Xğº\(ğ‘†âˆªğ‘”)âˆ… ğ‘‹ğ‘– ğ‘‹ğ‘— ğ‘‹ğ‘– ğ‘‹ğ‘–â€² ğ‘‹ğ‘— ğ‘‹ ğ‘‹ ğğ«ğ‘¿ğ’Š|ğ‘®\(ğ‘ºâˆªğ’ˆ ) = ğğ«ğ‘¯|ğ‘®\ğ‘ºğ‘¯âˆˆğš½ğ’Š Xğº\S Xğº\(ğ‘†âˆªğ‘” ) Xğº\(ğ‘†âˆªğ‘”)ğ‘’ ( 1 ) ( 2 ) ( 3 ) ( 4 ) influence graph is minimized . That is
âˆ—
S
:= argmin SâŠ†E:|S|=k
Ïƒ(a , G \ S ) ,
( 5 ) aâˆˆA
Figure 2 : A dashed line means the edge has been deleted .
3.3 Across Space Mapping Our third result further partitions X âˆ… G\S into a collection of sets {Î¦i} , and establishes a one to one mapping between Î¦i and element Xi in the space X âˆ… G\(Sâˆª{g} ) , where g = ( u , v ) is an edge in E \ S with v = v .
Proposition 3 . Let t = |X âˆ… partitioned into t sets {Î¦i}t exists a corresponding Xi âˆˆ X âˆ…
G\(Sâˆª{g})| , then X âˆ…
G\S can be i=1 such that , for every Î¦i , there
G\(Sâˆª{g} ) , and vice versa .
3.4 Across Space Probability Mapping Our fourth result relates the probability of the partition Î¦i âŠ† X âˆ… G\S to the probability of the corresponding live edge graph Xi âˆˆ X âˆ… G\(Sâˆª{g} ) . This result is a sequel to the across space mapping property in the last section . Essentially , we show that the sum of the probabilities of the elements in Î¦i is equal to the probability of Xi .
Proposition 4 . For every Î¦i âŠ† X âˆ…
G\(Sâˆª{g} ) , Pr[Xi|G\(Sâˆª{g} ) ] =
Xi âˆˆ X âˆ…
G\S and its associated Pr[H|G\S ] .
HâˆˆÎ¦i
4 . NETWORK OPTIMIZATION f ( S âˆª {e} ) âˆ’ f ( S ) â‰¤ f ( T âˆª {e} ) âˆ’ f ( T ) .
In this section , we will prove a set of results for the LT model , namely that the objective functions are supermodular in both the edge deletion and the edge addition problems . These results will form the basis for our algorithm design . A set function f : 2E â†’ R defined over the power set 2E of a set E is called supermodular iff âˆ€S âŠ† T âŠ‚ E,âˆ€e âˆˆ E \ T ( 4 ) Intuitively , for a monotone increasing supermodular function f , the marginal gain of adding a new element e to a set T is greater than the gain of adding e to any subset S of T . This property is referred to as the increasing differences property , as opposed to diminishing returns in the case of a submodular function . If f is a monotone decreasing function ( as will be the case when we consider deleting edges or nodes ) , then the marginal loss in adding e to T would be smaller than that of adding e to S . set of potential sources A as
We define the susceptibility of an influence graph G to a aâˆˆA Ïƒ(a , G ) , which is the sum of the influence function for each node a . Intuitively , one can think of each node a âˆˆ A as having equal probability of being the source , and the susceptibility of G as the expected value of the influence function with respect to the randomness of picking an a from A . Our definition of susceptibility can also be generalized to the case where each node a has a different probability of being the source . In this case , all our subsequent theorems would still hold . Furthermore , we assume that the size of the source set is only poly logarithmic in the total number of nodes in the network , ie , |A| |V | . 4.1 Edge Deletion Problem In this problem , given an influence graph G = ( V , E , w ) and a set of sources A , we want to delete a set of edges Sâˆ— of size k from G such that the susceptibility of the resulting where the objective function is a set function over the edges S to be deleted . We will show that each Ïƒ(a , G \ S ) is a monotonically decreasing and supermodular function of S , and hence their positive sum , aâˆˆA Ïƒ(a , G \ S ) , also is .
Monotonicity . In this section , we prove that Ïƒ(a , G\ S ) is a monotonically decreasing function of S . We will use the within space mapping property in Prop . 1 and the space inclusion property in Prop . 2 to prove the following result : Theorem 5 . Ïƒ(a , G \ S ) is a monotonically decreasing function of the set of edges S to be deleted . to show that for any set S âŠ† E and e = ( u , v ) âˆˆ E \ S :
Proof . Given the influence graph G = ( V , E , w ) , we need
Ïƒ(a,G \ S ) âˆ’ Ïƒ(a , G \ ( S âˆª {e} ) ) 0 . G\S , X Â¯e
Using the fact that the space XG\S is partitioned into G\S , and the space XG\(Sâˆª{e} ) G\S and X âˆ… G\S ( space inclusion three sets , X e G\S and X âˆ… is partitioned into two sets X Â¯e property in Prop . 2 ) , we can write the difference as
Ïƒ(a , G \ S ) âˆ’ Ïƒ(a , G \ ( S âˆª {e} ) ) Pr[X|G \ S ] Â· r(a , X ) = ( Pr[X|G \ S ] âˆ’ Pr[X|G \ ( S âˆª {e}) ] ) Â· r(a , X ) ( Pr[X|G \ S ] âˆ’ Pr[X|G \ ( S âˆª {e}) ] ) Â· r(a , X )
XâˆˆX âˆ…
XâˆˆX e
G\S
G\S
( 6 )
+
+
XâˆˆX Â¯e
G\S
â€¢ For X âˆˆ X âˆ…
â€¢ For X âˆˆ X Â¯e v=v p(v , X , G \ S ) .
S ) = p(v , X , G \ ( S âˆª {e} ) ) = w(Â¯e ) .
Recall that e = ( u , v ) . We will simplify the last two sum(S âˆª {e} ) ] = âˆ’w(u , v ) mands in the above equation using the following two facts : G\S based on Eq ( 3 ) : Pr[X|G\S]âˆ’Pr[X|G\ G\S , the probability is the same , p(v , X , G\ Then Eq ( 6 ) simplifies to âˆ’w(u , v ) + Pr[X|G \ S ] Â· r(a , X ) v=v p(v , X , G \ S ) Â· r(a , X ) . Since G\S has probability Pr[X|G \ S ] = w(u , v ) Â· any X âˆˆ X e v=v p(v , X , G\S ) , then using Prop . 1 to match X âˆˆ X e
Since the live edge graph X has one more edge than X , clearly r(a , X)âˆ’r(a , X ) 0 , which completes the proof .
Pr[X|G \ S ] Â· r(a , X ) âˆ’ r(a , X )
G\S , we have that Eq ( 6 ) is equal to to X âˆˆ X âˆ…
XâˆˆX âˆ…
XâˆˆX âˆ…
XâˆˆX e
G\S
G\S
G\S
G\S
( 7 )
. function of the set of edges S to be deleted .
Supermodularity . We will use the across space mapping property in Prop . 3 ( also Prop . 4 ) and the probability mapping property in Prop . 1 to prove the following result : Theorem 6 . The function Ïƒ(a , G \ S ) is a supermodular Proof . Let t = |X âˆ… G\(Sâˆª{g})| , then using the across space G\S into t i=1 and rewrite Eq ( 7 ) in the proof of Thm . 5 as : ( 8 ) mapping property in Prop . 3 , we can partition X âˆ… sets {Î¦i}t r(a , X ) âˆ’ r(a , X ) t i=1
XâˆˆÎ¦i
Using similar reasoning to that in Eq ( 7 ) in the proof of Thm . 5 for G \ ( S âˆª {g} ) , we have
Ïƒ(a , G \ ( S âˆª {g} ) ) âˆ’ Ïƒ(a , G \ ( S âˆª {g , e} )
( 9 )
Pr[X|G \ S ] Â· Pr[X|G \ ( S âˆª g ) ] Â· r(a , X ) âˆ’ r(a , X )
=
XâˆˆX âˆ…
G\(Sâˆª{g} )
ğ‘¢ ğ‘£ ğ‘¢â€² ğ‘£â€² ğ‘¡ ğ‘‹ğ‘– ğ‘’ ğ‘” ğ‘ ğ‘¢ ğ‘£ ğ‘¢â€² ğ‘£â€² ğ‘¡ ğ‘‹ğ‘–â€² ğ‘’ ğ‘” ğ‘ ğ‘¢ ğ‘£ ğ‘¢â€² ğ‘£â€² ğ‘¡ ğ‘‹ ğ‘– ğ‘’ ğ‘” ğ‘ i ) i ) âˆ’ r(a , X
( 10 ) i} , we need to show
Then to establish Eq ( 10 ) , it suffices to show that
Then we need only compare Eq ( 9 ) and ( 8 ) term by term for each Xi âˆˆ X âˆ… G\(Sâˆª{g} ) , i = 1 , . . . , t . Clearly , when Î¦i = {Xi} , the terms from the two equations are equal . When Î¦i = {Xi , X r(a , Xi ) âˆ’ r(a , Xi ) have Pr[Xi|G \ ( S âˆª {g} ) ] = Pr[Xi|G \ S ] + Pr[X i ) r(a , Xi ) âˆ’ r(a , Xi ) .
Pr[Xi|G \ S ] Â· r(a , Xi ) âˆ’ r(a , Xi ) i|G \ S ] Â· + Pr[X r(a , X Pr[Xi|G \ ( S âˆª {g} ) ] Â· r(a , X
Based on the probability mapping property in Prop . 4 , we i|G \ S ] . i ) âˆ’ r(a , X i = ( V , EXi âˆª {g} ) . Since live edge graphs are Recall that X constructed in a way that each node has at most one incoming edge , each reachable node y has a unique path from the source node a to node y . Furthermore : ( 1 ) a reachai , hence if re bility path in Xi is clearly also present in X moving edge e = ( u , v ) from Xi results in unreachability of able when removing e from X i ; ( 2 ) removing edge e from X able nodes when removing edge e from X larger than the reduction when removing edge e from Xi . i may disconnect some additional nodes whose paths from the source a include edge g . Therefore the reduction in reachi is the same or some nodes in Xi then those same nodes become unreach
This completes the proof . 4.2 Edge Addition Problem
In this section , given a partial influence graph G(V , E , w ) and a larger potential influence graph G = ( V , E , w ) with E âŠ† E , we want to add to G a set of edges Sâˆ— of size k from E \ E such that the resulting susceptibility is maximized : ( 11 )
âˆª S argmax
Ïƒ(a , G
:=
) ,
S
âˆ—
SâŠ†E\E:|S|=k aâˆˆA where the objective function is a set function over the edges S to be added . We will show that each Ïƒ(a , G âˆª S ) is monotone and supermodular , and hence their positive combination , Ïƒ(A , G âˆª S ) , is also monotone and supermodular . Theorem 7 . The function Ïƒ(a , G âˆª S ) is a monotone and supermodular function of the set of S edges to be added .
Proof . We will prove the results by relating the objective function to that in the edge deletion problem and then apply the results from the edge deletion problem . More specifically , If we define S = E \ ( S âˆª E âˆª {e} ) , then let S âŠ† T and e âˆˆ E \ T . âˆª {e} ) ) = Ïƒ(a , G \ S )
Ïƒ(a , G
) = Ïƒ(a , G \ ( S âˆª {e}) ) , since G âˆª ( S âˆª {e} ) = G \ S and G âˆª S = G \ ( S âˆª {e} ) . Similarly , if we define T = E \ ( T âˆª E âˆª {e} ) , then
âˆª S
âˆª ( S Ïƒ(a , G
Ïƒ(a , G
âˆª ( T Ïƒ(a , G
âˆª {e} ) ) = Ïƒ(a , G \ T ) âˆª T
) = Ïƒ(a , G \ ( T âˆª {e}) ) .
Note that S âŠ† T implies that T âŠ† S . Then we apply the supermodularity of Ïƒ(a , G \ S ) as a function of the edges S to be deleted in Thm . 6 , and obtain
Ïƒ(a , G
âˆª(S
âˆª {e} ) ) âˆ’ Ïƒ(a , G Ïƒ(a , G
âˆª ( T
âˆª S
)
âˆª {e} ) ) âˆ’ Ïƒ(a , G
âˆª T
) , which completes the proof .
Figure 3 : Illustration of a live edge graph X , the tree T a X ina X which is duced by BFS rooted at a , the part of the graph T the complement to T a X . For the edge deletion problem , we build a descendant counting tree data structure for each live edge tree T a X where each node stores its number of descendants . For the edge addition problem , we build a neighbor counting graph data a structure for each complement T X , where each node stores a list i ( v ) ) obtained over q random labelings . of q least labels(lâˆ—
5 . SCALABLE ALGORITHMS
Given that the edge deletion and addition problems are supermodular , we can , in principle , solve the network topology optimization problems using the state of the art supermodular optimization algorithms . However , there remain great challenges in scaling these algorithms up to diffusion networks with millions of nodes . First , supermodular optimization requires evaluating the influence function many times . The problem of computing the influence function Ïƒ(a , G ) exactly has been shown to be #P Hard [ 4 ] . Thus there is a need to design methods to approximately compute the influence function in near linear time . To tackle this problem , we will estimate Ïƒ(a , G ) using empirical averaging ( EA ) over a fixed set of live edge graphs , pre sampled using the LT live edge graph generation process described in section 22 That is r(a , T a
Xi )
XiâˆˆL
( 12 ) where L = {Xi}1â‰¤iâ‰¤l is the set of sampled live edge graphs from G . Recall T a Xi is the tree rooted at a induced from Xi . Second , typically , the marginal change of the influence function for each candidate edge needs to be computed . This imposes the additional requirement that each marginal change computation has to be nearly constant time to handle the large number of candidate edges . To address these challenges , we will design an efficient descendant counting tree data structure for the edge deletion problem , and use it as part of a greedy algorithm to minimize the supermodular objective function . For the edge addition problem , we will employ an efficient randomized neighbor counting graph data structure , and use it inside a modular approximation algorithm to maximize the supermodular objective function . Fig 3 illustrates the data structures . In both cases , time and space complexities are linear in the network size . 5.1 Edge Deletion tionÏƒ(a , G\S ) under edge deletion is also supermodular and
It is easy to see that the empirical average influence func monotonically decreasing . To solve the problem at hand , we
Ïƒ(a , G ) â‰ˆÏƒ(a , G ) :=
|L| Â·
1
12453ğ‘ğ‘‡ğ‘‹ğ‘14100descendant counting tree6789 ğ‘‡ğ‘‹ğ‘0101â€¦030802â€¦040203â€¦040603â€¦07neighbor counting graph12453ğ‘‹ğ‘ğ‘‡ğ‘‹ğ‘6789 ğ‘‡ğ‘‹ğ‘live edge graphğ‘ 1 L r(a , T a
Xi \ St ) âˆ’ r(a , T a adopt a simple greedy approach : at each iteration , given the current solution St , add to the solution the element e with the largest marginal loss âˆ†(e|St ) defined using Eq ( 12 )
Xi \ ( St âˆª {e} ) ) aâˆˆA XiâˆˆL Xi \St means deleting edges St from tree T a where T a on this expansion , we notice that the edge with largest marginal loss is the edge whose deletion results in the largest decrease in the average number of descendants over all source nodes and the set of induced live edge trees T a X . Note that we use the terminology â€œ marginal loss â€ rather than â€œ marginal gain â€ because our objective function is monotone decreasing , hence âˆ†(e|St ) measures the marginal loss resulting from removing e after edges St have been removed .
Xi . Based
( 13 )
NaÂ¨Ä±vely applying the greedy algorithm is computationally intensive and will not scale to networks with millions of nodes . Basically , at iteration t , for every edge e âˆˆ E \ St X , we need to compute âˆ†(e|St ) by performing and every T a a Breadth First Search ( BFS ) traversal from the source a , Xi \ St and and count the number of nodes reachable in T a Xi \ ( St âˆª {e} ) . It is easy to see that such an approach will T a lead to an O(|V |2 + |V ||E| ) complexity algorithm : BFS is O(|V | + |E| ) and we need to check O(|E| ) edges in E \ St . Such quadratic dependence on the network size motivates us to design a more efficient solution .
X \ St)âˆ’ r(a , T a
Scaling Up . Can we avoid the many BFS traversals ? To answer this question , we first make the following observation Observation 1 . Given an edge e = ( u , v ) to be deleted where v is reachable from the source a , the marginal loss âˆ†(e|St ) can be computed as X \ St ) + 1 ( 14 ) X \ ( St âˆª{e} ) ) = r(v , T a r(a , T a This observation implies that , if we can compute r(v , T a X ) for all v âˆˆ V in the original live edge tree T a X , we can then compute the marginal gain of each edge e efficiently . X ) , efficiently , for all v âˆˆ V ? Fortunately , since we are dealing with trees of at most |V | edges each , this can be done in time O(|V | ) using a single BFS traversal . More specifically , after initializing r(v , T a
Can we compute the number of descendant , r(v , T a
X ) = 0 , âˆ€v âˆˆ V ,
1 . Perform a BFS starting from the source a of T a
X , adding each traversed edge e to a stack H ; at the end of the BFS , the top of the queue is the last edge traversed .
2 . While stack H is not empty , pop edge e = ( u , v ) and increment r(u , T a
X ) by r(v , T a
X ) + 1 .
The correctness of the above procedure is easy to verify : the number of descendants of a node is equal to the sum of the number of descendants of its children , plus the number of children it has , which is exactly what we are computing .
, T a
X \ ( St âˆª {e} ) ) = r(u
Suppose we have already maintained the descendant counts X \ St ) for all node v âˆˆ V . Then after deleting edge r(v , T a e = ( u , v ) , there are two types of nodes for which need to update the descendant counts : the ancestors u of node v , and the nodes that have become unreachable . For the former , we update their descendant counts by subtracting out the number of descendants of node v plus 1 . Similar to Eq ( 14 ) , X \ St ) âˆ’ 1 . r(u For the latter , we simply set their descendant counts to X \ ( St âˆª {e} ) ) = 0 . Last , the marginal zero , ie , r(u , T a loss of each edge can also be updated according to Eq ( 14 ) . Overall Algorithm : GreedyCutting is summarized in Algorithm 1 . It first samples live edge graphs and obtains the corresponding live edge trees for the input sources A . Lines 4â€“12 compute the initial descendant counts variables r(u , T a X , and the edge marginal
X ) for each node u and each T a
X \ St ) âˆ’ r(v , T a
, T a
6 7 8 9 10
21
22 23 24 25 26 loss variables âˆ†(e ) for all edges in E . For each iteration , line 15 adds to the solution set the edge with largest marginal loss , and lines 16â€“27 locally update the descendant count variables for nodes , and marginal loss variables for edges . Finally , the solution set Sâˆ— is returned . If we assume the number of source nodes to be polylogarithmic in |V | , then Algorithm 1 has computational complexity O(k|L||V | ) , which is linear ( up to poly logarithmic factors ) in the size of the network . As for space complexity , our main data structures store the node descendant counts for each induced live edge tree on one hand , and the marginal losses of the edges on the other , requiring space of complexity O(|E| + |V ||L| ) , linear in the network size . and h(S ) = Lemma 8 . Let Sâˆ— âˆˆ argminSâŠ†E:|S|=k aâˆˆA Ïƒ(a , G \ S ) , aâˆˆA Ïƒ(a , G ) âˆ’ Ïƒ(a , G \ S ) , the reduction in S returned by GreedyCutting satisfies influence when S is deleted from E . Let Î± be the approximation factor for influence estimation by EA . The solution h(S ) ( 1 âˆ’ 1/e âˆ’ Î±)h(S
âˆ— ) Proof . Straightforward based on [ 18 ] .
Algorithm 1 : GreedyCutting Input : Influence Graph G(V , E , w ) , Sources A , k Output : Edges Sâˆ— 1 Sample a set of live edge graphs L = {X} from G 2 Obtain the set of induced live edge trees {T a 3 Initialize âˆ†(e ) = 0 for all e âˆˆ E , r(u , T a
4 for each T a 5 u âˆˆ V and T a X do Initialize queue Q , stack H , Q.enqueue(a ) , visited = {a} while Q is not empty do
X
X} from L
X ) = 0 for all s = Q.dequeue( ) for u âˆˆ V and ( s , u ) is an edge in T a
X do if u /âˆˆ visited then visited = visited âˆª {u} , Q.enqueue(u ) , H.push((s , u ) ) while H is not empty do
( u , v ) = H.pop( ) , r(u , T a âˆ†((u , v ) ) += r(v , T a
X ) + 1
X ) += r(v , T a
X ) + 1 , et = ( ut , vt ) = argmaxeâˆˆE\Sâˆ— âˆ†(e ) , Sâˆ— = Sâˆ— âˆª {et} for each T a
X do if et is an edge in T a
X then
11 12 13 Sâˆ— = âˆ… 14 for t=1 to k do 15 16 17 18 19 20 s = ut while s is not the source a do X ) + 1 ,
X ) âˆ’= r(vt , T a r(s , T a âˆ†((parent(s ) , s ) ) âˆ’= r(vt , T a s = parent(s )
Initialize queue Q , Q.enqueue(ut ) , visited = {ut} while Q is not empty do
X ) + 1 , s = Q.dequeue( ) for u âˆˆ V and ( s , u ) is an edge in T a
X do if u /âˆˆ visited then visited = visited âˆª {u} , Q.enqueue(u ) , âˆ†((s , u ) ) âˆ’= r(u , T a r(s , T a X ) = 0 , r(u , T a
X ) + 1 , X ) = 0
27 return Sâˆ— 5.2 Edge Addition
We now turn to our algorithmic framework for solving the problem of adding edges . Recently , Iyer et al . [ 11 ] proposed
Ïƒ(a , G a simple approach for constrained submodular minimization with approximation guarantees , which we will adapt for our ( analog ) supermodular maximization problem . Recall that given a partial influence graph G(V , E , w ) and a larger potential influence graph G = ( V , E , w ) with E âŠ† E , we want to add to G a set of edges Sâˆ— of size k from E \ E such that the resulting susceptibility is maximized ( Eq ( 11) ) . The algorithm constructs a modular lower bound ( MLB ) of the objective function , and then adds edges that maximize this lower bound , instead of the original objective . That is , Xi âˆª {e} ) , 1 |L| where L = {Xi}1â‰¤iâ‰¤l is the set of sampled live edge graphs from G , and T a Xi is the tree rooted at a induced from Xi . Xi âˆª S refers to the live edge tree resulting from Then , T a adding new edges S to T a Xi . Note that the resulting tree may allow the source a to reach some nodes originally not reachable in T a
Xi âˆª S ) 1 |L| r(a , T a r(a , T a
XiâˆˆL
XiâˆˆL aâˆˆA aâˆˆA eâˆˆS
Xi .
The MLB approach has several nice properties . First , the modular lower bound function is simple , essentially requiring Xi âˆª{e} ) for each us to compute the reachability score r(a , T a candidate edge to be added . Second , maximizing the MLB for a budget k reduces to simply finding the top k edges which lead to the largest function value
âˆª {e} ) =
1 |L| r(a , T a
Xi âˆª {e} ) .
( 15 ) aâˆˆA
XiâˆˆL aâˆˆA However , naÂ¨Ä±vely applying the MLB algorithm is computationally intensive and can not be scaled up to networks with millions of nodes . Basically , for every candidate edge e to be added and for every T a X , we need to compute the Xi âˆª {e} ) by performing a BFS traversal reachability r(a , T a from the source a , and count the number of nodes reachable Xi âˆª {e} . It is easy to see that such an approach will in T a lead to an O(|V ||E| ) complexity algorithm : BFS is O(|V | ) X have at most |V | edges ) , and we need to ( since trees T a check O(|E| ) edges in E \ E . Again , we are motivated to design a more efficient solution . a X ) + 1 )
Scaling Up . Can we avoid the many BFS traversals ? To answer this question , we first make the following observation Observation 2 . Given an edge e = ( u , v ) to be added , where node v is originally not reachable from the source a , but becomes reachable with the addition of e , the reachability of a can be updated as
X âˆª {e} ) = r(a , T a r(a , T a a X is the complement of T a
X ) + w(e ) Â· ( r(v , T
( 16 ) X containing those nodes where T and edges not reachable from a . a We note that the term r(v , T X ) + 1 is multiplied by the weight w(e ) of edge e to account for the probability of that edge being actually picked by node v in the live edge generation process of the new influence graph G âˆª {e} . Furthermore , note that T a X may contain cycles .
Can we compute the number of reachable nodes , r(v , T a X ) , a efficiently , for all v in T X ? Fortunately , this problem has been extensively studied in the theoretical computer science literature as the neighborhood size estimation problem [ 5 ] , and was recently applied in the context of influence estimation for a continuous time diffusion model [ 7 ] . We will adapt a linear time algorithm by Cohen [ 5 ] for our problem .
We apply the algorithm to T a X as follows : first , we assign to each node u a label l(u ) drawn from the exponential distribution with parameter ( mean ) 1 . Then , we exploit the fact that the minimum lâˆ—(v ) of the set of exponential random labels {l(u)} for nodes u reachable from v will itself be an exponential random variable , with its parameter equal a X ) . If we repeat the random labeling q times and i=1 , then the neighborhood i ( v)}q to r(v , T obtain q such least labels {lâˆ— size is estimated as X ) â‰ˆ r(v , T a
.
( 17 ) q âˆ’ 1q i=1 lâˆ— i ( v )
Can we find the least labels efficiently for all nodes v given each random labeling ? In fact , this can be done using a modified BFS traversal which requires time only linear in the network size . More specifically , For a given labeling , we start from the node v with the smallest label , and perform a BFS traversal in the reverse direction of the graph edges . For each node u encountered in the BFS , we set lâˆ—(u ) = l(v ) . Once a node has been encountered in a BFS and its least label has been set , it is marked as visited , not only for this particular BFS , but across all subsequent BFS runs . After the BFS traversal from node v is complete , we move to the unvisited node with the next smallest label , and repeat the procedure iteratively until all nodes have been marked as visited . It is easy to see why this algorithm correctly assigns the appropriate least label lâˆ—(v ) to each node v : since we order the BFS runs by minimum labels , and traverse the edges in reversed direction , then once a node u has been visited , we are guaranteed that the lâˆ—(u ) we assign to it is the smallest , and any subsequent BFS that can reach u will have a label larger than lâˆ—(u ) .
Overall Algorithm : ModularAdding is summarized in Algorithm 2 : we first generate the live edge graphs , induce the live edge trees , and draw q labels for each node v âˆˆ V from the exponential distribution with mean 1 ( lines 1 5 ) . Then , for each source node a âˆˆ A , we iterate over the induced live edge trees T a X , collecting the estimated neigha borhood size of each node v in the complement T X of each such tree , by applying Cohen â€™s algorithm ( lines 7 20 ) . After iterating over the live edge trees , we compute the final score for each edge e âˆˆ C in the candidate set C as the sum over v â€™s neighborhood size estimates , weighted by the edge â€™s diffusion probability w(e ) ( lines 21 22 ) . Finally we sort the scores vector in descending order , and return the top k edges . We assume the number of sources |A| is poly logarithmic in |V | and hence ignored in the complexity analysis . Then Algorithm 2 has computational complexity O(q|L||V | ) and space complexity O(q|V | ) . This is because the Cohen â€™s algorithm has complexity O(q|V | ) , and is invoked O(|L| ) times . The final sorting of the scores can be done in O(|E \ E| ) . As for space , we only require data structures of sizes linear in the number of nodes O(q|V | ) to hold the least labels . aâˆˆA Ïƒ(a , Gâˆª aâˆˆA Ïƒ(a , G)âˆ’ Ïƒ(a , G âˆª S ) , the difference between the influence in the potential graph G and the influence when S is added to E . Let Îºg be the curvature [ 11 ] of g , and Î² be the approximation factor of our two estimation subroutines ( 1 ) EA and ( 2 ) Cohen â€™s algorithm . The solution
Lemma 9 . Let Sâˆ— âˆˆ argmaxSâŠ†E\E:|S|=k
S ) , and g(S ) =
S returned by ModularAdding satisfies g(S ) Î²/(1 âˆ’ Îºg ) Â· g(S
âˆ—
)
Proof . Straightforward based on Thm . 5.4 in [ 11 ] .
6 . EXPERIMENTS AND RESULTS
We now present our experimental setting and results .
6.1 Setting
Synthetic networks . We generate three types of networks using the Kronecker graph model2 [ 17 ] , known to
2http://snapstanfordedu/data/
X} from L
Algorithm 2 : ModularAdding Input : G(V , E , w ) , k , Sources A , Candidates C Output : Edges Sâˆ— for each i = 1 , . . . , q do
1 Sample a set of live edge graphs L = {X} from G 2 Obtain the set of induced live edge trees {T a 3 for each v âˆˆ V do 4 5 6 for each a âˆˆ A do a 7 X do 8 9 10 li(v ) âˆ¼ exp ( âˆ’x ) a X ordered according to visited = âˆ… for nodes v in T argsort({li(v)} ) do for each i = 1 , . . . , q do for each T if v /âˆˆ visited then visited = visited âˆª {v} Initialize Q , Q.enqueue(v ) while Q is not empty do u = Q.dequeue( ) , lâˆ— visited = visited âˆª {u} for each parent s of u in T i ( u ) = l(v ) a X do
Q.enqueue(s )
11 12 13 14 15 16 17 18 19
20 r(v , T a X ) = a X do for each node v in T q âˆ’ 1q score(e ) += w(e ) Â· i=1 lâˆ— for each e = ( u , v ) âˆˆ C do
21 22 23 Sâˆ— = argsort(score , k , descending ) 24 return Sâˆ— i ( v )
XiâˆˆL(r(v , T a X ) + 1 )
Table 1 : Datasets summary . Numbers outside ( inside ) bracket are for edge deletion ( addition ) experiments . Last column is for Kronecker parameter matrices .
Dataset CorePeriphery ErdosRenyi Hierarchical HepPH Epinions MemeTracker
#Nodes
#Edges Kronecker
1M(65K )
2M ( 131K )
35K 75K 1.8K
420K 509K
5K
[ .9 .5 ; .5 .3 ] [ .5 .5 ; .5 .5 ] [ .9 .1 ; .1 .9 ]
â€” generalize a number of realistic graph models : ( 1 ) CorePeriphery , ( 2 ) ErdosRenyi and ( 3 ) Hierarchical . These three graph models have very different structural properties , allowing us to test for sensitivity to network structure .
Real world networks . We choose three publicly available real world datasets2 that are amenable to diffusion processes and hence suitable for our problems : ( 1 ) HepPH : a whom cites whom citation network based on the Arxiv Highenergy Physics papers over the period 1993 2003 ; ( 2 ) Epinions : a who trusts whom online social network of the consumer review site Epinions.com ; ( 3 ) MemeTracker : a whocopies from whom network of news media sites and blogs . The statistics of the datasets are summarized in Table 1 . given node v âˆˆ V , we draw a probability value w(u , v ) for
Assigning probabilities . Given a network G(V , E ) , we populate the weight vector representing the probabilities on the edges E according to the LT model , as follows : for a each edge e = ( u , v ) âˆˆ E that is incoming into v , uniformly at random from the interval [ 0 , 1 ] . In addition , we draw from the same interval a probability value wv representing no infection , i.e the probability that v â€™s infected parents fail
Table 2 : Parameter values used in the experiments of Fig 4 ( 1st row ) , and Fig 5 ( 2nd row ) : A is the set of sources , Lopt is the set of live edge graphs used by our algorithm , Leval is the set of liveedge graphs used for evaluation of all algorithms and heuristics , t refers to the budget of edges deleted for which diffusion stops completely , q is the number of random labelings used in Algo . 2 .
Problem
Edge Deletion Edge Addition
Parameters for Experiments
|A|
|Lopt|
|Leval|
100
1 , 000
5 , 000 k
[ 0 , t ]
[ 0 , 2000 ] q âˆ’ 20 the median transmission time between two nodes u and v , this method for all datasets except for MemeTracker .
For MemeTracker , we make use of the median transmis to activate it . Since the probabilities on the edges plus the probability of no infection must sum to 1 , we then normalize each probability over the sum of all the probabilities , ie , we obtain w(u , v ) = w(u , v)/( uâˆˆV w(u , v ) + wv ) . We apply sion time , also provided as part of the dataset . Lett(u , v ) be then we set w(u , v ) âˆt(u , v)âˆ’1 , rewarding smaller transmisthe weights for all nodes v such that sion times with higher diffusion probabilities , and vice versa . We assign a probability of wv = 0.2,âˆ€v âˆˆ V , and normalize uâˆˆV w(u , v)+wv = 1 . Competing heuristics . To evaluate the efficacy of the solutions provided by our algorithms , we compare against other heuristic measures that are not based on the dynamics entailed by the LT diffusion model . These heuristic strategies can be described as follows : ( 1 ) Random : select k edges uniformly at random from the input set of edges , ( 2 ) Weights : select the k edges with highest diffusion probability ( weight ) w(u , v ) , ( 3 ) Betweenness : select k edges with highest edge betweenness centrality [ 2 , 20 ] , ( 4 ) Eigen : select the k edges that cause the maximum decrease ( increase ) in the leading eigenvalue of the network when removed from it , or added to it [ 22 ] , ( 5 ) Degree : select the k edges whose destination nodes have the highest out degrees [ 8 ] .
6.2 Deleting Edges
We carry out each experiment as follows : given an influence graph G(V , E , w ) , a set of source nodes A chosen uniformly at random from V , and a budget k of edges to delete , we run GreedyCutting and the five heuristics and obtain a set of edges from each . Then , for each algorithm or heuristic , we simulate the LT diffusion process by generating a set of live edge graphs Leval based on G , and then deleting the proposed set of edges Sâˆ— from all live edge graphs in Leval . The efficacy of each proposed set of edges is measured by Ik , the average number of infected nodes over Leval . These parameters are summarized in Table 2 . The budget k is increased until diffusion is no longer possible , ie , the source nodes are completely isolated .
Synthetic networks . The results are shown in Fig 4 ( a c ) . First , we observe that our algorithm clearly outperforms all five other heuristics : for any budget k of edges to delete , our algorithm minimizes the graph susceptibility ratio ( Ik/I0 ) better than any of the heuristics for all three synthetic network types , implying that it produces good solutions independently of the structural properties of the input network . On the other hand , the considered heuristics perform arbitrarily good or bad , as we vary the type of synthetic network . At last , we observe that even for |Lopt| = 1 , 000 , a quantity much smaller than the typical 10 , 000 used in the literature , the green and red lines are almost indistinguishable , meaning our solution generalizes well to the larger evaluation set of 5 , 000 live edge graphs . a ) CorePeriphery b ) ErdosRenyi c ) Hierarchical d ) HepPH e ) Epinions f ) MemeTracker
Figure 4 : Efficacy of the edge deletion solutions provided by different algorithms . Lower is better . The x axis refers to the budget k ; the y axis refers to the graph susceptibility ratio , defined in the range [ 0 , 1 ] as : Ik/I0 .
Real world networks . We observe similar performance for real world networks ( Fig 4 ( d f) ) . For instance , for the Epinions dataset ( Fig 4(e) ) , our method has decreased the graph susceptibility to 40 % of its original value at k = 200 , whereas the best performing heuristic at the same k is Weights with 60 % ( here , lower is better ) . 6.3 Adding Edges
The experimental procedure for evaluating our ModularAdding algorithm and other heuristics is analogous to that described in 6.2 for edge deletion . We compare our algorithm to all previously described heuristics , for the exception of the Betweenness heuristic , as it is not obvious how meaningful it would be to compute this metric for edges that do not initially exist in the network . Results are in Fig 5 . Synthetic networks . Our algorithm is almost always twice as effective as the next best heuristic , be it Weights or Degree . This efficacy gap is consistent across all three types of networks , confirming yet again the robustness of the solutions we find to varying structural properties of networks . Real world networks . Similarly to the synthetic setting , our algorithm significantly outperforms all four heuristics in the real world setting , for all three datasets . For instance , for the HepPH dataset in Fig 5(d ) , the Degree heuristic requires adding 2 , 000 edges to the set A of 100 sources in order to increase the graph susceptibility by twice its initial value ( ie , at k = 0 ) , whereas our algorithm increases the graph susceptibility by the same amount for k = 200 edges , a small fraction of 2000 . This superior performance implies that our algorithm is more amenable to real world applications , where the budget is typically very small relative to the number of nodes , possibly representing humans in a social network , blogs on the web , etc . 6.4 Scalability
Scalability is a major concern in the industrial setting . We experimentally verify the scalability of both our edge deletion and addition algorithms . All experiments were executed on a laptop with a 2.7GHz quad core i7 CPU and 16Gb RAM . The results presented in Fig 6 measure the runtime of our algorithms on synthetic CorePeriphery networks of increasing number of nodes , and fixed average degree of 2 .
Figure 6 : Runtime on synthetic core periphery networks : for both lines , each point represents the average time in seconds per edge deleted or added . The number of sources is poly logarithmic in the number of nodes and the number of live edge graphs used is 100 , for both problems . For ModularAdding , q = 5 .
We vary the number of nodes , starting at 27 = 128 nodes , and up to 223 = 8 , 388 , 608 nodes ( 16 , 777 , 216 edges ) . The experimental results show that our algorithms scale linearly in the size of the network . As expected , ModularAdding , while also having a linear scaling , is more time consuming than GreedyCutting , due to the repeated linear time algorithm for building the neighbor counting graph .
7 . ACKNOWLEDGEMENTS
This research was supported in part by NSF/NIH BIGDATA 1R01GM108341 01 , NSF IIS1116886 , NSF CAREER IIS1350983 and a Raytheon faculty fellowship to L . Song . References [ 1 ] I . Bogunovic . Robust protection of networks against cascading phenomena . Master â€™s thesis , ETHZ , 2012 .
[ 2 ] U . Brandes . A faster algorithm for betweenness centrality . Journal of Mathematical Sociology , 25(2 ) , 2001 . [ 3 ] W . Chen , L . V . Lakshmanan , and C . Castillo . Information and influence propagation in social networks . Synthesis Lectures on Data Management , 2013 .
[ 4 ] W . Chen , Y . Yuan , and L . Zhang .
Scalable influence maximization in social networks under the linear threshold model . In IEEE ICDM , pages 88â€“97 , 2010 .
[ 5 ] E . Cohen . Size estimation framework with applications to transitive closure and reachability . Journal of Computer and System Sciences , 55(3):441â€“453 , 1997 .
[ 6 ] P . Domingos and M . Richardson . Mining the network value of customers . In ACM KDD , pages 57â€“66 , 2001 .
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 50 100 150 200 250Graph Susceptibility RatioBudget ( k)GreedyCutting ( Training)GreedyCuttingRandomWeightsBetweennessEigenDegree 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 20 40 60 80 100 120 140 160 180 200Graph Susceptibility RatioBudget ( k)GreedyCutting ( Training)GreedyCuttingRandomWeightsBetweennessEigenDegree 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 50 100 150 200Graph Susceptibility RatioBudget ( k)GreedyCutting ( Training)GreedyCuttingRandomWeightsBetweennessEigenDegree 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 200 400 600 800 1000 1200Graph Susceptibility RatioBudget ( k)GreedyCutting ( Training)GreedyCuttingRandomWeightsBetweennessEigenDegree 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 200 400 600 800 1000Graph Susceptibility RatioBudget ( k)GreedyCutting ( Training)GreedyCuttingRandomWeightsBetweennessEigenDegree 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 100 200 300 400 500 600Graph Susceptibility RatioBudget ( k)GreedyCutting ( Training)GreedyCuttingRandomWeightsBetweennessEigenDegree 12 10 8 6 4 202468681012141618202224Running Time ( seconds per edge , log2)Number of Nodes ( log2)GreedyCuttingModularAdding a ) CorePeriphery b ) ErdosRenyi c ) Hierarchical d ) HepPH e ) Epinions f ) MemeTracker
Figure 5 : Efficacy of the edge addtion solutions provided by different algorithms . Higher is better . The x axis refers to the budget of edges to add ; the y axis refers to the graph susceptibility ratio , defined in the range [ 0 , n ] as : ( Ik âˆ’ I0)/I0 .
[ 7 ] N . Du , L . Song , H . Zha , and M . Gomez Rodriguez . Scalable influence estimation in continuous time diffusion networks . In NIPS , 2013 .
[ 8 ] C . Gao , J . Liu , and N . Zhong . Network immunization and virus propagation in email networks : experimental evaluation and analysis . KAIS , 27(2):253â€“279 , 2011 .
[ 9 ] X . He , G . Song , W . Chen , and Q . Jiang .
Influence blocking maximization in social networks under the competitive linear threshold model . In SDM , 2012 .
[ 10 ] H . W . Hethcote . The mathematics of infectious dis eases . SIAM review , 42(4):599â€“653 , 2000 .
[ 11 ] R . Iyer , S . Jegelka , and J . Bilmes . Fast semidifferentialIn ICML , based submodular function optimization . 2013 .
[ 12 ] D . Kempe , J . Kleinberg , and Â´E . Tardos . Maximizing In the spread of influence through a social network . ACM KDD , pages 137â€“146 . ACM , 2003 .
[ 13 ] M . Kimura , K . Saito , and H . Motoda . Solving the contamination minimization problem on networks for the linear threshold model . In PRICAI . 2008 .
[ 14 ] M . Kimura , K . Saito , and H . Motoda . Blocking links to minimize contamination spread in a social network . ACM TKDD , 3(2):9 , 2009 .
[ 15 ] C . J . Kuhlman , G . Tuli , S . Swarup , M . V . Marathe , and S . Ravi . Blocking simple and complex contagion by edge removal . In IEEE ICDM , 2013 .
[ 16 ] J . Leskovec , L . Backstrom , and J . Kleinberg . Memetracking and the dynamics of the news cycle . In ACM KDD , pages 497â€“506 . ACM , 2009 .
[ 17 ] J . Leskovec , D . Chakrabarti , J . Kleinberg , C . Faloutsos , and Z . Ghahramani . Kronecker graphs : An approach to modeling networks . 11(Feb):985â€“1042 , 2010 .
[ 18 ] G . Nemhauser , L . Wolsey , and M . Fisher . An analysis of the approximations for maximizing submodular set functions . Mathematical Programming , 14 , 1978 .
[ 19 ] S . Peng , S . Yu , and A . Yang . Smartphone malware and its propagation modeling : A survey . IEEE Communications Surveys Tutorials , PP(99):1â€“17 , 2013 .
[ 20 ] C . M . Schneider , T . Mihaljev , S . Havlin , and H . J . Herrmann . Suppressing epidemics with a limited amount of immunization units . Physical Review E , 84(6 ) , 2011 . [ 21 ] D . Sheldon , B . Dilkina , A . N . Elmachtoub , R . Finseth , et al . Maximizing the spread of cascades using network design . UAI , 2010 .
[ 22 ] H . Tong , B . A . Prakash , T . Eliassi Rad , M . Faloutsos , and C . Faloutsos . Gelling , and melting , large graphs by edge manipulation . In ACM CIKM , 2012 .
G\S and X âˆ…
APPENDIX Proof of Prop . 1 . Since edge e /âˆˆ S , we can always find two live edge graphs within XG\S which differ by the edge e . The first live edge graph X does not contain e , and the second live edge graph X contains the additional edge e . Proof of Prop . 2 . Since S âŠ‚ S âˆª {e} , the influence graph G\ ( S âˆª{e} ) has one less edge than G\ S , while other parameters of the two graphs remain the same . This implies that any live edge graph X generated from the former influence graph can always be generated from the latter one , which establishes the first part of the proposition . Furthermore , XG\(Sâˆª{e} ) contains those live edge graphs without edge e , which is essentially the union of X Â¯e G\S by definition . Proof of Prop . 3 . We will explicitly construct a set Î¦i âŠ† G\S for each element Xi âˆˆ X âˆ… X âˆ… G\(Sâˆª{g} ) . There are two types of elements in X âˆ… G\(Sâˆª{g} ) , and we will construct Î¦i respectively as follows : ( 1 ) If node v has an incoming edge in Xi , then Î¦i = {Xi} . Î¦i is contained in X âˆ… G\S since G\(Sâˆª{g} ) âŠ† X âˆ… X âˆ… G\S using a similar argument as in the space i} , where inclusion property . i = ( V , EXi âˆª {g} ) is obtained by extending Xi with edge X G\S since g /âˆˆ S and hence X g . Î¦i is also contained in X âˆ… i is a valid live edge graph in X âˆ… G\S . It is easy to see that the Î¦is are pairwise disjoint and form a partition of the space X âˆ… G\S . Proof of Prop . 4 . We will consider two cases . When Î¦i = {Xi} is a singleton , Pr[Xi|G\ ( Sâˆª{g} ) ] = Pr[Xi|G\ S ] and hence the statement holds true trivially . When Î¦i = {Xi , X Pr[H|G\ S ] is proportional to p(v , Xi , G \ ( S âˆª {g} ) ) âˆ’ p(v , Xi , G \ S)âˆ’p(v , X i , G\S ) , where we only need to consider the contribution of the terminal node v of edge g = ( u , v ) , since all other nodes contribute the same amount to the probability of each live edge graph involved . Based on Eq ( 3 ) , the difference between the first two terms , w(u , v ) , cancels out with the third term , w(u , v ) , which shows that the differPr[H|G \ S ] is zero , and i} , the difference Pr[Xi|G\(Sâˆª{g})]âˆ’ ence Pr[Xi|G \ ( S âˆª {g} ) ] âˆ’
( 2 ) Otherwise , Î¦i = {Xi , X
HâˆˆÎ¦i
HâˆˆÎ¦i completes the proof .
0 0.5 1 1.5 2 2.5 3 0 500 1000 1500 2000Graph Susceptibility RatioBudget ( k)ModularAddingRandomWeightsEigenDegree 0 0.5 1 1.5 2 2.5 0 500 1000 1500 2000Graph Susceptibility RatioBudget ( k)ModularAddingRandomWeightsEigenDegree 0 0.5 1 1.5 2 2.5 3 0 500 1000 1500 2000Graph Susceptibility RatioBudget ( k)ModularAddingRandomWeightsEigenDegree 0 2 4 6 8 10 12 0 500 1000 1500 2000Graph Susceptibility RatioBudget ( k)ModularAddingRandomWeightsEigenDegree 0 0.5 1 1.5 2 2.5 3 0 500 1000 1500 2000Graph Susceptibility RatioBudget ( k)ModularAddingRandomWeightsEigenDegree 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0 500 1000 1500 2000Graph Susceptibility RatioBudget ( k)ModularAddingRandomWeightsEigenDegree
