On Social Event Organization
Keqian Li† Wei Lu† Smriti Bhagat‡ Laks VS Lakshmanan† Cong Yu
†University of British Columbia
Vancouver , BC , Canada {keqianli,welu,laks}@csubcca
‡Technicolor Research Palo Alto , CA , USA
Google Research New York , NY , USA smritibhagat@technicolorcom congyu@google.com
ABSTRACT Online platforms , such as Meetup and Plancast , have recently become popular for planning gatherings and event organization . However , there is a surprising lack of studies on how to effectively and efficiently organize social events for a large group of people through such platforms . In this paper , we study the key computational problem involved in organization of social events , to our best knowledge , for the first time .
We propose the Social Event Organization ( SEO ) problem as one of assigning a set of events for a group of users to attend , where the users are socially connected with each other and have innate levels of interest in those events . As a first step toward Social Event Organization , we introduce a formal definition of a restricted version of the problem and show that it is NP hard and is hard to approximate . We propose efficient heuristic algorithms that improve upon simple greedy algorithms by incorporating the notion of phantom events and by using look ahead estimation . Using synthetic datasets and three real datasets including those from the platforms Meetup and Plancast , we experimentally demonstrate that our greedy heuristics are scalable and furthermore outperform the baseline algorithms significantly in terms of achieving superior social welfare .
Categories and Subject Descriptors H28 [ Database Applications ] : Data Mining
Keywords Social Networks ; Event Organization ; Assignment Problems
1 .
INTRODUCTION
The problem of organizing social events for a large group of people can resonate with the academic community : we are all familiar with the “ canned ” social events offered by conference organizers , which are often a simple list of activities to choose from and attendance at each event is organically decided by people at the conference based on who they know and how interested they are in the events .
More broadly , event organization is one of the most important social activities online , with many companies , established giants and startups alike , such as Meetup1 and Plancast2 , offering platforms for their users to plan and organize events . The social networks data and the data indicating the interests of the users on these platforms offer a rich setting in which events can be organized effectively and efficiently . Despite its importance , there are few academic studies on this topic : most of the existing research is focused on event detection through time series analysis ( eg , burst detection ) . Our goal in this paper is to provide a first principled definition of Social Event Organization ( SEO ) and a platform of algorithmic solutions for addressing this problem . To the best of our knowledge , this is the first paper on organizing events , instead of detecting events .
The tasks of organizing various social events share many common characteristics . First , each user often has his or her unique preference for the events being offered , a numeric measure which we call a user ’s innate affinity towards an event . Innate affinities can be stated explicitly : eg , a user can mark his preference for a game of chess as 9 out of 10 . Or they can be categorically stated by the users and computed by the organizer : eg , a user can list outdoor activities in her profile and the organizer can deduce that she will likely prefer hiking to playing chess . Finally , they can be predicted by a recommender system based on the past events that the user has participated in . Regardless of how innate affinities are computed , they are one of the two key ingredients for users’ happiness , for purposes of successful organization of social events .
The other key ingredient is the social connections among users – individuals often enjoy an activity more if they attend it along with their friends or others whom they would like to be around with . This connection is often defined between a pair of users and we call this pairwise social affinity . Similar to innate affinities , social affinities can be stated explicitly by the users . For example , users on social networks explicitly provide their friendship connections . They can also be deduced based on users’ interests or past activities . For instance , two users who share lots of interests and past activities are more likely to enjoy each other ’s company . Thus , similar to innate affinity , social affinity is represented by a numerical measure .
Importantly , in real world situations , events typically come with natural cardinality constraints . For example , most sports activities need a certain number of participants : two or four for tennis , two for chess , and two to nine for poker games .
We illustrate aforementioned characteristics more concretely through the following motivating example . Academic conferences and business conventions often provide networking opportunities for attendees by offering social events . Planning them involves gathering individuals with similar interests to facilitate interactions
1http://wwwmeetupcom 2http://wwwplancastcom as well as ensuring that they have a good time . The current practice is to offer these events as a “ canned ” list of options : eg , everybody selects from a small set of event choices based on their interests , perhaps uses ad hoc conversations among friends for coordination . Being able to automatically assign people to events from a large list of options , in a centralized manner , taking into account both users’ interests and friendships will likely lead to people enjoying those events more .
The above example illustrates the core technical challenge inherent in event organization , viz . , the assignment problem , where the system has to assign a given set of users to events , with the goal of making users happy . Other examples in this category include organization of activities at a reunion party , corporate activity day , community fund raising , or volunteering gatherings .
In this first paper towards Social Event Organization , we focus on the assignment problem illustrated above . Specifically , we are given a set of users , who are socially connected and have varying inherent interests in the events being offered . We need to assign users to events so as to maximize the “ overall happiness ” of the users , while respecting the event cardinality constraints ( min and max ) . In event organization over a wide area , in addition to cardinality constraints , time and location also play a role . Eg , user ’s proximity to the event ’s location may affect the user ’s innate affinity for the event . A similar remark holds for the time at which the event is organized . In order to allow us to focus on the key technical problem of assignment , we assume that users’ proximity to the location of events as well as availability of users for the events are factored in while determining the innate affinity of a user to an event . Consequently , our focus is squarely on finding good assignments of users to events as opposed to scheduling of events .
One critical aspect of the solution is to define the overall happiness as a combination innate and social affinities . We provide an intuitive definition of social welfare , as a linear combination of ( i ) the total innate affinities enjoyed by the users to the events they are assigned , and ( ii ) the aggregate social affinities enjoyed by pairs of users assigned to the same event ( exact definition in §31 ) This focus allows us to cast the Social Event Organization problem as a constrained discrete optimization problem , for which we can explore algorithmic solutions .
Our event organization problem has close connections with several major bodies of work – generalized assignment problem ( GAP ) [ 20 , 7 , 6 , 12 ] , a family of two sided matching problems including the National Resident Matching Problem ( NRMP ) [ 19 ] , and community search problems [ 21 ] . We depart from them by taking both innate and social affinities into account and solving the event organization problem under a unified framework . A detailed comparison with these related works appears in §2 .
Specifically , we make the following contributions . • We formally define social event organization as a constrained discrete optimization problem that asks for an assignment with maximum social welfare while respecting cardinality constraints of events ( §31 ) • The problem is shown to be NP hard . Given this , we analyze its approximability : we establish close connections between restricted versions of our problem and the SUBSETSUM problem and DENSE k SUBGRAPH problem . We exploit these connections to offer strong evidence that the problem is hard to approximate ( §32 ) • We then develop several heuristics including a greedy hillclimbing strategy and several improvements . Our improvements are based on a notion of “ phantom events ” which refer to tentatively scheduled events which have yet to meet their lower cardinality constraint , and a look ahead based technique ( §4 ) . • We conduct a comprehensive experimental study on both synthetic and real data sets from Plancast , Meetup and SIGCOMM 2009 . Our results show that our methods with look ahead estimation far exceed the baseline methods in terms of the social welfare achieved and the regret attained . Furthermore , our most sophisticated algorithm completes event assignments on a dataset consisting of 100,000 users and 500 events in under 17 minutes ( §5 ) .
Finally , we conclude the paper and summarize interesting direc tions for future work in §6 .
2 . RELATED WORK
Our problem has close connections to the generalized assignment problem ( GAP ) [ 20 , 7 , 6 , 12 ] : there are multiple bins with capacity constraints , multiple objects with a size and a profit for placing an object in a bin ; the problem is to find an assignment of objects to bins respecting capacity such that the total profit is maximized . In a special case , all objects have the same size and capacity is replaced by ( maximum ) cardinality . Differences between GAP and event organization are two fold . First , events typically have lower bound constraints on cardinality : eg , a game of Mahjong cannot be played by fewer than four people . Both lower and upper cardinality constraints must be respected by the solutions we propose . Very recently , lower bound constraints have been studied in the context of GAP [ 12 ] , and the precise relationship between event organization and [ 12 ] will be made clear in §32 Second , social affinity is not considered in GAP , whereas it is a key ingredient in social event organization .
Our problem is also related to the National Resident Matching Problem ( NRMP ) and other two sided matching problems such as college admissions [ 19 , 9 , 8 , 5 ] . In NRMP , medical school graduates are matched with residency programs offered by hospitals throughout the US The differences with event organization are three fold . First , graduates choose residency programs as individuals , and social affinity is almost never a concern , except in rare cases where two graduates are a couple . Second , in NRMP , every graduate provides an ordered list of programs she’d like to join and every program has its own preference list over graduates . Stability is an important concern . A matching is stable if there is no pair of a graduate and a program so that they both prefer each other over the current assignment they get . While stability is similar in spirit to avoiding regrets ( ie , assigning a user to an event she does not enjoy ) in event organization , in event organization stability is not important as events treat all users alike! Third , in contrast to the objectives in NRMP , our goal is to maximize social welfare ( defined in §3.1 ) of the assignment , taking both innate and social affinities into account , while respecting the cardinality constraints of events . In §4 , we adapt the NRMP solution to solve our problem , and empirically compare it in §5 .
In a sense , event organization is also similar to group recommendations : so long as we know which set of users will attend the same event , ie , group memberships , but not which one , we can , in principle , determine that event using group recommendations [ 2 ] . However , we do not know these groups and part of the challenge is to find them . Besides , our assignment of users ( and hence of groups ) to events is more “ holistic ” in considering not only innate , but also social affinity : it is their combination that drives our assignment . Thus , group recommendations cannot solve our problem .
Team formation problems in social networks [ 13 , 3 ] assume for each user a set of skills and for each pair of users a compatibility measure . The problem is to put together teams that satisfy the skill requirements of a given task while minimizing the communication overhead of the team , eg , the diameter or weight of the minimum spanning tree of the graph of the formed team . The problem is NPhard and many of the works resort to approximation algorithms . Superficially , the team formation problem seems similar to ours . However , while social affinity has a counterpart in compatibility , there is no direct innate affinity between users and tasks , except indirectly via skills . More importantly , cardinality constraints in event organization make the problem significantly more challenging . Finally , a user may be assigned to more than one task whereas users are assigned to at most one event in our problem .
Also relevant to our work is the community search problem [ 21 ] , where given a set of query nodes , the task is to find a community containing the query nodes that maximizes the overall social affinity , subject to a maximum cardinality constraint . However , there is no notion of events , nor users’ innate affinities towards events in [ 21 ] . In contrast , our problem involves a combination of social and innate affinities and thus a holistic approach is needed which at once pays attention to the innate aspect ( matching quality ) and the social aspect . There have also been studies on geo social query processing [ 4 ] . Though both our problem and theirs consider social effects , the SEO problem is inherently an assignment problem and cannot be solved by issuing queries .
3 . SOCIAL EVENT ORGANIZATION
We now formulate Social Event Organization ( SEO ) as an as signment problem and study its hardness and approximation . 3.1 Problem Definition
Consider a setting where organizers of a large gathering ( eg , an international conference or a company wide retreat ) are planning social activities for the conference attendees . Or a scenario in which or an event planning platform ( eg , Meetup ) is being used to plan social events for its users over a wide local area such as a city . In both cases , there is a set of users U who must be assigned to events or activities from a given set of possible events A . We assume the presence of a social network , through which the friendships among those users can be obtained . Let G = ( U , E ) be the friendship graph induced on U . Each event a ∈ A is associated with a minimum cardinality bound γa and a maximum cardinality bound δa , as motivated in §1 . There is a function σ : U × A → R+ such that for each user u and event a , σ(u , a ) models the user ’s innate affinity for the event . We often denote σ(u , a ) as σu,a for simplicity . As mentioned in the introduction , we assume that the innate affinity σu,a factors in u ’s proximity to a ’s location and u ’s availability wrt the time at which a is held . In addition to their innate affinity to events , users have pair wise social affinity with each other , and we capture this by a function w : U × U → R+ , such that w(u , v ) is the social affinity between u and v . Both innate affinity to events and social affinity to other users attending the same event contribute to a user ’s sense of “ utility ” for attending an event . Note that as discussed in §1 , social affinity is important because an individual may enjoy an event more when she is joined by her friends . We assume in this paper that social affinity is non negative and that social affinity values are symmetric , ie , w(u , v ) = w(v , u ) , for all u , v ∈ U . Suppose a set of users S ⊂ U is assigned to an event a ∈ A . We define the utility of this assignment as :
µ(S , a ) = ( 1 − α )
σu,a + α u,v∈S,u=v w(u , v ) ,
( 1 ) u∈S where α ∈ [ 0 , 1 ] can be chosen by the user of the SEO system , ie , the organizer , to adjust the relative importance of the two affinities . That is , the overall utility of the set of participants of an event is a linear combination of the total innate affinity of the participants for the event and the total social affinity of all pairs of participants . As a special case , we define µ(∅ , a ) = 0 : when nobody is assigned to an event , it results in zero utility . As mentioned in the introduction , both innate affinity σu,a and social affinity w(u , v ) can be provided by the users explicitly through stated interests and friendships . However , in case such explicit information is not available , those values can be estimated from a user ’s implicit interests and past activities . For example , social affinity can be computed using well studied social distance measures ( eg , graph distance , Katz , or hitting time ) [ 14 ] . We defer the details to §5 . An assignment is a ( possibly partial ) function M : U → A . For a ∈ A , we denote by M −1(a ) the ( possibly empty ) subset −1(a ) = {u ∈ U | M ( u ) = a} . of users assigned to a , ie , M An assignment M is said to be feasible provided all cardinality constraints are satisfied , ie , ∀a ∈ A for which M −1(a ) = ∅ , we have γa ≤ |M −1(a)| ≤ δa , in words , for all events to which at least one user is assigned , the number of users assigned to that event lies within its lower and upper bounds . Notice that owing to the cardinality constraints and the number of users and events in an instance of the assignment problem , it may not be possible to find a feasible assignment that covers all users : eg , we may have 10 users and 1 event such that the event can accommodate at most 5 people . This is the reason we allow partial functions above . Similarly , not all events may be scheduled by an assignment , ie , M need not be onto . We define the social welfare of a feasible assignment M as
ω(M ) = a∈A
µ(M
−1(a ) , a ) .
( 2 )
The overall social welfare of an assignment is thus determined by the sum of utilities of the assignments made to each event . Our objective is to find a feasible assignment that maximizes the overall social welfare . Our definition of overall social welfare reflects the following intuition . A user ’s personal utility for an assignment increases with her innate affinity for the event , as well as the social affinity she has toward other users attending the same event . Besides , the more such fellow attendees , the higher her utility . The definition of overall social welfare is a simple extension of this intuition . Note that other definitions of social welfare , using other aggregate functions , are possible : we prefer to use a simple definition here that captures the intuition above . We formally define the Social Event Organization ( SEO ) problem as follows .
PROBLEM 1
( SOCIAL EVENT ORGANIZATION ( SEO) ) .
Given a set U of users with a social graph G = ( U , E ) , a set A of events where each a ∈ A has a minimum and maximum cardinality bound , denoted γa ∈ N and δa ∈ N respectively ( γa ≤ δa ) , innnate affinity function σ(·,· ) , and social affinity function w(·,· ) , produce a feasible assignment M : U → A that has the maximum overall social welfare ω(M ) , ie , find
∗
= arg max{ω(M ) | M is feasible} .
M
The number of scheduled events ( ie , those have at least one user assigned and cardinality constraints satisfied ) is not fixed in advance , but rather determined by the solution , in which some events may receive zero users . However , the cardinality constraints for each event that has non zero participants assigned must be respected . It is possible to have multiple groups performing the same event , eg , there may be four groups of two participants each that are suggested the event of playing chess . This is easily handled by technically treating different instances of a given event as different events . We can consider weighting the two terms in Eq ( 1 ) , corresponding to the innate and social contributions to social welfare , differently . Our results in the next section show that the problem remains hard regardless of the weights chosen . 3.2 Hardness Results
Not surprisingly , our first result is that Social Event Organization is NP hard . Our reduction is from the recently studied Seminar Assignment Problem ( SAP ) . SAP is obtained by adding lower bound constraints to a restricted version of GAP where all objects have the same size , and is formally stated as follows . Given a set of n students and and a set of m seminars with maximum cardinality B1 , B2 , . . . , Bm ∈ N and minimum cardinality q1 , q2 , . . . , qm ∈ N , qi ≤ Bi , a profit pi,j ∈ N of assigning student i to seminar j , we want to find an assignment of students to seminars that satisfies the cardinality constraints and maximizes the total profit . Krumke and Thielen [ 12 ] recently showed that this problem is NP hard . We have the following easy result :
THEOREM 1 . The decision version of Social Event Organiza tion is NP complete .
PROOF . Clearly , SAP is isomorphic to a restricted version of SEO where all innate affinities are natural numbers , all social affinities are zero ( and α = 0 ) . The NP hardness of SEO follows from this . Membership in NP is straightforward : given an assignment , both checking its feasibility and whether its social welfare exceeds a given threshold can be done in polynomial time .
Next , we analyze how hard it is to approximate SEO . Our analysis involves two special cases of the problem , one with only innate affinities ( which is isomorphic to the SAP problem ) and the other with only social affinity . Special Case 1 : Innate Utility Only . In this case , we only consider instances of SEO where w(u , v ) = 0 , for all users u and v ( and α = 0 ) . Thus , the problem is to find a feasible assignment M : U → A that maximizes the social welfare , which is solely determined by innate affinities . We call this version SEO Innate .
THEOREM 2 . It is NP hard to approximate SEO Innate within a factor of ( 1 − 1/n + ) ( ∀ > 0 ) in polynomial time , where n is the number of users .
PROOF . We prove the result by showing that if such an algorithm existed , it could solve the SUBSET SUM problem , an NPcomplete problem , in polynomial time . Since this is impossible unless P = NP , the theorem follows . Consider an arbitrary instance I of SUBSET SUM consisting of a set of integers T = {t1 , t2 , . . . , tN} and a target number τ . We must find out if there is a subset of T whose elements sum to exactly τ . Algorithm B first creates an instance J of the SEO problem with τ users and N events , and for each event a ∈ [ 1 , N ] , it sets γa = δa := ta . Also , σu,a = 1 for all u ∈ U , a ∈ A and w(u , v ) = 0 for all u , v ∈ U . Then B runs A on J , and outputs YES ( indicating there is a subset of T summing to exactly τ ) if and only if A outputs an assignment with social welfare τ . We next prove that algorithm B can correctly distinguish between the YES and NO instances of SUBSET SUM . If I is a YES instance , then by the above reduction , OP TJ = τ , ie , the maximum possible social welfare of any feasible assingment on instance J is τ . By assumption , A will output an assignment with welfare ≥ ( 1 − 1/τ + )τ > τ − 1 . Since all utility values are 1 , the output of A will be exactly τ , and thus B answers correctly : YES .
If I is a NO instance , then for J , by construction , not all users can be fit into an event , implying OP TJ < τ . Since the output of A is always ≤ OP TJ , it will be surely < τ . Again , algorithm B answers correctly : NO . This was to be shown .
We note that complementarily , Krumke and Thielen [ 12 ] show that it is NP hard to approximate SAP within a factor of 1 − 0/3 even when all profits are in {0 , 1} , where 0 > 0 is a constant associated with the hardness gap of the 3 Bounded 3 Dimensional Matching problem [ 16 ] . As a consequence , they show that SAP does not admit PTAS ( polynomial time approximation scheme ) . This hardness is clearly inherited by SEO Innate as well . Note that both 1 − 0/3 and ( 1 − 1/n ) are close to 1 ( the latter when n is large ) . This raises the question whether coarser approximations exist for SEO . Our result in the next section suggests it is unlikely . Special Case 2 : Pair wise Affinity Only . In this case , we restrict attention to instances of SEO where σu,a = 0 for all users and all events ( and α = 1 ) . We refer to this restricted version of SEO as SEO Social . We show that this restricted problem is hard to approximate within any constant factor under hardness assumptions about certain combinatorial problems . Specifically , our result is achieved by a reduction from the DENSE k SUBGRAPH problem . That problem , given a graph G = ( V , E ) and a parameter k , asks to of G induced by k nodes such that average defind a subgraph G is maximum . The average degree of a node in gree of nodes in G | . By assuming the hardness = ( V G of a conjecture known as Unique Games with Small Set Expansion Conjecture [ 11 ] , Raghavendra and Streurer [ 18 ] show that DENSE k SUBGRAPH is hard to approximate within any constant factor . We “ lift ” this to show a similar hardness of approximation of SEOSocial . For lack of space , we refer the reader to [ 18 ] for details and history of this conjecture .
) is given by 2|E
|/|V
, E
THEOREM 3 . Assuming the Unique Games with Small Set Expansion Conjecture , it is NP hard to approximate SEO Social within any constant factor in polynomial time .
PROOF . Given an instance I of DENSE k SUBGRAPH defined by G = ( V , E ) and a positive integer k , create an SEO instance J by setting A = {a} , γa = δa = k , and U = V . Ie , there is just one event whose lower and upper bound on cardinality is k and there is a user corresponding to each node of G . For all u ∈ U , set σu,a = 0 , and for all u , v ∈ U , w(u , v ) = 1 . By construction , OP TI = OP TJ , ie , the maximum social welfare of a feasible assignment on instance J is identical to the maximum average degree of a k vertex induced subgraph of G in instance I . Suppose there is a PTIME algorithm A approximating SEO within a factor of c ∈ ( 0 , 1 ) . Then , B can approximate DENSE k SUBGRAPH within the same factor by converting I to J as above , running A on J , and outputting the nodes corresponding to the users chosen by A to attend event a . This is impossible unless the Unique Games with Small Set Expansion Conjecture doesn’t hold .
To conclude this section , not only is SEO NP complete , it is also made up of two hard subproblems . Our results show that it is unlikely to be approximable within any constant factor in polynomial time , unless some hardness assumptions about important combinatorial problems break down . It should be clear from the proof of Theorems 2 and 3 that this is true regardless of the choice of α in Eq ( 1 ) .
4 . PROPOSED SOLUTIONS
Given that SEO is NP hard to even approximate , we propose a variety of heuristics that give emphasis to different aspects of the problem , such as the social affinity , the innate affinity , and the cardinality constraints . Before diving into the details of the algorithms , it is important to first understand what constitutes a feasible ( valid ) solution to the SEO problem . Characterizing Feasible Solutions . For any event , if the event has reached its minimum cardinality , we refer to it as a real event ; otherwise , we call it a phantom event . For example , a tennis or chess game with only one player is a phantom event , that will become real only after one other person is assigned to the event . An event is open and can accept more participants if the maximum cardinality has not been reached yet , otherwise it is declared closed . By definition , all phantom events are open . However , a real event can be either open or closed . A user u is available if u has not been assigned to a real event yet . A user event assignment is valid if it involves an available user and an open event . During the assignment process , if the event to which a user was assigned becomes real , then the user ’s assignment is fixed , and she is marked unavailable . Consequently , all other previous and future assignments involving that particular user are deemed invalid . Recall that the final solution must be feasible , ie , respect cardinality constraints . As shown in §3 , in some instances it is not possible to find an assignment for every user , so the assignment function may be partial . In practice , we can deal with this by supposing that there are sufficiently many events with large capacity such as movies or theatrical shows to which users left unassigned by the algorithm may be assigned .
Notice that each assignment decision impacts the utility received from future assignments , due to the coupling effect with other users in the form of social affinity . Therefore , it is non trivial to achieve a ( feasible ) solution to SEO that achieves a high social welfare . Solution Template . In the remainder of this section we discuss a variety of algorithms . At a high level , each algorithm ( except Random and NRMP+ ) follows the following template . First , a sorted list L of potential assignments of users to events is generated . The additional contents of the list may vary depending on the algorithm . This list may be updated and re ordered several times during a run of the algorithm . Second , users are assigned to events by making one pass on this list , and the “ state ” of users ( available , unavailable ) , and events ( phantom , real open , real closed ) is updated appropriately . In particular , it marks an event a as “ real ” when it reaches its minimum cardinality γa , and “ closed ” when it reaches its maximum cardinality δa . These assignments are tentative and are recorded by membership in the “ S ” sets , eg , u ∈ Sa means u is tentatively assigned to event a , and possibly to other events . All events are “ open ” and “ phantom ” to start with . Once an event a becomes real , the users in the set Sa are marked “ unavailable ” for future assignments and we set M ( u ) = a,∀u ∈ Sa . Additionally , the algorithm invalidates any previous and future assignments of each user u ∈ M −1(a ) , by cleaning up other “ S ” sets as needed . Finally , the algorithm performs post processing to ensure that the output is a feasible solution , ie , no phantom events are left behind . 4.1 Baselines
In this section , we present a set of intuitive baseline solutions , in increasing level of sophistication . We build on these baselines and present our proposed algorithms in §42 Random . Our first baseline is called Random , which randomly assigns users to events while respecting the cardinality constraints . Specifically , the algorithm first randomly shuffles the list L containing user event pairs u , a . It then traverses the list and at each tuple u , a assigns user u to event a if u is available and a is open . It appropriately marks an event as real when it reaches its minimum cardinality constraint . Clearly , this is a “ straw man ” approach , which does not take into account the “ utility ” of any assignment .
Sa ← Sa ∪ {u} if |Sa| > γa then g(u , a | Sa ) ← ( 1 − α)σu,a L.insert(u , a , g(u , a | Sa ) ) if M ( u ) = ⊥ and |Sa| < δa then
Algorithm 1 Dynamic Greedy ( U , A , σ , w , α ) 1 : M ( u ) ← ⊥,∀u ∈ U ; Sa ← ∅,∀a ∈ A 2 : for all ( u , a ) ∈ U × A st σu,a > 0 do 3 : 4 : 5 : while u , a , g(u , a | Sa ) ← L.pop( ) do 6 : 7 : 8 : 9 : 10 : 11 : 12 : 13 : 14 : 15 : 16 : 17 : 18 : 19 : Reassign available users {u|M ( u ) = ⊥} 20 : return M if |Sa| = γa then M ( v ) ← a for all a
∈ A st a Sa ← Sa − {u}
M ( u ) ← a for all a
= a ∧ u ∈ Sa do for all v ∈ Sa do
∈ A st a Sa ← Sa − {v}
= a ∧ v ∈ Sa do for all v : ( w(u , v ) > 0 ∧ M ( v ) = ⊥ ) do
L.update(v , a , g(v , a | Sa ) )
// Using Eq ( 3 )
NRMP+ . Given the connection between SEO and NRMP , a natural question is whether we can leverage algorithms developed for NRMP . We next describe an adaptation of the NRMP algorithm [ 8 ] for handling the lower bound constraints present in SEO . In this adaptation , called NRMP+ , we cast SEO in the NRMP framework by associating a preference list of events for each user , ordered by the innate affinity , and a preference list of users for each event , ordered by the innate affinity.3
NRMP+ repeats the following procedure until each user is either “ accepted ” by an event or is “ rejected ” by all events she applied to . Initially , all users are unassigned and no acceptance or rejection has been made yet . In each round , each unassigned user “ applies ” to the most preferred event that has not rejected her . Each event a then picks the δa most preferred users who applied to it , or all applicants if there are fewer than δa of them , and puts them on a waiting list . Users who failed to get on the waiting list are rejected and are thus unassigned after this round . After this iterative process stops , we check if there exists any phantom event . If yes , redistribute users assigned to phantom events to existing real open events in a greedy manner , based on innate affinity . After that , either no user is left unassigned or there are no real events to which unassigned users can be assigned , and we stop .
It is unclear how NRMP can be directly adapted to take social affinity into account in deciding acceptances . In Section 5 , we empirically compare NRMP+ with the more sophisticated baselines we develop next , as well as with our main algorithm . Static Pairwise Greedy . Our next baseline , called Static Pairwise Greedy ( SG ) , assigns pairs of users to events , taking into account both innate event and pairwise social affinities . Specifically , a sorted list L containing tuples u , v , a representing potential assignment of pairs of users to events is generated . The list is ordered by non increasing potential gain ( of “ utility ” ) , defined as g((u , v ) , a ) = ( 1 − α)(σu,a + σv,a ) + 2 α w(u , v ) .
The list is traversed and at each tuple u , v , a users u and v are assigned to event a if both users are available , and a is open with at least two spots . User and event states are appropriately updated .
3Events don’t have independent preference lists : we induce them from user event affinities for the sake of simulation of NRMP . v∈Sa w(u , v ) .
Finally , any users that are in phantom events at the end of one pass over the list L are redistributed greedily among remaining open events . We call this a static approach as the function g is computed only once . Therefore , the partial ordering of the L is static , and it only incurs deletions ( with some assignments being invalidated ) . Therefore , the assignment of a pair of users to an event is oblivious to which users are already assigned to that event . Dynamic Greedy . Our next algorithm , called Dynamic Greedy ( DG ) , is more sophisticated . It updates its estimation of the “ utility ” a user will attain from an assignment , based on the current set of assignments . To achieve this , the algorithm updates the list L at each assignment , where L is composed of tuples u , a , g(u , a|Sa ) , Sa = ∅ initially , and the potential gain g is g(u , a | Sa ) = ( 1 − α)σu,a + α
( 3 ) Clearly , when no users are assigned to an event a , g(u , a | ∅ ) = ( 1 − α)σu,a . Algorithm 1 presents the pseudocode for the DG method . At each step , the assignment that gives the largest potential gain g( . ) is performed . Let Nu be the set of users v : wu,v > 0 . Now , whenever a user u is assigned to an event a , we need to recompute the potential gain g(v , a | Sa ) for all neighbors v ∈ Nu of user u in the network , since their utility for event a increases after the assignment of u to that event . In practice , the algorithm maintains the list L as a priority queue of tuples in non increasing order of g(u , a | Sa ) . We use the notation M ( u ) = ⊥ to denote that the user u is available . We remark that the update operation ( line 18 ) is in charge of not only updating the existing entries in the priority queue but also checking whether the pair ( v , a ) is already in the heap and if not , adding it . The post processing in Line 19 is done in a greedy manner . Let = {a | γa ≤ be the set of currently open real events , ie , A A |Sa| < δa} and U be the set of users assigned to phantom events . The list L is re constructed with users from U and events from , and we rerun the DG algorithm over this list . This process can A be repeated as needed . The post processing stops when either all users are assigned or there are not enough real events ( ie , all real events are closed ) . In the latter case , from a practical perspective , the remaining users may be assigned to new events with a large capacity , eg , watching a movie or a theatrical show . Implementation Notes and Time and Space Complexity . We remark that in our implementation , we optimize the algorithm for better performance . In particular , we tune our implementation to suit a Fibonacci heap based realization of the priority queue . Specifically , we commit to making an assignment for new users right after line 7 . This allows us to avoid assigning users to multiple phantom events . Thus , when the priority queue is updated , “ decrease key ” operation will not be needed , permitting us to implement the priority queue using a Fibonacci heap . We note , however , in this case the assignment function M no longer corresponds to only real events since some phantom events may be left behind by the algorithm at termination . For ease of exposition , we have chosen to present our algorithm in a conceptually simpler way . When the priority queue L is implemented using a Fibonacci heap , then for each assignment ( u , a ) , the algorithms performs O(|Nu| ) update operations ( Line 18 ) , each of which is constant time . Summing over all users , the total running time of all update operations is O(|E| ) , where E is the edge set of the social network of users , or more precisely the set of pairs ( u , v ) with w(u , v ) > 0 . Next , since the number of all possible ( u , a ) pairs is bounded by |L| , we need at most that many pop operations , which in total takes O(|L| log(|L| ) ) time . In addition , insertion is constant time for Fibonacci heaps so the initialization step takes O(|L| ) . Hence , the to else continue else if |Sa| = 0 then deficit ← deficit + γa − 1 P ← P ∪ {a} g(u , a | Sa ) ← ( 1 − α)σu,a L.insert(u , a , g(u , a | Sa ) ) if M ( u ) = ⊥ and |Sa| < δa then if deficit + γa ≤ |V | then
Algorithm 2 PCADG ( U , A , σ , w , α ) 1 : M ( u ) ← ⊥,∀u ∈ U ; Sa ← ∅,∀a ∈ A ; P ← ∅ 2 : deficit ← 0 ; V ← U 3 : for each ( u , a ) ∈ U × A st σu,a > 0 do 4 : 5 : 6 : while u , a , g(u , a | Sa ) ← L.pop( ) do 7 : 8 : 9 : 10 : 11 : 12 : 13 : 14 : 15 : 16 : 17 : 18 : 19 : 20 : 21 : 22 : 23 : 24 : 25 : 26 : 27 : 28 : 29 : 30 : 31 : return M if a ∈ P then Sa ← Sa ∪ {u} V ← V \ {u} if |Sa| > γa then M ( u ) ← a for all a if |Sa| = γa then P ← P \ {a} ; for all v ∈ Sa do M ( v ) ← a for all a
∈ A st a Sa ← Sa − {v}
= a ∧ v ∈ Sa do for all v : ( w(u , v ) > 0 ∧ M ( v ) = ⊥ ) do
L.update(v , a , g(v , a | Sa ) )
∈ A st a Sa ← Sa − {u} deficit ← deficit − 1
= a ∧ u ∈ Sa do
// Using Eq ( 4 ) tal time complexity for Dynamic Greedy is O(|L| log(|L| ) + |E| ) . Finally , the space complexity is Ω(|L| + |E| ) . 4.2 Greedy with Look Ahead Estimation
The Dynamic Greedy algorithm is intuitive : it tries to make assignments based on the largest estimated gain , given the current state of the assignment . However , it has its limitations : ( i ) it is oblivious to which events a user ’s friends are likely to be assigned ; ( ii ) the first pass may result in a large number of phantom events as it is ignorant of which events are likely to materialize . To address these limitations , we propose the Phantom and Community Aware Dynamic Greedy or PCADG ( pseudocode in Algorithm 2 ) . A key feature of this algorithm is that it looks ahead at the forthcoming assignments to inform the decision at each step . Community Awareness . The earlier algorithms do not take into account the potential gain that future assignments of friends to an event may bring to a user . In our Phantom and Community Aware Dynamic Greedy algorithm , the awareness of friends’ potential assignments is incorporated into the decision making process . More specifically , here , the potential gain g is defined as g(u , a|Sa ) =(1 − α)σu,a + α + α(δa − |Sa| ) v∈Sa w(u , v ) w(u , v)/(|V | − 1 ) , v∈V
( 4 ) where V is the set of users that have not yet been assigned to any event , phantom or real : V = {u | u ∈ U ∧ M ( u ) = ⊥ ∧ u ∈ a∈A Sa} .
Notice that the first two terms in this equation are identical to the two terms in Equation 3 of the Dynamic Greedy method . The third term corresponds to the “ look ahead ” whereby it is optimistically assumed that the remaining spots in the event a will be filled with friends of u , with an average social affinity toward u . The average is computed over users in V . While the first two terms are based on the current membership of Sa , the third term is based on anticipation . Thus , this algorithm gives equal importance to both innate affinity and social affinity in gauging the potential gain that could come from an assignment . Other variants can be easily designed to weigh the importance of the innate and social affinities differently .
Phantom Awareness . Another observation about Dynamic Greedy is that it tends to be somewhat indiscriminate in the creation of phantom events : it never restricts the creation of new events as the condition |Sa| < δa ( line 6 of Algorithm 1 ) will always be true for new events , for which |Sa| = 0 by definition . All phantom events that are left behind after a pass over the list L have to be cleaned up later . PCADG tries to limit the creation of phantom events , by employing a stronger condition for phantom event creation . Intuitively , it keeps track of phantom events as it proceeds , and procrastinates on creating new events if the number of unassigned users is less than the currently unfilled spots in existing phantom events that need to be filled in order for the events to materialize .
To achieve this , PCADG maintains a variable called deficit , defined to be deficit =
( γa − |Sa| ) , a∈P where P is the set of phantom events and Sa is the set of users assigned to event a . If , at any point of the execution of PCADG , it happens that deficit > |V | , then there must be at least one phantom event at the end of one pass over L , thus requiring reassignment . Therefore , the algorithm performs an assignment based on a tuple u , a , g( . ) only if it does not push deficit over |V | ( Line 9 ) . Otherwise , it will skip that tuple and continue to the next one in L . As can be seen , by using deficit and V , the algorithm does limit the creation of new phantom events . We now give more details about the PCADG algorithm . At the beginning , when P = ∅ , deficit = 0 and V = U . The size of V is non increasing throughout the algorithm . For any assignment u , a , g(u , a | Sa ) that consists of an available user u and open event a , if a is a new event with no users , ie , |Sa| = 0 , we increment deficit by γa − 1 ( because a is a phantom event and it would take γa − 1 more users to make a real ) . Otherwise , we decrease deficit by 1 ( since u removes one “ unit ” of deficit ) . Furthermore , u is removed from V , if u ∈ V before this assignment was made .
It is worth noting that PCADG may consider user event combinations for which the innate affinity may be zero , as this assignment may potentially result in a large gain owing to the social affinity with other users assigned to this event , as per Equation 4 . This is in keeping with our stated objective of maximizing social welfare . Therefore , it is possible that some users may be assigned to low innate affinity events as a result . We measure this tradeoff empirically in §5 by measuring the “ regret ratio ” ( defined in §5 ) of the assignment returned by the various algorithms .
In order to explicitly study the impact of community and phantom awareness , we will compare PCADG with a lesser variant called Phantom Aware Dynamic Greedy ( PADG ) that only takes into account phantom awareness . As such , the PADG algorithm is identical to Algorithm 2 , with the one change that the potential gain is defined using Eq ( 3 ) instead of Equation 4 . In §5 , we compare the running times and scalability of different proposed algorithms , in addition to comparing them on their quality .
We close this section by noting that the time and space complexity of the PCADG algorithm is the same as that of DG ( and PADG ) except that the size of the list L may potentially become O(|U| × |A| ) in the worst case .
5 . EXPERIMENTAL ANALYSIS
,
We evaluate our Phantom and Community Aware Dynamic the Phantom Aware variant ie , Random ,
Greedy ( PCADG ) method against ( PADG ) and the baselines described in §4.1 , NRMP+ , Static Greedy ( SG ) and Dynamic Greedy ( DG ) . Evaluation Metrics . The most natural evaluation metric is the total social welfare , ω(M ) defined in Eq ( (2) ) . In addition , since optimal or near optimal solution cannot be found in polynomial time , we measure the effectiveness of each algorithm “ indirectly ” by comparing the utility a user gets against a coarse upper bound , which is the maximum utility she could have enjoyed by going to her favorite event with her best friends . Formally , we define the regret ratio for a user u , denoted ρ(u ) , to be
ρ(u ) = 1 − ( 1 − α)σu,M ( u ) + α maxa∈A((1 − α)σu,a + α v∈SM ( u ) v∈Bu w(u , v ) )
( 5 ) where M is the assignment made by an algorithm , and Bu ⊆ Nu is the set of top Ku,a friends of u in terms of social affinity w(u , v ) , and Ku,a = min{|Nu| , δa − 1} . regret in the assignment made . Note that
Ideally an algorithm that performs well wrt this metric should assign users to events in such a way that many users experience low u∈U maxa∈A(σu,a + v∈Bu w(u , v ) ) is guaranteed to be greater than the optimal social welfare , except when the favorite event of all users is the same , in which case the optimal welfare may reach this quantity . Moreover , ρ is a very pessimistic ratio , as the denominator is an upper bound on the maximum possible utility that the user can achieve . Also , it is worth pointing out that our algorithms are not designed to directly minimize individual regrets of users , but rather social welfare that is the overall utility enjoyed by all users . The purpose here is to gain some insights about to what extent our algorithms would lead to a compromise wrt regret . w(u , v )
We set α to 0.5 in Eq ( 1 ) and ( 5 ) for all experiments unless otherwise mentioned . We also conduct a detailed experiment on real data , where we vary α and study its effect , illustrated in Figure 5 . 5.1 Experiments on Synthetic Datasets
To better understand the impact of various parameters on our proposed algorithms , we first perform rigorous evaluations on synthetically generated data . We also conduct scalability tests on large synthetic data to show that our algorithms are scalable and efficient . For all events a ∈ A , δa is sampled from a normal distribution with mean 20 and variance 10 , and given that , γa is sampled uniformly at random from the interval [ 1 , δa ] . The social network G = ( U , E ) is generated by a random power law graph model with a power law exponent of 1.5 [ 1 ] . The data generated has 500 users and 50 events . A user is interested in an event with probability 0.05 , and thus the average number of events he is interested is 25 For each ( u , v ) ∈ E , the social affinity value is sampled from a normal distribution with mean 1.5 and variance 3 , as is innate affinity σu,a , for each ( u , a ) pair in the user event relation . All values less than 10−5 are set to be zero : all affinity values are thus non negative . This gives the default setting for the parameters used to generate the data , however , throughout this section , we vary these parameters to understand their effect on the performance of
Figure 1 : Effects of parameter choices on the performance of PADG and PCADG
Algorithm |U|
PADG
PCADG
50 0.085 1K 10K 0.343 100K 2.75 1K 0.315 10K 2.09 100K 22.10
Number of Events 200 0.152 1.54 15.0 3.17 32.1 207
150 0.108 0.572 6.63 1.46 14.47 166
100 0.085 0.435 4.61 0.759 10.07 64.50
500 0.187 1.6 27.1 9.05 77.2 1085
Table 1 : Running time ( in seconds ) of PADG and PCADG
Time ( s )
Random NRMP+ 0.98
0.14
SG 12.7
DG 0.31
PADG PCADG 0.43
10.1
Table 2 : Running time ( in seconds ) of all algorithms with 10K users and 100 events our three dynamic greedy methods , DG , PADG and PCADG . Figure 1 shows the social welfare achieved by these algorithms with three types of comparisons : minimum cardinality constraints , total number of events , and density of the social network graph . Effect of Minimum Cardinality . We alter minimum cardinality constraint ( γ ) and evaluate its effect on PADG and PCADG . We keep the maximum cardinality constraint δa ’s unchanged from the basic setting for each event a ∈ A , and vary their γas . We generate three groups of data , by sampling the minimum cardinality constraint γa uniformly at random from [ δa/2 , δa ] ( low mean ) , [ δa − δa/4 , δa ] ( medium mean ) , and [ δa − δa/8 , δa ] ( high mean ) respectively . As seen in Figure 1(a ) , there is a noticeable improvement in social welfare for PADG and PCADG over DG ( which does not account for phantom events ) . As γ increases , more phantom events may be created , which increases the gain of PADG . Effect of the Number of Events . We vary the number of events as 10 , 25 and 35 , for a 500 user dataset . From Figure 1(b ) , as the number of events increases , each event needs to accommodate fewer users and thus the effect of social affinity decreases . With fewer events , PCADG is at an advantage over PADG and DG , as it is community aware and takes into account social affinity values by looking ahead . Effect of Graph Density . Next , we test various graph densities of the underlying social network graph by generating four different graphs using Erd˝os Rényi model G(500 , p ) where the edge existence probability being p = 0.001 , 0.01 , 0.1 , and 1 respectively . For denser graphs , more social affinity values are present and hence we observe that the margin between PCADG and the other two is higher in comparison with sparse graphs ( Figure 1(c) ) . Running Time . Finally , we evaluate the scalability of the algorithms by varying the number of users ( 1K , 10K and 100K ) and events ( 50 , 100 , 150 , 200 , and 500 ) . We maintain the default settings for all other parameters . Table 1 shows the running time of PADG and PCADG . Overall , both algorithms achieve good efficiency , finishing within seconds or minutes in all cases , and PADG always runs faster than PCADG . As the trend is similar , we show the running time comparison with Random , NRMP+ , SG , and DG for one case of 10K users and 100 events . Random , DG , and SG take 0.98 , 0.31 , and 12.7 seconds to finish , while PADG takes 0.43 and PCADG takes 10.07 seconds respectively ( see Table 2 ) . SG was consistently the slowest algorithm in all cases that we tested . For our largest simulation of 100K users and 500 events , PCADG takes 20 mins . This is a reasonable for large scale event organization , where real time response is not critical . 5.2 Experiments on Real Event Datasets
521 Data Description and Preprocessing We evaluate our algorithms on the following three real datasets . Plancast and Meetup are local event organization websites that allow groups of users to interact and plan events . We use the data4 released by [ 15 ] . Since in Plancast and Meetup users and events are from all over the world , we select several big cities and project the data to such locations . The third dataset is SIGCOMM2009 ( referred to as SIG ) , collected by Pietilainen et al . [ 17 ] ( details later ) . The following pre processing was performed on the datasets to match our problem setting . Plancast . We extract two subsets from the Plancast dataset in [ 15 ] corresponding to users and events in the vicinity of Chicago ( CHI ) and Vancouver ( VAN ) . The two datasets CHI and VAN have 2338 and 2327 users , and 339 and 360 events , respectively . For computing the innate affinity , we set σu,a to 1 for events located within 0.01 units of Euclidian distance from the user ’s geolocation . Plancast allows users to subscribe to each other and receive updates on friends’ activities , which gives us a ground truth social network . We compute the Katz distance [ 10 ] for each adjacent pair of users in the subscription graph to learn social affinities w(u , v ) . By defiu,v is the set of paths of length between u and v in the graph , and β is a damping factor so that the measure counts short path more heavily , and is set to 0.01 in our case . Higher Katz score intuitively implies that two nodes are more connected , and hence gives a higher social affinity value . Meetup . Similarly , we project Meetup data from [ 15 ] on events and users located in San Francisco and New York City and refer to these datasets as SFO and NYC . SFO contains 6438 users and 59 events , while NYC contains 10328 users and 127 events . Meetup allows users to create and participate in groups , which in turn organize events . For both locations , we consider the labeled heterogeneous tripartite graph between users , groups , and events , with edges labeled by the relation that connects the pairs of nodes : eg , if user u is a member of group g that organized event a which the user attended , we draw edges ( u , g ) and ( g , a ) . We then define σu,a as the Katz distance between the user node u and event node a in 4http://wwwlargenetworkorg/ebsn nition of Katz , we have w(u , v ) :=∞ u,v| , where P ( )
=1 β·|P ( ) lowmedhigh(a)γ0100020003000400050006000SocialWelfare(ω)102535(b)#Events02000400060008000100001010010001(c)Graphdensity01000020000300004000050000DGPADGPCADG Figure 2 : Distributions of social affinity values
Figure 3 : Improvement of social welfare yielded by various algorithms over Random
Figure 4 : CDF showing regret ratio ρ for different algorithms
Figure 5 : Dominance of PCADG is preserved on varying contributions of social and innate affinities ( VAN ) the heterogeneous graph , with higher Katz score indicating higher affinity . For social affinity between users , we utilize tags provided in the data . More specifically , users on Meetup can attach tags in their profiles to indicate preferences and interests . Intuitively , users sharing common interests may enjoy being with each other in activities they both like . Thus , for each ( u , v ) ∈ E , we compute w(u , v ) as the Jaccard similarity coefficient of u ’s tag sets and v ’s tag sets : |Tu∩Tv| |Tu∪Tv| , where Tu and Tv is are sets of tags of u and w(u , v ) := v respectively . Note that users without any tags in their profile are filtered out . SIGCOMM2009 . This is a small dataset with 76 users , and 11 events , collected by a mobile application that records bluetooth device discovery information . Users’ innate utility for events is 1 if a user attends an event as indicated by the data , and 0 otherwise . The data includes ground truth Facebook friendship information , and thus as in the case of Plancast , we take this underlying social network and compute the Katz scores for social affinities .
Finally , for all five datasets described above , the user event innate affinity is set to 1 if the user attends the event as indicated by the data , and to 0 otherwise . Also due to lack of ground truth data , we generate the maximum and minimum cardinality constraints on the events as in the basic synthetic case , ie , let r be the ratio between the number of users and the number of events ; then for all a ∈ A , maximum cardinality constraint δa is sampled from a normal distribution with mean 2r and variance r , while minimum cardinality γa is sampled uniformly at random from [ 1 , δa ] . Figure 2 shows the distributions of social affinity values for all datasets .
522 Evaluations and Analysis Social Welfare . Figure 3 shows the social welfare ( Eq ( 2 ) ) obtained by the various methods considered relative to the welfare obtained using a Random assignment . It shows the ratio between the social welfare yielded by assignments made by NRMP+ , SG , DG , PADG , PCADG and that by Random . PCADG consistently
051015202530NYC10−1100101102103104105106#Edges08162432SFO10−11001011021031041051060510152025CHI10−110010110210310410508162432VAN10−1100101102103104105100104108112116SIG10−1100101102NRMP+SGDGPADGPCADGNYC0481216ω(Malgo)/ω(MRandom)NRMP+SGDGPADGPCADGSFONRMP+SGDGPADGPCADGCHINRMP+SGDGPADGPCADGVANNRMP+SGDGPADGPCADGSIG000204060810NYC000204060810CDFPCADGDGRandomNRMP+SG000204060810SFO000204060810000204060810CHI000204060810000204060810VAN0002040608100204060810SIG000204060810NRMP+SGDGPADGPCADGα=01025005000750010000ω(Malgo)SocialInnateNRMP+SGDGPADGPCADGα=03NRMP+SGDGPADGPCADGα=05NRMP+SGDGPADGPCADGα=07NRMP+SGDGPADGPCADGα=09 has the highest social welfare , followed by PADG , DG , SG and NRMP+ . The margin between PCADG and the rest of the algorithms is significant in all cases , indicting its overall effectiveness . The biggest lead of PCADG is observed in NYC , 17 times better than Random , while the smallest happens in SIG , in which it is still 4 times better . On all datasets PADG and DG have similar values , with PADG outperforming only slightly . This is because the generated minimum cardinality constraints for events are much smaller than maximum cardinality constraints . Recall from Figure 1(a ) that when γs are high , the gap between PADG and DG is also high . Regret Ratio . Figure 4 shows the cumulative distribution function ( CDF ) of the regret ratio ρ(u ) ( see Eq ( 5 ) ) achieved by the various methods ( PADG skipped for clarity ) on the five datasets . The general trend is similar to that of social welfare , where PCADG outperforms all baselines . For instance , in NYC , 20 % of the users have a regret below 0.8 using PCADG , while only 8 % have that regret with NRMP+ . This gap is even more pronounced in CHI and VAN , with the largest difference in SIG . In particular , 70 % of users have a regret ratio below 0.7 using PCADG , while only 18 % have that regret using NRMP+ . Varying Contribution of Social and Innate Affinities . A possible concern about our definition of social welfare ( Eq ( 1 ) ) is that it may be dominated by social affinity . However , Eq ( 1 ) allows the organizer to control the relative importance of social and innate affinities and not let the overall objective be undesirably dominated by either . To analyze this , in this final experiment , we first boost the innate affinities such that at α = 0.5 , innate and social affinities ( found by PADG ) are nearly equal , and stress test the various algorithms on VAN by varying α . This allows us to vary the relative contribution of social and innate affinities to the overall welfare achieved and study its impact on the algorithms . Figure 5 shows the absolute value of the total welfare and the individual contribution of the two affinities for α = 0.1 , 0.3 , 0.5 , 0.7 and 09 As can be seen , the dominance of PCADG over other algorithms is maintained across all values of α , with higher overall welfare for larger α . We also measured regret ratios in all cases . The trend was found to be the same as in Figure 4 and the plot is omitted for brevity .
In summary , through extensive experiments on both synthetic and real world data , we have demonstrated the effectiveness ( in terms of social welfare and regret ) and efficiency ( in terms of running time ) of our proposed solutions to the SEO problem .
6 . DISCUSSION AND CONCLUSIONS
While there has been considerable work on detecting emerging events from social media , the related , equally important area of organizing events has received much less research attention . In this paper , motivated by popular social event organization platforms like Meetup and Plancast and by applications such as organizing events using these platforms over a wide local area , and organizing events co located with large conferences and conventions , we study the novel research direction of Social Event Organization ( SEO ) .
Our focus in this work has been on the assignment problem , where we consider two critical factors : innate affinity , which captures a user ’s intrinsic preferences for the events being offered , and social affinity , which captures the social connections among the users themselves . We formally define the overall measure of social welfare in event organization and formalize the SEO problem as the problem of maximizing social welfare subject to constraints on the participation cardinality of the events . We show that this problem is not only NP hard , but also hard to approximate . We propose a set of heuristic solutions that leverage the notion of phantom events and the technique of looking ahead the potential gain that may ac crue as a result of future assignments to the current event for which a user is being assigned . Using an extensive set of experiments over synthetic datasets and three real datasets including those from the platforms Meetup and Plancast , we demonstrate that our heuristic algorithms are scalable and furthermore outperform the baseline algorithms significantly in terms of social welfare and regret ratio . Several interesting questions remain . Innate and social affinities may be interdependent . Eg , Al and Ed are close friends but don’t like to play poker together since they know each other ’s tells , while Al may like going to a hockey game ( for which she has low innate affinity ) with Bo who is knowledgeable and keeps her engaged . Handling such interdependency is important . Predicting which events a user will attend in the future is also an interesting problem . It is also worth comparing the assignments made by SEO to ground truth from event participations , which may be challenging to obtain . Also , a systematic study of alternative ways of aggregating innate and social affinities for defining social welfare is worthwhile .
7 . REFERENCES [ 1 ] W . Aiello , F . R . K . Chung , and L . Lu . A random graph model for massive graphs . In STOC , pages 171–180 , 2000 .
[ 2 ] S . Amer Yahia , S . B . Roy , A . Chawla , G . Das , and C . Yu . Group recommendation : Semantics and efficiency . PVLDB , 2(1 ) , 2009 .
[ 3 ] A . Anagnostopoulos et al . Online team formation in social networks .
In WWW , 2012 .
[ 4 ] N . Armenatzoglou , S . Papadopoulos , and D . Papadias . A general framework for geo social query processing . PVLDB , 6(10 ) , 2013 .
[ 5 ] P . Biró et al . The college admissions problem with lower and common quotas . Theor . Comput . Sci , 411(34 36):3136–3153 , 2010 .
[ 6 ] C . Chekuri and S . Khanna . A ptas for the multiple knapsack problem . In SODA , 2000 .
[ 7 ] L . Fleischer et al . Tight approximation algorithms for maximum general assignment problems . In SODA , 2006 .
[ 8 ] D . Gale and L . S . Shapley . College admissions and the stability of marriage . Amer . Math . Monthly , 69 , 1962 .
[ 9 ] K . Hamada , K . Iwama , and SMiyazaki The hospitals/ residents problem with quota lower bounds . In MATCH UP : Matching Under Preferences Workshop at ICALP , 2008 .
[ 10 ] L . Katz . A new status index derived from sociometric analysis .
Psychometrika , 18(1 ) , 1953 .
[ 11 ] S . Khot . On the power of unique 2 prover 1 round games . STOC ,
2002 .
[ 12 ] S . O . Krumke and C . Thielen . The generalized assignment problem with minimum quantities . European Journal of Operational Research , 2013 .
[ 13 ] T . Lappas , K . Liu , and E . Terzi . Finding a team of experts in social networks . In KDD , 2009 .
[ 14 ] D . Liben Nowell and J . Kleinberg . The link prediction problem for social networks . Journal of the American society for information science and technology , 58(7 ) , 2007 .
[ 15 ] X . Liu et al . Event based social networks : linking the online and offline social worlds . In KDD , 2012 .
[ 16 ] E . Petrank . The hardness of approximations : Gap location .
Computational Complexity , 4:133–157 , 1994 .
[ 17 ] A K Pietilainen and C . Diot . CRAWDAD data set thlab/sigcomm2009 ( v . 2012 07 15 ) . Downloaded from http://crawdadcsdartmouthedu/thlab/sigcomm2009 , 2012 .
[ 18 ] P . Raghavendra and D . Steurer . Graph expansion and the unique games conjecture . In STOC , 2010 .
[ 19 ] A . E . Roth . The evolution of the labor market for medical interns and residents : a case study in game theory . Journal of Political Economy , 6(4):991–1016 , 1984 .
[ 20 ] D . B . Shmoys et al . An approximation algorithm for the generalized assignment problem . Math . Program . , 62:461–474 , 1993 .
[ 21 ] M . Sozio and A . Gionis . The community search problem and how to plan a successful cocktail party . In KDD , pages 939–948 , 2010 .
