Travel Time Estimation of a Path using Sparse Trajectories
Yilun Wang1,2,* , Yu Zheng1,+
, Yexiang Xue1,3,*
1Microsoft Research , No.5 Danling Street , Haidian District , Beijing 100080 , China
2College of Computer Science , Zhejiang Univeristy 3Department of Computer Science , Cornell University
{v yilwan , yuzheng}@microsoft.com , yexiang@cscornelledu
ABSTRACT In this paper , we propose a citywide and real time model for estimating the travel time of any path ( represented as a sequence of connected road segments ) in real time in a city , based on the GPS trajectories of vehicles received in current time slots and over a period of history as well as map data sources . Though this is a strategically important task in many traffic monitoring and routing systems , the problem has not been well solved yet given the following three challenges . The first is the data sparsity problem , ie , many road segments may not be traveled by any GPS equipped vehicles in present time slot . In most cases , we cannot find a trajectory exactly traversing a query path either . Second , for the fragment of a path with trajectories , they are multiple ways of using ( or combining ) the trajectories to estimate the corresponding travel time . Finding an optimal combination is a challenging problem , subject to a tradeoff between the length of a path and the number of trajectories traversing the path ( ie , support ) . Third , we need to instantly answer users’ queries which may occur in any part of a given city . This calls for an efficient , scalable and effective solution that can enable a citywide and real time travel time estimation . To address these challenges , we model different drivers’ travel times on different road segments in different time slots with a three dimension tensor . Combined with geospatial , temporal and historical contexts learned from trajectories and map data , we fill in the tensor ’s missing values through a contextaware tensor decomposition approach . We then devise and prove an object function to model the aforementioned tradeoff , with which we find the most optimal concatenation of trajectories for an estimate through a dynamic programming solution . In addition , we propose using frequent trajectory patterns ( mined from historical trajectories ) to scale down the candidates of concatenation and a suffix tree based index to manage the trajectories received in the present time slot . We evaluate our method based on extensive experiments , using GPS trajectories generated by more than 32,000 taxis over a period of two months . The results demonstrate the effectiveness , efficiency and scalability of our method beyond baseline approaches . Categories and Subject Descriptors H28 [ Database Management ] : Database Applications data mining , Spatial databases and GIS ; Keywords Travel time estimation ; tensor ; trajectories ; urban computing ;
*The paper was done when the first and third authors were interns in Microsoft Research under the supervision of the second author who contributed the main idea and algorithms of this paper . Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page . Copyrights for components of this work owned by others than ACM must be honored . Abstracting with credit is permitted . To copy otherwise , or republish , to post on servers or to redistribute to lists , requires prior specific permission and/or a fee . Request permissions from permissions@acmorg KDD’14 , August 24–27 , 2014 , New York , New York , USA . Copyright © 2014 ACM 978 1 4503 2956 9/14/08…$15.00 http://dxdoiorg/101145/26233302623656
1 . INTRODUCTION Real time estimation of the travel time of a path , which is represented by a sequence of connected road segments , is of great importance for traffic monitoring [ 1 ] , finding driving directions [ 20 ] , ridesharing [ 13 ] and taxi dispatching [ 22 ] . Existing solutions , eg , using loop sensors , usually tell people the travel speed of an individual road segment rather than the travel time of an entire path . The latter ’s value is not a simple summation of the travel time of each individual road segment , as a path also contains road intersections ( sometimes with traffic lights ) where a driver needs to slow down or wait for a while . Explicitly modeling the time delay at an intersection is not easy [ 8 ] . In addition , these methods have limited coverage , as many streets do not have a loop sensor embedded . An alternative method is to use floating car data ( eg , GPS trajectories of vehicles ) to estimate the travel time of a path . For example , as shown in Figure 1 , we estimate the travel time of path ( cid:1372)(cid:2870)(cid:1372 ) ( cid:2871)(cid:1372)(cid:2872 ) , using four trajectories ( cid:1846 ) , ( cid:1846)(cid:2870 ) , ( cid:1846)(cid:2871 ) , and ( cid:1846)(cid:2872 ) . Unfortunately , there are three major issues remaining unsolved in existing methods . They are as follows :
Tr1 Tr2 Tr3 Tr4 r1 r5 r2 r7 r3 r6 r4
Figure 1 . Problem demonstration with trajectories , how to combine these trajectories effectively to achieve an accurate estimate is still a challenging problem . Clearly , there are multiple ways of using the four trajectories shown in Figure times is not accurate enough ( since its traffic conditions change over time of day and day of the week ) . Sometimes , the road may never be traversed by any trajectories ( even in history ) in our dataset , as in practice we only have the data of a sample of vehicles .
1 ) Data sparsity : For example , ( cid:2872 ) is not traversed by any trajectory in the previous 30 minutes . Using an average of ( cid:2872 ) ’s historical travel 2 ) Trajectory concatenation : For the sub path ( eg , ( cid:1372)(cid:2870)(cid:1372)(cid:2871 ) ) 1 . For instance , we can calculate the travel time of ( cid:1372)(cid:2870)(cid:1372)(cid:2871 ) solely based on ( cid:1846)(cid:2870 ) . Or , we can compute the travel time for ( based on ( cid:1846 ) and ( cid:1846)(cid:2870) ) , ( cid:2870 ) ( based on ( cid:1846 ) , ( cid:1846)(cid:2870 ) and ( cid:1846)(cid:2871) ) , and ( cid:2871 ) ( using ( cid:1846)(cid:2870 ) , ( cid:1846)(cid:2871 ) and ( cid:1846)(cid:2872) ) , separately . Later , the travel time of ( cid:1372)(cid:2870)(cid:1372)(cid:2871 ) can can also use ( cid:1846)(cid:2870 ) and ( cid:1846)(cid:2871 ) to estimate the travel time of ( cid:2870)(cid:1372)(cid:2871 ) , then concatenating it with that of ; or , do ( cid:1372)(cid:2870 ) first based on ( cid:1846 ) and ( cid:1846)(cid:2870 ) , then concatenating it with ( cid:2871 ) . ( cid:1372)(cid:2870)(cid:1372)(cid:2871 ) using many trajectories like ( cid:1846)(cid:2870 ) covering the entire
Different concatenations have their own advantages and disadvantages , subject to a trade off between their support and length . The ideal situation is to estimate the travel time of be obtained by summing the travel times of each road segment . We path . Such trajectories reflect the traffic conditions of an entire path , including intersections , traffic lights and direction turns , hence , no need to model these complex factors separately and
+ Yu Zheng is the correspondence author of this paper . explicitly . However , as the length of a path increases , the number of trajectories ( ie , the support ) traveling on the path decreases ( refer to Figure 10 A ) for details ) . Consequently , the confidence of the travel time ( derived from few drivers ) decreases . For example , what if ( cid:1846)(cid:2870 ) is generated by an uncommon driver or in an unusual situation like pedestrians crossing a street ? Furthermore , in many cases , we cannot even find a trajectory passing an entire path . On the other hand , using the concatenation of shorter subpaths can have more occurrences of trajectories on each sub path ( ie , having a high confidence in the derived travel time for each sub path ) . But this results in more fragments , across which the aforementioned complex factors are difficult to model . The more fragments a concatenation contains , the more inaccuracy a path ’s travel time could involve . 3 ) Tradeoff among Scalability , effectiveness and efficiency : As users can query any path in a city , we need to model the traffic conditions with a city scale , which usually contains tens of thousands of road segments . In the meantime , we have to answer users’ query instantly . So , a good solution should be scalable , effective and efficient , all simultaneously . This requirement fails some complex models that work well on a particular road . In this paper , we propose a model for instant Path Travel Time Estimation ( PTTE ) , based on sparse trajectories generated by a sample of vehicles ( eg , some GPS equipped taxicabs ) in the recent time slots as well as in history . Our model is comprised of two major components . One is to estimate the travel time for road segments without being traversed by trajectories through a context aware tensor decomposition ( CATD ) approach . The second is to find the most optimal concatenation ( OC ) of trajectories to estimate a path ’s travel time using a dynamic programing solution . Our work has three primary contributions :  Dealing with the missing values : We model different drivers’ travel times on different road segments in different time slots with a three dimensional tensor . Combined with geospatial , temporal and historical contexts learned from other data sources , we fill in the tensor ’s missing values through a context aware tensor decomposition approach . To expedite the inference , we partition a city into disjoint geo regions and carry out the decomposition for each region in parallel .
 Optimal concatenation : We devise and prove an object function that can model the tradeoff between the support and length of a concatenation . Using a dynamic programming solution , we find the most optimal concatenation of trajectories for estimating a path ’s travel time . In addition , we use frequent trajectory patterns mined in advance to scale down the candidates of concatenation and propose a suffixtree based index to manage the recently received trajectories , improving the efficiency of our model . Evaluation : We evaluate our model with the real trajectories generated by over 32,000 taxis over a period of 2 month on Beijing ’s road network . The results of extensive experiments demonstrate the advantages of our model . A sample of the data has been released at [ 25 ] .

The rest of the paper is organized as follows : Section 2 overviews our model . Section 3 elaborates on the method for inferring the travel time of road segments without trajectories . Section 3 introduces the method that searches for the most optimal concatenation . Section 4 presents the experiments and Section 5 summarizes related work . We conclude the paper in Section 6 .
2 . OVERVIEW points , a list of intermediate points describing the segment , a
Definition 1 : Road Network . A road network ( cid:1840 ) is comprised of a set of road segments ( cid:4668)(cid:4669 ) connected among each other in a graph format . Each road segment is a directed edge with two terminal length .(cid:1864)(cid:1857 ) , a level .(cid:1864)(cid:1857 ) ( eg a highway or a street ) , a direction .(cid:1856)(cid:1861 ) ( eg one way or bi directional ) and the number of lanes Definition 2 : Trajectory . A spatial trajectory ( cid:1846 ) is a sequence of time ordered points , ( cid:1846):(cid:1868)(cid:1372)(cid:1868)(cid:2870)(cid:1372)(cid:1710)(cid:1372)(cid:1868 ) , where each point has a geospatial coordinate set and a timestamp , ( cid:1868)(cid:4666)(cid:1876),(cid:1877),(cid:4667 ) . Definition 3 : Path . A path ( cid:1842 ) is represented by a sequence of connected road segments , eg , ( cid:1842):(cid:1372)(cid:2870)(cid:1372)(cid:1710)(cid:1372 ) , in an ( cid:1840 ) . Definition 4 : Trajectory pattern . A trajectory pattern ( cid:1846)(cid:1842 ) is a road segments . If we set support as 2 , ( cid:1372)(cid:2870 ) and ( cid:2870)(cid:1372)(cid:2871 ) in Figure 1 are trajectory patterns , while ( cid:1372)(cid:2870)(cid:1372)(cid:2871 ) is not eligible . Definition 5 : Concatenation . A path ( cid:2172 ) can be decomposed into ( cid:2172)(cid:1842)|| ||(cid:1842)…||(cid:1842 ) …|| ( cid:1842 ) , ( cid:1482)1(cid:1861) , , ( cid:1861)(cid:3405 ) , ( cid:1842)(cid:1514)(cid:1842)(cid:1486 ) . For instance , ( cid:1372)(cid:2870)(cid:1372)(cid:2871)(cid:1372)(cid:2872 ) can be formed by ( cid:4666)(cid:1372)(cid:2870)(cid:1372 ) ( cid:2871)(cid:4667)||(cid:2872 ) , or ( cid:4666)(cid:1372)(cid:2870)(cid:4667)||(cid:4666)(cid:2871)(cid:1372)(cid:2872)(cid:4667 ) , or ||(cid:4666)(cid:2870)(cid:1372)(cid:2871)(cid:1372)(cid:2872)(cid:4667 ) . Thus , the travel time of ( cid:2172 ) can be obtained via the summation of different concatenations , eg , ( cid:2172)(cid:3045)(cid:3117)(cid:1372)(cid:3045)(cid:3118)(cid:1372)(cid:3045)(cid:3119 ) +(cid:3045)(cid:3120 ) , or ( cid:2172)(cid:3045)(cid:3117)(cid:1372)(cid:3045)(cid:3118)(cid:3397)(cid:3045)(cid:3119)(cid:1372)(cid:3045)(cid:3120 ) , or ( cid:2172)(cid:3045)(cid:3117)(cid:3397)(cid:3045)(cid:3118)(cid:1372)(cid:3045)(cid:3119)(cid:1372)(cid:3045)(cid:3120 ) . Definition 6 : Travel Time . A driver ’s travel time on a road segment in time slot ( cid:1863 ) is defined as ( cid:3045),,(cid:3038 ) . Likewise , ( cid:3017),,(cid:3038 ) denotes ’s travel time on path ( cid:1842 ) in time slot ( cid:1863 ) . sequential pattern of road segments with a support over a threshold , calculated by the number of trajectories traversing these concatenations
( different
||
) of its sub paths ,
Map
Matching
Trajectories
Tensor
Construction
Road
Networks
Trajectory Database
Context Feature
Extraction
Ar
Features
Tensor
Decomposition
Arec
Frequent Trajectory
Pattern Mining
Patterns
Optimal
Concatenation
Path cost
Figure 2 . Framework of our model
Figure 2 presents the framework of our model which is comprised of two major parts . In the above part , we project each trajectory received in a current time slot onto a road network , using a map matching algorithm [ 21 ] . The trajectories ( combined with road network data ) are then used to construct a 3D tensor ( cid:2267)(cid:3045 ) where the three dimensions stand for road segments , time slots and drivers , respectively . Each entry is the travel time of a particular driver on a particular road segment in a specific time slot . We partition a day into several time slots based on a certain time interval ( eg , we divide a day into 48 time slots with 30 minutes each in the experiments ) . Clearly , the tensor is very sparse ( ie , having many entries without values ) , as a driver can only travel a few road segments in a time slot . To deal with the data sparsity problem , we extract three categories of features , consisting of geospatial , temporal , and historical contexts , from the road network data and trajectories . The first two feature sets are stored in two matrices , respectively , and the historical context is represented by another tensor ( cid:2267)(cid:3035 ) . The two matrices and ( cid:2267)(cid:3035 ) are then factorized with ( cid:2267)(cid:3045 ) collaboratively , helping fill ( cid:2267)(cid:3045 ) ’s missing entries in a current more proportion of non zero entries than ( cid:2267)(cid:3045 ) , thereby reducing the time slot ( ie , inferring the travel time of road segments without being traveled by trajectories in the current time slot ) . The general idea is that road segments with similar contexts could have a similar travel time . The context matrices and tensor reveal the similarity and with a factorization error and improving the inference accuracy . After filling the missing entries in ( cid:2267)(cid:3045 ) , we obtain the travel time of any driver on any road segment in current time slot ( stored in ( cid:2267)(cid:3045)(cid:3032)(cid:3030) ) . In the bottom part , given a query path ( cid:1842 ) , we estimate its travel time in the current time slot , based on ( cid:2267)(cid:3045)(cid:3032)(cid:3030 ) , the trajectories received in the time slot and trajectory patterns . Specifically , we devise and prove an objective function that can represent the tradeoff between the length and support of a trajectory pattern . Based on the objective function , we find the most optimal concatenation of trajectories for a path , using a dynamic programing approach . In practice , it is not necessary to try every possible concatenation of a path , as some sub paths have never been traversed by any trajectory . So , we mine frequent trajectory patterns from historical trajectories in advance and study the concatenation of these existing patterns to estimate the travel time of a path . This reduces the online computational loads significantly , while guaranteeing accuracy in travel time estimation . Note that we are not using the historical travel time of a trajectory pattern . The patterns just provide us with candidate schemes of subpaths for finding an optimal concatenation of a path . Each trajectory pattern ’s travel time in current time slot is mainly calculated based on the trajectories received in the time slot . If a pattern contains road segments without being traversed by trajectories in the current time slot , we retrieve the inferred time from ( cid:2267)(cid:3045)(cid:3032)(cid:3030 ) , according to the driver , road segment and time slot . For instance , two drivers ( , ( cid:2870 ) ) travelled ( cid:1372)(cid:2870 ) , but nobody traveled ( cid:2871 ) in a pattern ( cid:1372)(cid:2870)(cid:1372)(cid:2871 ) , in current time slot ( cid:1863 ) . That is , ( cid:3045)(cid:3117)(cid:1372)(cid:3045)(cid:3118),(cid:3117),(cid:3038 ) , and ( cid:3045)(cid:3117)(cid:1372)(cid:3045)(cid:3118),(cid:3118),(cid:3038 ) can be calculated from the present trajectory data , while ( cid:3045)(cid:3119),(cid:3117),(cid:3038 ) and ( cid:3045)(cid:3119),(cid:3118),(cid:3038 ) are unknown . In this case , we retrieve the latter two from ( cid:2267)(cid:3045)(cid:3032)(cid:3030 ) , calculating ( cid:3045)(cid:3117)(cid:1372)(cid:3045)(cid:3118)(cid:1372)(cid:3045)(cid:3119),(cid:3117),(cid:3038)(cid:3045)(cid:3117)(cid:1372)(cid:3045)(cid:3118),(cid:3117),(cid:3038)(cid:3397)(cid:3045)(cid:3119),(cid:3117),(cid:3038 ) , and ( cid:3045)(cid:3117)(cid:1372)(cid:3045)(cid:3118)(cid:1372)(cid:3045)(cid:3119),(cid:3118),(cid:3038)(cid:3045)(cid:3117)(cid:1372)(cid:3045)(cid:3118),(cid:3118),(cid:3038)(cid:3397)(cid:3045)(cid:3119),(cid:3118),(cid:3038 ) . With ( cid:2267)(cid:3045)(cid:3032)(cid:3030 ) , we can estimate a driver ’s travel time on a trajectory dimension of drivers in ( cid:2267)(cid:3045)(cid:3032)(cid:3030 ) enables us to calculate the variance pattern even if the recently received data is incomplete . The
; ( 1 )
( cid:3047)(cid:3269)(cid:3265),(cid:3296),(cid:3286 ) ( cid:3296)(cid:1488)(cid:3270)|(cid:3022)|
( cid:1846)∑ ( cid:3017)(cid:1488)(cid:2959 ) among different drivers’ travel times on a road segment or a subpath . Intrinsically , different drivers travel the same road segment with different times , majorly depending on the different traffic conditions they experience . Thus , the variance implies the complexity of traffic conditions on a road segment or a sub path , helping estimate a more accurate travel time of a path ( elaborated in Section 41 ) Finally , the travel time of a path is calculated as :
Where Ψ is the concatenation of path ( cid:1842 ) , represented by a set of trajectory pattern ( cid:1846)(cid:1842)s ; ( cid:1847 ) is a collection of drivers traversing ( or partially traversing ) a ( cid:1846)(cid:1842 ) ; ( cid:1863 ) is the current time slot . construct a tensor ( cid:2267)(cid:3045)(cid:1488)(cid:1337)(cid:3015)(cid:3400)(cid:3014)(cid:3400)(cid:3013 ) , with the three dimensions based on the GPS trajectories received in the most recent ( cid:1838 ) time ( cid:2267)(cid:3045)(cid:4666)(cid:1861),,(cid:1863)(cid:4667)(cid:1855 ) denotes the ( cid:1861)th road segment is traveled by the th driver with a time cost ( cid:1855 ) in time slot ( cid:1863 ) ( eg , 2 2:30pm ) . The last time slot denotes the present time slot , combined with the ( cid:1838) 1
3 . DEALING WITH MISSING VALUES 3.1 Tensor Building and Feature Extraction To model the traffic conditions of the current time slot , we slots and the road network data . As shown in Figure 3 , an entry standing for road segments , drivers and time slots , respectively , time slots right before it to formulate the tensor . Clearly , the tensor is very sparse as a driver can only travel a few road segments in a short time period . If we were able to fill in the missing entries in terms of the values of non zero entries , we can know the travel time of any driver on any road segment in the present time slot .
∑ objective function is defined as Equation 2 to control the errors .
A common approach to this problem is to decompose a tensor into the multiplication of a few ( low rank ) matrices and a core tensor ( or just a few vectors ) , based on the tensor ’s non zero entries . For example , we can decompose ( cid:2267)(cid:3045 ) into the multiplication of a core tensor ( cid:1488)(cid:1337)(cid:3031)(cid:3267)(cid:3400)(cid:3031)(cid:3270)(cid:3400)(cid:3031)(cid:3269 ) and three matrices , ( cid:1488)(cid:1337)(cid:3015)(cid:3400)(cid:3031)(cid:3267 ) , ( cid:1847)(cid:1488 ) ( cid:1337)(cid:3014)(cid:3400)(cid:3031)(cid:3270 ) , ( cid:1846)(cid:1488)(cid:1337)(cid:3013)(cid:3400)(cid:3031)(cid:3269 ) , if using a tucker decomposition model . An ( cid:2278)(cid:4666),,(cid:1847),(cid:1846)(cid:4667)(cid:2870)(cid:1313)(cid:2267)(cid:3045)(cid:3400)(cid:3019)(cid:3400)(cid:3022)(cid:1847)(cid:3400)(cid:1846)(cid:1313)(cid:2870 ) ( cid:3397)(cid:3090)(cid:2870)(cid:4666)(cid:1313)(cid:1313)(cid:2870)(cid:3397)(cid:1313)(cid:1313)(cid:2870)(cid:3397)(cid:1313)(cid:1847)(cid:1313)(cid:2870)(cid:3397)(cid:1313)(cid:1846)(cid:1313)(cid:2870)(cid:4667 ) , ( 2 ) where ( cid:1313)·(cid:1313)(cid:2870 ) denotes the ( cid:1864)(cid:2870 ) norm and ( cid:3090)(cid:2870)(cid:4666)(cid:1313)(cid:1313)(cid:2870)(cid:3397)(cid:1313)(cid:1313)(cid:2870)(cid:3397)(cid:1313)(cid:1847)(cid:1313)(cid:2870)(cid:3397)(cid:1313)(cid:1846)(cid:1313)(cid:2870)(cid:4667 ) is a regularization of penalties to avoid over fitting ; ( cid:1856)(cid:3019 ) , ( cid:1856)(cid:3022 ) , and ( cid:1856 ) are usually very small , denoting the number of latent factors . ( cid:2019 ) Afterwards , we can recover the missing values in ( cid:2267)(cid:3045 ) by multiplying decomposed factors as ( cid:2267)(cid:3045)(cid:3032)(cid:3030)(cid:3400)(cid:3019)(cid:3400)(cid:3022)(cid:1847)(cid:3400)(cid:1846 ) . is a parameter controlling the contributions of the regularization . g1 g2
X
Xh
Xr tj tk t'j t'k
Y f1 f2 fr fq fp r1 r2 rN t'k
Ah tk t'j g16
Ar tj uM u2 u1 rN r1 r2
A = Ar || Ah
Figure 3 . The model dealing with data sparsity
In our problem , however , the tensor is over sparse . For example , if based on the historical trajectories over a long period of time ( eg traffic patterns and drivers’ behavior on an entire road network . For instance , using one month trajectories and setting 30 minutes as a setting 30 minutes as a time slot , only 0.03 % entries of ( cid:2267)(cid:3045 ) have values . Decomposing ( cid:2267)(cid:3045 ) solely based on its own non zero entries is not accurate enough . To this end , we build another tensor ( cid:2267)(cid:3035 ) one month ) . As shown in Figure 3 , ( cid:2267)(cid:3035 ) has the same structure as ( cid:2267)(cid:3045 ) , while an entry ( cid:2267)(cid:3035)(cid:4666)(cid:1861),,(cid:1863)(cid:4667)(cid:1855)(cid:1314 ) denotes the th driver ’s average travel time on the ( cid:1861)th road segment in time slot ( cid:1863 ) in the history . Intrinsically , ( cid:2267)(cid:3035 ) is much denser than ( cid:2267)(cid:3045 ) , denoting the historical time slot , the non zero entries of ( cid:2267)(cid:3035 ) is about 04 % Decomposing ( cid:2267)(cid:3045 ) and ( cid:2267)(cid:3035 ) together reduces the error of supplementing ( cid:2267)(cid:3045 ) . Besides ( cid:2267)(cid:3035 ) , we also construct another two matrices ( cid:1850 ) and ( cid:1851 ) to help the decomposition of ( cid:2267)(cid:3045 ) . Specifically , as illustrated in Figure 4 A ) , ( cid:1851 ) stores the geographical features ( cid:1858)(cid:3045 ) of each road segment , such as .(cid:1864)(cid:1857 ) , .(cid:1864)(cid:1857 ) , .(cid:1856)(cid:1861 ) , . , the number of neighbors ( eg , has 2 and 3 neighbors ) at its terminals , and a tortuosity ratio ( cid:2028 ) ( eg ( cid:2028)(cid:1864)(cid:1857 ) ( cid:1856)⁄ ) , as well as the distribution of Point of Interests ( POIs ) ( cid:1858)(cid:3043 ) around ’s terminals . While ( cid:1851 ) captures the similarity between different road segments in geographic spaces , matrix ( cid:1850 ) ( consisting of ( cid:1850)(cid:3045 ) and ( cid:1850)(cid:3035 ) ) represents the correlation between ( eg , 4(cid:3400)4 in Figure 4 B ) , each of which is comprised of many road segments . ( cid:1850)(cid:3045 ) is built based on the recent trajectory data received from to ( eg , 1pm 3pm ) , reflecting the present traffic conditions on a road network . An entry of ( cid:1850)(cid:3045 ) denotes the number of of ( cid:1850)(cid:3045 ) represents coarse grained traffic conditions in a city of a individual road segment in ( cid:2267)(cid:3045 ) , ( cid:1850)(cid:3045 ) can be filled densely , therefore can help reduce the error of decomposing ( cid:2267)(cid:3045 ) . ( cid:1850)(cid:3035 ) has the same structure as ( cid:1850)(cid:3045 ) , storing the historical average number of vehicles traversing a grid from to . In other words , ( cid:1850)(cid:3045 ) and ( cid:1850)(cid:3035 ) particular time slot . Consequently , the similarity of two different rows indicates the correlation of traffic flows between two time slots . Additionally , in contrast to using the traffic flow on each different time slots in terms of the coarse grained traffic conditions . More specifically , we partition a city into disjoint and uniform grids vehicles traversing a particular grid in a particular time slot . A row respectively correspond to the coarse grained current and historical traffic conditions in the same span of time of day . In the implementation , we build ( cid:1827)(cid:3035 ) and ( cid:1850)(cid:3035 ) of an entire day in advance time slots ( cid:1838 ) needed ) when constructing ( cid:1850 ) and ( cid:1827 ) . For example , as shown in Figure 4 C ) , the rows from to will be retrieved from the prebuilt ( cid:1850)(cid:3035 ) to construct ( cid:1850 ) with ( cid:1850)(cid:3045 ) . and retrieve the entries according to current time ( and the number of r6 r5 r1 d1 r2 r3 r4 g1 g5 g9 g13 g2 g6 g10 g14 g3 g7 g11 g15 g4 g8 g12 g16
Xh= t1 t2 ti tj tm g1 g2 g16 14 50 22 27 16 8
26 72 49
91
23 6 9 42 2 11
61
7 C )
B )
A ) function is defined as Equation 3 ,
Figure 4 . Constructing context matrices
3.2 Tensor Decomposition
To achieve a high accuracy of decomposition , we put together ( cid:2267)(cid:3045 ) and ( cid:2267)(cid:3035)(ie , ( cid:2267)(cid:2267)(cid:3045)|| ( cid:2267)(cid:3035 ) , as shown in Figure 3 ) , decomposing ( cid:2267 ) with context matrices ( cid:1850 ) and ( cid:1851 ) collaboratively . The objective ( cid:2278)(cid:4666),,(cid:1847),(cid:1846),(cid:1832),(cid:1833)(cid:4667)(cid:2870)(cid:1313)(cid:2267)(cid:3045)(cid:3400)(cid:3019)(cid:3400)(cid:3022)(cid:1847)(cid:3400)(cid:1846)(cid:1313)(cid:2870)(cid:3397)(cid:3090)(cid:3117)(cid:2870)(cid:1313)(cid:1850)(cid:1846)(cid:1833)(cid:1313)(cid:2870)(cid:3397 ) ( cid:3090)(cid:3118)(cid:2870)(cid:1313)(cid:1851)(cid:1832)(cid:1313)(cid:2870)(cid:3397)(cid:3090)(cid:3119)(cid:2870)(cid:4666)(cid:1313)(cid:1313)(cid:2870)(cid:3397)(cid:1313)(cid:1313)(cid:2870)(cid:3397)(cid:1313)(cid:1847)(cid:1313)(cid:2870)(cid:3397)(cid:1313)(cid:1846)(cid:1313)(cid:2870)(cid:3397)(cid:1313)(cid:1832)(cid:1313)(cid:2870)(cid:3397)(cid:1313)(cid:1833)(cid:1313)(cid:2870)(cid:4667 ) , ( 3 ) where ( cid:2267)(cid:1488)(cid:1337)(cid:3015)(cid:3400)(cid:3014)(cid:3400)(cid:2870)(cid:3013 ) and ( cid:1850)(cid:1488)(cid:1337)(cid:2870)(cid:3013)(cid:3400)(cid:3017 ) , ( cid:1842 ) denotes the number of grids ; ( cid:1851)(cid:1488)(cid:1337)(cid:3015)(cid:3400)(cid:3018 ) , ( cid:1843 ) denotes the dimension of geographical features ; ( cid:1846)(cid:1488)(cid:1337)(cid:2870)(cid:3013)(cid:3400)(cid:3031)(cid:3269 ) , ( cid:1833)(cid:1488)(cid:1337)(cid:3031)(cid:3269)(cid:3400)(cid:3017 ) , ( cid:1488)(cid:1337)(cid:3015)(cid:3400)(cid:3031)(cid:3267 ) and ( cid:1832)(cid:1488)(cid:1337)(cid:3031)(cid:3267)(cid:3400)(cid:3018 ) geographical features . Later , we can recover ( cid:2267 ) according to ( cid:2267)(cid:3045)(cid:3032)(cid:3030)(cid:3400)(cid:3019)(cid:3400)(cid:3022)(cid:1847)(cid:3400)(cid:1846 ) . ( cid:2019 ) , ( cid:2019)(cid:2870 ) , and ( cid:2019)(cid:2871 ) are parameters In our model , ( cid:2267 ) and ( cid:1850 ) shares matrix ( cid:1846 ) , and ( cid:2267 ) and ( cid:1851 ) share matrix . The dense representation of ( cid:1850 ) and ( cid:1851 ) helps generate a relatively accurate ( cid:1846 ) and , which reduce the decomposition error of ( cid:2267 ) in turn . Additionally , the combination of ( cid:1850)(cid:3045 ) and ( cid:1850)(cid:3035 ) reveals how patterns . The information of the deviation is then propagated to ( cid:2267 ) , are low rank latent factor matrices for time slots , grids , roads and current coarse grained traffic condition deviates from its historical controlling the contribution of different parts . helping figure out the fine grained deviation between current traffic conditions and historical traffic patterns on each road segment . So , our model considers both geospatial and temporal correlations . It also incorporates the knowledge from present and historical traffic data . As there is no closed form solution for finding the most optimal result of Equation 3 , we use a numeric method , gradient descent , to find a local optimization , as presented in Figure 5 . Algorithm 1 : Tensor Decomposition
Input : tensor ( cid:2267 ) , matrix ( cid:1850 ) , and matrix ( cid:1851 ) , an error threshold Output : , ( cid:1847 ) , ( cid:1846 ) , 1 . Initialize ( cid:1488)(cid:1337)(cid:3031)(cid:3267)(cid:3400)(cid:3031)(cid:3270)(cid:3400)(cid:3031)(cid:3269 ) , ( cid:1488)(cid:1337)(cid:3015)(cid:3400)(cid:3031)(cid:3267 ) , ( cid:1847)(cid:1488)(cid:1337)(cid:3014)(cid:3400)(cid:3031)(cid:3270 ) , ( cid:1846)(cid:1488)(cid:1337)(cid:2870)(cid:3013)(cid:3400)(cid:3031)(cid:3269 ) , ( cid:1833)(cid:1488)(cid:1337)(cid:3031)(cid:3269)(cid:3400)(cid:3017 ) , ( cid:1832)(cid:1488)(cid:1337)(cid:3031)(cid:3267)(cid:3400)(cid:3018 ) with small random values 2 . Set ( cid:2015 ) as step size 3 . While ( cid:1838)(cid:3047)(cid:1838)(cid:3047)(cid:3408 ) 4 . Foreach ( cid:2267)(cid:3038)(cid:3405)0 5 . ( cid:1851)(cid:3038)(cid:3400)(cid:3019)(cid:1499)(cid:3400)(cid:3022)(cid:1847)(cid:1499)(cid:3400)(cid:1846)(cid:3038)(cid:1499 ) ; 6 . ( cid:1499)(cid:1370)(cid:1499)(cid:2015)(cid:2019)(cid:2871)(cid:1499)(cid:2015)(cid:3435)(cid:1851)(cid:3038)(cid:2267)(cid:3038)(cid:3439)(cid:3400)(cid:3400)(cid:3022)(cid:1847)(cid:1499)(cid:3400)(cid:1846)(cid:3038)(cid:1499 ) ( cid:2015)(cid:2019)(cid:2870)(cid:4666)(cid:1499)(cid:3400)(cid:1832)(cid:1851)(cid:1499)(cid:4667)(cid:3400)(cid:1832 ) ; 7 . ( cid:1847)(cid:1499)(cid:1370)(cid:1847)(cid:1499)(cid:2015)(cid:2019)(cid:2871)(cid:1847)(cid:1499)(cid:2015)(cid:3435)(cid:1851)(cid:3038)(cid:2267)(cid:3038)(cid:3439)(cid:3400)(cid:3400)(cid:3019)(cid:1499)(cid:3400)(cid:1846)(cid:3038)(cid:1499 ) ; 8 . ( cid:1846)(cid:3038)(cid:1499)(cid:1370)(cid:1846)(cid:3038)(cid:1499)(cid:2015)(cid:2019)(cid:2871)(cid:1846)(cid:3038)(cid:1499)(cid:2015)(cid:3435)(cid:1851)(cid:3038)(cid:2267)(cid:3038)(cid:3439)(cid:3400)(cid:3400)(cid:3019)(cid:1499)(cid:3400)(cid:3022)(cid:1847)(cid:1499 ) ( cid:2015)(cid:2019)(cid:4666)(cid:1846)(cid:3038)(cid:1499)(cid:3400)(cid:1833)(cid:1850)(cid:3038)(cid:1499)(cid:4667)(cid:3400)(cid:1833 ) ; 9 . ( cid:1370)(cid:2015)(cid:2019)(cid:2871)(cid:2015)(cid:3435)(cid:1851)(cid:3038)(cid:2267)(cid:3038)(cid:3439)(cid:3400)(cid:1499)(cid:1620)(cid:1847)(cid:1499)(cid:1620)(cid:1846)(cid:3038)(cid:1499 ) ; 10 . ( cid:1833)(cid:1370)(cid:1833)(cid:2015)(cid:2019)(cid:2871)(cid:1833)(cid:2015)(cid:2019)(cid:4666)(cid:1846)(cid:3038)(cid:1499)(cid:3400)(cid:1833)(cid:1850)(cid:3038)(cid:1499)(cid:4667)(cid:3400)(cid:1846)(cid:3038)(cid:1499 ) ; 11 . ( cid:1832)(cid:1370)(cid:1832)(cid:2015)(cid:2019)(cid:2871)(cid:1832)(cid:2015)(cid:2019)(cid:2870)(cid:4666)(cid:1499)(cid:3400)(cid:1832)(cid:1851)(cid:1499)(cid:4667)(cid:3400)(cid:1499 ) ; 12 . Return , ( cid:1847 ) , ( cid:1846 ) ,
Figure 5 . Algorithm for decomposing a tensor
( cid:3031)(cid:3267)(cid:2880 ) tensor outer product ( also called Kronecker product ) ; the entries specifically , we use an element wise optimization algorithm ( instead of batch decomposition ) [ 10 ] , which updates the factors independently ( meaning they can be performed in parallel ) .
The Symbol “ ( cid:3400 ) ” denotes the matrix multiplication ; ( cid:3400)(cid:3019 ) stands for the tensor matrix multiplication , where the subscript stands for the direction , eg , ( cid:1834)(cid:3400)(cid:3019 ) is ( cid:1834)(cid:3038)∑ ( cid:3038)(cid:3400 ) ; ( cid:1620 ) is the of the ( cid:1861 ) th row of matrix are represented as ( cid:1499 ) . More In reality , tensor ( cid:2267 ) is very large , given hundreds of thousands of data of the region . The matrices ( cid:1850 ) and ( cid:1851 ) are built in each smaller to keep these small tensors a similar size . As a result , ( cid:2267 ) is road segments and tens of thousands of drivers . Decomposing such a big tensor is very time consuming , therefore reducing the feasibility of our method in providing online services . To address this issue , as illustrated in Figure 6 , we partition a city into several disjoint regions , building a tensor for each region based on the region accordingly . By setting a proper splitting boundary , we try replaced by a few small tensors , which will be factorized in parallel and more efficiently . We validate ( in later experiments ) that the partition does not compromise the accuracy of the original decomposition when choosing a proper number of partitions . tk tj uM u2 u1 r1 r2 rN g1 g4 g2 g3 g1 g4 g2 g3 then wrote as , concatenation that results in an accurate travel time estimation . Intuitively , the best decomposition is the one that achieves the
, ( 4 ) Hence , our problem is to search for the best concatenation which yields the least empirical risk , formally defined as ,
Figure 6 . Spatial partition for expediting the tensor decomposition 4 . OPTIMAL CONCATENATION ( OC ) 4.1 Objective Function
Given a path ( cid:2172 ) covered by trajectories , we need to find the best lowest empirical risk between the estimate and true travel time ( cid:2020)(cid:2172 ) . Suppose ( cid:2172 ) is decomposed as ( cid:1842)||(cid:1842)(cid:2870)||(cid:1710)||(cid:1842)(cid:3038 ) , where the estimated travel time is ( cid:1191)(cid:3017)(cid:3117)(cid:3397)(cid:1191)(cid:3017)(cid:3118)(cid:3397)(cid:1710)(cid:3397)(cid:1191)(cid:3017)(cid:3286 ) , the squared empirical risk is ( cid:1838)(cid:1831)(cid:2172),(cid:3017)(cid:3117),(cid:3017)(cid:3118),(cid:1710),(cid:3017)(cid:3286)(cid:1564)(cid:1831)(cid:3435)(cid:2020)(cid:2172)(cid:1191)(cid:3017)(cid:3117)(cid:1191)(cid:3017)(cid:3118)(cid:1710)(cid:1191)(cid:3017)(cid:3286)(cid:3439)(cid:2870 ) argmin(cid:3017)(cid:3117),(cid:3017)(cid:3118),(cid:1710),(cid:3017)(cid:3286 ) ( cid:1838)(cid:1831)(cid:2172),(cid:3017)(cid:3117),(cid:3017)(cid:3118),(cid:1710),(cid:3017)(cid:3286 ) , subject to ( cid:1842)||(cid:1842)(cid:2870)||(cid:1710)||(cid:1842)(cid:3038)(cid:2172 ) . ( 5 ) To come up with a computable form of ( cid:1838)(cid:1831)(cid:2172),(cid:3017)(cid:3117),(cid:3017)(cid:3118),(cid:1710),(cid:3017)(cid:3286 ) , we relate ( cid:1838)(cid:1831)(cid:2172),(cid:3017)(cid:3117),(cid:3017)(cid:3118),(cid:1710),(cid:3017)(cid:3286 ) with ( cid:1831)(cid:4666)(cid:2020)(cid:3017)(cid:3284)(cid:1191)(cid:3017)(cid:3284)(cid:4667)(cid:2870 ) , where ( cid:2020)(cid:3017)(cid:3284 ) is the true travel time of sub path ( cid:1842 ) . It is fair to assume if ( cid:2172)(cid:1842)||(cid:1842)(cid:2870)||(cid:1710)||(cid:1842)(cid:3038 ) , then ( cid:2020)(cid:2172)(cid:3017)(cid:3117)(cid:3397)(cid:3017)(cid:3118)(cid:3397)(cid:1710)(cid:3397)(cid:3017)(cid:3286 ) . Hence we have , ( cid:1838)(cid:1831)(cid:2172),(cid:3017)(cid:3117),(cid:3017)(cid:3118),(cid:1710),(cid:3017)(cid:3286)(cid:1831)(cid:3435)(cid:2020)(cid:2172)(cid:1191)(cid:3017)(cid:3117)(cid:1191)(cid:3017)(cid:3118)(cid:1710)(cid:1191)(cid:3017)(cid:3286)(cid:3439)(cid:2870 ) ( cid:1831)(cid:3435)(cid:2020)(cid:3017)(cid:3117)(cid:3397)(cid:2020)(cid:3017)(cid:3118)(cid:3397)(cid:1710)(cid:2020)(cid:3017)(cid:3286)(cid:1191)(cid:3017)(cid:3117)(cid:1191)(cid:3017)(cid:3118)(cid:1710)(cid:1191)(cid:3017)(cid:3286)(cid:3439)(cid:2870 ) ( cid:3397)∑ ∑ ( cid:4666)(cid:2020)(cid:3017)(cid:3284)(cid:1191)(cid:3017)(cid:3284)(cid:4667)(cid:4666)(cid:2020)(cid:3017)(cid:3285)(cid:1191)(cid:3017)(cid:3285)(cid:4667 ) ( cid:1831)(cid:4672)∑ ( cid:3435)(cid:2020)(cid:3017)(cid:3284)(cid:1191)(cid:3017)(cid:3284)(cid:3439)(cid:2870 ) ( cid:4673 ) ( cid:3038)(cid:2880 ) ( cid:3038)(cid:2880 ) ( cid:1831)(cid:4672)(cid:4666)(cid:2020)(cid:3017)(cid:3284)(cid:1191)(cid:3017)(cid:3284)(cid:4667)(cid:4666)(cid:2020)(cid:3017)(cid:3285)(cid:1191)(cid:3017)(cid:3285)(cid:4667)(cid:4673 ) ∑ ( cid:1831)(cid:4666)(cid:2020)(cid:3017)(cid:3284)(cid:1191)(cid:3017)(cid:3284)(cid:4667)(cid:2870 ) ( cid:3397)∑ ∑ ( cid:3038)(cid:2880 ) ( cid:3038)(cid:2880 ) ( cid:3038)(cid:2880 ) If assuming ( cid:1191)(cid:3017)(cid:3284 ) and ( cid:1191)(cid:3017)(cid:3285 ) are independent , we have ( cid:1831)(cid:4672)(cid:4666)(cid:2020)(cid:3017)(cid:3284 ) ( cid:1191)(cid:3017)(cid:3284)(cid:4667)(cid:4666)(cid:2020)(cid:3017)(cid:3285)(cid:1191)(cid:3017)(cid:3285)(cid:4667)(cid:4673)(cid:1831)(cid:3435)(cid:2020)(cid:3017)(cid:3284)(cid:1191)(cid:3017)(cid:3284)(cid:3439)(cid:1831)(cid:4666)(cid:2020)(cid:3017)(cid:3285)(cid:1191)(cid:3017)(cid:3285)(cid:4667)=0 , Therefore ,
( cid:3038)(cid:2880 )
. ( 6 )
( cid:3265)(cid:3284)(cid:2880 )
( cid:1838)(cid:1831)(cid:2172),(cid:3017)(cid:3117),(cid:3017)(cid:3118),(cid:1710),(cid:3017)(cid:3286)∑ ( cid:1831)(cid:4666)(cid:2020)(cid:3017)(cid:3284)(cid:1191)(cid:3017)(cid:3284)(cid:4667)(cid:2870 ) ( cid:3038)(cid:2880 ) Further , ( cid:1831)(cid:4666)(cid:2020)(cid:3017)(cid:3284)(cid:1191)(cid:3017)(cid:3284)(cid:4667)(cid:2870)(cid:1831)(cid:4666)(cid:2020)(cid:3017)(cid:3284 ) ( cid:3265)(cid:3284)∑ ( cid:3017)(cid:3284 ) , ( cid:4667)(cid:2870 ) ( cid:3265)(cid:3284)(cid:2880 ) ( cid:3265)(cid:3284)(cid:3118)∑ ( cid:3265)(cid:3284)(cid:3118)(cid:1831)∑ ( cid:4666)(cid:2020)(cid:3017)(cid:3284)(cid:3017)(cid:3284),(cid:4667)(cid:2870 ) ( cid:1831)(cid:4666)(cid:2020)(cid:3017)(cid:3284)(cid:3017)(cid:3284),(cid:4667)(cid:2870 ) ( cid:3265)(cid:3284)(cid:2880 ) ( cid:3265)(cid:3284)(cid:1848)(cid:1853)(cid:4666)(cid:3017)(cid:3284),(cid:4667 ) , ( 7 ) where ( cid:3017)(cid:3284 ) is the number of drivers passing ( cid:1842 ) , and ( cid:3017)(cid:3284 ) , denotes the th driver ’s travel time on ( cid:1842 ) ; ( cid:1848)(cid:1853)(cid:4666)(cid:3017)(cid:3284),(cid:4667 ) is the variance of argmin(cid:3017)(cid:3117),(cid:3017)(cid:3118),(cid:1710),(cid:3017)(cid:3286 ) ∑ ( cid:3265)(cid:3284)(cid:1848)(cid:1853)(cid:4666)(cid:3017)(cid:3284),(cid:4667 ) ( cid:3038)(cid:2880 ) subject to ( cid:1842)||(cid:1842)(cid:2870)||(cid:1710)||(cid:1842)(cid:3038)(cid:2172 ) ( 8 ) drivers pass a sub path ( ie support is higher , ( cid:3017)(cid:3284 ) is bigger ) , the
Equation 8 well reflects the aforementioned tradeoff between the support and length of a concatenation . On one hand , it is easier to find more drivers traveling a shorter sub path . The more the these drivers’ travel times . Then , Equation 5 can be represented as :
( cid:1859)(cid:3435)(cid:1842)(cid:3439 ) represented as Equation 9 .
Additionally , we have a state transition function as Equation 10 . smaller the error of the inferred travel time is . On the other hand , the shorter a sub path is , the bigger the variance in travel time would be . There are a lot of uncertainties of traveling a short path . Eg , if only traveling one road segment , the travel time will be significantly influenced by a traffic light . As a result , different drivers’ travel times could be dramatically different . 4.2 Dynamic Programing Solution To solve the optimization problem shown in Equation 8 , we propose a dynamic programing solution . Suppose a path ( cid:2172):(cid:1372 ) ( cid:2870)(cid:1372)(cid:1710)(cid:1372 ) , ( cid:1842)(cid:1314)(cid:1372)(cid:2870)(cid:1372)(cid:1710)(cid:1372 ) , ( cid:1861 ) , denote ( cid:1859)(cid:4666)(cid:1842)(cid:4667 ) ( cid:3265)(cid:3284 ) ( cid:1848)(cid:1853)(cid:4666)(cid:3017)(cid:3284),(cid:4667 ) , then the optimization problem of ( cid:1842)(cid:1314 ) can be argmin(cid:3017)(cid:3117),(cid:3017)(cid:3118),(cid:1710),(cid:3017)(cid:3287 ) ∑ ( cid:3039)(cid:2880 ) subject to ( cid:1842)||(cid:1842)(cid:2870)||(cid:1710)||(cid:1842)(cid:3039)(cid:1842)(cid:1314 ) . ( 9 ) Let ( cid:1867)(cid:1868 ) be the minimal value of ( cid:1842)(cid:1314 ) to the above problem , then the minimal value of the squared empirical risk function of ( cid:2172 ) is ( cid:1867)(cid:1868 ) . ( cid:1867)(cid:1868)min(cid:3000)(cid:2996)(cid:4666)(cid:1867)(cid:1868)(cid:3397)(cid:1859)(cid:4666)(cid:1842)(cid:3045)(cid:3284)(cid:3126)(cid:3117)||(cid:3045)(cid:3284)(cid:3126)(cid:3118)(cid:1710)||(cid:3045)(cid:3289)(cid:4667)(cid:4667 ) . ( 10 ) Input : a query path ( cid:2172)(cid:1372)(cid:2870)(cid:1372)(cid:1710)(cid:1372 ) , a collection of trajectory pattern ( cid:1846)(cid:1842)s , a time slot ( cid:1863 ) , trajectories received in ( cid:1863 ) , and tensor ( cid:2267)(cid:3045)(cid:3032)(cid:3030)  Output : Ψ , the most optimal concatenation of path ( cid:2172 ) 1 . ( cid:1867)(cid:1868)(cid:1370)0 , Ψ(cid:1370)(cid:1486 ) ; 2 . For ( cid:1861)1 to do 3 . ( cid:1867)(cid:1868)(cid:1370)(cid:3397)∞ ; Ψ(cid:1486 ) ; 4 . For ( cid:1861 ) down to 1 do 5 . ( cid:1842)(cid:4593)(cid:1372)(cid:1372)(cid:1710)(cid:1372 ) ; ( cid:3017)(cid:4593),,(cid:3038)(cid:1370)0 ; 6 . ( cid:1847)(cid:1370 ) retrieve the drivers traversing ( or partially traversing ) ( cid:1842)(cid:1314 ) from the trajectory database 7 . Foreach ( cid:1488)(cid:1847 ) do 8 . ( cid:3017)(cid:4593),,(cid:3038)(cid:1370 ) 0 ; 9 . Foreach ( cid:3032)(cid:1488 ) ( cid:1842)(cid:1314 ) not traversed by ’s trajectory ( cid:1846 ) 10 . ( cid:3017)(cid:4593),,(cid:3038)(cid:3397)(cid:4666)(cid:2267)(cid:3045)(cid:3032)(cid:3030)(cid:4667)(cid:3045)(cid:3280),,(cid:3038 ) ; 11 . ( cid:3017)(cid:3294)(cid:4593),,(cid:3038)(cid:1370)Calculate the time for the rest of ( cid:1842)(cid:1314 ) based on ( cid:1846 ) ; 12 . ( cid:3017)(cid:4593),,(cid:3038)(cid:3397)(cid:3017)(cid:3294)(cid:4593),,(cid:3038 ) ; 13 . ( cid:1859)(cid:4666)(cid:1842)(cid:1314)(cid:4667 ) |(cid:3022)|(cid:1848)(cid:1853)(cid:1488)(cid:3022)(cid:4666)(cid:3017)(cid:4593),,(cid:3038)(cid:4667 ) ; 14 . If ( cid:1867)(cid:1868)(cid:3397)(cid:1859)(cid:4666)(cid:1842)(cid:1314)(cid:4667)(cid:1867)(cid:1868 ) 15 . ( cid:1867)(cid:1868)(cid:1370)(cid:1867)(cid:1868)(cid:3397)(cid:1859)(cid:4666)(cid:1842)(cid:1314)(cid:4667 ) ; 16 . ( cid:2006)(cid:1370)(cid:2006)||(cid:1842)(cid:1314 ) ; 17 . Return Ψ ;
Algorithm 2 : Query path decomposition
Figure 7 . Algorithm for finding the most optimal concatenation complexity of ( cid:1841)(cid:4666)(cid:2870)(cid:3400)(cid:1865)(cid:4667 ) , where is the number of road segments in ( cid:2172 ) and ( cid:1865 ) is the number of drivers passing a segment .
Using Algorithm 2 shown in Figure 7 , we solve this problem with a
In practice , it is not necessary to check every concatenation of a path , as many sub paths may not be traversed by any trajectory in the current time slot . To further improve the efficiency of our solution , we mine frequent trajectory patterns from historical trajectories the concatenation of the trajectories patterns . Specifically , we can stop the iteration at Line 4 in algorithm 2 if ( cid:1842)(cid:4593 ) is not a trajectory pattern . in advance . Then , we just need to check
We use a suffix tree based algorithm [ 18 ] to find the frequent trajectory patterns . Specifically , after being map matched , a trajectory can be regarded as a string of road segment IDs . By building a suffix tree , where a node denotes a road segment ID , a trajectory is then represented as a path on the tree . For example , the four trajectories shown in Figure 1 can be represented as the tree depicted in Figure 8 A ) , where ( cid:1372)(cid:2870)(cid:1372)(cid:2871 ) is the most left path of the tree . ( cid:2870)(cid:1372)(cid:2871 ) and ( cid:2871 ) are suffixes of ( cid:1372)(cid:2870)(cid:1372)(cid:2871 ) . The support , we find ( cid:1372)(cid:2870 ) , ( cid:2870)(cid:1372)(cid:2871 ) , and ( cid:2871 ) are patterns . In reality , number associated with each link stands for the number of the trajectories passing the path ( ie , the support ) . If setting 2 as a the suffix tree is built based on historical trajectories over a long period of time . As long trajectory patterns are very rare , we set the maximum length of a pattern to 20 road segments .
Root
P : r1→r2→r3→r4
( 1 )
1 r6 r7 tj uM
( 1 )
Patterns : tr3→r4,u2,k = tr3,u2,k+t r4,u2,k tr4,u2,k tr4,u3,k tr4,u4,k
, ( 3 )
, tk
2 r2 2 r3
3
1 r6
1
3 r3 1 r7
1 r5 1 r2 1 r3 r1 2 r2 1 r3 u2 u1 r2→r3 , r3→r4 Tr2,Tr3,Tr4 ( u2 , u3 , u4 )
1 rN r6 r1 r2 ( 3 )
Arec
B ) Filling in the missing time for a pattern
A ) An example of suffix tree Figure 8 . Mining frequent trajectory patterns and used with tensor built based on the trajectory data over a long history ( not the one shown in the left part of Figure 8 A ) , for the trajectory patterns that
Note that a query path may have some road segments that are not traversed by any trajectory in the current time slot , though these segments may belong to a trajectory pattern ( in history ) . Following the example shown in Figure 1 , we demonstrate in Figure 8 B ) how
4.3 Working with Tensor ( cid:2315)(cid:2200)(cid:2187)(cid:2185 ) ( cid:2267)(cid:3045)(cid:3032)(cid:3030 ) is used with trajectory patterns to help the decomposition of a query path . To estimate the travel time of a query path ( cid:1842):(cid:1372)(cid:2870)(cid:1372 ) ( cid:2871)(cid:1372)(cid:2872 ) in time slot ( cid:1863 ) , we first search the suffix tree , which was ( cid:1842 ) contains , eg , ( cid:2870)(cid:1372)(cid:2871 ) and ( cid:2871)(cid:1372)(cid:2872 ) . To calculate ( cid:1859)(cid:4666)(cid:2871)(cid:1372)(cid:2872)(cid:4667 ) driver passing ( cid:2871)(cid:1372)(cid:2872 ) . However , ( cid:2872 ) is not traversed by any trajectory in time slot ( cid:1863 ) . That is ( cid:3045)(cid:3119)(cid:1372)(cid:3045)(cid:3120),,(cid:3038 ) is unknown for every driver , though ( cid:3045)(cid:3119),,(cid:3038 ) can be calculated based on the recently received trajectories , ie ( cid:1846)(cid:2870 ) , ( cid:1846)(cid:2871 ) and ( cid:1846)(cid:2872 ) . To address this issue , we retrieve ( cid:3045)(cid:3120),(cid:3118),(cid:3038 ) , ( cid:3045)(cid:3120),(cid:3119),(cid:3038 ) , and ( cid:3045)(cid:3120),(cid:3120),(cid:3038 ) from ( cid:2267)(cid:3045)(cid:3032)(cid:3030 ) and calculate ( cid:3045)(cid:3119)(cid:1372)(cid:3045)(cid:3120),,(cid:3038 ) for ( cid:4666)(cid:2870),(cid:2871),(cid:2872)(cid:4667 ) , respectively , by Equation 11 . ( cid:3045)(cid:3119)(cid:1372)(cid:3045)(cid:3120),,(cid:3038)(cid:3045)(cid:3119),,(cid:3038)(cid:3397)(cid:3045)(cid:3120),,(cid:3038 ) , ( 11 ) Having ( cid:3045)(cid:3119)(cid:1372)(cid:3045)(cid:3120),,(cid:3038 ) , we can calculate the most optimal concatenation time . The dimension of users in tensor ( cid:2267)(cid:3045 ) enables us to retrieve a according to Equation 9 , 10 and Algorithm 2 . When the supplement of an entry is negative , we resort to the historical average travel defined in Equation 9 , we need to know the travel time of each more accurate travel time for a particular driver , resulting in a better estimate of the variance of travel times ( as Equation 8 ) . We validate that this is more accurate than just using a historical average of calculate the travel time of path ( cid:1842 ) by Equation 1 , setting Ψ as Ψ . travel times . After finding the most optimal concatenation , we
In the implementation , if not building an effective indexing structure , we need to scan a trajectory when calculating the travel time of a path based on the trajectory ( ie , Line 11 of Algorithm 2 ) . This becomes very time consuming if we need to repeat the process many times . To address this issue , we propose an indexing structure to maintain the trajectories received in the current time slot , as shown in Figure 9 . The structure looks like the suffix tree we build for mining trajectory patterns . However , each node in the tree stores the ID of the trajectory that traverses the path from the root to the node and the corresponding travel time . For example , ( cid:1846 ) and ( cid:1846)(cid:2870 ) where ( cid:3045)(cid:3117)(cid:1372)(cid:3045)(cid:3118)(cid:1372)(cid:3045)(cid:3119 ) stands for the time for traveling path ( cid:1372)(cid:2870)(cid:1372)(cid:2871 ) . shown in Figure 1 are stored in the index demonstrated in Figure 9 ,
Root r2 r6 Tr1 r3 r6 tr3
Tr1
Tr1 tr6 tr2→r6 tr1t r1 tr1→r2 tr1→r2
Tr1 Tr2 Tr1 Tr2 r1 r2 r3 Tr2 r6 Tr1 tr1→r2→r3 tr2tr2 t r2→r3
Tr2 Tr2 r3 Tr2 tr1→r2→r6
Figure 9 . Indexing structure for maintaining recent trajectories
5 . EXPERIMENTS In this section , we evaluate the effectiveness and efficiency of the two major parts of PTTE , ie , CATD and OC , respectively . 5.1 Settings 511 Datasets Taxi Trajectories . We use a GPS trajectory dataset generated by 32,670 taxicabs in Beijing from Sept . 1 to Oct . 31 , 2013 . The number of GPS points reaches 673,469,757 , and the total length of the trajectories is over 26,218,407km . The average sampling rate is 96 seconds per point . Road networks : We use the road network of Beijing , which is comprised of 148,110 nodes and 196,307 edges . The road network covers a 40(cid:3400)50km spatial range , with a total length ( of road segments ) ( cid:2267)(cid:3045 ) and ( cid:2267)(cid:3035 ) to model the recent and historical traffic conditions , of 21,985km . POIs : The dataset consists of 273,165 POIs of Beijing , which are classified into 195 tier two categories . We only chose the top 10 categories that occur around road segments most frequently . After projecting the trajectories onto the road network , we build respectively . We set four time slots ( each time slot is 30 minutes ) in the two tensors , as we find 4 have a good tradeoff between effectiveness and efficiency the implementation , we remove the road segments that are traveled less than 50 times in two months ( ie , less than 1 time per entire day ) . The GPS points on such road segments may be noises , or due to the imperfect map matching algorithm or such places cannot be traveled by vehicles ( such as pedestrian streets ) , and therefore may not be really queried by drivers . Finally , 118,401 road segments are used in our models . We also build geographic and temporal contexts ( cid:1850 ) and ( cid:1851 ) based on the above mentioned where the third row means ( cid:2267)(cid:3045 ) is partitioned into 25 sub tensors . datasets . Table 1 shows the statistics of these tensors and matrices ,
( see Figure 12 A ) .
In
As shown in Figure 10 A ) , the maximum number of trajectories traversing a path ( per day ) decreases quickly as the length of the path increases . For instance , a path with 10 road segments is traversed by less than 245 trajectories per day . Figure 10 B ) presents the number road segments traveled by taxis with different times . For example , from 8am to 9am , about 25,000 roads segments are traversed by taxis 1 2 times and 8,000 segments ( about 4 % of Beijing road network ) are traveled 3 4 times .
( cid:2267)(cid:3045 ) ( cid:2267)(cid:3035 ) ( cid:2267)(cid:3045)/(5×5 ) ( cid:1850 ) ( cid:1851 )
Table 1 . Statistics on the data models
Size
118,401×32,670×4 118,401×32,670×4 4,736×12,674×4
8×16
118,401×18
Average non zero entries
0.035 % 0.4 % 0.09 %
1 1
10.0k
8.0k
6.0k
4.0k
2.0k
0.0
) t r o p p u S
( s e i r o j t c e a r T f o
. m u N
. x a M
1 2 3 4 5 6 7 8 >8
50k
40k
30k
20k
10k s t n e m g e S d a o R f o
. m u N
0
10
20
30
40
50
Length of a Path
0
0
4
8
12
16
20
Time of Day
A ) Support of Path Wrt it length B ) Road segments traversed
Figure 10 . Statistics on the trajectory data set
512 Baseline Methods We compare PTTE with the following four baseline methods . 1 ) Speed Constraint based ( SC ) method . The travel time of each road segment is computed by the length of a road segment and its speed constraint . The travel time of a path is then a summation of that of each road segment . 2 ) Trajectory based Simple Concatenation ( TSC ) method . TSC estimates the travel time of each road segment individually based on the trajectories passing the road segment in the most recent time slot . If a road segment is not covered by any recent trajectory , TSC uses the average historical travel time instead . The travel time of a path is then a summation of that of each road segment . 3 ) Optimal Concatenation with Historical Travel Time ( OC+H ) method . OC+H uses Algorithm 2 proposed in this paper to find the most optimal concatenation of trajectories to estimate the travel time of a path . For a road segment not covered by any trajectories , this method uses an average historical travel time of the road segment . 4 ) Optimal Concatenation with Nonnegative Matrix Factorization ( OC+MF ) . This method is similar to OC+H , except for using MF ( rather than historical average ) to infer the travel time of segments without trajectories . MF is applied to the road time matrix , which is degraded from tensor ( cid:2267 ) by averaging the driver dimensions .
Comparing PTTE with the first baseline , we can demonstrate the advantages of using the trajectory data . The second baseline method can reveal the contribution of the proposed optimal concatenation algorithm . Through comparing it with the third and fourth baselines , we can justify why a tensor with the driver dimension is needed in PTTE . Regarding CATD , the first step of PTTE , we study the contribution of using context matrices and historical data , respectively , in filling the missing values of ( cid:2267)(cid:3045 ) .
513 Query Paths and Ground Truth We randomly pick out 50 paths , each of which has been fully traversed by at least two drivers , in each hour of a day , from the taxi trajectory data . We then use these paths as queries and the average travel time of these trajectories as the ground truth . Once a trajectory is selected as a ground truth , we remove them from the training data . In total , we generate 12,384 queries , whose length ranges from 2KM to 16KM following the distribution as shown in Figure 11 B ) and time span follows the distribution depicted in Figure 11 C ) . The total length of these query paths is 76,412.6km with an effective total time span of 27339hours The queries selected in this way cover different times of day ( from 6am to 11pm ) and follow the distance distribution of people ’s true travel patterns in a city ’s road network . In the experiments , we do not study the query after 11pm and earlier than 6am , as there is almost no traffic at those times . In other words , people can travel as fast as the speed constraint of a road . According to Figure 11 A ) , these query paths ( denoted as blue road segments ) also cover the majority of the Beijing road network .
B ) Distribution of the length
A ) Geographical distribution
C ) Distribution of time length
, ( 13 )
, ( 12 )
Figure 11 . Distributions of the query paths
We study the mean absolute error ( MAE ) and mean relative error ( MRE ) of an estimate according to Equation 12 and 13 ,
5.2 Results 521 Performance of CATD To test the accuracy of estimating the travel time of road segments absent of trajectories , we randomly remove 30 % of non zero respectively , where ( cid:1877 ) is an estimate and ( cid:1877)(cid:3114)(cid:3549 ) is the ground truth . ( cid:1839)(cid:1827)(cid:1831)∑|(cid:3052)(cid:3284)(cid:3052)(cid:3362)(cid:3549)| ( cid:3284 ) ( cid:1839)(cid:1831)∑|(cid:3052)(cid:3284)(cid:3052)(cid:3362)(cid:3549)| ( cid:3284)∑(cid:3052)(cid:3362)(cid:3549)(cid:3284 ) entries from the last time slice of tensor ( cid:2267)(cid:3045 ) . We then infer these ( (cid:2019)=(cid:2019)(cid:2870)=(cid:2019)(cid:2871)= 001 ) RMSE is widely used to measure the error of a ( cid:1839)(cid:1831)(cid:3495)∑(cid:4666)(cid:3052)(cid:3284)(cid:3052)(cid:3362)(cid:3549)(cid:4667)(cid:3118 ) ( cid:3284 ) Adding historical trajectories ( ie , ( cid:2267)(cid:3035 ) ) and context matrices entries with our method , using their original values as a ground truth to calculate MAE and RMSE , as shown in Table 2 tensor decomposition , defined as Equation 14 . gradually into the tensor decomposition , denoted as TD+H and TD+H+C , increase of performance in estimating the missing values . respectively , we achieve a clear
; ( 14 )
Table 2 . The performance of CATD
( cid:1846)(cid:1830 ) ( cid:1846)(cid:1830)(cid:3397)(cid:1834 ) ( cid:1829)(cid:1827)(cid:1846)(cid:1830 ) ( cid:4666)(cid:1846)(cid:1830)(cid:3397)(cid:1834)(cid:3397)(cid:1829)(cid:4667 )
MAE ( min )
0.747 0.732 0.714
RMSE 1.646 1.629 1.613 more time slices into ( cid:2267)(cid:3045 ) and ( cid:2267)(cid:3035 ) achieves a more accurate
We further study the effectiveness and efficiency of CATD changing over the number of time slices in Figure 12 A ) . Adding estimate of missing values ( ie , the travel time of road segments without trajectories ) , as we have richer information of previous traffic conditions . On the other hand , more time slices consume a longer time . We find that formulating a tensor with 4 time slices is a relatively strong tradeoff between effectiveness and efficiency .
0.74
0.73
0.72
0.71
0.70
) n m i
(
E A M
MAE Time Cost
300
250
200
150
100
50
) e t u n m i
( t s o C e m T i
1.0
0.9
0.8
0.7
0.6
) n m i
(
E A M
MAE ( min ) Time cost ( min )
180
160
140
120
100
80
60
40
20
0
) n m i
( t s o c e m T i
0
0.5
4
3
2
Number of time slices L
1 5 The number of partitions ( hxh ) A ) Wrt time slices B ) wrt partitions
5
2
3
4
Figure 12 . Performance of CATD
However , the time cost for decomposing such big tensors and matrices ( see Table 1 ) makes our method impractical for answering instant queries . As a consequence , we partition a city into disjointed regions , building individual tensors and matrices , separately and in parallel . Figure 12 B ) shows the performance changing over the number of partitions . When dividing Beijing into 5(cid:3400)5 regions , we can finish CATD for each region in 6 minutes . The partition does not compromise the accuracy ( only a 0.1min gap ) as compared to decomposing the original tensors . Additionally , the tensor decomposition method we adopt can be performed in parallel , further reducing the time cost of CATD . 522 Overall Performance Table 3 presents the overall performance of our model PTTE ( ie , CATD+OC ) and baseline methods . Besides MAE and MRE , we also present the average error of travel time per km ( MAE/L ) . For example , the average error of PTTE in estimating the travel time of a path is about 0.412min ( 25 seconds ) per kilometer . Clearly , PTTE outperforms all the baselines in terms of the three metrics . Given the queries introduced in Section 513 , on average , the absolute error of the estimated travel time is about 2 minutes per path , which is about 19 % of the true travel time . From the results , we can draw the following conclusions . First , using trajectory data ( TSC ) is much better than that only based on speed constraints of roads . But , simply concatenating the travel time of each individual road segment ( TSC ) is not an optimal solution . As we mentioned before , the more fragments involved in a concatenation , the more uncertain of travel time for crossing two consecutive fragments occurs is . Second , regarding estimating the travel time of road segments without covered by trajectories , using the historical average travel time ( OC+H ) is significantly better than using its speed constraint . Using a collaborative filtering model ( OC+MF ) is slightly better than using an historical average . The PTTE considering the driver dimension is even better than OC+MF .
( cid:1829 ) ( cid:1846)(cid:1829 ) ( cid:1841)(cid:1829)(cid:3397)(cid:1834 ) ( cid:1841)(cid:1829)(cid:3397)(cid:1839)(cid:1832 ) ( cid:2172)(cid:2176)(cid:2176)(cid:2161 )
Table 3 . Comparison of different methods
MAE ( min )
8.808 5.244 3.245 3.061 2.545
MRE 0.665 0.396 0.245 0.231 0.192
MAE/L ( min/km )
1.428 0.850 0.526 0.496 0.412
Figures 13 and 14 present the performance of SC , TSC , and PTTE changing over time of day , on weekdays and weekends . We do not show that of OC+H and OC+MF , as they almost follow the same trend as ( but worse than ) PTTE . As depicted in Figure 11 , the error of SC increases tremendously during peak traffic hours , around 8 9am and 6 7pm . The complex traffic conditions on roads at these moments deviate the true travel speed far from their speed constraints . When time goes to late night ( ie , no complex traffic conditions anymore ) , the error decreases and approaches our PTTE method . This is also the reason that we do not need to perform PTTE on late night time sets , especially after 12am and before 6am . Simply estimating the travel time for each individual road segment and then doing a summation ( TSC ) is not accurate enough . When there are not enough taxis traveling on Beijing ’s road network , eg , after 9pm and before 8am , MAE of TSC is higher than other time slots . With the help of CATD , the MAE of our method only increases slightly after 9am . This demonstrates the value of inferring the missing values .
12
8
4
E A M
SC TSC PTTE
6
8
10
12
14 16 Time of day
18
20
22
24
Figure 13 . Performance changing over time of day ( Weekday )
As most people do not drive to work on weekends , we observe different trends of the performance in Figure 14 , in contrast to Figure 13 . SC ’s MAE reaches its peak around 6pm which is the weekend rush hour . The reason why PTTE has the biggest error around 9am on weekends is a tradeoff between the number of taxis and the complexity of traffic conditions in a road network . On weekends , the number of taxis traveling in Beijing ’s road network is still very small at 9am , while the traffic conditions start becoming complex . As time goes by , more taxis are present on Beijing ’s road network , alleviating the data sparsity problem and decreasing traffic condition is still very simple to predict on roads . The travel speed is almost close to the speed limit . the MAE . Conversely , before 8am , the
SC TSC PTTE
14
12
10
8
6
4
2
E A M
6
8
10
12
Figure 14 . Performance changing over time of day ( Weekend )
16 14 Time of day
18
20
22
24
Figure 15 shows the performance of PTTE changing over the length of a query path . As the length increases , both MAE and MRE decrease . A longer path is more likely to contain more trajectory patterns , which provide more choices for an optimal concatenation . This also echoes the assumption we proposed in the introduction . The shorter a sub path is the more unstable its travel time could be . In an extreme case , the travel time of a single road segment is terrifically impacted by traffic lights and pedestrians crossing it . So , the travel time varies in time quickly and tremendously , becoming hard to predict .
5.0 4.5 4.0 3.5 3.0 2.5 2.0 1.5 1.0
E A M
2
4
MAE MRE
0.4
0.3
0.2
0.1
E R M
12
14
Figure 15 . Performance of PTTE changing over the length of a path
8
6 10 Length of a Path
Table 4 presents the time and space cost of PTTE ’s two major components for processing the trajectories received in recent 30 minutes . The first component CATD is only performed once for the entire dataset , while OC is conducted for each query path . All numbers are obtained by only using a single core of a server with 2.80GHz Xeon CPU and 24GB RAM . For example , if we partition a city into 25 regions , building ( cid:2267)(cid:3045 ) and ( cid:2267)(cid:3035 ) for an individual region matrices ( cid:1850 ) and ( cid:1851 ) needs about 6.31min for each region . We do not list the time for building matrix ( cid:1851 ) , as it is static and can be built needs 44 and 233 seconds , respectively , costing 4.4MB and 14.6 MB of memory , respectively ( each tensor contains 4 time slices ) . Using Algorithm 1 to decompose these tensors with context offline . In total , we can infer the travel time on each road segment for each particular driver within 6.4min if using 25 cores in a server . Note that Algorithm 1 is based on an entry wised decomposition approach , which can be performed in parallel further . If using six 25 core servers , we can finish CATD in about 1 minute . In the optimal concatenation , we can process a query path in 23ms However , the time is much longer if the trajectory patterns and the real time indexing structure proposed in Figure 9 are not used .
Table 4 . Time and memory cost for each step of PTTE
Components
Building matrix ( cid:1850 ) , ( cid:1851 ) ( cid:2267)(cid:3045 ) ( cid:2267)(cid:3035 )
Tensor construction Decomposition Total Best OC
5×5 w/o trajectory patterns w/o index
Deal with missing values
( (cid:1829)(cid:1827)(cid:1846)(cid:1830 ) )
Optimal Concatenat ion ( OC )
Time 34ms 44ms 233ms 6.31min 6.4min 2.3ms 8.6ms 12.2s
Memory ( MB )
9 4.4 14.6 116 144 995 877 714
Figure 16 A ) shows the tradeoff between effectiveness ( measured by MAE ) and efficiency ( by time cost ) of using trajectory patterns in optimal concatenations , where the horizontal axis denotes the threshold of support . For example , if setting 400 as a threshold , we regard a path as a trajectory pattern if the path has been covered by over 400 trajectories in the two month dataset . The bigger threshold is the smaller number of trajectory patterns we can obtain . So , the time cost decreases and the MAE increases , as the support increases . Additionally , as depicted in Figure 16 B ) , setting a smaller support threshold leads to a bigger size of the suffix treebased index for trajectory pattern mining . In the implementation , we find 500 is a good tradeoff among MAE , time cost , and index size . Note that without using the indexing structure proposed in Section 4.3 , we need about 12 seconds to find the most optimal concatenation for a query path ( see Table 4 ) .
) s m
( y r e u Q e m T
/ i
9 8 7 6 5 4 3 2 1
Time/Query ( ms ) MAE
3.0
2.8
2.6
E A M
2.4
2.2
)
B M
( x e d n
I f o e z S i
800
700
600
500
400
300
200
100
0
2.0
0
0
200
400
800
1000
200
800
400
1000
600 Support
600 Support
A ) Time cost and MAE wrt support B ) Size of the index wrt support Figure 16 . Performance of OC wrt support of a trajectory pattern
The recovered tensor ( cid:2267)(cid:3045)(cid:3032)(cid:3030 ) helps the optimal concatenation When processing the query paths , we access tensor ( cid:2267)(cid:3045)(cid:3032)(cid:3030 ) 1,706,648 significantly . In the experiments , we test our model with 12,384 query paths , which are comprised of 217,326 road segments in total . times ( ie , 137.8 times per query ) to retrieve the missing travel time of a road segment in a trajectory pattern . The travel times of 58,223 paths ) are finally retrieved from ( cid:2267)(cid:3045)(cid:3032)(cid:3030 ) for constructing the most road segments ( about 26.8 % of the road segments in the query optimal concatenation , ie , 4.7 road segments per path . We study the performance of PTTE changing over different number of vehicles in Figure 17 , aiming to figure out how many GPS equipped vehicles are needed to have accurate results . For example , using 30,000 GPS equipped vehicles in Beijing is enough to achieving a MRE smaller than 023 In other words , if having 1.36 vehicles on every kilometer road in a city , we can achieve a relative error of estimation smaller than 023
5.0
4.5
4.0
3.5
3.0
2.5
E A M
MAE MRE
0.35
0.30
0.25
0.20
E R M
5000
10000
15000
20000
25000
30000
35000
Figure 17 . Performance wrt the number of taxis
Number of Vehicles
523 Field Study Besides using GPS trajectories from taxi drivers , we also send two drivers carrying a GPS logger to test the accuracy of our method from Sept . 1 to Oct . 30 . Finally , we collect 114 driving paths with a total length of 999.4km and an effective total time period of 616hours The sampling rate of these GPS trajectories is 5 seconds per point . Table 5 shows the performance of the study , where we observe a better MRE than using taxi drivers’ trajectories as a ground truth . The major reason is the length of a path collected in the study is usually long ( on average 8.78KM each ) , where our model has a better accuracy than a shorter path . Additionally , the map matching for high sampling rate trajectories is more accurate than low sampling rate taxi trajectories , resulting in a more accurate estimation of the ground truth .
( cid:1829 ) ( cid:1846)(cid:1829 ) ( cid:1841)(cid:1829)(cid:3397)(cid:1834 ) ( cid:1841)(cid:1829)(cid:3397)(cid:1839)(cid:1832 ) ( cid:2172)(cid:2176)(cid:2176)(cid:2161 )
Table 5 . Performance of the in the field study
MAE ( min )
18.193 11.300 4.990 4.052 3.771
MRE 0.561 0.349 0.154 0.125 0.116
MAE/L ( min/km )
2.075 1.289 0.569 0.462 0.430
6 . RELATED WORK 6.1 Road Segment Based Travel Time Approaches using Loop Detectors : Estimating travel time based on loop detectors installed on both endpoints of a road segment has been studied intensively over the past few decades . When a vehicle passes through , the time interval for crossing two adjacent loop detectors is recorded , based on which the speed of the vehicle is inferred . [ 9 , 14 , 16 ] use various models to estimate the travel speed on an individual road segment based on the sensor readings from loop detectors , and then convert the speed into a travel time . [ 19 ] predicts the travel time of a road segment by applying support vector regression to its historical travel times . As many roads do not have a loop detector buried , this category of research mainly focuses on individual road segments , and therefore is difficult to scale up to an entire city . Floating Car Data Approaches : Learning city transportation using floating car data has gained more attention recently [ 1 , 5 , 17 , 23 , 24 ] . In these approaches , cars driven in a city serve as dynamic sensors to probe traffic conditions , and their GPS trajectories are used to compute the speed and travel time on road segments . Most methods infer the travel time of an individual road segment without considering the correlation between the traffic conditions on different roads . This reduces the accuracy of an inference in an urban environment where traffic conditions are inter related . Some models [ 2 ] predict the travel speed of a road segment by considering the traffic patterns of other road segments connected to it . Unfortunately , when scaling up to an entire city , these methods often result in a model with high complexities . Additionally , they do not tackle the data sparsity problem , ie many road segments are not traveled by trajectories in the current time slot , which is quite common in reality . The neighboring segments’ traffic patterns can be regarded as the local correlation between road segments . However , the correlation between road segments that are not geospatially connected is not considered in these modes . [ 8 ] aims to estimate the travel time between two points on a road network using low sampling rate trajectory data . It considers the correlation between different road segments in terms of their historical traffic patterns to infer the travel time on a road segment and the delay at intersections . The model is trained using a Maximum Likelihood Estimation over the collected data in an urban road network . However , these methods still follow the idea of first estimating the travel time of individual road segments and then summing up the travel times of the road segments belonging to a path . As we mentioned before , it is difficult to explicitly model the complex factors for crossing two road segments , eg , intersections , direction turns , and traffic lights . Though we also infer the travel time for individual segments , the time is combined with trajectory patterns to formulate a sub path rather than simply concatenating them one by one . The variance of different users’ travel times also captures the complexity of traffic conditions on a road segment or a sub path . In the meantime , when inferring the travel time of a road segment , we incorporate both spatial correlation between different road segments and the temporal correlation between the traffic conditions of different time slots , as well as the deviation between current traffic conditions and historical traffic patterns . 6.2 Path Based Travel Time A possible approach to deal with the weakness of the individual road segment based methods is to estimate the travel time of a path as a whole based on frequent trajectory patterns . For example , we can mine frequent patterns from historical trajectories [ 6 , 7 , 12 ] in advance , and then use the average travel time of a pattern to represent the travel of the path corresponding to the pattern . Some models can also be built based on the historical data of a path [ 15 ] to estimate the future travel time of the path . This approach needs a balance between the coverage of queries that it can answer and the accuracy of the inferred travel time . To be able to answer various query paths , these methods need to select more trajectory patterns by using a small support . However , the travel time derived from a small support is not accurate . Additionally , a path ’s travel time of its historical average current significantly , depending on traffic conditions . Moreover , many query paths may not be traversed by any trajectories in current time slot as well in the history . Recent research has started finding more optimal concatenations of road segments to estimate the travel time of a path . A series of research attempts to explicitly calculate the time spent on intersections using an interpolation method [ 11 ] , or a joint probability model [ 3 ] , or a dynamic Bayesian network [ 4 ] . This could result in a more accurate summation of individual road segments’ travel times . However , these methods do not study how time slot may deviate from the real time to leverage sub trajectories to construct an optimal estimation of a path . As we mentioned before , the accuracy of estimating a subpath ’s travel time is subject to the tradeoff between its length and the number of trajectories passing the sub path . In our model , we propose and prove an objective function that can represent the tradeoff . We also consider the variance of different drivers’ travel times , resulting in a more accurate travel time estimation of a path . Based on the trajectories generated by a large number of taxis , [ 20 ] builds a landmark graph , where a node ( entitled a landmark ) is a road segment frequently traveled by taxis and an edge denotes the aggregation of taxis’ commutes between two landmarks . The travel time of a path is then approximated by the summation of the travel times between landmarks . Though the proposed landmark graph can also deal with the data sparsity problem , the main goal of [ 20 ] is to find the quickest driving path between an origin and a destination ; this is different from our problem . Knowing the shortest time for traveling between two points does not mean we can obtain the travel time of any path traversing the two points . 7 . CONCLUSION In this paper , we propose a real time and citywide model , called PTTE , to estimate the travel time of a path in current time slot in a city ’s road network , using the GPS trajectories from a sample of vehicles ( eg taxicabs ) . Though this is a very important foundation for many traffic monitoring and routing systems , the problem has not been well solved given three challenges : 1 ) data sparsity , 2 ) finding an optimal combination of trajectories ( ie , the tradeoff between the length of a sub path and the number of trajectories passing the sub path ) , and 3 ) the tradeoff between scalability , effectiveness and efficiency . PTTE is comprised of two major components , CATD and OC . The former infers the travel time of a road segment without being traversed by trajectories in the current time slot through a context aware tensor decomposition approach . The the most optimal concatenation of trajectories for a query path using a dynamic programing solution . We evaluate PTTE with extensive experiments based on GPS trajectories generated by over 32,000 taxicabs over a period of two months in Beijing . We test the effectiveness and efficiency of CATD and OC , respectively . First , the results demonstrate the advantages of CATD in accurately filling in the missing values beyond baseline methods , such as using speed constraints , or using a historical average travel time , or using a matrix factorization based approach . The driver dimension in tensor ( cid:2267)(cid:3045 ) helps us latter searches for calculate the variance of different drivers’ travel times on a road segment . The variance indicates the complexity of a road ’s traffic condition , helping us find the most optimal concatenation for a path . In addition , the geospatial/temporal contexts and historical traffic patterns increase the accuracy of estimating the missing values . Regarding the most optimal concatenation , we devise an objective function which has been proved to be able to model the tradeoff between a sub path ’s length and the number of trajectories passing it . Tested by 12,384 query paths , PTTE achieves a mean absolute error of 0.4min per km , which is about 19 % of the truth travel time . The results of the in the field study have an even smaller estimation error ( 116 % ) Using the suffix tree based indexing structure to manage the trajectories received currently and the trajectory patterns ( mined in advance ) to scale down the concatenation candidates , on average , we are able to infer the travel time of a path in 23ms The codes and a sample of the data used here have been released at [ 25 ] . In the future , we plan to infer the travel time of a path for a particular driver . In addition , we would like to study the impact of other factors , such as weather conditions and air quality , on the travel time estimation of a path .
8 . REFERENCES [ 1 ] S . Chawla , Y . Zheng , J . Hu . 2012 . Inferring the Root Cause in Road
Traffic Anomalies . In Proc . of IEEE ICDM 2012 .
[ 2 ] C . De Fabritiis , R . Ragona , G . Valenti . 2008 . Traffic estimation and prediction based on real time floating car data . In Proc . of IEEE ITSC 2008 .
[ 3 ] A . Hofleitner , A . Bayen . 2011 . Optimal decomposition of travel times measured by probe vehicles using a statistical traffic flow model . In Proc . of IEEE ITSC 2011 .
[ 4 ] A . Hofleitner , R . Herring , P . Abbeel , A . Bayen . 2012 . Learning the dynamics of arterial traffic from probe data using a dynamic Bayesian network . IEEE Trans . on Intelligent Transportation Systems , 13(4 ) , 1679 1693 .
[ 5 ] B . Hull , V . Bychkovsky , Y . Zhang , K . Chen , M . Goraczko , A . Miu , E .
Shih , H . Balakrishnan , S . Madden . 2006 . CarTel : a distributed mobile sensor computing system . In Proc . of ACM Sensys 2006 .
[ 6 ] J . Han , M . Kamber , J . Pei . 2006 . Data mining : concepts and techniques . Morgan kaufmann .
[ 7 ] J . Han , J . Pei , Y . Yin . 2000 . Mining frequent patterns without candidate generation . ACM SIGMOD Record , 29(2 ) , 1 12 .
[ 8 ] E . Jenelius , H . N . Koutsopoulos . 2013 . Travel time estimation for urban road networks using low frequency probe vehicle data . Transportation Research Part B : Methodological , 53 , 64 81 .
[ 9 ] Z . Jia , C . Chen , B . Coifman , P . Varaiya . 2001 . The PeMS algorithms for accurate , real time estimates of g factors and speeds from singleloop detectors . IEEE Trans . on Intelligent Transportation Systems .
[ 10 ] A . Karatzoglou , X . Amatriain , L . Baltrunas , N . Oliver . 2010 .
Multiverse recommendation : n dimensional tensor factorization for context aware collaborative filtering . In Proc . of ACM Recsys 2010 . [ 11 ] T . V . Larsen . Travel Time Estimation in Road Networks Using GPS
Data . White paper .
[ 12 ] W . Luo , H . Tan , L . Chen , L . M . Ni . 2013 . Finding time period based most frequent path in big trajectory data . In Proc . of ACM SIGMOD 2013 .
[ 13 ] S . Ma , Y . Zheng , O . Wolfson . 2013 . T share : A large scale dynamic taxi ridesharing service . In Proc . of IEEE ICDE 2013 .
[ 14 ] K . F . Pettya , P . Bickelb , J . Jiangc , M . Ostlandb , J . Riceb , Y . Ritovd ,
F . Schoenbergb . 1998 . Accurate estimation of travel times from single loop detectors . Transportation Research Part A : Policy and Practice , 32(1 ) , 1 17 .
[ 15 ] M . Rahmani , E . Jenelius , H . N . Koutsopoulos . 2013 . Route travel time estimation using low frequency floating car data . In Proc . of IEEE ITSC 2013 .
[ 16 ] J . Rice , E . Van Zwet . 2004 . A simple and effective method for predicting travel times on freeways . IEEE Trans . on Intelligent Transportation Systems , 5(3 ) , 200 207 .
[ 17 ] R . Sevlian , R . Rajagopal . 2010 . Travel Time Estimation Using
Floating Car Data . arXiv preprint arXiv:10124249
[ 18 ] R . Song , W . Sun , B . Zheng , Y . Zheng , C . Tu , S . Li . 2014 . PRESS : A Novel Framework of Trajectory Compression in Road Networks . In Proc . of VLDB 2014 .
[ 19 ] C . H . Wu , J . M . Ho , D . T . Lee . 2004 . Travel time prediction with support vector regression . IEEE Trans . on Intelligent Transportation Systems , 5(4 ) , 276 281 .
[ 20 ] J . Yuan , Y . Zheng , C . Zhang , W . Xie , X . Xie , G . Sun , Y . Huang . 2010 . T Drive : Driving Directions Based on Taxi Trajectories . In Proc . of ACM SIGSPATIAL 2010 .
[ 21 ] J . Yuan , Y . Zheng , C . Zhang , X . Xie , G . Sun . 2010 . An interactive voting based map matching algorithm . In Proc . of IEEE MDM 2010 .
[ 22 ] N . J . Yuan , Y . Zheng , L . Zhang , X . Xie . 2013 . T finder : A recommender system for finding passengers and vacant taxis . IEEE Trans . on Knowledge and Data Engineering , 25(10 ) , 2390 2403 . [ 23 ] Y . Zheng , Y . Chen , Q . Li , X . Xie , W . Y . Ma . 2010 . Understanding transportation modes based on GPS data for web applications . ACM Trans . on the Web , 4(1 ) , 1 .
[ 24 ] Zheng , Y . , Capra , Li , Wolfson , O . , Yang , H . 2014 . Urban computing : concepts , methodologies , and applications . ACM Trans . on Intelligent systems and Technology , 5(3 ) .
[ 25 ] Data released : http://researchmicrosoftcom/apps/pubs/?id=217493
