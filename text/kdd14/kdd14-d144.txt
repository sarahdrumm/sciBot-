User Effort Minimization Through Adaptive Diversification
Mahbub Hasan
Abhijith Kashyap
Vagelis Hristidis
Vassilis Tsotras
Computer Science and Engineering , UC Riverside {hasanm , akash001 , vagelis , tsotras}@csucredu
ABSTRACT Ambiguous queries , which are typical on search engines and recommendation systems , often return a large number of results from multiple interpretations . Given that many users often perform their searches on limited size screens ( eg mobile phones ) , an important problem is which results to display first . Recent work has suggested displaying a set of results ( Top k ) based on their relevance score with respect to the query and their diversity with respect to each other . However , previous works balance relevance and diversity mostly by a predefined fixed way . In this paper , we show that for different search tasks there is a different ideal balance of relevance and diversity . We propose a principled method for adaptive diversification of query results that minimizes the user effort to find the desired results , by dynamically balancing the relevance and diversity at each query step ( eg when refining the query or viewing the next page of results ) . We introduce a navigation cost model as a means to estimate the effort required to navigate the queryresults , and show that the problem of estimating the ideal amount of diversification at each step is NP Hard . We propose an efficient approximate algorithm to select a near optimal subset of the query results that minimizes the expected user effort . Finally we demonstrate the efficacy and efficiency of our solution in minimizing user effort , compared to state of the art ranking methods , by means of an extensive experimental evaluation and a comprehensive user study on Amazon Mechanical Turk .
Categories and Subject Descriptors H2m [ Database Management ] : Miscellaneous
Keywords Diversity ; User Effort Minimization ; Mobile Applications
1 . INTRODUCTION Now a days mobile devices have become increasingly popular for searching . The majority of ecommerce sales are currently performed through smartphones or tablets , and specifically about 35 % exclusively through smartphones [ 27 ] . Keywordbased interfaces have been widely adopted as the preferred query method because intuitive . Nevertheless , keyword queries are often ambiguous , that is , they they are simple and have multiple interpretations , and consequently generate many results . As an example , consider the query “ memory ” which might refer to computer memory ( RAM , ROM , Flash etc . ) or the song Memory from the acclaimed musical Cats . For such ambiguous queries , a ranking that considers only relevance ( eg , [ 8 ] ) might return a large number of similar results from just one interpretation of the query , eg DDR3 RAM , and a user with different search intent ( say music ) might not find any result that is relevant to her in the first page ( Top k ) of the results .
To deal with query ambiguity , recently several search applications have incorporated diversification while ranking results to improve the user experience . Examples of such applications include web search [ 4][6 ] , recommendation systems [ 9][18][19][20 ] , semi structured databases [ 23 ] , graph search [ 2 ] , and document summarization [ 15 ] . A diversified ranking includes not only relevant ( as judged by the underlying ranking function ) results , but also results that may be less relevant and are diverse with respect to other results in the ranked list . By covering results from multiple interpretations of a query , diversified ranking thereby increases the probability of the user finding desired results based on her query intent [ 1 ] . Of course , just focusing on diversity and displaying the set of most diverse results is ineffective since some of these results may have low relevance . In its most general form , the problem of query result diversification is modeled as a bi criteria optimization problem [ 1][5 ] , which uses a trade off parameter ( to tune the relative effect of relevance and diversity factors during ranking . Using , the impact of the diversity factor can be increased for highly ambiguous queries so as to include more diverse elements in the result set ; whereas for very specific ( non ambiguous ) queries , this factor can be decreased to prevent inclusion of results of lesser relevance .
As an example , consider Figure 1a which depicts the result set returned for the query „Camera‟ ( on a structured dataset like Amazoncom ) As seen in the figure , the result set includes products from several categories including DSLR , Compact cameras and Accessories . Each result has a set of features ( eg Brand , Megapixel , Zoom etc ) Note that the Lenses of DSLR cameras are considered in the Accessory category , therefore DSLR cameras do not have a Zoom feature . Since there is a limited paginated interface available to the user for displaying the results ( mobile screen size etc. ) , Figures 1b 1d show the Top 3 results ( first page ) selected by varying the trade off parameter between diversity and relevance . Note that the relevance ranking in this example assigns a higher score to DSLRs . For a user shopping for DSLR cameras , the ranking shown in Figure 1b , which prefers relevance over diversity , might be sufficient . However , a user looking for a camera Lens would prefer the highly diversified ranking shown in Figure 1d , where she could click on the Lens attribute value for attribute Type in the Accessory category to see more camera lenses .
Figure 1 : A subset of results of the query Camera and associated ranked list of results
Note that , for a given query , the user navigation cost ( the user “ effort ” or actions required to find the desired results ) varies for different choices of the trade off parameter ( see Figure 2 , for the query “ Camera ” using the MMR algorithm [ 10 ] to implement diversified ranking ) . Moreover , in Section 5 ( Figure 7 ) , we show experimentally , that the best value of the trade off parameter varies for different queries . However , no previous work addresses the problem of computing a trade off parameter that will minimize the user effort . Instead , many hard code it to a reasonable value ( fixing the relative weight between relevance and diversity ) . Recently , several methods have been proposed [ 4][16 ] to learn the trade off parameter . Unfortunately , these methods depend on training data provided by the experts which are expensive to collect or might not be available . Further , they compute a single trade off parameter for a query , whereas we show how this trade off changes as the query refinement or results viewing progress .
Because of the display interface , finding the desired result to a particular query might involve several steps . If the user does not find her desired result on the first page , then she might take additional actions to find the result , such as : ( a ) scan additional pages looking for the results of interest , or , ( b ) refine the query by clicking on a displayed attribute value to focus on a subset of the original results . Our goal in this paper is to compute at each step a set of k results ( corresponding to a page in the user‟s interface ) that dynamically balances diversity and relevance such that the expected user navigation cost is minimized .
Figure 2 : Navigation Cost vs . for Query Camera
What makes the problem difficult is that when the query is posed , neither the target result nor the sequence of actions the user will execute to find it , are known . Therefore , to compute the best set of results to display at each step , we must probabilistically consider all the unknown future user actions , which is a key challenge of our solution . For example , if the user poses the ( highly ambiguous ) query Camera while her target object is Lens , she will need further actions if we provide the results in Figure 1b ( high relevance ) in the first page . A higher diversified result set ( like the one in Figure 1d ) would have been more appropriate . If instead , a more specific query is posed , like DSLR Camera , then higher relevance and lower diversity is preferable , because the user may ( with high probability ) satisfy her search with just one page . Note that this dynamic balancing of relevance versus diversity can also occur , within the subsequent navigation steps of the same query , as it is progressively refined by the user ( eg after posing the Camera query and getting the results in Figure 1d , a user interested in lens might refine by selecting the condition Type : Lens ) .
To this end , we propose a user navigation model that considers factors such as the characteristics of the query result , the user‟s familiarity with various refine conditions , the number of pages the user would have to navigate and the expected number of navigation steps required to reach a result of interest . The resulting model is adaptive to user actions and constructs a diversified result that minimizes the expected user effort . This is in contrast to the fixed diversity vs . relevance trade off achieved by previous techniques , which leads to a much higher navigation cost , as shown in our experiments . In summary , we make the following contributions :
1 . A user navigation cost model that captures the actions of a user navigating a result set ( Section 2 ) .
2 . The cost model is necessarily probabilistic since it computes the cost based on possible future actions taken by the user while navigating a result set . We propose ways of estimating the expected cost in Section 3 .
3 . We show that the problem of computing the best set of results to minimize the expected user effort is NP hard and propose efficient approximate algorithms to compute an appropriately balanced diversified result set that minimizes the expected user navigation cost ( Section 4 ) .
4 . We present the results of an extensive experimental evaluation of the proposed techniques compared to state ofthe art ranking methods using two real datasets ( Section 5 ) .
5 . We validate our cost model and measure user navigation time with a user study at Amazon Mechanical Turk , which
00102030405060708091320330340350360370380390400410Trade off Parameter ( λ)Navigation CostIDProductCategoryFeaturesRel1CameraDSLRBrand : CanonMegapixel : 180092CameraDSLRBrand:NikonMegapixel : 160083CameraDSLRBrand : CanonMegapixel : 140074CameraDSLRBrand : NikonMegapixel : 120065CameraDSLRBrand : SonyMegapixel : 120066CameraCompactBrand:PanasonicZoom : 7x0.6Megapixel : 14.07CameraCompactBrand:PanasonicZoom : 5x0.6Megapixel : 16.08CameraCompactBrand:FujifilmZoom : 5x0.4Megapixel : 12.29CameraCompactBrand:KodakZoom : 3x0.2Megapixel : 10.010CameraAccessoryType : LensFocal Length : 18 –55 mm0.311CameraAccessoryType : LensFocal Length : 55 –300 mm0.2IDProductCategoryFeaturesRel1CameraDSLRBrand : CanonMegapixel : 180092CameraDSLRBrand:NikonMegapixel : 160083CameraDSLRBrand : CanonMegapixel : 14007IDProductCategoryFeaturesRel1CameraDSLRBrand : CanonMegapixel : 180092CameraDSLRBrand:NikonMegapixel : 160086CameraCompactBrand:PanasonicZoom : 7x0.6Megapixel : 14.0IDProductCategoryFeaturesRel1CameraDSLRBrand : CanonMegapixel : 180096CameraCompactBrand:PanasonicZoom : 7x0.6Megapixel : 14.010CameraAccessoryType : LensFocal Length : 18 –55 mm0.3(b ) High Relevance and Low Diversity(c ) Moderate Relevance and Moderate Diversity(d ) Low Relevance and High Diversity(a ) Result Set shows that our methods outperform the state of the art ( Section 6 ) . difficulty in selecting a value of for a given navigation step of a query .
Related work is discussed in Section 7 and we conclude in Section 8 .
2 . PROBLEM DEFINITION We proceed with the problem setting ( Section 2.1 ) , and describe our navigation cost model ( Section 2.2 ) , which mimics the actions of a user navigating query results and quantifies the user effort , that is , assigns cost to the user actions . We then conclude with a formal problem definition ( Section 23 )
2.1 Preliminaries Database : Let { } be a database consisting of tuples and { } be a set of attributes . Each attribute has an associated domain consisting of uninterpreted constants . The database is heterogeneous and each tuple has a value for a subset of attributes and a null value for the rest .
Query : The user exploring , navigates the results of a query which could be a keyword query . Each attribute value combination in the results of , denoted by , is a condition and can be used to refine the query . We denote the set of all conditions of by ( ) .
Example : Figure 1a shows a result set for Q : Camera , where the user could refine the query by selecting condition Brand = Canon , which would return the two Canon cameras ( #1 , #3 ) .
Paginated Result Subset : Typically , the result set is too large to fit into a single page on the user interface . These results are therefore paginated and only a small subset of size is presented to the user at a time . The size of the result subset depends on the display size of the device . For example , ecommerce and web search interfaces typically show 10 15 results at a time on desktop browsers and 5 on mobile devices . The latter are the key focus of this paper , which are even more challenging because the screen size does not allow displaying other result information like facets ( see discussion in Section 7 ) .
Example : Figures 1b d show examples of various paginated result subsets ( with ) for the query results in Figure 1a .
The choice of the subset is critical in determining the effectiveness of a search interface . In particular , should contain relevant and a diverse set of results .
Let be the relevance score of a result , where a higher score means the result is more relevant to query . Existing object relevance ranking functions like [ 8 ] can be used to compute . Also , let be the distance between two results . For instance , can be the Euclidean distance between the vectors representing and . Currently , most systems model search result diversification as a bi criteria optimization problem that balances the effect of relevance and diversity using a trade off parameter as follows :
| |
∑
(
∑ ( )
)
In Section 1 , we described several scenarios where this bicriteria optimization is problematic . The primary reason is the
Instead of fixing the trade off between relevance and diversity , we model the diversification problem in terms of the user navigation effort . We do this by designing a holistic model of the user navigating a list of paginated results that considers all the actions taken by a user , discussed next .
2.2 Navigation Cost Model Users execute queries on a search interface to satisfy a certain information need , which may be satisfied by a certain objects in the query result . Given a user query and corresponding result set , the query interface presents the first page of results of size to the user . Each result consists of a set of attribute value conditions . These conditions are selectable ( eg by clicking on the associated link ) , thereby refining the query . Note that the search interface does not provide any facet conditions to refine the results , but the results serve this dual purpose . Such an arrangement is desirable especially in mobile devices where there is not enough space to show both results and facet conditions .
NAVIGATE ( ) 1 . COMPUTE PAGE( 2 . READ RESULT 3 . 4 . 5 . Choose one of the following : 6 .
If search need satisfied by TERMINATE
Select a
( a ) : REFINE : ( b ) : NEXT PAGE( ) : condition to refine ;
7 . NAVIGATE( )
Figure 3 : Diversification Navigation Model
In particular , the user chooses among the following possible actions at each step :
1 . If the user‟s search need is satisfied on the current page , the search is terminated .
2 . ( ) The user can navigate to the next page of the result set in the hope of satisfying her search need there . In this case , the search interface computes the next page of results and presents these results to the user .
3 . Typically , a user has a notion of the properties or conditions that a target ( desired ) object must have . If one of these conditions is found in one of the displayed results , then the user can refine her query by selecting ( clicking ) this condition c . The query is then refined to . For example , if a user is looking for Compact cameras while reading through the result subset in Figure 1d , she could click on the Compact attribute value . This user repeatedly executes REFINE and NEXT PAGE actions until the target object is found , at which point the user TERMINATEs the navigation . This iterative result navigation process is captured by the recursive navigation model presented in Figure 3 . At the beginning of each step ( line 1 ) , the system computes a page of results to be presented to the user . The user reads all the results , represented by READ RESULT( ) and the rest of the navigation repeats recursively .
In our model , the user executes an action based on the displayed result set . Such navigation models , where the user only selects actions proposed by the system , have been used extensively in the navigation of keyword based query results [ 12][21][22 ] . Each user action ( REFINE , READ RESULT , NEXT PAGE ) is an effort on the part of the user . The total effort of the user to satisfy her search need is the navigation cost .
As an example , consider the user navigating the result set in Figure 1a using the initial pagination in Figure 1d . Further assume that the user is interested in Lenses with 55 300 mm Focal Length ( #11 ) . As a first step , the user would read ( READRESULT ) the first page of 3 results . Next , the user REFINEs by Type : Lens to see only the Lens results , since she is interested in Lenses . Up to this point the navigation cost consists of 3 READRESULT actions and 1 REFINE . Upon REFINE , the interface presents the 2 lens results ( #10,#11 ) , which the user reads and finds the navigation . The overall navigation cost is READ RESULT + REFINE . thereby TERMINATING the desired object ,
If we assume that reading a result incurs unit cost ( as was assumed in [ 12] ) , and the cost of REFINE ( click ) action is a constant greater than one , the total cost is 5 1 + 1 3 = 8 . This assumption about the constant reflects our belief that REFINE incurs more user effort than reading a result , since the user has to consider all the conditions and then decide on a condition to click on . Similarly , the user could do NEXT PAGE instead of REFINE if she does not find any useful condition to refine on . The cost of NEXT PAGE is β .
2.3 Problem Statement The overall navigation cost depends on the result subset that is presented to the user at each step . For example , if the user in the example above is presented with a paginated result subset containing the Camera Lens with 55 300 Focal Length ( #11 ) , then she would find the desired target object on the first page and TERMINATE the search . In this case , the total navigation cost is 3 ( 3 READ RESULTs ) . relevance and balancing
Therefore , we need to compute a paginated result subset , that will minimize the expected navigation cost , by appropriately diversity . Let ( ) denote the cost of navigating the result set of a query , using the paginated result subset . Then the minimal cost of navigation , , is the cost of the paginated result set ) k subsets , that has the minimum cost . Formally ,
, amongst the ( | |
Problem 1 : Minimum Cost Diversification( ) : Given a query and its result set | | , compute the result | ) such that the expected subset navigation cost incurred to satisfy the user‟s search need is minimized . of size ( |
( ) = ( ) ( 2 )
Next , we show how to estimate ( ) , the cost of a result subset for a result set .
3 . NAVIGATION COST ESTIMATION The navigation cost of a result set , computed as discussed in Section 2.2 , depends on the actions taken by the user in reaching a target object and can be exactly determined after the navigation is complete . However , solution to the minimum cost diversification problem ( Problem 1 ) requires the selection of result subset before knowing what sequence of actions the user will perform after viewing . In this section , we propose a way to estimate the cost of navigating a result subset by means of a probabilistic cost model that assigns uncertainty measures to each possible action a user can take and computes the expected navigation cost for a given . We begin by introducing the probability measures that capture the uncertainty in user action . In the user navigation model in Figure 3 , the user , at each navigation step , has three choices – ( 1 ) TERMINATE the navigation ( line 3 ) ( 2 ) REFINE by a condition ( line 6a ) and ( 3 ) to go to the NEXT PAGE of results ( line 6b ) , and we introduce probability measures for each of these actions .
 ( : This is the probability that the user finds the result she is looking for in , and therefore terminates the navigation process .
 : This is the probability that the user chooses to refine the result set by adding a condition to the query . On the other hand , the user could instead choose to see the next page of the results . Since these are the only two choices supported by the navigation model , the probability that the user chooses the NEXT PAGE action is .
 : If the user chooses to REFINE , then she also has to select a condition to refine by . The probability captures the probability that the user selects a condition .
Given the probabilities defined above , the entire navigation process , which contains several iterations , can be expressed by the following recursive cost equation ( cost(, , ) is overloaded ) : ( ) | |
{ ∑ ( )
[
}
( ( ) ) ]
This cost equation can be described as follows :
1 . The user reads the results in , and decides about her next action . The cost for reading the results is | | ( assuming unit cost for the READ RESULT action ) . If the user finds the target object then she terminates the navigation .
2 . Otherwise , with probability , she can either refine the query or go to the next page , a . The user decides to refine the query with probability Let be the cost for a REFINE action . As the user can select any condition we consider the cost associated with each selection candidate ( shown as ( ) ) weighted by the value . b . With probability the user decides to go to the next page . is the cost of a NEXT PAGE action , and the cost entailed by the NEXT PAGE action and the cost of the rest navigation is .
The cost equation ( Equation 3 ) depends on the key probability terms , and . We present specific and reasonable methods to compute the probabilities used in our cost model . Depending on the specific application , other computation methods may more closely model the user . The computation of these probabilities is orthogonal to the algorithms presented in Section 4 , which are the key contributions of this paper .
Computing : This is the probability that the user finds the target object in and therefore terminates the navigation . Since the target object is not known before navigation , a reasonable assumption is the probability of a potential target object is proportional to its relevance score . If the user finds the target object amongst the result subset , then she can terminate the navigation . Therefore , we estimate the probability of termination as being proportional to the sum of relevance scores in the paginated result subset and normalize it with sum of relevance scores of all the results in as ∑ . The choice of the relevance
∑
⁄ function is orthogonal to this paper and can be computed in various ways such as TF IDF [ 13 ] for keyword queries or by using Probabilistic Information Retrieval models [ 8 ] .
Computing : The key assumption we make is that the user has a high likelihood of refining the query when the results in are diverse . This is because a diverse covers multiple aspects of the query by containing results from different interpretations [ 7 ] , [ 24 ] . For example , the result subset in Figure 1d contains results from different categories and also contains a variety of attribute values , and hence offers many refinement opportunities , which translated to a high In contrast , the result subset of Figure 1b would translate to a low To compute the diversity of a result subset , we need to compute the distance between all pairs of results [ 5 ] . Distance measures like Euclidean distance , Cosine Similarity can be used for this purpose and again the choice is orthogonal to ∑
∑
| | ∑
. Hence , can be computed as
, where the denominator is this paper . The diversity of can be defined as used for normalization and is equal to the maximum possible diversity of a k result set from . Finding the maximum diversity in the denominator is similar to the maximum clique problem , and therefore known to be NP Complete [ 5 ] . We use [ 10 ] the maximum diversity for our experiments ( in Section 5 ) . to compute
Computing : This probability shows how likely the user will refine the query by selecting condition , which depends on the user‟s preferences or her familiarity to this condition . A reasonable choice is that is proportional to the frequency of condition in the result set as described in [ 12 ] .
4 . ADAPTIVE DIVERSIFICATION Exact Algorithm : To compute the paginated result set such that cost of navigating is minimized , it is necessary to compute the cost , using Equation 3 , of each subset of size and selecting the subset that has the minimum cost . We show that this problem ( Problem 1 ) is NP hard [ 28 ] , by reducing Set Cover to a simplified version of this problem . There are two sources of complexity the exact algorithm computationally expensive : that make
1 . Computing the navigation cost of each subset of ) size requires evaluating Equation 3 for ( | | subsets .
2 . Since Equation 3 is recursive , to solve it we must compute for each condition c in ( more formally ) , the minimum cost ( according to Equation 2 ) , which in turn requires computing the minimum cost over all subsets of ( Figure 4(a) ) . This process continues recursively for deeper levels of the recursion tree . The depth of the recursion is | | in the worst case , since each refinement may eliminate just one result in . The width of each recursive step , ie , the cardinality of the summation , can be up to , which is the number of attribute values displayed at each step .
Approach overview : We attack the problem by proposing efficient techniques to approximate both sources of complexity . We first show how to effectively eliminate the recursion from Equation 3 using a sequence of two relaxations . Then we show how to avoid evaluating the simplified equation for every combination of result subsets using a greedy algorithm .
Our approach starts by eliminating recursion from Equation 3 using two relaxations . Figure 4 shows the recursive tree to compute Equation 3 and the simplifications achieved through the two relaxation steps .
Relaxation 1 ( Eliminate Conditions from Recursion Tree ) : The navigation cost function ( Equation 3 ) has two recursive calls – one each for REFINE and NEXT PAGE actions , respectively to compute the navigation cost for subsequent navigation steps .
Intuitively , the navigation cost of a result set is proportional to its size | | , since for a larger result set the user must explore more results to reach the results of interest . This assumption is backed by our experiments in Section 5 ( specifically Figure 6 ) and we use this observation to simplify the cost equation . Formally ,
( ) | |
The cost associated with REFINE actions , denoted by ( ) , is the navigation cost incurred to reach the target results from the refined result set . Based on the observation above , this cost is proportional to size of , ie
( ) | |
Based on observations and and ignoring the constants of proportionality , the cost of the REFINE by a condition can be estimated as :
( ) ( | | | |
⁄
) ( )
Analogously , the cost of NEXT PAGE action ( (
) ) can be approximated as ( ) , since the user is left with of the original result set after a NEXT_PAGE action .
| |
| |
By plugging in these approximations and rearranging terms , our cost equation can be rewritten as :
( ) | |
{
( ) [ ∑
| | | |
| | ]
| |
}
Equation 4 replaces the recursive calls of REFINE and NEXTPAGE actions ( in Equation 3 ) with ( )(Figure 4(b) ) . However , it still requires evaluation of all possible k subsets of RQ to compute ( ) according to Equation 2 . We address this by the next relaxation .
Relaxation 2 ( Eliminate Result Subsets from Recursion Tree ) : Our goal is to find the result subset that minimizes Equation 4 . But note that this same optimal Sk is used to compute ( ) according to Equation 2 . Hence , we can replace ( ) by ( ) in Equation 4 .
Then , by solving for ( ) , Equation 4 can be further simplified as :
( )
| | { }
{ ∑
| | | |
| | }
| |
Equation 5 has no recursion , and can be easily computed for a given . Note incur any approximation error , in contrast to Relaxation 1 . that Relaxation 2 does not
Given the relaxed cost Equation 5 , we still need to compute the cost of all possible k result subsets of to find the optimal with minimum cost .
Figure 4 : Elimination of Recursion Using Relaxations 1&2
Algorithm : Input : Query and Result Set Output : Set of results , 1 . 2 . 3 . 4 . 5 . 6 . 7 . 8 . 9 . 10 . return for p 2 to k do ( )
Figure 5 : Adaptive Diversification Algorithm
For that , we present an efficient greedy algorithm , called Adaptive Diversification Algorithm ( ADA ) , which incrementally builds the result set by adding at each step the result with minimum incremental navigation cost . At each iteration p ( ) , makes use of two sets : the set of remaining results and the set of selected results , with | | . Note that = , the set of all the results . Initially and . At each iteration , computes ( ) ( using Equation 5 ) for each result and moves the result with minimum navigation cost to . This process continues until we select results ( ie ) . the pseudo code of our diversification Figure 5 shows algorithm . The first result is chosen as the object with highest relevance score ( line 3 ) since we want to provide to the user the most relevant object . After that , in each iteration , ranks the results in according to Equation 5 with replaced by , removes the result with minimum navigation cost from , and adds it in the selected result set ( line 6 9 ) . The algorithm terminates when we select results .
Complexity : The running time of depends on the cost computation time in line 7 , which is invoked up to | | times . To compute ( ) using Equation 5 , we the cost of all possible need to calculate , | | | |
REFINEments ( ∑
) and of NEXT PAGE action
| |
(
| |
) . Computation of and ( Section 3 ) is dominated by their denominators , which depend on the result set and . However , in ADA we only need to compute these probabilities for the original result set , which takes time | | and ( | |)(using ) , respectively . The computation of all ments cost ∑ requires
| | | |
| | time . The cost of NEXT PAGE and can be computed in time . Therefore , the total running time of is O | | the execution time is much faster than this worst case bound ( Section 5 ) .
| | ) .
In practice ,
( assuming
Example : Let us apply to the result set in Figure 1a . We are interested to find the 3 results returned by . But before that we analyze Equation 5 more closely to infer the implication of the cost equation . The cost of a result set is minimized when the denominator of the right hand side in Equation 5 is maximized , which implies having higher value . But when the result set size | | is high , we have smaller value ( since the denominator part of in Section 3 is high ) . Therefore , the navigation cost depends on the cost of and NEXT| |
PAGE actions . Since the NEXT PAGE cost ( denoted as
)
| | is the same for all result sets , the navigation cost is minimized for the result set containing highly diverse results with popular selective conditions ( ie , with high Pc ) . As | | becomes smaller , dominates cost equation , therefore cost is minimized for highly relevant results .
The conclusion of the above discussion is that , initially when | | is large ( small ) , ADA prefers diversity over relevance . As | | becomes smaller ( higher ) in the next iterations , ADA increases preference to relevance , and provides highly relevant results . to the running example ,
Returning initially prefers diversity over relevance in Figure 1a since | | is relatively large . The first result is the result #1 as it has the highest relevance score ( diversity is not a factor when selecting the first result , which is always selected by relevance ) . The second result would be from Compact or Accessory categories . Assuming all the conditions in Compact and Accessory categories have similar selectivity ( similar Pc and similar diversity with respect to #1 ) , the second result is #6 because of its high relevance score . The third result would be from the Accessory category to increase diversity , and specifically #10 since it has higher relevance score than #11 . Thus would return result set in Figure 1d . In the next iteration , as RQ becomes smaller , ADA will return more relevant result set snippets like the one in Figure 1c , and in the last iterations like the ones in Figure 1b .
5 . EXPERIMENTAL EVALUATION In this section , we describe the results of an extensive experimental evaluation of our approach . The setup , including methodology , datasets , baselines and metrics used , is described in Section 51 Sections 5.2 and 5.3 demonstrate the quality and performance of diversification algorithms in terms of user
N P Relax . 1Relax . 2(a)(b)(c ) navigation cost and CPU time . All experiments were performed on a 2.5GHz Intel Core i5 CPU , 8GB RAM machine running Windows 7 . We used MySQL as our database and all algorithms were implemented in Java .
5.1 Setup
Datasets : We evaluated our approach on two datasets :
1 . UsedCars : This dataset consists of a listing of 15,191 used cars , extracted from a popular car trade website . Each tuple has 10 attributes , 4 categorical and the rest numeric .
2 . Electronics : This dataset consists of 65K products from the Electronics product catalog of a popular e commerce website . The products were sampled from various Electronics categories , such as Laptops , Desktops , Cameras , Printers etc . and therefore the dataset is highly heterogeneous in nature . The dataset has a total of 86 ( 51 categorical and 35 numeric ) attributes , but each product has values for a small subset ( avg . 12 ) of these attributes and null for the rest .
Queries : We selected 8 queries each from the two datasets . These queries are shown in Table 1 along with result set sizes . Note that we are interested optimizing the navigation of diverse result sets , and therefore these queries were selected to be deliberately ambiguous so as to include results from a variety of categories . For that , we use single keyword queries , although our methods support any number of keywords or query conditions ; more keywords could be used if larger e commerce datasets were available . For each query , we select a target object , which we assume the user is looking for , ie the navigation terminates when the user locates this target object .
Table 1 : Query Set
State of the art : Current approaches to diversification use a fixed relevance vs. diversity trade off parameter ( in Equation 1 ) to diversify rankings . However , as we argued in Section 1 , setting this parameter is not always obvious and depends on the characteristics of the result set . In Section 5.2 , we provide evidence to further support this claim . We compare with two commonly used approaches for ranking results : 1 . Baseline 1 ( REL ) : In this approach , the results were ranked solely based on relevance , ie by setting in Equation 1 . the Maximal Marginal Relevance
2 . Baseline 2 ( MMR ) : As a second baseline , we ( MMR ) choose diversification algorithm [ 10 ] . MMR computes a diversified result set by balancing relevance and diversity based on Equation 1 . MMR is an approximation algorithm since computing a diversified set based on Equation 1 is NPComplete [ 5 ] . In our experiments , we set giving equal weight to diversity and relevance factors .
Note that , for a fair comparison , we used MMR both as a baseline and to compute in ADA algorithm . We chose MMR since it outperforms other algorithms in terms of time and generates quality results [ 5 ] . However , our use of MMR does not preclude the use of other diversification algorithms , eg GMC , GNE [ 5 ] , which may produce better quality results but take more time compared to MMR [ 10 ] .
Next , we describe the relevance and diversity measures used in our experimental evaluation . We reemphasize that computing these measures is orthogonal to our problem and any suitable and versions can be plugged in to our approach . Due to space limitations we omit experiments with additional measures .
Computing : Computing diversity involves computing distance between two results . We use the sum of distances values between the attribute
.
For
( )
( ) √∑ attributes , we used the Manhattan distance and for categorical attributes , the Kronecker delta function was used between the values of attribute . numeric
Computing : In a structured result set , the relevance of a result depends on relevance of its attribute values . We estimated the relevance of each attribute value by computing the Google Trends scores ( see [ 8 ] for more details ) . The rationale for using Google Trends is based on the idea that the relevance of a term can be based on its frequency in a query workload [ 8 ] .
Since results in satisfy all conditions in , the relevance scorewas computed using the unspecified attributes in by , as was proposed by [ 8 ] , where unspecified refers to an attribute that does not match any query condition . For example in Figure 1a , all the records satisfy the query condition "Camera" with their Product attribute . Therefore , we compute the relevance score using the unspecified attributes ( eg Category , Brand ) .
Methodology : For each query in Table 1 , we picked a result as the target object . The chance of selecting a result as the target object is proportional to its relevance score , which means the results with high relevance scores have a higher chance to be selected as the target object . We then simulated the user navigation until target is reached . Since multiple navigation paths can lead to the target object , we used a randomized simulation [ 12 ] to select navigation paths . Note that , given a set of displayed results , the set of conditions that can lead to is . We assumed that the user will select one of these conditions , or go to next page , according to the navigation probabilities ( Section 3 ) . For example in Figure 1a , if the target object is #4 , and we select Figure 1c as the displayed result subset , the conditions that lead to #4 are "Product=Camera" , "Category = DSLR" and "Brand = Nikon" . The user would go to the next page if she does not like or know these three conditions . Therefore , in our simulation , we computed as ∏ ( the probability that the user would not like any condition in ) and as . In case of refinement , the user could refine the query by selecting any condition in . The choice of selecting a condition is proportional to . We used in the experiments in Section 5.2 , 5.3 , and showed the findings averaged over 1000 runs ( 50 random target objects , and 20 runs per target object ) for each query .
ElectronicsUsedCarsQueryIDQuery# ResultsQueryIDQuery# ResultsQ1Kodak193Q9Honda789Q2Dell125Q10BMW730Q3Canon1097Q1120012034Q4Nikon511Q122005920Q5Camcorder789Q13Dallas2932Q6Speaker737Q14Irving1064Q7Desktop394Q15Black2163Q8Laptop518Q16Blue1183 Figure 6 : ( a ) Avg . Navigation Cost ( b ) Avg . Number of Refine and Next Page actions incurred for Electronics Dataset using =1 ,
β=1 . ( c ) , ( d ) show the same figures respectively for UsedCars Dataset
5.2 Qualitative Analysis
In this section , we present the experimental results of the qualitative evaluation of the three different algorithms ( REL , MMR and our algorithm ADA ) . Figures 6(a ) , 6(b ) show the average navigation cost and average number of and actions incurred respectively by each algorithm to reach the target object for the queries of Electronics dataset . Note that , all algorithms require similar number of REFINE actions ( ie selection of target object conditions ) to filter out enough undesired objects ( Figure 6b ) . Since displays results from popular categories , it requires a larger number of actions to display the conditions of the less relevant target objects . has a fixed ratio of relevance and diversity , which happens to work well for some queries with small number of results like Q1 , Q2 and Q4 , but is ineffective for other queries like Q3 , Q6 , where more NEXT PAGE actions are required to find the target object conditions .
ADA outperforms the other two algorithms , because of its adaptive nature . As discussed in Section 4 , when | | is high , ADA prefers diversity over relevance to pick the Top k results . As becomes more selective over iterations , ADA switches to preferring relevance . Therefore , by balancing diversity and relevance based on the result set at hand , ADA displays the target object conditions much earlier compared to the other two algorithms . This results in fewer actions , and thus reduces the navigation cost of ADA algorithm ( Figure 6a ) . The improvement of ADA over the other two algorithms is more pronounced for the queries that have large number of results ( eg Q3 , Q5 , Q6 ) .
Figures 6(c ) , 6(d ) show the average cost and actions respectively for the queries of dataset . Similar to the Electronics dataset , ADA outperforms the other two algorithms for all the queries of . Since is homogeneous , and perform slightly better as compared to Electronics dataset , due to less variability in attribute conditions . the dataset
Table 2 : Average Navigation Cost for the Datasets
We also compare the average navigation cost incurred by the three algorithms , REL , MMR and ADA , with the expected optimal navigation cost computed by solving Equations 2 and 3 . Due to the exponential complexity , we compute the expected optimal cost for smaller sizes of initial result sets ( RQ ) and query parameter ( k ) . Table 2 shows the average navigation costs for |RQ| = 100 and k = 5 across all queries for the two datasets Electronics and . We see that our algorithm ADA is only 1.07 and 1.03 times worse than the optimal for the
Electronics and datasets respectively . For MMR and REL , these factors are 1.36 ( 1.32 ) and 1.69 ( 1.65 ) respectively for the Electronics ( ) dataset .
Figure 7 shows average navigation cost of with increasing trade off ( λ ) values ( high λ value implies preference to diversity over relevance ) for four queries from Table 1 . The results of the other queries are shown in [ 28 ] . Since ADA is independent of value , therefore the cost of is shown as a straight line . We skipped since it incurs higher cost compared to ADA and . As seen from Figure 7 , there is no value for λ that is optimal for a given dataset or even for a particular query . Intuitively λ should change adaptively , at each navigation step , depending on the characteristics of the result set . By balancing the relative importance of relevance and diversity adaptively at each step , ADA shows better performance ( on average ) compared to with a fixed .
Figure 7 : Average Navigation Cost vs . Tradeoff ( λ ) values the model We also perform experiments while varying parameters ( ) . The results depict that the overall cost of ADA increases at a slower rate with the model parameters compared to and [ 28 ] .
5.3 Performance Analysis takes the shortest time among all
We now present the performance results of REL , MMR and our ADA algorithms . Table 3 shows the average ( across all queries ) computation ( CPU ) times taken by each of these algorithms to reach the target object . As expected , the relevance only algorithm ( REL ) the algorithms . Computing diversity is a costly operation since it involves computation of distance between all pairs of results . As a result any algorithm that incorporates diversity is much slower as compared to REL ; our implementation of MMR is three times slower as REL . Our algorithm ( ADA ) performs this distance computation over all future navigations and therefore is slower than MMR by a factor of 16 While ADA takes more time to compute the set of paginated results , it is very effective in reducing the time or effort incurred by users to navigate such diverse result sets ( discussed in Section 6 ) .
Table 3 : Avg . CPU Time for the Datasets
DatasetsAverage Navigation Cost ( α=1 , β=1)RELADAMMR ( λ= 0.5)Expected OptimalElectronics482530625387528525UsedCars305191524375185120010203040506070809130405060708090λAvg Navigation CostADAMMRQ1Q20010203040506070809150556065707580859095100λAvg Navigation CostADAMMRQ9Q10DatasetsCPU Time ( sec)RELADAMMR ( λ= 05)Electronics00201060066UsedCars005801560107050100150200250Avg Navigation CostRELADAMMR ( λ= 05)RAMRAMRAMRAMRAMRAMRAMRAM051015202530Avg Number of ActionsRefineNextPageR–REL A–ADAM–MMR ( λ= 05)Q1Q2Q3Q4Q5Q6Q7Q8Q1Q2Q3Q4Q5Q6Q7Q8020406080100120140Avg Navigation CostRELADAMMR ( λ= 05)Q9Q10Q11Q12Q13Q14Q15Q16RAMRAMRAMRAMRAMRAMRAMRAM02468101214AvgNumberofActionsQ9Q10Q11Q12Q13Q14Q15Q16RefineNextPageR–REL A–ADAM–MMR ( λ= 0.5)(a)(b)(c)(d ) Figure 8 . ( a ) Avg . User Navigation Time , ( b ) Avg . number of Refine and Next Page Actions incurred by the users for 10 different queries using UsedCars dataset ( for =1 , β=1 )
We also examine the scalability of our algorithm ( ADA ) by applying it to large result set and find that our algorithm scales almost linearly with result set size [ 28 ] .
6 . USER STUDY In this section , we present the results of a user study that we conducted at Amazon Mechanical Turk ( MTurk ) [ 26 ] using the dataset . We selected three keyword queries ( eg , ‘Ford’ ) , and for each query we created a set of search tasks ; each search task specifies a set of target conditions ( eg , find a car with Color = Green ) . We asked the users , starting from the results of the initial keyword query , to find the best car ( according to the relevance score defined in Section 5.1 ) that satisfies all the target conditions .
Table 4 : Query Set for User Study
( λ ) , MMR
( λ ) , ADA
We repeated the experiment for the four different ranking ( λalgorithms : REL independent ) and a diversity only baseline , DIV , which the k result subset greedily at each step by constructs maximizing the score function ( Equation 1 ) ; ie with λ . The reason that we asked users to find the best and not any result is to avoid giving an unfair advantage to methods biased towards diversity like DIV which may help the user to find a satisfying result , but this result may have low relevance . Table 4 shows the list of initial queries , their results‟ cardinality , the target conditions , and the cardinality of results that satisfy all the target conditions . The page size is set to 10 . Each task was completed by 36 MTurk users ; we present the average results .
Figures 8(a ) and 8(b ) show the average time taken and average number of actions executed respectively , by users to find the best target object . As seen in Figure 8(b ) , if we have more target conditions ( eg Q19 , Q26 ) , using DIV ( diversity only ) , the chances of getting a desired target condition on a given page increases . This increases the probability of REFINE action and , therefore , DIV performs better ( Figure 8(b ) ) than the other two baselines REL , MMR , and slightly worse that our algorithm ADA , which prefers diversity over relevance during the initial steps . If we decrease the number of target conditions , the performance of DIV degrades , especially if multiple results satisfy all target conditions ( as seen for the other queries ) , since the user needs to find the best and not any object . For Q17 and Q24 , MMR ( ) and ADA perform similarly , which intuitively shows that 0.5 happens to be the ideal balance between relevance and diversity for these two queries . This is clearly not that case for other queries such as Q23 , where MMR takes longer time even compared to the relevance based REL .
As shown by the average values in Figure 8(a ) , ADA reduces the navigation time significantly compared to all other algorithms . On average , ADA is faster by a factor of 2.04 ( p value 0.004 ) , 1.97 ( p value 0.001 ) and 1.66 ( p value 0.0002 ) over REL , MMR and DIV , respectively . This significant improvement is because of the smaller number of actions incurred by ADA compared to the other three algorithms ( Figure 8(b) ) .
Figure 9 shows the actual user navigation time vs . the estimated cost ( using our cost model in Section 3 ) for the 10 different queries using the four different algorithms , where for each query we average over all users . The figure and the trend line show a clear correlation , and specifically a linear relationship , which confirms the validity of the cost model .
Figure 9 . Estimated Cost vs . Actual Time
7 . RELATED WORK Diversification has recently been introduced in search engines and recommendation systems to increase user satisfaction . [ 6][17 ] use coverage approaches to cover diverse aspects of search space . [ 17 ] expresses the degree of diversification by a setting a parameter which also determines the size of final result set . [ 6 ] operates on Web documents and selects diverse documents to cover many different interpretations of the query . [ 18 ] the recommendations and the past history of the user . [ 19 ] presents a method based on medoids clustering to select a set of diverse and highly ranked items to recommend to a user . However , none of these approaches considers the problem of how to minimize the total navigation cost incurred by the user to find the target object by considering subsequent navigation steps . In this paper , we have addressed this concern by introducing a navigation cost model ( Section 2 ) . diversity provides of using the content
Diversification in [ 1][3][5][10 ] . Most of these approaches ( eg [ 5 ] ) consider is being used along with relevance
Q17Q18Q19Q20Q21Q22Q23Q24Q25Q26Avg.0102030405060708090100Navigation Time ( sec)RELADAMMR ( λ= 0.5)DIV(a)RAMDRAMDRAMDRAMDRAMDRAMDRAMDRAMDRAMDRAMDRAMD0246810121416Number of ActionsRefineNextPageR–REL A–ADAM–MMR ( λ= 0.5 ) D –DIV Q17Q18Q19Q20Q21Q22Q23Q24Q25Q26Avg.(b)QueryIDInitial QueryInitial Result Set SizeTarget Conditions# of Results contain all Target ConditionsQ17Toyota1470Color = Green86Q18Ford2747City = Grand Prairie133Q19Ford2747Model = F150 Regular CAB,State = MD , Color = Maroon1Q20Ford2747Color = Maroon42Q21Ford2747City = Ashland75Q22Ford2747Color = Beige40Q23Toyota1470City = Richmond88Q24Toyota1470Color = Red;79Q25Ford2747Color = Gold;116Q26BMW730Model = Convertible,City = Fairfax,Color = Grey;120406080100120140160180102030405060708090Estimated Navigation CostActual Navigation Time ( sec)RelADAMMR ( λ= 0.5)Div diversification as a bi criteria optimization , which uses a fixed trade off value for relevance and diversity . In Section 5 , we have shown that different search tasks require different ideal trade off value . Some learning methods [ 4][16 ] have been proposed to learn the trade off value . However , these methods rely on training data provided by the experts which is expensive and difficult to obtain in all cases . [ 25 ] proposes a dynamic ranking model for interactive user feedback . The ranking is based on the history of other users . In contrast , our ranking function aims to minimize the expected user effort . Threshold based techniques , a variant of the optimization problem , have been proposed in [ 11 ] to solve the diversification problem . These approaches consider a threshold value of relevance and maximize the diversity between results ( or vice versa ) . Setting a threshold value is hard , and depends on the domains . Moreover , [ 5 ] shows a comparison between several diversification approaches where MMR ( the baseline used in this paper ) clearly outperforms the threshold based approach in both quality and time . Our approach does not require the threshold value , and can adaptively set the balance between relevance and diversity for different tasks .
Faceted Search has been shown to be effective in reducing the user effort and time required to navigate large result sets of structured databases . For a given query , these approaches compute the best facet conditions and matching results to display to the user [ 12][21][22 ] . However , this model is not suitable for our setting of limited screen size , where we cannot display separately faceted conditions and results . Instead , our results serve a dual purpose , since a user can click on results‟ conditions to refine her navigation .
8 . CONCLUSIONS We described a novel framework for adaptive diversification of query results that dynamically adjusts the relevance and diversity of displayed results with the aim to minimize the total expected user navigation cost to reach the desired target objects . Based on this framework , we prove that the problem is NP hard and we present an efficient approximate algorithm that computes the best set results to display , by dynamically balancing relevance and diversity at each query step . We experimentally evaluate the performance of our proposed algorithm and show it outperforms state of the art algorithms . A Mechanical Turk user study confirms our findings and validates our navigation model . As a future work , we plan to extend our navigation model where the user can update/delete the selected conditions during the navigation process . that
9 . ACKNOWLEDGMENTS This project was partially supported by NSF grants IIS 1161997 , IIS 1216007 , and a Samsung GRO grant .
10 . REFERENCES [ 1 ] C . Clarke , M . Kolla , G . Cormack , O . Vechtomova , A .
Ashkan , S . Buttcher , I . MacKinnon . Novelty and Diversity in Information Retrieval Evaluation . In SIGIR 2008 .
[ 2 ] H . Tong , J . He , Z . Wen , R . Konuru , and C . Lin . Diversified
Ranking on Large Graphs : An Optimization Viewpoint.In KDD 2011 .
[ 3 ] E . Demidova , P . Fankhauser , X . Zhou , and W . Nejdl .
DivQ : Diversification for Keyword Search over Structured Databases . In SIGIR 2010 .
[ 4 ] R . Santos , C . Macdonald , and I . Ounis . Selectively Diversifying Web Search Results . In CIKM 2010 .
[ 5 ] M . Vieira , H . Razente , M . Barioni , M . Hadjieleftheriou , D .
Srivastava , C . Traina , and V . Tsotras . On Query Result Diversification . In ICDE 2011 .
[ 6 ] R . Agrawal , S . Gollapudi , A . Halverson , and S . Ieong .
Diversifying Search Results . In WSDM 2009 .
[ 7 ] F . Radlinski , P . Bennett , B . Carterette , and T . Joachims .
Redundancy , Diversity and Interdependent Document Relevance . In SIGIR Forum , 43(2):46 52 , 2009 . [ 8 ] S . Chaudhuri , G . Das , V . Hristidis , G . Weikum .
Probabilistic Ranking of Database Query Results . In VLDB 2004 .
[ 9 ] K . Raman , P . Shivaswamy,and T . Joachims . Online
Learning to Diversity from Implicit Feedback . In KDD 2012 .
[ 10 ] J . Carbonell and J . Goldstein . The Use of MMR , DiversityBased Reranking for Reordering Documents and Producing Summaries . In SIGIR 1998 .
[ 11 ] L . Qin , J . X . Yu , and L . Chang : Diversifying Top K
Results , In VLDB 2012 .
[ 12 ] A . Kashyap , V . Hristidis , and M . Petropoulos . FACeTOR :
Cost Driven Exploration of Faceted Query Results . In CIKM 2010 .
[ 13 ] M . J . McGill , G . Salton . Introduction to Modern
Information Retrieval . McGraw Hill , 1986 .
[ 14 ] E . Vee , U . Srivastava , J . Shanmugasundaram , P . Bhat , and
S . A . Yahia . Efficient Computation of Diverse Query Results . In ICDE 2008 .
[ 15 ] K . Liu , E . Terzi , and T . Grandison . Highlighting Diverse
Concepts in Documents . In SDM 2009 .
[ 16 ] Y . Yue , and T . Joachims . Predicting Diverse Subsets Using
Structural SVMs . In ICML 2008 .
[ 17 ] M . Drosou , E . Pitoura : DisC Diversity : Result
Diversification based on Dissimilarity and Coverage , In VLDB 2013 .
[ 18 ] C . Yu , L . Lakshmanan , and S . AYahia It Takes Variety to
Make a World : Diversification in Recommender Systems . In EDBT 2009 .
[ 19 ] R . Boim , T . Milo , S . Novgorodov . Diversification and
Refinement in Collaborative Filtering Recommender . In CIKM 2011 .
[ 20 ] C N Ziegler , S . McNee , J . Konstan , G . Lausen : Improving
Recommendation Lists through Topic Diversification , in WWW 2005 .
[ 21 ] S . B . Roy , H . Wang , G . Das , U . Nambiar , and M . Mohania .
Minimum Effort Driven Dynamic Faceted Search in Structured Databases . In CIKM 2008 .
[ 22 ] K . Chakrabarti , S . Chaudhuri , and S . Hwang . Automatic
Categorization of Query Results . In SIGMOD 2004 .
[ 23 ] M . Hasan , A . Mueen , V . Tsotras and E . Keogh .
Diversifying Query Results on Semi Structured Data . In CIKM 2012 .
[ 24 ] M . Hasan , A . Mueen and V . Tsotras . Distributed Diversification of Large Datasets . In IC2E 2014 .
[ 25 ] C . Brandt , T . Joachims , Y . Yue and J . Bank . Dynamic
Ranked Retrieval . In WSDM 2011 .
[ 26 ] Amazon Mechanical Turk . https://wwwmturkcom [ 27 ] eMarketer Report http://wwwemarketercom/Article/Smartphones TabletsDrive Faster Growth Ecommerce Sales/1009835 , 2013
[ 28 ] Extended Version of the paper appears at : http://wwwcsucredu/~hasanm/adadivpdf
