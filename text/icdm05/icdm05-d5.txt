Mining Frequent Spatio temporal Sequential Patterns
Huiping Cao , Nikos Mamoulis , and David W . Cheung
Department of Computer Science
The University of Hong Kong Pokfulam Road , Hong Kong
{hpcao , nikos , dcheung}@cshkuhk
Abstract
Many applications track the movement of mobile objects , which can be represented as sequences of timestamped locations . Given such a spatio temporal series , we study the problem of discovering sequential patterns , which are routes frequently followed by the object . Sequential pattern mining algorithms for transaction data are not directly applicable for this setting . The challenges to address are ( i ) the fuzziness of locations in patterns , and ( ii ) the identification of non explicit pattern instances . In this paper , we define pattern elements as spatial regions around frequent line segments . Our method first transforms the original sequence into a list of sequence segments , and detects frequent regions in a heuristic way . Then , we propose algorithms to find patterns by employing a newly proposed substring tree structure and improving Apriori technique . A performance evaluation demonstrates the effectiveness and efficiency of our approach .
1 Introduction
The movement of an object ( ie , trajectory ) can be described by a sequence of spatial locations sampled at consecutive timestamps ( eg , with the use of Global Positioning System ( GPS ) devices ) . Parts of the object routes are often repeated in the archived history of locations . For instance , buses move along series of streets repeatedly , people go to and return from work following more or less the same routes , etc . The movement routes of most objects ( eg , private cars ) are not predefined . Even for objects ( eg , buses ) with pre scheduled paths , the routes may not be repeated with same frequency due to different schedule in weekends or some special days . We are interested in finding frequently repeated paths , ie , spatio temporal sequential patterns , from a long spatio temporal sequence . These patterns could help to analyze/predict the past/future movement of the object , support approximate query on the original data , and so on . However , they cannot be obtained straightfor wardly by eliminating the noisy movement because of the large volume of the spatio temporal data .
Discovery of sequential patterns from transactional databases has attracted lots of interest since Agrawal et al . introduced the problem [ 1 ] . In such a database , each transaction contains a set of items bought by some customer in one time , and a transaction sequence is a list of transactions ordered by time . For example , .(a , b ) , ( a , c ) , ( b)fi is a sequence containing three transactions ( a , b ) , ( a , c ) and ( b ) . Given a collection of transaction sequences , the problem is to find ordered lists of itemsets appearing with high frequency . Eg , .(b ) , ( a ) , ( b)fi is a pattern supported by the above sequence .
Unfortunately , pattern discovery techniques in transactional databases are not readily applicable for finding sequential patterns in spatio temporal data . First , the elements in a transactional pattern are items that explicitly appear in pattern instances . On the other hand , location coordinates in a spatio temporal series are real numbers , which do not repeat themselves exactly in every pattern instance . Second , the patterns are discovered from explicitly defined sets of sequences , like .(a , b ) , ( a , c ) , ( b)fi , in the previous example . Thus , a transaction list only contributes 0 or 1 to the support of a pattern , depending on whether the pattern appears or not in the specific sequence set . In our setting , however , we detect frequent patterns from one long spatio temporal sequence , without predefined segmentation of the data . The challenge is to identify the segments that contribute to a pattern , without allowing them to overlap with each other .
To summarize , the main contributions of this paper are : ( i ) We propose a model for spatio temporal sequential patterns mining , based on appropriate definitions for pattern elements and pattern instances . ( ii ) We present an effective method for extracting pattern elements . ( iii ) We provide efficient pattern mining algorithms for discovering longer patterns . The remainder of the paper is organized as follows . Section 2 reviews the related literature . The formal definition of spatio temporal sequential pattern is given in Section 3 . Section 4 presents our solutions in detail . An ex
Proceedings of the Fifth IEEE International Conference on Data Mining ( ICDM’05 )
1550 4786/05 $20.00 © 2005 IEEE perimental evaluation about the effectiveness and efficiency of our approach is presented in Section 5 . Finally , Section 6 concludes this paper .
2 Related work
Our work is most related to pattern discovery from sequential data , which include time series , event sequences , and spatio temporal trajectories .
Mannila et al . [ 10 ] investigated the discovery of frequent episodes from event sequences . An episodes is a ( partially or totally ) ordered list of events , thus is a variant of sequential pattern . A fixed sliding window w is used to extract segments ( ie , subsequences ) in the event series , and the contribution of every segment to each candidate episode ’s frequency is counted . The segments supporting one episode may overlap , which is reasonable since episodes try to capture the appearing order of instantaneous events . However , this methodology may not get satisfactory results in finding spatio temporal patterns , for several reasons . First , the window limits the length of the patterns . Second , pattern supports may not be counted correctly . Eg , the object ’s movement is aabbcdef g , where each character a , b , etc . corresponds to a spatial region . The occurrence of the pattern abc should be 1 , since the object moves from a to c , once . However , if w is 5 , pattern abc has support 4 due to the contribution of 4 segments ( a b c , ab c , a bc , and a bc ) . Third , as opposed to well defined categorical values for event instances , object locations do not repeat themselves exactly in pattern instances , for they are usually ordinal and inexact . Yang et al . investigated mining long sequential patterns in [ 13 ] , also dealing with event series with noise .
Previous work on detecting patterns from time series ( e.g , [ 2 , 7 ] ) converted the problem to finding subsequences in lists of categorical data ( eg , event sequences ) , by preprocessing the original sequence to a string . A window w of fixed size is slided along the sequence , and a subsequence with length w is extracted for every position . In [ 2 ] , the subsequences are clustered based on their shapes , and each cluster is given an id . In [ 7 ] , some features are extracted from each subsequence ( eg , the slope of the best fitting line of the sub series , the mean of the signal , etc ) The feature space is divided into groups of similar values , and every subsequence is converted to a group id . The raw sequence is then transformed to a string of cluster ids or group ids . The use of the window may over count the patterns due to the reason explained above . In addition , since w is fixed , the extracted subsequences have the same length , which may affect the resultant patterns . Furthermore , for spatio temporal data , even when we extract the subsequences using a sliding window and get simple features from these segments , we cannot directly group these features using methods in [ 2 ] and [ 7 ] . The cluster based approach ( [2 ] ) has been discredited by [ 8 ] . The way to group the subsequence features
( [7 ] ) may be effective for time series with 1 dimension values . For more complex spatio temporal data , if we directly apply this method , ie , split the features into groups , we may miss the information about the spatial proximity of segments , which is essential for grouping .
The first study on finding frequent sequential patterns from spatio temporal data is [ 11 ] . The raw data here is not a long sequence , but lists of spatial locations . After discretizing the locations to pre defined spatial decomposition , the process is intrinsically similar to that in transactional databases .
[ 9 ] addresses the problem of discovering periodic patterns in spatio temporal data , which is a generalization of mining periodic patterns in event sequences . Given a period T , in the case of spatio temporal data , a periodic pattern is a ( not necessarily contiguous ) sequence of spatial regions , which appears frequently every T timestamps and describes the object movement ( eg , a bus moves from district a to district b and then to c with high probability , every three hours ) . The contribution of [ 9 ] is that it does not treat spatio temporal series as event sequences , by merely replacing each location by a predefined region enclosing it , but automatically discovers the regions that form the patterns . This method , although effective for its purpose , relies on a fixed T ( ie , the patterns repeat themselves every regular time periods ) . In addition , it is prone to distortions/shiftings of the pattern instances , ie , periodic segments where the pattern does not appear in the same positions as in the pattern definition do not contribute to the pattern ’s support . 3 Spatio temporal sequential patterns
A spatio temporal sequence S is a list of locations , ( x1 , y1 , t1 ) , ( x2 , y2 , t2 ) , . . . , ( xn , yn , tn ) , where ti represents the timestamp of location ( xi , yi ) ( 1 ≤ i ≤ n ) . Figure 1 illustrates the movement of an object which repeats a similar route in three runs . We are interested in movement patterns repeated frequently in such a series . This section first motivates our solution , then formally defines the problem . 3.1 Motivation
Locations are not repeated exactly in every instance of a movement pattern . Our idea is to summarize a series of spatial locations to that of spatial regions .
A naive method is to use a regular grid ( or some predefined spatial decomposition ) to divide the space into regions by taking a user defined parameter G,an approximate number that each axis will be split to . Then , the locations series can become a sequence of grid ids utilizing a transformation approach . The first method , Grid I , converts each location to the id of the cell it falls in . Eg , the raw series in Figure 1a , can be transformed to the cell id sequence c2c4c8c9c6c2 . . . c3 . Although intuitive , this method has two problems . First , we lose the information on how the object moves inside a cell , if the space decomposition is
Proceedings of the Fifth IEEE International Conference on Data Mining ( ICDM’05 )
1550 4786/05 $20.00 © 2005 IEEE coarse . The patterns may not be very descriptive . Second , for two instances of a pattern , the locations may not fall into the same cell ( ie , two adjacent locations appear in neighboring cells ) . We may miss some frequent patterns , whose instances are divided between different grid based patterns . The first problem could be alleviated by decreasing G , however , this would increase the chances of missing patterns due to the second problem . An alternative conversion technique adds the ids of cells that intersect with the line segments connecting consecutive locations to the transformed sequence . In the example of Figure 1a , Grid II converts the sequence for the first run to c2c1c4c7c8c9c6c3c2 . Nevertheless , by this improvement , the new series may be significantly longer than the original one , which may already be extremely long , like spatio temporal sequences usually are .
1
4
7
2
5
3 run 1 run 2 run 3
6
9
8
( a ) l run 1 run 2 run 3
( b )
Figure 1 . Object Movement
Thus , we need a better way to abstract the trajectory . Motivated by line simplification techniques ( [3] ) , we represent segments of the spatio temporal series by directed line segments . Figure 1b shows that the line segment l summarizes the first three points in each of the three runs with little error . In this way , not only do we compress the original data , decreasing the mining effort , but also the derived line segments ( which approximately describe movement ) provide initial seeds for defining the spatial regions , which could be expanded later by merging similar and close segments . 3.2 Problem definition A segment sij in a spatio temporal sequence S ( 1 ≤ i < j ≤ n ) is a contiguous subsequence of S , starting from ( xi , yi , ti ) and ending at ( xj , yj , tj ) . Given sij , we define its representative line segment .lij with starting point ( xi , yi ) and ending point ( xj , yj ) . Let be a distance error threshold , sij complies with .lij with respect to and is denoted as sij ∝ .lij , if dist((xk , yk ) , .lij ) ≤ for all k(i ≤ k ≤ j ) , where dist((xk , yk),.l ) is the distance between ( xk , yk ) and line segment l When sij ∝ .lij , each point ( xk , yk ) , i ≤ k ≤ j , in sij can be projected to a point . ) implicitly denotes the projection ( x k , y of ( xk , yk ) to lij Figure 2a illustrates a segment sij com . plying with .lij and shows the projection ( x ) of point k , y
. . k ) on lij ( x k , y
. k
. k
( xk , yk ) on lij A segmental decomposition Ss of S is defined by a list of consecutive segments that constitute S . Formally , Ss = sk0k1 sk1k2 . . . skm−1km , k0 = 1 , km = n , m < n , where skiki+1 ∝ .lkiki+1 for all i , To simplify notation , we use s0s1 . . . sm−1 to denote Ss .
Let .l represent a directed line segment , langle and llen be its slope angle and length respectively . Two line segments .lij and .lgh representing segments sij and sgh are similar , denoted by .lij ∼ .lgh , with respect to angle difference threshold θ and length factor f ( 0 ≤ f ≤ 1 ) if : ( i ) | lijangle − lghangle| ≤ θ and ( ii ) | lijlen − lghlen| ≤ f × max( lijlen , lghlen ) If .lij ∼ .lgh , sij and sgh are also treated as similar to each other . Note that similarity is symmetric . The location information of segments is not considered in defining similarity , since we use it when defining the segments’ closeness . ) ∈ .lij , ) , .lgh ) ≤ . When .lij is close to .lgh , we also . dist((x k , y say that the segment sij is close to the segment sgh , where sij ∝ .lij and sgh ∝ lgh As opposed to similarity , closeness is asymmetric . Figure 2b shows an example . Let .lij is parallel to .lgh and = 50 The distance between these two parallel line segments is 45 Observe that .lij is close to .lgh because the distance from each point in .lij to .lgh is less than 50 However , .lgh is not close to .lij for the point in the right upper part has distance to .lij bigger than 50
Line segment .lij is close to .lgh if for ∀(x . k , y
. k
. k p∈P Set dist(p,.l ) ∀.l )= lc
Let L be a set of segments from sequence Ss . The mean line segment for L , .lc , is a line segment that best fits all the points in L with the minimum sum of squared errors ( SSE ) . In other words , if P Set contains all the points of the segments in L , the mean line segment .lc is such that p∈P Set dist(p , .lc ) ≤ . . Let tol be the average orthogonal distance of all the points in L to lc A spatial pattern element is a rectangular spatial region rL with four sides determined by ( .lc , tol ) as following : ( 1 ) two sides of r ’s that are parallel to .lc , have the same length as .lc , and their distances to .lc are tol ; ( 2 ) the other two vertical sides have length 2 · tol , and their midpoints are the two end points of lc We refer to .lc as the central line segment of region rL . We say that region rL contains k segments or k segments contribute to rL if L consists of k segments . Figure 2c visualizes this definition . A spatio temporal sequential pattern P is an ordered sequence of pattern elements : r1r2 . . . rq , ( 1 ≤ q ≤ m ) . The length of pattern P is the number of regions in it . A contiguous subsequence of Ss , sisi+1 . . . si+q−1 , is a pattern instance for P : r1r2 . . . rq if ∀j(1 ≤ j ≤ q ) , if the representative line segment for segment si+j−1 is similar and close to the central line segment of region rj . A pattern ’s instances cannot overlap in time ( the pattern may be over counted like that in [ 10 ] otherwise ) , ie , if two con
Proceedings of the Fifth IEEE International Conference on Data Mining ( ICDM’05 )
1550 4786/05 $20.00 © 2005 IEEE
( cid:72 )
( cid:72 )
( k yx , k
) ( cid:72 )
(
,' k y x k
)' ijl
( cid:72 )
4.5 ijl ghl cl tol r
( a ) Segment complies with .lij
( b ) Example for closeness
( c ) Region r determined by ( .lc , tol )
Figure 2 . Example of definitions such that the perpendicular distance from every point in Sli to li is at most . For efficiency purpose , DP ’s improved version ( [5 ] ) could be adopted .
Discovering frequent singular patterns from Ss is a hard problem , since in the worst case , all combinations of segments in Ss have to be considered as candidate . To expedite the process , we employ a heuristic , Growing . Let Segs be a set initially containing all the segments in Ss . Growing works as follows . It selects the segment s with median length , ie , the median of the lengths of the segments in Segs , as seed for the initial spatial region r . Then , r is grown by merging other segments in Segs through filtering and verification steps , described later . Next , for the set of with remaining segments not merged to r , the segment s median length in it is selected as seed for growing . Finally , the overall algorithm terminates after all segments ( i ) have been assigned to a region ( as initial seeds or to the region of another seed ) , or ( ii ) have been found not to belong to any frequent region and marked as outliers . Selecting the segment with median length as seed could help to absorb short segments with less error , compared to taking segment with longer length as seed . Meanwhile , it could prevent generating regions with too fine granularity , which could happen when shorter length segment is used as seed . Growing is deterministic in using this seed selection procedure .
.
The filtering process checks two conditions . First , for each si in Segs the angle difference dif f ai between .ls and si is computed , and si is treated as candidate if dif f ai is less than θ . All the candidate segments are put into a set C . Second , the minimum distance from every segment in C to .ls is computed and all segments whose minimum distances to .ls is larger than f · lslen are pruned . The remaining segments in C will be used for verification .
The filtering step computes the minimum distance between segments , but it does not consider the length difference ( second condition of similarity ) , between each .lsi ∈ C and .ls , and the exact spatial distances of segments in C to .ls ( closeness condition ) . In the verification step , Algorithm 1 ( shown below ) merges the segments in C to the spatial region r around .ls , if si ∈ C satisfies the closeness and length difference condition . Otherwise , we extract from si the part that satisfies the condition , and merge this part with r . The remaining part of si is a new segment and inserted back to tinuous subsequences of Ss , si . . . sj and sg . . . sh , are two instances for pattern P , either j < g or h < i . Given patis a subpattern terns P of P if i ≤ j and ∃k , ( 1 ≤ k ≤ j− i+1 ) such that r . 1 = rk , . 2 = rk+1 , . . . , r r
= rk+i−1 . P is a superpattern of P
. i and P : r1r2 . . . rj , P
. 1r
. 2 . . . r
.
.
.
.
: r
. i
The support of a pattern P is the number of instances supporting P . Given a support threshold min sup , P is frequent if its support exceeds min sup . Since a pattern with same frequency to one of its supersets is redundant , we focus on detecting closed frequent patterns [ 4 ] , for which every proper subpattern has equal frequency . The mining problem is to find frequent patterns from a long spatiotemporal sequence S with respect to a support threshold min sup , and subject to a segmenting distance error threshold , a similarity parameter θ and a length factor f . The parameter values depend on the application domain , or can be tuned as part of the mining process [ 2 ] . In using the raw data to discover patterns , we discuss how to set the parameters in Section 5.1 more applicably . 4 Solution
In this section , we describe how to discover frequent singular patterns , ie , frequent spatial regions ( Section 4.1 ) and longer closed patterns ( Section 42 )
4.1 Discovering frequent singular patterns
The segmentation ( line simplification ) algorithm ( [3 , 5 , 6 ] ) is used to convert the locations series to segments sequences so that each raw sequence segment could be abstracted by a line segment . Our idea is to transform S to Ss using such a technique , and take the segments obtained as seed for the desired spatial regions , whose central line segments best fit the points of segments in the regions . The DP ( Douglas Peucker ) algorithm [ 3 ] is a classical top down approach for this problem . [ 6 ] provides an online algorithm in splitting a sequence to segments with quite good quality . Since it is important to keep the internal movement inside a region , we need to capture the sharp turn of the movement in the transformation . We employ DP method because it has been proved to be the best algorithm in choosing splitting points [ 12 ] . In brief , DP algorithm recursively decomposes S : {p1 , . . . , pn} to a series of line segments l1 , . . . lm , m ≤ n , each of which , li , simplifies a subsequence Sli ,
Proceedings of the Fifth IEEE International Conference on Data Mining ( ICDM’05 )
1550 4786/05 $20.00 © 2005 IEEE to some but not all the others in SR . This constraint can help reduce the number of generated candidates , as follows . We first construct a connectivity graph for all the spatial regions in SR . A directed edge from ri to rj is added to the graph if the substring rirj appears in the sequence . The edge weight is the frequency that rirj appears in the sequence . Let r1r2 . . . rk be a frequent pattern , and rk only points to ri and rj , only two candidates , r1r2 . . . rkri and r1r2 . . . rkrj are generated . Further , if the edge weight from rk to some element , say ri , is no more than min sup , we need not generate candidate r1r2 . . . rkri .
Property 2 ( Closeness Property ) : Given a pattern P , suppose its last element connects to r1 , r1 connects to r2 , . . . , rm−1 connects to rm , ( m ≥ 2 ) . We can get pattern P1 = P r1 ( concatenating P and r1 ) , P2 = P r1r2 , . . . , Pm = P r1r2 . . . rm . Obviously , if P1 and Pm have the same support , any Pi , ( 1 < i < m ) also has the same support . This property helps to generate candidates more efficiently . Let result be the frequent patterns at the end of the kth scan and P be a pattern in it with last element r . We can extend P using other patterns in result that start with r . For instance , let P = r1r2r3 , and r3 only connect to r4 in the connectivity graph . In addition , assume that result con . = r3r4r6r7 . P tains only one pattern starting from r3 : P can then be extended to candidates r1r2r3r4 ( using Property 1 ) , and r1r2r3r4r6r7 ( using Property 2 ) . If r1r2r3r4 and r1r2r3r4r6r7 have the same support after the counting , we only need to consider candidates longer than r1r2r3r4r6r7 later , significantly reducing the number of scans .
422 Mining using the substring tree
We propose a substring tree structure to facilitate counting of long substrings with different elements . The substring tree is a rooted directed tree whose root links to multiple substring sub trees . Each node in a sub tree consists of pattern element and a counter , which counts the number of substrings ( ie , subsequences of elements ) that contribute to the pattern formed by the path from the root to this node . A substring tree example is shown in Figure 3a .
To construct the tree , in scanning SR , we extract substrings containing distinct elements , and insert them to the tree . In seeing an element r in SR , we concatenate it to the substrings found so far that do not contain r . Also , if no substring starting with r is found , r is treated as a new substring . We give an example to illustrate the extraction of substrings . Let SR be r1r2r3r4r1r3r4r2r3r4r1r2r3r4 . Initially , no substring is extracted . When see the first r1 , we create a new substring for it . On seeing the second element r2 , we create a new substring r2 since no substring starting with r2 exists . In addition , we concatenate it to the only substring r1 and get r1r2 . The process continues until we see the fifth element r1 . There is already a string r1r2r3r4 with r1 as first element , so r1r2r3r4 is inserted to the tree ,
Segs ( Line 15 ) for later processing .
Algorithm 1 Verification(.ls , C , Segs , f , min sup ) 1 : α := lslen × f ; m:=0 ; 2 : //length check 3 : for each segment si in C do . intersect si with .ls , get s and ls ; 4 : if ( diff(lslen , ls .len ) ≤ α ) m++ ; 5 : 6 : end for 7 : //closeness check 8 : while ( m ≥ min sup ) do 9 : 10 : 11 : 12 : end while 13 : if ( m<min sup ) return ; 14 : for each segment si in C do 15 : 16 : 17 : end for 18 : Remove segment that .ls represents from Segs ;
Get .lc from all intersected points for region r ; Validate all intersected parts from C ; if ( all intersected parts are close to .lc ) break ;
Add non intersected part of si to Segs ; Remove si from Segs ;
. If all projection points ( x k , y
We explain how we compute the intersected part of si and .ls in Line 4 . Let .lsi be the representative line seg ) in .lsi have ment for si . distance to .ls no more than α ( Line 1 ) , its related location point ( xk , yk ) in the segment is put into the intersected part . . . The line segment created by mapping each point in s s to .lsi is denoted as ls For example , let si represent segment ( x10 , y10 , t10 ) , . . . , ( x30 , y30 , t30 ) . Assume that the distances from points in .lsi to .ls are all smaller than α ex . cept points from ( x is seg10 , y ment ( x16 , y16 , t16 ) , . . . , ( x30 , y30 , t30 ) , and ls represents . line segment from ( x 16 , y 4.2 Deriving longer patterns
. . 16 ) to ( x 30 , y
. 30 ) in lsi
. k
. . 10 ) to ( x 15 , y
. 15 ) . Then , s
.
After finding frequently visited spatial regions , original data S is converted to a series SR of spatial regions by changing the segments in frequent regions to region ids , and those not in any region to outliers . SR preserves the motion continuity of the object by showing how it moves among regions . Although each region in SR is repeated frequently , the concatenation of some regions may not be frequent . Eg , a person living in r1 often goes to a place r2 in some days and to region r3 in other days . r1 , r2 and r3 are frequently visited , but the path r2r3 is not frequent . This section discusses how to detect the longer frequent patterns . 421 Level wise mining A direct way is to perform level wise pattern mining . However , this approach suffers from the disadvantage that SR needs to be scanned many times . We propose solutions to reduce the number of candidates and scans in probing long candidates , based on the following properties we observe .
Property 1 ( Connectivity Constraint ) : Due to continuity of object movement , a spatial region can only connect
Proceedings of the Fifth IEEE International Conference on Data Mining ( ICDM’05 )
1550 4786/05 $20.00 © 2005 IEEE and a new substring starting from r1 is created . Figure 3a shows the full substring tree for sequence SR .
1r3
3r1
1
1
4r
2r
2 2r
2
3r
2 4r
3
3
3
2
2r
3r
4r
1r root
4
3r
4 4r
2
1r
1 2r
1 2r
3 4r
2
1
1r
3r
1 2r
1
3r
2r
3r
1
1
( a ) Substring tree example result stack r3(4 ) r1(3 ) r2(3 ) r4(3 ) r1(3 ) r2(3 ) r4(3 )
⇒ r3r4r1(2 ) r3r4(4 ) stack r3r4(4 ) r1(3 ) r2(3 ) r4(3 ) result r3(4 )
⇒ r2(3 ) r4(3 )
⇒ r3r4r1(2 ) r1r2r3r4(2 ) r1(3 ) r3r4(4 )
( b ) Mining patterns from the substring tree
Figure 3 . Mining using substring tree
For deriving frequent patterns from the substring tree , we utilize a stack . Each element in the stack comprises of a pattern , its count and a level , indicating whether the pattern has reached a leaf or not . First , we add to the stack the patterns associated with the root ’s children . Then , we iteratively pop patterns with highest frequency from the stack . If the popped up pattern is not at leaf level and is frequent , we output it , and extend it by concatenating it with its children ’s elements and push the extended patterns to the stack ; otherwise , the pattern is just output ( if frequent ) . In the above example , there are initially four elements in the stack . Figure 3b shows the first several steps for the mining process . Let min sup = 2 . When popping r3(4 ) from the initial stack , we output it as result , and extend it to r3r4 since it is not at the leaf level . Next , we pop up r3r4(4 ) and delete r3(4 ) from the result because its frequency is the same to that of r3r4 ( definition of closed patterns ) . This process continues until no pattern exists in the stack . The final closed patterns are r3r4(4 ) , r1(3 ) , r2r3r4(3 ) , r4r1(2 ) , r3r4r1(2 ) , r1r2r3r4(2 ) , r2r3r4r1(2 ) . The patterns discovered from the substring tree are not the final results because they only contain patterns with distinct elements . We extend the patterns using the level wise method . The result may contain overlapping patterns like r1r2r3r4(2 ) and r2r3r4r1(2 ) . We report all of them though the pattern space may be large . The reason is that if we output only one of them , say r1r2r3r4(2 ) , the information that r4 connects to r1 ( necessary for generating longer patterns ) will be missed .
Finally , our algorithm outputs frequent closed patterns .
5 Experiments
This section evaluates our proposed approach with real and synthetic data . After discussing the way to set the parameters in Section 5.1 , we study the effectivesness and efficiency in Section 52
Real datasets : The real data contain tracked bus movements in Patras , Greece . Each sequence is the movement of a bus in a single day . The coordinates in the sequence are in meters following the EGSA84 projection ( A Greek coordinate system ) . Bus locations were sampled every 30 seconds . However , since a vehicle might stop intermittently and the GPS is switched off during that period , the movement in a sequence may not be straightly continuous . The series length varies in the range between 1000 to 7000 .
Synthetic data : We also generated long sequences to facilitate the performance study . The generator takes three parameters , |p| , n , and m . |p| is the number of line segments constituting circular paths ( ie , patterns ) of the movement . n denotes the sequence length . And m represents the number of times that the object repeats the patterns . Obviously , n > |p| × m . The generator first creates circular routes with |p| connected line segments . Then , it generates locations along the routes to simulate the object movement . The actual number of positions for each run is produced fl . In by adding/reducing some random values to/from fi n every run , the locations for each line segment are approximately the same . The description of the artificial series is given in related experiments . m
5.1 Setting the parameters
6
5
4
3
2
1
0
YR2 YR2 YR2 YR2 YR2 YR2 YR2 YR2 YR2 YR2 YR2 YR2 YR2
YR4 YR4 YR4 YR4 YR4 YR4 YR4 YR4 YR4 YR4 YR4 YR4 YR4
YR6 YR6 YR6 YR6 YR6 YR6 YR6 YR6 YR6 YR6 YR6 YR6 YR6
YR5 YR5 YR5 YR5 YR5 YR5 YR5 YR5 YR5 YR5 YR5 YR5 YR5
YR3 YR3 YR3 YR3 YR3 YR3 YR3 YR3 YR3 YR3 YR3 YR3 YR3
YR1 YR1 YR1 YR1 YR1 YR1 YR1 YR1 YR1 YR1 YR1 YR1 YR1
0
1
2
3
4
Figure 4 . Parameter estimation example
We employ a heuristic based on sampling , to determine the value of parameter . We choose a random sample from the dataset and keep only the locations , for which the x coordinates are very close to a set of x values , say x1 , x2 , x3 . For each value in the set , we cluster the y coordinates of the sample points and derive dense ranges of y values . For instance , in Figure 4 for x values x1 = 1 , x2 = 2 , x3 = 3 , we can identify 6 dense ranges Y R1 , Y R2 , . . . , Y R6 — denoted by the bold ( red in color mode ) vertical short line segments .
Proceedings of the Fifth IEEE International Conference on Data Mining ( ICDM’05 )
1550 4786/05 $20.00 © 2005 IEEE
10 9 8 7 6 5 4 3 2 1 0
52
0
1
2
3
4
5
6
7
98
10
9
8
7
6
5
51
5
6
7
8
9
( a ) Raw sequence
( b ) Partial sequence
7
6
5
5
7
6
6
( c ) Pattern 1
7
5
5
6
7
( d ) Pattern 2
10 9 8 7 6 5 4 3 2 1 0
0
1
2
3
4
5
6
7
98
7
6
5
5
6
5
5
6
7
6
( e ) Grid II ( G=10 )
( f ) Grid II ( G=20 )
( g ) Grid II ( G=100 )
Figure 5 . Raw sequence and patterns discovered
We define y as the average length of these y values . Similarly , x can be obtained . Finally , we set = min{ x , y} as smaller will allow pattern definition at a finer granularity . Experimentally , we found that , for most datasets , by setting to the estimated value ( even vary a little ) , θ to around 0.3 radians , and f to around 0.2 ( 20 % rule ) , our algorithm retrieves hidden patterns in the data , ie , pre scheduled paths for bus data and patterns generated for synthetic data .
5.2 Effectiveness and efficiency study
We examine the effectiveness of our method taking as input a raw bus movement sequence shown in Figure 5a , which contains 6921 locations . This movement exhibits partial regularity and consists of noise .
For visualization purpose , we show its interesting part in more detail in Figure 5b because the remainder contains noise segments appearing only once . According to the description in Section 5.1 , we tune the parameters to = 20 ( map size is 100 × 100 ) , f = 0.2 , θ = 0.3 radian , and min sup = 3 . In this movement , the frequently repeated paths are around cell c51 . Figure 5c and 5d show the two longest closed patterns discovered by our method . For simplicity , only the central line segments for the regions in the patterns are plotted . The arrow of each central line segment shows the movement direction inside that region and the connection of these directed line segments illustrates the movement from one region to another . They are not connected because of the noise movement near the boundary of grid 51 ( see Figure 5b ) . We also plot the results discovered by Grid II since it is more effective than Grid I . When G is 10 , the pattern discovered near cell 51 is c50c51c60 in Figure 5e ( movement from the region of cell c50 to cell c51 then to cell c60 ) . This is quite coarse , since the movement inside each cell is unknown . The longest closed patterns for G=20 and G=100 are shown in Figure 5f and Figure 5g . They improve on accuracy with the increase of G , however , the patterns in the cell above c51 ( related to pattern in Figure 5d ) is still missed . Furthermore , the mining efficiency degrades significantly . Our approach takes about 200ms , while Grid II with G = 100 takes about 450ms , which is more than double . In summary , the results show that our method can find hidden sequential patterns effectively . Given proper G , Grid II can also discover coarse movement patterns . However , it suffers from two disadvantages ( i ) the internal movement in a grid cell cannot be found ; ( ii ) it is less efficient than our method in finding patterns of similar quality .
We used synthetic data to evaluate the efficiency . We first analyze the performance of finding frequent singular patterns . The parameters of the data generator were set to |p| = 20 , n = 30K , and m = 50 in a map of size=1×1 . We set the mining parameters = 0.01 , f = 0.2 and θ = 0.3 , and vary min sup . The performance is shown in Table 1a . N umP1 is the number of frequent singular patterns and SR len is the length of SR . We observe that the time rises only when the increase of min sup brings the decrease of N umP1 . It is because the Growing method inspects more seeds before it finds satisfactory spatial regions when the resultant N umP1 is smaller . In the worst case , every segment in Segs need to be examined .
Table 1b compares the total time spent by our methods , and the grid methods which use the substring tree for finding longer patterns . The generating parameters are |p| = 100 , m = 50 , and n = 500K . The substring tree technique slightly outperforms the level wise method in all cases since it uses most time ( about 12s ) to find singular frequent pattern and most patterns contain long subpatterns with distinct elements . Their time is nearly constant to min sup because SR len is the same for different min sup . The grid methods
Proceedings of the Fifth IEEE International Conference on Data Mining ( ICDM’05 )
1550 4786/05 $20.00 © 2005 IEEE terns are found effectively , by grouping segments not only by similar shape ( like previous work in time series mining ) , but also by closeness in space . In addition , we employed special properties of the problem ( spatial connectivity , closeness ) and a newly proposed substring tree to accelerate search for longer patterns . Acknowledgements
The authors would like to thank Dieter Pfoser and CTI for providing us with the real bus dataset . Unfortunately , the data are copyrighted and cannot be made publicly available . The work was supported by grant HKU 7142/04E from Hong Kong RGC . References [ 1 ] R . Agrawal and R . Srikant . Mining sequential patterns . In Proc . of Intl . Conf . on Data Engineering , pages 3–14 , 1995 . [ 2 ] G . Das , K . I . Lin , H . Mannila , G . Renganathan , and P . Smyth . Rule discovery from time series . In Proc . of Intl . Conf . on Knowledge Discovery and Data Mining , pages 16–22 , 1998 . [ 3 ] D . H . Douglas and T . K . Peucker . Algorithms for the reduction of the number of points required to represent a digitized line or its caricature . In The Canadian Cartographer , Vol.10 , No.2 , pages 112–122 , 1973 .
[ 4 ] J . Han , J . Wang , Y . Lu , and P . Tzvetkov . Mining top k frequent closed patterns without minimum support . In Proc . of Intl . Conf . on Data Mining , pages 211–218 , 2002 .
[ 5 ] J . Hershberger and J . Snoeyink . Speeding up the douglaspeucker line simplification algorithm . In Proc . of the 5th Intl . Symposium on Spatial Data Handling(SDH ) , pages 134–143 , 1992 .
[ 6 ] E . Keogh , S . Chu , D . Hart , and M . Pazzani . An online algorithm for segmenting time series . In Proc . of Intl . Conf . on Data Mining , pages 289–296 , 2001 .
[ 7 ] E . Keogh , S . Lonardi , and B . Chiu . Finding surprising patterns in a time series database in linear time and space . In Proc . of ACM Knowledge Discovery and Data Mining , pages 550–556 , 2002 .
[ 8 ] J . Lin , E . Keogh , and W . Truppel . Clustering of streaming time series is meaningless . In Proc . of the SIGMOD workshop in Data Mining and Knowledge Discovery , pages 56– 65 , 2003 .
[ 9 ] N . Mamoulis , H . Cao , G . Kollios , M . Hadjieleftheriou , Y . Tao , and D . Cheung . Mining , indexing , and querying historical spatiotemporal data . In Proc . of Intl . Conf . on Knowledge Discovery and Data Mining , pages 236–245 , 2004 .
[ 10 ] H . Mannila , H . Toivonen , and A . I . Verkamo . Discovery of In Data Mining and frequent episodes in event sequences . Knowledge Discovery , Vol . 1 , pages 259–287 , 1997 .
[ 11 ] I . Tsoukatos and D . Gunopulos . Efficient mining of spatiotemporal patterns . In Proc . of Intl . Symp . on Spatial and Temporal Databases , pages 425–442 , 2001 .
[ 12 ] E . R . White . Assessment of line generalization algorithms using characteristic points . The American Cartographer , 12(1):17–27 , 1985 .
[ 13 ] J . Yang , W . Wang , P . S . Yu , and J . Han . Mining long sequenIn Proc . of SIGMOD tial patterns in a noisy environment . conf . , pages 406–417 , 2002 . min sup N umP1 ≤ 82 83,84 85 ≥ 86
18 11 3 2
SR len 1576 1268 423 339 time ( ms )
560 600 1130 1190
( a ) Time for discovering singular patterns vs . min sup time ( s ) for different min sup
Method
Level wise
Substring tree Grid I ( G = 10 ) Grid II ( G = 10 ) Grid I ( G = 20 ) Grid II ( G = 20 )
50
17.35 13.47 42.58 30.52 57.38 345.35
60
17.33 13.49 42.56 30.56 33.86 58.56
70
17.32 13.49 16.11 30.51 22.00 45.54
( b ) Total time vs . various min sup
Table 1 . Efficiency comparison take longer time , since the transformed cell ids sequence is much longer ( ie , n or higher ) than that of SR . When we increase G from 10 to 20 , the time increases sharply , since the number of cells quadruplicates and the sequence becomes much longer . Sometimes , Grid II may take less time than Grid I ( eg , for G=10 and min sup=50 and 60 ) . This happens because many cells in the sequence become outliers for this case , thus Grid II discovers shorter patterns ( whereas Grid I finds longer ones , since it does not introduce intermediate cells at a sharp movement ) .
) s ( e m i t
60 50 40 30 20 10 0
Find singular pattern Total mining task
0 0.2 0.4 0.6 0.8 1 1.2 1.4 1.6 data volume ( M )
Figure 6 . Scalability
Figure 6 tests the scalability of our method in using the substring tree . We generate the datasets , keeping |p| constant ( 50 ) and changing n ( the number of spatial locations in S ) from 50K to 15M The total cost is nearly linear to n , although it includes the cost for sorting the segments lengths and computing angle differences , which is about O(mlogm ) where m ( m ffi n ) is the number of segments . 6 Conclusion
In this paper , we modeled the problem of mining sequential patterns from spatio temporal data by considering both spatial and temporal information . Singular frequent pat
Proceedings of the Fifth IEEE International Conference on Data Mining ( ICDM’05 )
1550 4786/05 $20.00 © 2005 IEEE
