Generalized Graph Matching for Data Mining and Information Retrieval
Alexandra Br¨ugger1 , Horst Bunke1 , Peter Dickinson2 , and Kaspar Riesen1
1 Institute of Computer Science and Applied Mathematics , University of Bern ,
Neubr¨uckstrasse 10 , CH 3012 Bern , Switzerland
{bruegger,bunke,riesen}@iamunibech
2 C3I Division , DSTO , PO Box 1500 , Edinburgh SA 5111 , Australia peterdickinson@dstodefencegovau
ABSTRACT Graph based data representation offers a convenient possibility to represent entities , their attributes , and their relationships to other entities . Consequently , the use of graph based representation for data mining has become a promising approach to extracting novel and useful knowledge from relational data . In order to check whether a certain graph occurs , as a substructure , within a larger database graph , the widely studied concept of subgraph isomorphism can be used . However , this conventional approach is rather limited . In the present paper the concept of subgraph isomorphism is substantially extended such that it can cope with don’t care symbols , variables , and constraints . Our novel approach leads to a powerful graph matching methodology which can be used for advanced graph based data mining .
1 Introduction
In recent years powerful methods for knowledge mining and information retrieval have become available [ 1,2,3,4 ] . The vast majority of these mining and retrieval methods rely on data represented as a set of independent entities and their attributes . However , this approach does not consider a relevant part of the information in the underlying data , viz . the relationships between different entities . Graphs , which are in fact one of the most general forms of data representation , are able to represent not only the values of an entity , but can be used to explicitly model structural relations that may exist between different parts of an object [ 5,6 ] . This crucial benefit of graphs recently led to an emerging interest in graph based data mining [ 7 ] .
In the current paper , mining of graph data refers to the process of extracting useful knowledge from the underlying data represented as a large database graph . Typically , the extracted knowledge mined from the database graph is also a graph , which may be , for instance , a subgraph of the underlying database graph [ 7 ] . In the present paper the concept of subgraph isomorphism is employed for information retrieval from the database graph . Subgraph isomorphism , which
P . Perner ( Ed. ) : ICDM 2008 , LNAI 5077 , pp . 298–312 , 2008 . c . Springer Verlag Berlin Heidelberg 2008
Generalized Graph Matching for Data Mining and Information Retrieval
299 can be seen as a formal concept for checking subgraph equality , intuitively indicates that a smaller graph is contained in a larger graph . Let us assume that we represent a query by means of an attributed graph q , termed query graph . Given q and the database graph G , we can check whether the query graph q is contained in the underlying database G . That is , the knowledge mining system is able to come to a binary decision ( yes if q is a subgraph of G , and no otherwise ) . Yet , the use of conventional subgraph isomorphism in graph based data mining implicates some severe limitations . First of all , the underlying database graph often includes a rather large number of attributes , some of which might be irrelevant for a particular query . The second restriction arises from the limited answer format to a given query graph q . That is , conventional subgraph isomorphism is only able to check whether or not a query graph is embedded in a larger database graph and can thus answer only yes or no . Thirdly , subgraph isomorphism in its original mode does not allow constraints that may be imposed on the attributes of a query graph q to model restrictions or dependencies .
The generalized subgraph isomorphism methodology described in the present paper overcomes these three restrictions . First , the novel approach offers the possibility to mask out attributes in query graphs . To this end , don’t care values are introduced for attributes that are irrelevant for a particular query . Secondly , for the retrieval of more specific information from the database graph than just a binary decision yes or no , variables are used . By means of these variables we are able to retrieve values of predefined attributes in our database graph . Thirdly , through the concept of constrained variables , for example variables that can assume only values from a certain interval , we become able to define more specific queries .
Our work is somewhat related to the work presented in [ 8,9 ] . In [ 8 ] a visual language for querying and updating graph databases is introduced . In [ 9 ] another generalization of subgraph isomorphism is introduced . However , our approach is more rigorously embedded in a graph theoretical context . The novelty and main contribution of the present paper is a generalization of subgraph isomorphism that leads to a powerful and flexible graph matching framework suitable for general graph based data mining .
2 Graphs and Exact Graph Matching
The basic structures we are dealing with in this paper are attributed graphs , or graphs , for short .
Definition 1 ( Graph ) . A graph is a 4 tuple g = ( V , E , μ , ν ) , where
– V is the finite set of nodes – E ⊆ V × V is the set of edges – μ : V → {(t , x(t))|t ∈ Tnodes , x(t ) ∈ ( D1(t ) × . . . × Dnt(t))} is the node – ν : V × V → P({(t , x(t))|t ∈ Tedges , x(t ) ∈ ( D1(t ) × . . . × Dnt(t))} ) \ ∅ is the attribute function edge attribute function .
300
A . Br¨ugger et al .
Through the node attribute function μ , each node in a graph is labeled by a type and a number of attributes . Formally , function μ assigns a ( type,attribute) pair ( t , x(t ) ) to each node u ∈ V . The first component of a ( type,attribute) pair , t , denotes the type of node u . The type t is an element of a finite set of node types , Tnodes . The second component is an attribute vector , ie x(t ) = ( x1 , . . . , xnt ) , where each attribute , xi , belongs to some domain , Di(t ) . The dimension of vector x(t ) , ie the number nt of its attributes , as well as each individual attribute domain , Di(t ) , is dependent on the type t of the node . Edges are pairs of nodes , ( u , v ) ∈ V × V . According to Def . 1 , there exists at most one edge ( u , v ) from node u to node v . In some applications , it may be necessary to include more than one edge between the same two nodes , because of the existence of multiple relations . In the formal graph model provided in Def . 1 , this can be accomplished by assigning several ( type,attribute) pairs , ( t1 , x(t1) ) , . . . , ( tn , x(tn) ) , to an edge ( u , v ) by means of edge attribute function ν , ie ν(u , v ) = {(t1 , x(t1) ) , . . . , ( tn , x(tn))} . Note that the range of function ν is the power set of all ( type,attribute) pairs ( t , x(t) ) , where t is an edge type , ie an element of the finite set Tedges . Assigning ( t1 , x(t1) ) , . . . , ( tn , x(tn ) ) to edge ( u , v ) by means of ν is equivalent to providing n individual edges from node u to node v . The meaning of a pair ( t , x(t) ) , which is assigned to an edge by means of function ν is the same as for the nodes .
The identity of two graphs g1 and g2 is commonly established by defining a bijective function , termed graph isomorphism , mapping the nodes of g1 to the nodes of g2 such that the edge structure is preserved and the node and edge labels are consistent . In Fig 1 ( a ) and ( b ) two isomorphic graphs are shown .
( a )
( b )
( c )
Fig 1 . Graph ( b ) is isomorphic to ( a ) , and graph ( c ) is isomorphic to a subgraph of ( a ) . Node attributes are indicated by color .
Definition 2 ( Graph Isomorphism ) . Assume that two graphs g1 = ( V1 , E1 , μ1 , ν1 ) and g2 = ( V2 , E2 , μ2 , ν2 ) are given . A graph isomorphism is a bijective function f : V1 → V2 satisfying 1 . μ1(u ) = μ2(f(u ) ) for all nodes u ∈ V1 2 . for each edge e1 = ( u , v ) ∈ E1 , there exists an edge e2 = ( f(u ) , f(v ) ) ∈ E2 3 . for each edge e2 = ( u , v ) ∈ E2 , there exists an edge e1 = ( f −1(v ) ) ∈ such that ν1(e1 ) = ν2(e2 )
−1(u ) , f
E1 such that ν1(e1 ) = ν2(e2 )
Two graphs are called isomorphic if there exists an isomorphism between them .
Generalized Graph Matching for Data Mining and Information Retrieval
301
In contrast with the components of a feature vector , the nodes and edges cannot be ordered in general . Therefore , the problem of graph isomorphism is computationally very demanding . Standard procedures for testing graphs for isomorphism are based on tree search techniques with backtracking . The basic idea is that a partial node matching , which assigns nodes from the two graphs to each other , is iteratively expanded by adding new node to node correspondences . This is repeated until either the edge structure is violated or node or edge labels are inconsistent . In this case a backtracking procedure is initiated , ie the last node mappings are undone until a partial node matching is found for which an alternative extension is possible . Obviously , if there is no further possibility for expanding the partial node matching without violating the constraints , the algorithm terminates indicating that there is no isomorphism between the considered graphs . Conversely , finding a complete node to node correspondence without violating both structure and label constraints proves that the investigated graphs are isomorphic .
A popular algorithm implementing the idea of a tree search for graph isomorphism is described in [ 10 ] . More recent algorithms for graph isomorphism also based on the idea of tree search can be found in [ 11,12 ] .
Closely related to graph isomorphism is subgraph isomorphism , which can be seen as a concept describing subgraph equality . A subgraph isomorphism is a weaker form of matching in terms of requiring only that an isomorphism holds between a graph g1 and a subgraph of g2 . Intuitively , subgraph isomorphism is the problem to detect if a smaller graph is present in a larger graph . In Fig 1 ( a ) and ( c ) , an example of subgraph isomorphism is given .
Definition 3 ( Subgraph Isomorphism ) . Let g1 = ( V1 , E1 , μ1 , ν1 ) and g2 = ( V2 , E2 , μ2 , ν2 ) be graphs . An injective function f : V1 → V2 from g1 to g2 is a subgraph isomorphism if there exists a subgraph g ⊆ g2 such that f is a graph isomorphism between g1 and g .
Obviously , the tree search based algorithms for graph isomorphism [ 10,11,12 ] described above can be also applied to the subgraph isomorphism problem .
3 Generalized Subgraph Isomorphism for Information
Retrieval
Relational databases offer a popular possibility to represent relational structured data . Another approach recently emerged is that of representing the underlying data by means of graph based representation . In fact , the graph representation supports all aspects of the relational data mining process [ 7 ] . The approach to knowledge mining and information retrieval proposed in this paper is based on the idea of specifying a query by means of a query graph , possibly augmented by some constraints .
Definition 4 ( Query Graph ) . A query graph is a 4 tuple , q = ( V , E , μ , ν ) , where V , E , μ , and ν are the same as in an attributed graph ( see Def . 1 ) , except
302
A . Br¨ugger et al . for the domains Di(t ) of all node and edge attributes , xi . These domains include the don’t care symbol , − , and variables , X , from a finite set of variables , Σ . Any variable X ∈ Σ can not occur more than once in a query graph . Query graphs are more general than graphs following Def . 1 in the sense that the don’t care symbol and variables may occur as the values of attributes on the nodes or edges . The purpose of the variables is to define those attributes whose values are to be returned as an answer to a query ( we will come back to this point later ) . Furthermore variables may occur in a query because they may be used to express constraints on one or several attribute values .
Definition 5 ( Constraint ) . Let q = ( V , E , μ , ν ) be a query graph and Σ the set of all variables occurring in q . A constraint on set Σ is a condition on one or several variables from Σ that evaluates to true or false if we assign a concrete attribute value to each variable occurring in Σ .
Once the query graph has been construced by the user , it is matched against a database graph . The process of matching a query graph to a database graph essentially means that we want to find out whether there exists a subgraph isomorphism from the query to the database graph . Obviously , as our query graph may include don’t care symbols and variables , we need a more general notion of subgraph isomorphism . According to the next definition , we call such a generalized subgraph isomorphism a match between a query and a database graph . Definition 6 ( Match ) . Let q = ( V1 , E1 , μ1 , ν1 ) be a query graph , Σ the set of all variables occurring in q , C be a set of constraints on Σ , and G = ( V2 , E2 , μ2 , ν2 ) be an attributed graph , called the database graph . Query graph q matches database graph G if there exists an injective mapping f : V1 → V2 such that the following conditions hold : 1 . For each edge ( u , v ) ∈ E1 there exists an edge ( f(u ) , f(v ) ) ∈ E2 2 . For each node u ∈ V1 , let μ1(u ) = ( t , x(t ) ) = ( t , ( x1 , . . . , xn ) ) and fi fi m) ) ; then μ2(f(u ) ) = ( t , ( x 1 , . . . , x ( a ) t = t ( b ) if xi /∈ Σ and xi = − then xi = x fi ( c ) if xi ∈ Σ and there are one or several constraints from C imposed on i fi xi , then all these constraints are satisfied if the value of x i is substituted for xi 3 . For each edge ( u , v ) ∈ E1 let ν1(u , v ) = {(t1 , x(t1) ) , . . . , ( tk , x(tk))} and fi and n = m fi ) ) = ( t
, xfi(t fi fi s , xfi(t fi
1 , xfi(t fi fi 1) ) , . . . , ( t s))} ; then for each fi fi))=(t
ν2(f(u ) , f(v ) ) = {(t ( t , x(t))=(t , ( x1 , . . . , xn))∈ ν1(u , v ) there exists ( t such that ( a ) t = t ( b ) if xi /∈ Σ and xi = − then xi = x fi ( c ) if xi ∈ Σ and there are one or several constraints from C imposed on i fi xi , then all these constraints are satisfied if the value of x i is substituted for xi fi fi , ( x m ) ) 1 , . . . , x fi and n = m
, xfi(t fi fi
Generalized Graph Matching for Data Mining and Information Retrieval
303 fi ) ) matches Conditions 2 and 3 ensure that the ( type,attribute) pair ( t ( t , x(t ) ) under f . If a query graph q matches a database graph G , we call the injective function f a match between q and G . Note that for given q and G and a given set of constraints C over Σ , there can be zero , one , or more than one matches .
, xfi(t fi
For a match we require each edge of the query graph being included in the database graph ( condition 1 in Def . 6 ) . A node , u , can be mapped , via injective function f , only to a node of the same type ( condition 2a)1 If the ( type,attribute) pair of a node u of the query graph includes an attribute value xi then it is required that the same value occur at the corresponding position in the ( type,attribute) pair of the node f(u ) in the database graph ( condition 2b ) Don’t care symbols occuring in the ( type , attribute) pair of a node u will match any attribute value at the corresponding position in the ( type,attribute) pair of node f(u ) . Similarly , unconstrained variables match any attribute value at their corresponding position in f(u ) . In case there exist constraints on a variable in the query graph , the attribute values at the corresponding positions in f(u ) must satisfy these constraints ( condition 2c ) The conditions 3.a to 3.c imposed on the ( type , attribute) pairs of edges are similar to 2.a to 2c
To query a given database graph G we not only need a query graph q and a set of constraints C over the variables occurring in q , but also a set of answer variables A ⊆ Σ . An answer variable is a variable occurring in the query graph . By means of answer variables we indicate which attribute values are to be returned by our knowledge mining system as an answer to a query . Therefore , the answer to a query can be no , if there is no such structure as the query graph contained as a substructure in the database graph , or yes if the query graph exists ( at least once ) as a substructure in the database graph and the query graph does not contain any answer variables . In the case where answer variables are defined in the query graph and one or several matches are found , for each match , fj , an fi fi individual answer is generated . An answer is of the form X1 = x 1 , . . . , Xn = x fi n where X1 , . . . , Xn are the answer variables occurring in set A and x i are the values of the attributes in the database graph that correspond to the variables Xi under match fj .
In Fig 2 an example of a query graph ( Fig 2 ( a ) ) and database graph ( Fig 2 ( c ) ) are illustrated . In this illustration nodes are of the type person and labeled with the person ’s first and second name , and e mail address . Edges are of the type e mail and labeled with the e mail ’s subject , the date , and the size2 . We can easily verify that there exists a subgraph isomorphism from the query graph ( Fig 2 ( a ) ) to the database graph ( Fig 2 ( c) ) . In Fig 2 ( b ) an example of a query graph with variables ( X , Y ) and don’t care symbols ( − ) is given . In contrast with the query graph given in Fig 2 ( a ) we are now particularly interested in the subject ( X ) and the date ( Y ) of the e mail sent from John Arnold to Ina Rangel ( if there exists such an e mail ) .
1 Note that the condition n = m actually follows from t = t‘ . 2 Note that in general there may occur nodes as well as edges of different type in the same graph .
304
A . Br¨ugger et al . e mail(Slides , 10/4/00 , 2K ) e mail(X , Y , ) person(Jennifer , Fraser , fraser@mail.com ) e mail(Paper , 11/4/00 , 5K ) e mail(Deadline ,
8/4/00 , 1K ) e mail(Slides , 10/4/00 , 2K ) person(John , Arnold , arnold@mail.com ) person(Ina , Rangel , rangel@mail.com ) person(John , Arnold , arnold@mail.com ) person(Ina , Rangel ,
) person(John , Arnold , arnold@mail.com ) person(Ina , Rangel , rangel@mail.com )
( a ) Query graph
( b ) Query graph with variables and don’t care symbols
( c ) Database graph
Fig 2 . A subgraph isomorphism from the query to the database graph
As we do not care about the size of the e mail and we do not know the e mail address of Ina Rangel , two don’t care symbols are used . Obviously , there is a match between this query graph and the database graph in Fig 2 ( c ) . Hence , the variables are linked by X = Slides and Y = 10/4/00 . If the query in Fig 2 ( b ) is augmented by the constraint that the e mail has to be sent between October 1 and October 3 ( formally 9/31/00 < Y < 10/4/00 ) no match can be established as the linkage of variable Y violates the constraint imposed on the query .
Next we describe an algorithm for finding matches between a query and a database graph . The procedure given in Algorithm 1 checks two given graphs , q and G , whether there exists a match from q to G by constructing all possible mappings f : V1 → V2 and checking the conditions of Def . 6 . The algorithm uses a set OPEN to store a set of partial matches . A partial match is a set of pairs , {(u1 , vi1 ) , . . . , ( uk , vik)} , where f(u1 ) = vi1 , . . . , f(uk ) = vik . If a partial match is included in OPEN , it has been verified before that all its pairs fulfil the conditions of Def . 6 . Initially , OPEN is empty . In lines 2 to 6 , the first node of V1 , u1 , is matched against all nodes , w , of V2 and any pair ( u1 , w ) that satisfies the Boolean predicate feasible is added to OPEN as a partial match3 . In the main loop of the algorithm , from lines 7 to 18 , any partial match , {(u1 , vi1 ) , . . . , ( uk , vik)} , retrieved from OPEN , is first checked for completeness in line 9 . If the considered partial match is complete , the algorithm outputs match {(u1 , vi1 ) , . . . , ( uk , vik)} as the solution and terminates . If partial match {(u1 , vi1 ) , . . . , ( uk , vik)} is not complete , ie k < n , then it is extended by one additional pair ( uk+1 , w ) . This extension is done for all nodes , w , in V2 that are not yet included in {(u1 , vi1 ) , . . . , ( uk , vik)} . If the extended set of pairs,{(u1 , vi1 ) , . . . , ( uk , vik)} ∪ {(uk+1 , w)} satisfies Boolean predicate feasible , it is added to open . Otherwise it is discarded .
The Boolean predicate feasible is used to verify that a partial match satisfies all conditions stated in Def . 6 . In line 3 of the algorithm , as there are no edges included in the partial match under consideration , only condition 2 needs to be checked . In line 14 , partial match {(u1 , vi1 ) , . . . , ( uk , vik)} has already been checked for feasibility . Therefore , we only need to check condition 2 for nodes
3 For the purpose of computational efficiency , it is advisable to process nodes and edges with more constraints and fewer variables and don’t care symbols first . Fewer nodes and edges of this type will survive the feasibility test , which results in a search with fewer alternatives .
Generalized Graph Matching for Data Mining and Information Retrieval
305 uk+1 and f(uk+1 ) = w , and conditions 1 and 3 for all edges that start or end at uk+1 or w .
Algorithm 1 terminates as soon as it has found the first match from q to G . However , if we explicitly consider the situation of multiple matches , f1 , . . . , fn , it takes only a small modification to change the algorithm in such a way that it finds and outputs all matches from q to G . We only need to replace the terminate statement in line 11 by a statement to re enter the main loop starting in line 7 . The matching algorithm given in Algorithm 1 is exponential . However , as the underlying query graphs are often limited in size and due to the fact that the attributes and constraints limit the potential search space for a match , the computational complexity of our algorithm is expected to be still manageable , as shown in the experiments reported in Section 4 .
Algorithm 1 . Algorithm for finding a match between a query graph q to a database graph G Input : q = ( V1 , E1 , μ1 , ν1 ) , where V1 = {u1 , . . . , un} , G = ( V2 , E2 , μ2 , ν2 ) , where V2 = {v1 , . . . , vm} , a set of constraints , C , over the variables occurring in q injective mapping f : V1 → V2 , given as f = {(u1 , vi1 ) , ( u2 , vi2 ) , . . . , ( un , vin )}
Output : add partial match {(u1 , w)} to OPEN remove the first element , {(u1 , vi1 ) , . . . , ( uk , vik )} from OPEN if k = n then output{(u1 , vi1 ) , . . . , ( uk , vik )} as the solution and if feasible[{(u1 , w)} ] then
1 : initialise OPEN to be the empty set 2 : for each node w ∈ V2 do 3 : 4 : 5 : end if 6 : end for 7 : while OPEN is not empty do 8 : 9 : 10 : 11 : 12 : 13 : 14 : 15 : 16 : end if 17 : end for 18 : end while 19 : terminate for each w ∈ V2 \ {vi1 , . . . , vik terminate end if
} do if feasible[{(u1 , vi1 ) , . . . , ( uk , vik )} ∪ {(uk+1 , w)} ] then add partial match {(u1 , vi1 ) , . . . , ( uk , vik ) , ( uk+1 , w)} to OPEN
4 Experimental Results
The experiments described in this section are conducted on three real world data sets , viz . the Enron data set [ 13 ] , the AIDS data set [ 14 ] , and the Internet Movie Database [ 15 ] . The intention of the experiments is twofold . First , we want to show the power and flexibility of the proposed concept of extended subgraph isomorphism and its applicability to general information retrieval tasks of relational data . Therefore we give several examples of query graphs and their corresponding results . Secondly , an evaluation of the performance of the algorithm is conducted . We are in particular interested in the behavior of our system when parameters in
306
A . Br¨ugger et al . the query graph are changed systematically . For our tests a CPU Intel Core Duo 2GHz is used . The matching framework is implemented in Java .
4.1 Enron Database
The Enron corpus – a large set of e mail messages – has been made publicly available during the legal investigation concerning the Enron corporation [ 13 ] . The Enron corpus contains e mail messages belonging to 159 users . The underlying data is converted into a graph by representing the senders and addressees as nodes , attributed with their corresponding first and last name , and e mail address . Note that not only the 159 users are converted into nodes but any person appearing as a sender or addressee in the mail folders of the corpus . Each e mail that was sent is represented by an edge labeled with the file path , the subject , the date , and the size . The complete data set consists of 70,400 nodes and 203,865 edges4 .
In Fig 3 two example queries for the Enron database graph are illustrated . The first query ( Fig 3 ( a ) ) in conjunction with the constraint U = Z corresponds to the question : “ which person has written an e mail to Jennifer Fraser and Ina Rangel on the same day ? ” That is , there are four variables defined by A = {X , Y , U , Z} . The second query ( Fig 3 ( b ) ) in conjunction with the constraint D < E < D + 2h is of much higher complexity . The corresponding question is : “ which person has first written an e mail to John Arnold and then within two hours to Caroline Abramo ? ” Furthermore , we want to find out the subject and date of the two e mails . We request that there is at least one e mail sent by Caroline Abramo to John Arnold and we want to get the subject and date of all these e mails . Hence , there are eight variables A = {A , B , C , D , E , F , X , Y } . Our information retrieval system finds 13 possible answers to the first query . One of these answers is , for instance , A = {X = John , Y = Arnold , U = 10/4/00 , 9.18 AM , Z = 10/4/00 , 9.12 AM} . In order to retrieve all answers it takes our system only about 6 seconds . For the second query , however , 4 minutes are needed to find all possible answers . That is , running time crucially depends on the query graph to be found in the database graph .
In Fig 4 the run time of processing queries is plotted as a function of the query graph size ( Fig 4 ( a ) ) and as a function of the number of variables used in the query graph ( Fig 4 ( b) ) . The queries of Fig 4 ( a ) are defined according to three different scenarios . All scenarios have in common that the number of nodes ( senders or addressees ) is iteratively incremented by one . That is , starting with a query graph with two nodes , one additional node ( and a corresponding edge ) is iteratively added to the query graph until it consists of eight nodes totally . Three different query graphs are used for the scenarios plotted in Fig 4 ( b ) . For each of these query graphs the number of variables is iteratively incremented from zero to ten in steps of one .
It turns out that both the size of the query graph and the number of variables crucially influence the retrieval time . Clearly , the more nodes or variables the
4 Note that nodes and edges are solely of type person and e mail , respectively .
Generalized Graph Matching for Data Mining and Information Retrieval
307 person(X , Y , ) e mail( , , U , ) e mail( , , Z , ) person(Ina , Rangel , ) person(Jennifer , Fraser , ) person(X , Y , ) e mail( , A , D , ) e mail( , B , E , ) e mail( , C , F , ) person(John ,
Arnold , ) person(Caroline ,
Abramo , )
( a )
( b )
Fig 3 . Query graphs to the Enron database graph
( a )
( b )
Fig 4 . Retrieval time as a function of the number of nodes ( a ) and variables ( b ) in the query graph query graph contains , the slower the system is . However , query graphs with about eight nodes , which are in fact rather complex subgraphs in real world applications , are typically still processed below one second . Also a high number of variables weakens the system ’s performance . The proposed graph matching approach , however , copes well in general with up to about seven variables in the query graph which , again , allows quite complex queries .
4.2 AIDS Database
The AIDS data set consists of graphs representing molecular compounds . We construct graphs from the AIDS Antiviral Screen Database of Active Compounds [ 14 ] . Our molecule database consists of two classes ( active , inactive ) , which represent molecules with activity against HIV or not . The molecules are converted into graphs in a straightforward manner by representing atoms as nodes and the covalent bonds as edges . Hence , there is only one type for both nodes ( atom ) and edges ( bond ) . Nodes are labeled with the number of the corresponding chemical symbol and edges by the valence of the linkage . The complete data set consists of 42,689 molecular compounds which serve as a database graph . In order to test our information retrieval system on the AIDS data set , we define 20 molecular compounds as query graphs . Three of these compounds are illustrated in Fig 5 . Note that different shades of grey represent different chemical symbols , ie node labels . For the sake of readability the type of nodes and edges is not indicated .
308
A . Br¨ugger et al .
C
C
C
C
C
C
( a )
C
C
C
S
S
C
( b )
C
C
S
N
C
C
( c )
N
Fig 5 . Four examples of user defined molecular compounds
C
C
C
C
O
C
N
C
C
C
C
C
C
C
C
C
( a )
O
N
N
O
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
S
C
C
S
C
C
N
N
( c )
C
C
C
C
S
S
( b )
O
Fig 6 . Three molecular compounds of the original database graph where the user defined query graphs from Figure 5 are found as substructures
Given a certain query graph , our information retrieval system outputs all molecular compounds that contain the considered substructure . In Fig 6 examples of successful matches for each query graph from Fig 5 are shown . Note that these matches are not necessarily unique . In Fig 6 ( a ) the illustrated match is one out of 32 different possibilities ( 16 permuations per carbon cube ) , Fig 6 ( b ) shows one match from a total of nine possibilities , and in Fig 6 ( c ) there are two possibilities for a positive match . Depending on the algorithm ’s termination criterion , only one or all possible solutions are returned by the system .
In Fig 7 the total number of matches of the individual query graphs with the database graph and the total running time for performing the retrieval task are plotted as functions of the 20 individual substructures . Note that all substructures ( with the exception of query graph 5 which is illustrated in Fig 5 ( b ) ) are processed within at most 12 minutes . Most query graphs are processed in about three minutes . Clearly , the number of matches crucially depends on the structure and labels of the query graph , ie it varies from 30 up to 30,924 matches achieved with complex and rather simple query graphs , respectively .
As seen on the preceding data set , our novel information retrieval framework is able to cope with more complex query graphs than simple subgraph isomorphism tests . Fig 8 ( a ) , for instance , shows a query graph with answer variables A = {X , Y } . This query graph with constraints X = Y , X = C , Y = C represents the question if there exist molecular compounds with circular substructures consisting of four carbon atoms and two opposing non carbon atoms with the same chemical symbol in the database graph . In this example , besides the output of the original molecular compound from the database graph that contains
Generalized Graph Matching for Data Mining and Information Retrieval
309
Fig 7 . The number of matches in the database graph and the total run time for each of the 20 query graphs
C
C
C
C
N
P
C
C
C
C
P
C
C
C
C
C
C
( b )
C
X
C
C
Y
C
( a )
Fig 8 . Query graph and example solution from the database graph the required substructure ( Fig 8 ( b) ) , the answer variables A are linked by X = Y = P .
4.3 Internet Movie Database
The Internet Movie Database ( IMDb ) [ 15 ] maintains a large collection of movie and television information , which is publicly available . We use a subset of the whole dataset with 10,000 movie entities and 73,927 actor entities . Both types of entities are represented by nodes . Hence , there are two types of nodes ( movie and actor ) . The movie nodes are attributed with the corresponding genre , the title , a description , the year , the language , the type , and the country . Actor nodes are labeled with the first and last name of the corresponding actor . The 83,927 nodes are linked by 107,969 directed edges which represent relationships between actors and movies , ie the edges are labeled with the role a certain actor plays in the movie . Consequently , role is the sole edge type .
In Fig 9 two example queries for the IMDb graph are illustrated . The first query ( Fig 9 ( a ) ) represents the question : “ which actors play in which roles in the movie with the title “ Huff ” released in 2004 ? ” The answer variables are given by A = {U , X , Y } and there are no constraints . The second query ( Fig 9 ( b ) ) corresponds to the question : “ in which movies the actors Todd Berger and James Duval play together ? ” In addition to the title of the movie , we are interested in the roles both actors play , and where and when these movies were shot .
310
A . Br¨ugger et al . role(U ) actor(X , Y ) movie( , Huff , ,
2004 , English , , USA )
( a ) role(U ) role(V ) actor(Todd , Berger ) movie( , X , , actor(James , Duval )
Y , , , Z )
( b )
Fig 9 . Query graphs to the IMDb database graph role(U ) role(V ) actor(Tod , Berger ) movie( , X , , actor(Jame , Duval )
Y , , , Z )
Fig 10 . Misspellings in the query graph
Hence , the answer variables are given by A = {U , V , X , Y , Z} and there are no constraints .
For the first query our information retrieval system returns a list with 14 actors playing in the film “ Huff ” with their corresponding role , ie , for instance , A = {U = Craig Huffstodt , Y = Azaria , X = Hank} . For this retrieval task our system uses less than a second . For the second query only one answer is returned ; A = {U = Darryl Donaldson , V = Himself , X = '1 Fan : A Darkomentary , Y = 2005 , Z = USA} . For this retrieval operation the system also uses less than a second .
The proposed system described so far does not return any information from the database graph whenever no match is found . However , in some cases this behavior may be undesirable . Let us assume , for instance , a query graph as shown in Fig 10 is given . Obviously , this query represents the same query as defined in Fig 9 ( b ) . Note , however , that there are two misspellings in the actors’ names ( Tod and Jame instead of Todd and James ) . The graph matching framework presented so far merely returns the answer no as it finds no match in the database graph5 .
However , we can easily endow the novel graph isomorphism framework presented so far with a certain tolerance to errors . To this end we make use of graph edit distance [ 16 ] . Graph edit distance defines the dissimilarity of two graphs by the minimal amount of distortion that is needed to transform one graph into the other . Hence , in cases when no perfect match of the query graph to the database graph is possible , the query is minimally modified such that a match becomes possible . The modifications used in this paper are given by deletions of nodes and edges and substitutions of node and edge labels in the query graph . Furthermore , we also allow violations of constraints imposed on the variables .
Using our system in this extended fashion , approximate results will be returned whenever no perfect match is found . That is , for the misspelled query graph illustrated in Fig 10 the same answer is returned as for the query graph
5 One can think of similar situations in the two other data sets ( eg different valences of covalent bonds in a molecular compound ) .
Generalized Graph Matching for Data Mining and Information Retrieval
311 given in Fig 9 ( b ) . An additional comment is added making the user aware of the two label substitutions performed on the original query .
5 Conclusions
Data mining is an important area of study in both industry and the scientific community . In the present paper we focus on mining data represented by graphs . Graph based representation is particularly interesting because of its suitability for mining relational data . In order to find out whether a query graph is contained in a large database graph , the concept of subgraph isomorphism can be employed . However , since conventional subgraph isomorphism does not allow us to use don’t care symbols , variables , and constraints on the query graph , the concept is rather limited with respect to general information retrieval tasks . Therefore , we provide a substantial extension of subgraph isomorphism which overcomes these limitations . The resulting graph matching framework is characterized by its high flexibility and power . With several experiments on three real world data sets , we prove the applicability of our approach in graph based data mining in quite different application fields . Though the problem of subgraph isomorphism is NP complete , our framework accomplishes the matchings quite efficiently in practice . By means of the extension with graph edit distance we are able to endow the presented framework with a certain error tolerance such that approximate matches become possible . This is in particular interesting when it is not possible or not desirable to define a query graph which perfectly matches the database graph .
A possible extension of the presented methodology is the generalization of our framework to the domain of hypergraphs [ 17 ] . Such an extension , which can be done in a straightforward way , would result in greatly enhanced modelling capabilities . That is , representing n ary relationships among n entities in the graph is rather difficult with binary edges . However , with hyperedges , which connect n nodes simultaneously , such representations can be easily done .
References
1 . Perner , P . , Rosenfeld , A . : MLDM 2003 . LNCS , vol . 2734 . Springer , Heidelberg
( 2003 )
2 . Perner , P . , Imiya , A . ( eds. ) : MLDM 2005 . LNCS ( LNAI ) , vol . 3587 . Springer ,
Heidelberg ( 2005 )
3 . Perner , P . ( ed. ) : ICDM 2006 . LNCS ( LNAI ) , vol . 4065 . Springer , Heidelberg ( 2006 ) 4 . Perner , P . ( ed. ) : MLDM 2007 . LNCS ( LNAI ) , vol . 4571 . Springer , Heidelberg ( 2007 ) 5 . Conte , D . , Foggia , P . , Sansone , C . , Vento , M . : Thirty years of graph matching in pattern recognition . Int . Journal of Pattern Recognition and Artificial Intelligence 18(3 ) , 265–298 ( 2004 )
6 . Kandel , A . , Bunke , H . , Last , M . ( eds. ) : Applied Graph Theory in Computer Vision and Pattern Recognition . Studies in Computational Intelligence , vol . 52 . Springer , Heidelberg ( 2007 )
312
A . Br¨ugger et al .
7 . Cook , D . , Holder , L . ( eds. ) : Mining Graph Data . Wiley Interscience , Chichester
( 2007 )
8 . Blau , H . , Immerman , N . , Jensen , D . : A visual query language for relational knowl edge discovery . Technical report , University of Massachusetts ( 2001 )
9 . Marcus , S . , Moy , M . , Coffman , T . : Social Network Analysis . In : Cook , D . , Holder , L . ( eds . ) Mining Graph Data , pp . 443–467 . Wiley Interscience , Chichester ( 2007 ) 10 . Ullman , J . : An algorithm for subgraph isomorphism . Journal of the Association for Computing Machinery 23(1 ) , 31–42 ( 1976 )
11 . Cordella , L . , Foggia , P . , Sansone , C . , Vento , M . : A ( sub)graph isomorphism algorithm for matching large graphs . IEEE Trans . on Pattern Analysis and Machine Intelligence 26(20 ) , 1367–1372 ( 2004 )
12 . Larrosa , J . , Valiente , G . : Constraint satisfaction algorithms for graph pattern matching . Mathematical Structures in Computer Science 12(4 ) , 403–422 ( 2002 )
13 . Klimt , B . , Yang , Y . : Introducing the Enron corpus . In : Proc . First Conference on
Email and Anti Spam , CEAS ( Electronic Proceedings)(2004 )
14 . DTP , DTP : Aids antiviral screen ( 2004 ) , http://dtpncinihgov/docs/aids/aids data.html
15 . The Internet Movie Database , http://wwwimdbcom 16 . Bunke , H . , Allermann , G . : Inexact graph matching for structural pattern recogni tion . Pattern Recognition Letters 1 , 245–253 ( 1983 )
17 . Bunke , H . , Dickinson , P . , Kraetzl , M . : Theoretical and algorithmic framework for hypergraph matching . In : Roli , F . , Vitulano , S . ( eds . ) ICIAP 2005 . LNCS , vol . 3617 , pp . 463–470 . Springer , Heidelberg ( 2005 )
