Bayesian analysis of massive datasets via particle filters
Greg Ridgeway
RAND
PO Box 2138
Santa Monica , CA 90407 2138 gregr@rand.org
ABSTRACT Markov Chain Monte Carlo ( MCMC ) techniques revolutionized statistical practice in the 1990s by providing an essential toolkit for making the rigor and flexibility of Bayesian analysis computationally practical . At the same time the increasing prevalence of massive datasets and the expansion of the field of data mining has created the need to produce statistically sound methods that scale to these large problems . Except for the most trivial examples , current MCMC methods require a complete scan of the dataset for each iteration eliminating their candidacy as feasible data mining techniques .
In this article we present a method for making Bayesian analysis of massive datasets computationally feasible . The algorithm simulates from a posterior distribution that conditions on a smaller , more manageable portion of the dataset . The remainder of the dataset may be incorporated by reweighting the initial draws using importance sampling . Computation of the importance weights requires a single scan of the remaining observations . While importance sampling increases efficiency in data access , it comes at the expense of estimation efficiency . A simple modification , based on the “ rejuvenation ” step used in particle filters for dynamic systems models , sidesteps the loss of efficiency with only a slight increase in the number of data accesses .
To show proof of concept , we demonstrate the method on a mixture of transition models that has been used to model web traffic and robotics . For this example we show that estimation efficiency is not affected while offering a 95 % reduction in data accesses .
1 .
INTRODUCTION
The need for rigorous statistical analysis has not gone unnoticed in the data mining community . Statistical concepts such as latent variables , spurious correlation , and problems involving model search and selection have appeared in widely noted data mining literature [ 6 , 12 ] . However , algorithms , model fitting methods that actually work on massive data
David Madigan
Department of Statistics
477 Hill Center
Rutgers University
Piscataway , NJ 08855 madigan@statrutgersedu sets , have been slow to appear .
Bayesian analysis is a widely accepted paradigm for estimating unknown parameters from data . In applications with small to medium sized datasets , Bayesian methods have found great success in statistical practice . In particular , applied statistical work has seen a surge in the use of Bayesian hierarchical models for modeling multilevel or relational data [ 3 ] in a variety of fields including health and education . Spatial models in agriculture , image analysis , and remote sensing often utilize Bayesian methods and invariably require heavy computation ( see [ 1 ] for an overview ) . As shown in [ 7 ] , kernel methods also have a convenient Bayesian formulation , producing posterior distributions over a general class of prediction models . The power of Bayesian analysis comes from the transparent inclusion of prior knowledge , a more natural probabilistic interpretation of parameter estimates , and greater flexibility in model specification .
While Bayesian models and the computational tools behind them has revolutionized the field , they continue to rely on algorithms that perform thousands even millions of laps through the dataset in order to produce estimates of the posterior distribution of the model parameters . For massive datasets Bayesian methods still begin by a “ load data into memory ” step , make compromising assumptions , or resort to subsampling to skirt the issue .
If the most severe penalty comes when requesting data , algorithms might exist that only use a small manageable portion of the dataset at any one time . This paper proposes such an algorithm . It performs a rigorous Bayesian computation on a small , manageable portion of the dataset and adapts those calculations with the remaining observations . The adaptation attempts to minimize the number of times the algorithm loads each observation into memory .
2 . TECHNIQUES FOR BAYESIAN
COMPUTATION
Except for the simplest of models and regardless of the style of inference , estimation algorithms almost always require repeated scans of the dataset . We know that for well behaved likelihoods and priors , the posterior distribution converges to a multivariate normal [ 4 , 15 ] . For large but finite samples this approximation works rather well on marginal distributions and lower dimensional conditional distributions but does not always provide an accurate approximation to the full joint distribution [ 8 ] . The normal approximation also assumes that one has the maximum likelihood estimate for the parameter and the observed or ex pected information matrix . Even normal posterior approximations and maximum likelihood calculations can require heavy computation . Newton Raphson type algorithms for maximum likelihood estimation require several scans of the dataset , at least one for each iteration . When some observations also have missing data , the algorithms ( EM , for example ) likely will demand even more scans . For some models , dataset sizes , and applications these approximation methods may work and be preferable to a full Bayesian analysis . This will not always be the case and so the need exists for improved techniques to learn accurately from massive datasets .
Summaries of results from Bayesian data analyses often are in the form of expectations such as the marginal mean , variance , and covariance of the parameters of interest . We compute the expected value of the quantity of interest , h(θ ) , using
E(h(θ)|x1 , . . . , xN ) = h(θ)f ( θ|x1 , . . . , xN )dθ
( 1 ) where f ( θ|x ) , is the posterior distribution of the parameters given the observed data . Computation of these expectations requires calculating integrals that , for all but the simplest examples , are difficult to compute in closed form . Monte Carlo integration methods sample from the posterior , f ( θ|x ) , and appeal to the law of large numbers to estimate the integrals ,
( 2 ) lim M→∞
1 M h(θi ) = h(θ)f ( θ|x1 , . . . , xN )dθ
M:i=1 where the θi compose a sample from f ( θ|x ) . The ability to compute these expectations efficiently is equivalent to being able to sample efficiently from f ( θ|x ) . Sampling schemes are often difficult enough without the burden of large datasets . The additional complexity of massive datasets usually causes each iteration of the Monte Carlo sampler to be slower . When the number of iterations already needs to be large , efficient procedures within each iteration are essential to timely delivery of results . 2.1 Importance sampling
Importance sampling is a general Monte Carlo method for computing integrals . As previously mentioned , Monte Carlo methods approximate integrals of the form ( 1 ) . The approximation in ( 2 ) depends on the ability to sample from f ( θ|x ) . When a sampling mechanism is not readily available for the “ target distribution , ” f ( θ|x ) , but one is available for another “ sampling distribution , ” g(θ ) , we can use importance sampling . Note that for ( 1 ) we can write g(θ)dθ ( 3 ) wih(θi )
( 4 ) h(θ)f ( θ|x1 , . . . , xN )dθ = h(θ ) M:i=1
= lim M→∞ f ( θ|x ) g(θ ) where θi is a draw from g(θ ) and wi = f ( θi|x)/g(θi ) . Note that the expected value of wi under g(θ ) is 1 . Therefore , if we are able to compute the importance sampling weights , wi , only up to a constant of proportionality , we can normalize the weights to compute the integral . h(θ)f ( θ|x1 , . . . , xN )dθ = lim
M→∞2M 2M i=1 wih(θi ) i=1 wi
( 5 )
Naturally , in order for the sampling distribution to be useful , drawing from g(θ ) must be easy . We also want our sampling distribution to be such that the limit converges quickly to the value of the integral . If the tails of g(θ ) decay faster than f ( θ|x ) the weights will be numerically unstable . If the tails of g(θ ) decay much more slowly than f ( θ|x ) we will frequently sample from regions where the weight will be close to zero , wasting computation time . Second to sampling directly from f ( θ|x ) , we would like a sampling distribution slightly fatter than f ( θ|x ) . In section 2.3 we show that when we set the sampling density to be f ( θ|x1 , . . . , xn ) , where n ( cid:191 ) N so that we condition on a manageable subset of the entire dataset , the importance weights for each sampled θi require only one sequential scan of the remaining observations . Before beginning that discussion , the next section introduces the most popular computational method for Bayesian analysis of complex models .
2.2 Markov chain Monte Carlo
While a large group of statisticians have long felt that Bayesian analysis is appropriate for a wide class of problems , practical estimation methods were not available until Markov chain Monte Carlo ( MCMC ) techniques became available . Importance sampling is a useful tool , but for complex models crafting a reasonable sampling distribution can be extremely difficult . The excellent collection [ 11 ] contains a more detailed introduction to MCMC along with a variety of interesting examples and applications . As with importance sampling , the goal is to generate a set of draws from the posterior distribution f ( θ|x ) . Rather than create independent draws and reweight , MCMC methods build a Markov chain , a sample of dependent draws , θ1 , . . . , θM , that have stationary distribution f ( θ|x ) . It turns out that it is often easy to create such a Markov chain with a few basic strategies . However , there is still a bit of art involved in creating an efficient chain and assessing the chain ’s convergence .
Figure 1 shows the Metropolis Hastings algorithm [ 13 , 17 ] , a very general MCMC algorithm . Assume that we have a single draw θ1 from f ( θ|x ) and a proposal distribution for a new draw , q(θ|θ1 ) . If we follow step 2 of the MCMC algorithm then the distribution of θ2 will also be f ( θ|x ) . This is one of the key properties of the algorithm . Iterating this algorithm we will obtain a sequence θ1 , . . . , θM that has f ( θ|x ) as its stationary distribution .
MCMC methods have two main advantages that make them so useful for Bayesian analysis . First , we can choose q ’s from which sampling is easy . Any q that does not deterministically propose values and is capable of eventually visiting any value of θ will make the algorithm sample from the desired distribution . Special choices for q , which may or may not depend on the data , simplify the algorithm . If q is symmetric , for example a Gaussian centered on θi−1 , then the entire proposal distributions cancel out in ( 6 ) . If we choose a q that proposes values that are very close to θi−1 then it will almost always accept the proposal but the chain will move very slowly and take a long time to converge to the stationary distribution . If q proposes new draws that are far from θi−1 and outside the region with most of the posterior mass , the proposals will almost always be rejected and again the chain will converge slowly . With a little tuning the proposal distribution can usually be adjusted so that proposals are not rejected or accepted too frequently . The second advantage is that there is no need to compute the normalization constant of f ( θ|x ) since it cancels out in ( 6 ) . The Gibbs sampler [ 9 ] is a special case of the MetropolisHastings algorithm and is especially popular . If θ is a multidimensional parameter , the Gibbs sampler sequentially updates each of the components of θ from the full conditional distribution of that component given fixed values of all the other components and the data . For many models used in common practice , even the ones that yield a complex posterior distribution , sampling from the posterior ’s full conditionals is often a relatively simple task . Conveniently , the acceptance probability ( 6 ) always equals 1 and yet the chains often converge relatively quickly . The example in section 4 utilizes a Gibbs sampler and goes into further detail of the example ’s full conditionals .
MCMC as specified , however , is computationally infeasible for massive datasets . Except for the most trivial examples , computing the acceptance probability ( 6 ) requires a complete scan of the dataset . Although the Gibbs sampler avoids the acceptance probability calculation , precalculations for simulating from the full conditionals of f ( θ|x ) require a full scan of the dataset , sometimes a full scan for each component! Since MCMC algorithms produce dependent draws from the posterior , M usually has to be very large to reduce the amount of Monte Carlo variation in the posterior estimates . While MCMC makes fully Bayesian analysis practical it seems dead on arrival for massive dataset applications .
Although this section has not given great detail about the MCMC methods , the important ideas for the purpose of this paper are that
1 . MCMC methods make Bayesian analysis practical ,
2 . MCMC often requires an enormous number of laps through the dataset , and
3 . given a θ drawn from f ( θ|x ) we can use MCMC to draw another value , θ , from the same distribution .
The last point will be the key to implementing a particle filter solution that allows us to apply MCMC methods to massive datasets . We will use this technique to switch the inner and outer loops in figure 1 . The scan of the dataset will become the outer loop and the scan of the draws from f ( θ|x ) will become the inner loop . 2.3 Importance sampling for analysis of massive datasets
So far we have two tools , MCMC and importance sampling , to draw samples from an arbitrary posterior distribution . In this section we discuss a particular form of importance sampling that will help perform Bayesian analysis for massive datasets .
Ideally we would like to sample efficiently and take advantage of all the information available in the dataset . A factorization of the integrand of the right hand side of ( 3 ) shows that this is possible when the observations , xi , are independent given the parameters , θ . Such conditional independence is often satisfied , like in the class of hierarchical models , even when the observations are marginally dependent . Let D1 and D2 be a partition of the dataset so that every observation is in either D1 or D2 . As noted for ( 1 ) we would like to sample from the posterior conditioned on all of the data , f ( θ|D1 , D2 ) . Since sampling from f ( θ|D1 , D2 )
1 . Initialize the parameter θ1
2 . For i in 2 , . . . , M do
Step ( a ) and/or ( b ) requires a scan of the dataset ( a ) Draw a proposal θ from q(θ|θi−1 ) , ( b ) Loop through the dataset to compute the acceptance probability
α(θ
, θi−1 ) = min 1 , f ( θ|x)q(θi−1|θ ) f ( θi−1|x)q(θ|θi−1 )
( c ) With probability α(θ , θi−1 ) set θi = θ .
( 6 )
Otherwise set θi = θi−1
Figure 1 : The Metropolis Hastings algorithm is difficult due to the size of the dataset , we consider setting g(θ ) = f ( θ|D1 ) for use as our sampling distribution and using importance sampling to adjust the draws . If θi , i = 1 , . . . , M , are draws from f ( θ|D1 ) then we can estimate the posterior expectation ( 1 ) as where the wi ’s are the importance sampling weights wi =
( 8 ) Although these weights still involve f ( θi|D1 , D2 ) , they greatly simplify .
.
Line ( 9 ) follows from applying Bayes’ theorem to the numerator and denominator . Equation ( 10 ) follows from ( 9 ) since the observations in the dataset partition D1 are conditionally independent from those in D2 given θ . Conveniently , ( 11 ) is just the likelihood of the observations in D2 evaluated at the sampled value of θ . Figure 2 summarizes this result as an algorithm . The algorithm maintains the weights on the log scale for numerical stability .
So rather than sample from the posterior conditioned on all of the data , D1 and D2 , which slows the sampling procedure , we need only to sample from the posterior conditioned on D1 . The remaining data , D2 , simply adjusts the sampled parameter values by reweighting . The for loops in step 5 of figure 2 are interchangeable . The trick here is to have the inner loop scan through the draws so that the outer loop only needs to scan D2 once to update the weights . Although the
ˆE(h(θ)|D1 , D2 ) =2M 2M i=1 wih(θi ) i=1 wi f ( θi|D1 , D2 ) f ( θi|D1 ) f ( D1 ) f ( D1|θi)f ( θi ) wi =
=
= f ( D1 , D2|θi)f ( θi ) f ( D1 , D2 ) f ( D1|θi)f ( D2|θi)f ( D1 ) f ( D1|θi)f ( D1 , D2 ) f ( D2|θi ) f ( D2|D1 )
∝ f ( D2|θi ) = ;xj∈D2 f ( xj|θi )
( 7 )
( 9 )
( 10 )
( 11 ) same computations take place , in practice physically scanning a massive dataset is far more expensive than scanning a parameter list . However , massive models as well as massive datasets exist so that in these cases scanning the dataset may be cheaper than scanning the sampled parameter vectors . We will continue to assume that scanning the dataset is the main impediment to the data analysis . We certainly can sample from f ( θ|D1 ) more efficiently than from f ( θ|D1 , D2 ) since simulating from f ( θ|D1 ) will require a scan of a much smaller portion of the dataset . We also assume that , for a given value of θ , the likelihood is readily computable up to a constant , which is almost always the case . When some data are missing , the processing of an observation in D2 will require integrating out the missing information . Since the algorithm handles each observation case by case , computing the observed likelihood as an importance weight will be much more efficient than if it was embedded and repeatedly computed in a Metropolis Hastings rejection probability computation . Placing observations with missing values in D2 greatly reduces the number of times this integration step needs to occur , easing likelihood computations .
1 . Load as much data into memory as possible to form D1 , taking into account space requirements for the Monte Carlo algorithm
2 . Draw M times from f ( θ|D1 ) via Monte Carlo or
Markov chain Monte Carlo
3 . Purge the memory of D1
4 . Create a vector of length M to store the logarithm of the weights and initialize them to 0
5 . Iterate through the remaining observations . For each observation , xj , update the log weights on all of the draws from f ( θ|D1 ) for xj in the partition D2 do { for i in 1 , . . . , M do { } log wi ← log wi + log f ( xj|θi )
}
6 . Rescale to compute the weights wi ← exp ( log wi − max(log wi ) )
Figure 2 : Importance sampling for massive datasets
Therefore ,
2.4 Efficiency and the effective sample size
The algorithm shown in figure 2 does have some drawbacks . While it makes great gains in reducing the number of times the data need to be accessed the Monte Carlo variance of the importance sampling estimates grows quickly . The problem is easily demonstrated graphically as shown in figure 3 . The wide histogram represents the sampling distribution f ( θ|D1 ) that generates the initial posterior draws .
H¨older ’s inequality implies that ESS is always less than or equal to M . With a little algebra , the ESS is also expressible in terms of the sample variance of the wi as shown in ( 17 ) , which facilitates the study of its properties in Theorem 1 . If the θi are dependent from the start , as will be the case for MCMC draws , the effective sample size will further decrease in addition to reductions due to unequal importance weights . When the MCMC algorithm “ mixes well ” so that the set of θi are not too dependent , this is not too much of a problem .
Figure 3 : Comparison of f ( θ|D1 , D2 ) and f ( θ|D1 )
However , the target distribution , f ( θ|D1 , D2 ) , shown as the density plot , is shifted and narrower . About half of the draws from f ( θ|D1 ) will be wasted . Those that come from the right half will have importance weight near zero . Since all of the terms are positive in the familiar variance relationship
Var(θ|D1 ) = E(Var(θ|D1 , D2 ) ) + Var(E(θ|D1 , D2) ) ,
( 13 ) the posterior variance with the additional observations in D2 on average will be smaller than the posterior variance conditioned only on D1 . The addition of D2 can increase the variance ( see [ 22 ] for an example ) but usually D2 is large enough so that the averaging effect dominates . Therefore , although the location of the sampling distribution should be close to the target distribution , its spread will most likely be wider than that of the target . As additional observations become available , f ( θ|D1 , D2 ) becomes much narrower than f ( θ|D1 ) . The result of this narrowing is that the weights of many of the original draws from the sampling distribution approach 0 and so we have few effective draws from the target density .
As in [ 14 ] , the effective sample size ( ESS ) is the number of observations from a simple random sample needed to obtain an estimate with Monte Carlo variation equal to the Monte Carlo variation obtained with the M weighted draws of θi .
Var 1
ESS
ESS:i=1
⇒ Var(θ )
1
ESS i=1 w2 i i=1 wiθi
θi = Var 2M i=1 wi 2M = Var(θ ) 2M i=1 wi 2
2M ( 2 wi)2 2 w2
1 + Var(w ) i M
=
.
ESS =
( 14 )
( 15 )
( 16 )
( 17 )
00051015 Figure 4 shows the decay of the effective sample size for a simulated example . The data come from a three dimensional Gaussian with mean 0 and covariance equal to the identity matrix . The posterior therefore concerns the three mean and the six covariance parameters . We sampled M = 1000 times from the posterior conditioned on n = 100 observations . After 300 additional data points the ESS has dropped to 10 , a 99 % loss in estimation efficiency from the initial Monte Carlo sample of M = 1000 . At this point 65 of the initial 1000 draws account for 99 % of the total weight . Figure 4 also overlays the ESS curve assuming a known covariance and the expected ESS curve derived next .
The following theorem concerning the variance of the important sampling weights can help us gauge the effect of these problems in practice . The theorem assumes that we observe a finite set of multivariate normal data , xi . As before we will partition the xi ’s into two groups , D1 and D2 . To get accurate estimates of the mean , µ , we will be concerned about the variance of the importance sampling weights , φ(µ|D1 , D2 , Σ)/φ(µ|D1 , Σ ) , where φ(· ) is the normal density function . The theorem gives the variance of these importance sampling weights averaged over all possible datasets with a flat prior for µ .
Theorem 1 . If , for j = 1 , . . . , N , 1 . xj ∼ Nd(µ , Σ ) with known covariance Σ , 2 . D1 = {x1 , . . . , xn} and D2 = {xn+1 , . . . , xN} , and 3 . µ ∼ Nd(µ0 , Λ0 ) then lim −1 0 →0
Λ
ED2 ED1 Varµ|D1,Σ φ(µ|D1 , D2 , Σ ) φ(µ|D1 , Σ ) = N n d − 1
( 18 )
( 19 )
Proof : The most straightforward proof of the theorem involves simply computing the big multivariate Gaussian integral in ( 18 ) .
Theorem 1 basically says that in the multivariate normal case with a flat prior the variance of the importance sampling weights is on average ( 19 ) . These results may hold approximately in the non normal case if the posterior distributions and the likelihood are approximately normal . As we should expect , when n = N the variance of the weights is 0 . As N increases relative to n the variance increases quickly . This is unfortunate in our case since we would like to use this method for large values of N and high dimensional problems . Looking at this result from the effective sample size point of view we see that
ESS ≈ M n N d
.
( 20 )
If we draw M times from the sampling distribution when the size of the second partition D2 is equal to the size of the first partition D1 , the effective sample size is decreased by a factor of 2d .
Although things are looking grim for this method , recent advances in particle filters sidestep this problem by a simple “ rejuvenation ” step .
Figure 4 : The reduction in effective sample size with the addition of 1,000 observations . The top jagged curve assumes a known covariance while the bottom jagged also estimates the covariance . The smooth curve is the expected ESS with a known covariance .
3 . PARTICLE FILTERING FOR MASSIVE
DATASETS
The efficiency of the importance sampling scheme described in the previous section deteriorates when the importance weights accumulate on a small fraction of the initial draws . These θi with the largest weights are those parameter values that have the greatest posterior mass given the data absorbed so far . The remaining draws are simply wasting space .
Sequential Monte Carlo methods [ 5 ] aim to adapt estimates of posterior distributions as new data arrive . Particle filtering is the often used term to describe methods that use importance sampling to filter out those “ particles , ” the θi , that have the least posterior mass after incorporating the additional data . All of the methods struggle with maintaining a large effective Monte Carlo sample size while maintaining computational efficiency .
The “ resample move ” or “ rejuvenation ” step developed in [ 10 ] greatly increases the sampling efficiency of particle filters in a clever fashion . We can iterate step 5 ’s outer loop shown in figure 2 until the ESS has deteriorated below some tolerance limit , perhaps 10 % of M . Assume that this occurs after absorbing the next n1 observations . At that point we have an importance sample from the posterior conditioned on the first n + n1 data points . Then resample M times with replacement from the θi where the probability that θi is selected is proportional to wi . Note that these draws still represent a sample , albeit a dependent sample , from the posterior conditioned on the first n + n1 data points . Several of the θi will be represented multiple times in this new sample . For the most part this refreshed sample will be devoid of those θi not supported by the data . Remember that the basic idea behind MCMC was that given a draw from f ( θ|x1 , . . . , xn+n1 ) we can generate another observation from the same distribution by a single Metropolis Hastings step . Although this new draw will still be dependent , it will have less dependence than leaving it
Additional observationsEffective sample size010020030040002004006008001000 Figure 5 : The resample move step . 1 ) generate an initial sample from f ( θ|D1 ) . The ticks mark the particles , the sampled θi . 2 ) Weight based on f ( θ|D1 , D2 ) and resample , the length of the vertical lines indicate the number of times resampled . 3 ) For each θi perform an MCMC step to diversify the sample . so that it has duplicates in the set of draws . Additional MCMC steps will decrease that dependence , increase the ESS , but also increase the number of times the algorithm accesses the first n + n1 observations . Therefore , to rejuvenate the sample , for each of these new θi ’s we can perform a single Metropolis Hastings step “ centered around ” θi where the acceptance probability is based on all n + n1 data points . Our rejuvenated θi ’s now represent a more diverse set of parameter values with an effective sample size closer to M again . Figure 5 graphically walks through the resample move process step by step .
After rejuvenating the set of θi , we can continue where we left off , on observation n + n1 + 1 , and continue absorbing additional observations until either we include the entire dataset or the ESS again has dropped too low and we need to repeat a rejuvenation step . As opposed to standard MCMC , the particle filter implementation also admits an obvious path toward parallelization .
The next section demonstrates the method on a simulated dataset .
4 . EXAMPLE : MIXTURES OF
TRANSITION MODELS
In this section we present a small example to demonstrate proof of concept . While it uses a dataset that can easily fit in main memory , it demonstrates the notion that the particle filter approach greatly reduces the number of data accesses . At least for this example , additional observations would change the posterior slightly so that they can be absorbed by linearly scanning only the newest observations one or two times .
Mixtures of transition models have been used to model users visiting web sites [ 2 , 19 , 20 ] and unsupervised training of robots [ 18 ] . In [ 2 ] , the authors also develop visualization tools ( WebCANVAS ) for understanding clusters of users and apply their methodology to the msnbc.com web site .
Transition models [ 21 ] , or finite state Markov chains ( although related , in this context these are not to be confused with Markov chain Monte Carlo ) , are useful for describing discrete time series where an observed series switches between a finite number of states . A particular sequence , for example ( A,B,A,A,C,B ) might be generated by a first order transition model where the probability that the sequence moves to a particular state at time t + 1 depends only on the state at time t . Perhaps web users traverse a web site in such a manner .
Given a set of sequences we can estimate the underlying probability transition matrix , the matrix that describes the probability of specific state to state transitions . In fact the posterior distribution is computable in closed form with a single pass through the dataset by simply counting the number of times the sequences moves from state A to state A , state A to state B , and so on for all pairs of states .
However , a particular set of sequences may not all share a common probability transition matrix . For example , visitors to a web site are heterogeneous and may differ on their likely paths through the web site depending on their profession , their Internet experience , or the information that they seek . The mixture of transition models assumes that the dataset consists of sequences , each generated by one of C transition matrices . However , neither the transition matrices nor the group assignments nor the number from each group are known .
The goal , therefore , is to understand the shape of the posterior distribution of the elements of the two transition matrices and the mixing fraction given a sample of observed users’ paths . Independent samples from this posterior distribution are not easily obtained directly but the full conditionals , on the other hand , are simple enough so that the Gibbs sampler is easy to implement ( see [ 19 ] for complete details ) . Let C be the number of clusters and S be the number of possible states . The unknown parameters of this model are the C S × S transition matrices , P1 , . . . , PC , the mixing vector α of length C containing the fraction of observations from each cluster , and the N cluster assignments , zj ∈ {1 , . . . , C} . Placing a uniform prior on all parameters , the Gibbs sampler proceeds as follows . First randomly initialize the cluster assignments , zj . Given the cluster assignments , the full conditional of the ith row of the transition matrix Pc is
Dirichlet(1 + ni1c , 1 + ni2c , 1 + ni3c , . . . , 1 + niSc ) ,
( 21 ) where ni1c , for example , is the number of times sequences for which zj = c transition from state i to state 1 . The mixing vector is updated with a draw from
Dirichlet(1 + : I(zj = 1 ) , . . . , 1 + : I(zj = C) ) , where2 I(zj = c ) counts the number of observations as
( 22 )
2024 2024 2024 signed to cluster c . Lastly we update the cluster assignments conditional on the newly sampled values for the transition matrices . The new cluster assignment for sequence j is drawn from a Multinomial(p1 , p2 , . . . , pC ) where pc is the probability that transition matrix Pc generated the sequence . With these new cluster assignments we return to ( 21 ) and so the Gibbs sampler iterates .
As noted in section 2.2 , each iteration of the MCMC algorithm requires a full scan of the dataset , in this case two scans , one for the matrix update and one for the cluster assignment update . To test the improvement available using the particle filtering approach , we generated 10,000 sequences of length between 5 and 15 from two 4×4 transition matrices . We used the first n = 100 sequences to obtain the initial sample of M = 150 draws , step 1 of the algorithm shown in figure 2 . We then sequentially accessed the additional sequences , reweighting the M draws until the ESS dropped below 15 . At that point , we resampled and applied the rejuvenation step to the set of draws and continued again until the ESS dropped too low .
Figure 6 shows the results for the number of times the particle filtering algorithm accessed each observation . The lower curve indicates the number of accesses . The first 100 observations show the greatest number of accesses ( 348 for this example ) since they were also used to generate the initial sample . However , the additional observations were accessed infrequently . For example , the algorithm accessed observation #2000 only 14 times and observation #10000 only twice . same for both the particle filter and the full Gibbs sampler . Figure 6 shows a 95 % reduction in the total number of data accesses when using the particle filter .
The tick marks along the bottom mark the points at which a rejuvenation step took place . Note that they are very frequent at first and decrease as the algorithm absorbs addi√ tional observations . The marginal posterior standard den ) so that the viation approximately decreases like O(1/ target is shrinking at a slower rate as we add more data . From the ESS approximation in ( 20 ) we can estimate the frequency of rejuvenation . As before , let n be the size of the initial sample . Now let Nk be the total number of observations accommodated at the kth rejuvenation step . If we rejuvenate the θi ’s when the ESS drops to p × M then the Nk are approximately related according to n N1 d ≈ p , N1
Unraveling the recursion implies that
Nk d ≈ p .
N2 d ≈ p , . . . , Nk−1 p k Nk ≈ n 1 d ,
( 23 )
( 24 ) where d is the dimension of the parameter vector from theorem 1 . When we let the ESS get very small before rejuvenation , equivalently setting p to be small , the Nk can become large quickly . Naturally , there will be a balance between loss in computing efficiency and estimation efficiency . Fortunately Nk grows exponentially in k , so that once k exceeds d , the effective number of parameters we are trying to estimate , Nk will grow quickly . Therefore , after approximately k = d rejuvenations the algorithm has absorbed enough data points so that it can withhold future rejuvenations until many more observations have been accommodated . While Nk grows exponentially with k it grows only linearly with n , the number of observations in D1 . This implies that it may be better to spend more computational effort on the rejuvenation steps than the initial posterior sampling effort . For the mixture example , the effective number of parameters is no more than 25 . Each transition matrix is 4× 4 with the constraint that the rows sum to 1 . So each of the two transition matrices has 12 free parameters . With the single mixing fraction parameter the total parameter count is 25 . With additional correlation amongst the parameters the effective number of parameters could be less . In fact in our example we found that equation ( 24 ) matches the observed frequency of rejuvenation to near perfection when d = 17 .
Figure 6 : The frequency of access by observation . The horizontal line at 300 refers to the full MCMC run and the lower curve refers to the particle filter . The marks along the x axis refer to occurrences of the rejuvenation step .
For comparison , the line at 300 in figure 6 indicates the number of times the Gibbs sampler , conditioned on the entire dataset , needed to access each observation . Each of the 150 iterations required one scan for the cluster assignments and a second scan for the parameter updates ( 21 ) and ( 22 ) . The slightly larger values for the first 100 observations are due to their usage in determining the starting values for the Gibbs sampler . This starting value selection process was the
While efficiency as measured with the number of data accesses is important in the analysis of massive datasets , precision of parameter estimates is also important . Figure 7 shows the marginal posterior distributions for the 16 transition probabilities from the first cluster ’s transition matrix . The histogram is based on the M = 150 draws using the particle filtering method . The overlaid density is based on a rigorous MCMC run with 3000 draws . The histogram and density plots are nearly identical except for small fluctuations . The posterior means from the two methods virtually overlap for each parameter . The figure also marks the location of the parameter value used to generate the data . All of these values are within range of the posterior mean to the extent that we would expect from sampling variability . While achieving a 95 % reduction in the number of data points ac
ObservationNumber of times accessed02000400060008000100000100200300 Figure 7 : The posterior distribution of the transition probabilities for one of the transition matrices . The histogram is based on the particle filter while the black curve is the estimated density based on a rigorous 3000 draw MCMC run . The two darker vertical lines are the posterior means based on the particle filter and the rigorous run and are nearly identical if not overlapping . The dashed vertical line , which may be further away , is the true value used to simulate the dataset . cessed , the algorithm shows little if any loss in the estimation of the posterior distribution and the posterior mean . Note that increasing M does not change the number data accesses for the particle filter while each additional draw represents yet another scan for the standard implementation .
If for some reason one was not confident in the particle filter results , one could generate additional MCMC iterations utilizing the entire dataset initiated from the particle filter draws . If the densities change little then that would be evidence in favor of , but not necessarily proof of , the algorithm ’s estimation accuracy .
The example described involves a fairly small dataset . In additional experimentation we sampled 1000 draws using the particle filter from the posterior distribution conditioned on a dataset containing 1,406,000 observed processes . We observed similar performance metrics . The number of total observations accessed using the particle filter was 99.4 % less than if we had used the standard MCMC implementation . At the same time , equation ( 24 ) maintains its prediction of the refresh rate for a model with d = 17 effective parameters . To condition on 1.4 million processes the particle filter had to refresh 56 times , the last refresh after incorporating
136,000 processes with a single linear scan . We continue to observe no loss in estimation precision as all the true parameter values used to simulate the data always lie in regions of high posterior probability .
5 . DISCUSSION
MCMC methods have been almost completely absent from data mining research while they are widely used in modern statistical analysis of complex models . Indeed when working with massive datasets the first order of business may be obtaining simple point estimates for unknown parameters . Inevitably , analysts want to explore other aspects of the posterior distribution besides simply the posterior mean or mode . But to date MCMC methods have simply been computationally infeasible for massive datasets .
Likelihood based data squashing [ 16 ] is also a potential tool for making Bayesian analysis in massive datasets computationally feasible . It too uses the factorization of the likelihood ( 11 ) to avoid too many scans of the dataset . Likelihood based data squashing locates a small number of data points or pseudo data points with appropriate weights so that a weighted analysis of the pseudo dataset would pro
01450150015501600090009501000105039004000410042003350345035505505605705800250030003503703803904004100100014001801800190020001850195020502400250026002700340350360370415042504350115012001250130005500600065038003900400 [ 9 ] S . Geman and D . Geman . Stochastic relaxation , Gibbs distributions and the Bayesian restoration of images . IEEE Transactions on Pattern Analysis and Machine Intelligence , 6:721–741 , 1984 .
[ 10 ] W . Gilks and C . Berzuini . Following a moving target
Monte Carlo inference for dynamic Bayesian models . Journal of the Royal Statistical Society B , 63(1):127–146 , 2001 .
[ 11 ] W . Gilks , S . Richardson , and D . J . Spiegelhalter , editors . Markov Chain Monte Carlo in Practice . Chapman and Hall , 1996 .
[ 12 ] C . Glymour , D . Madigan , D . Pregibon , and P . Smyth .
Statistical themes and lessons for data mining . Data Mining and Knowledge Discovery , 1(1):11–28 , 1997 .
[ 13 ] W . K . Hastings . Monte Carlo sampling methods using
Markov chains and their applications . Biometrika , 57:97–109 , 1970 .
[ 14 ] A . Kong , J . Liu , and W . Wong . Sequential imputation and Bayesian missing data problems . Journal of the American Statistical Association , 89:278–288 , 1994 . [ 15 ] L . Le Cam and G . Yang . Asymptotics in Statistics : Some Basic Concepts . Springer Verlag , New York , 1990 .
[ 16 ] D . Madigan , N . Raghavan , W . DuMouchel , M . Nason , C . Posse , and G . Ridgeway . Instance construction via likelihood based data squashing . In H . Liu and H . Motoda , editors , Instance Selection and Construction A data mining perspective , chapter 12 . Kluwer Academic Publishers , 2001 .
[ 17 ] N . Metropolis , A . Rosenbluth , M . Rosenbluth ,
A . Teller , and E . Teller . Equations of state calculations by fast computing machine . Journal of Chemical Physics , 21:1087–1091 , 1953 .
[ 18 ] M . Ramoni , P . Sebastiani , and P . Cohen . Bayesian clustering by dynamics . Machine Learning , 47(1):91–121 , 2002 .
[ 19 ] G . Ridgeway . Finite discrete Markov process clustering . Technical Report MSR TR 97 24 , Microsoft Research , September .
[ 20 ] G . Ridgeway and S . Altschuler . Clustering finite discrete Markov chains . In Proceedings of the Section on Physical and Engineering Sciences , pages 228–229 , 1998 .
[ 21 ] S . M . Ross . Probability Models . Academic Press , 5th edition , 1993 .
[ 22 ] D . Spiegelhalter and R . Cowell . Learning in probabilistic expert systems . In J . Bernardo , J . Berger , A . Dawid , and A . Smith , editors , Bayesian Statistics , volume 4 , pages 447–466 . Clarendon Press , Oxford , 1992 . duce the same results as the unweighted analysis of the massive dataset . It is possible that a posterior conditioned on the pseudo dataset may offer a good importance sampling distribution so that some combination of data squashing , importance sampling , and particle filtering could provide a coherent solution .
While clearly the method needs to undergo more empirical work to test the boundaries of its limitations , the derivation and preliminary simulation work shows promise . If we can generally reduce the number of data accesses by 95 % MCMC becomes viable for a large class of models useful in data mining . The sequential nature of algorithm also allows the analyst to stop when uncertainty in the parameters of interests has dropped below a required tolerance limit . Parallelization of the algorithm is rather straightforward . Each processor manages a small set of the weighted draws from the posterior and is responsible for updating their weights and computing the refresh step . The last advantage that we discuss here involves convergence of the MCMC sampler . As noted in section 2.2 , the key to MCMC begins with assuming that we have an initial draw from f ( θ|x ) . While in practice the analyst usually just starts the chain from some reasonably selected starting point , the particle filter approach allows us to sample directly from the prior to initialize the algorithm . Sampling from the prior distributions often used in practice is usually simple . Then the particle filter can run its course starting with the first observation . Even though subsequent steps introduce dependence , the algorithm will always generate new draws from the correct distribution without approximation .
Bayesian analysis coupled with Markov chain Monte Carlo methods continues to revitalize many areas of statistical analysis . Some variant of the algorithm we propose here may indeed make this pair viable for massive datasets .
6 . REFERENCES [ 1 ] J . Besag , P . Green , D . Higdon , and K . Mengersen .
Bayesian computation and stochastic systems ( with discussion ) . Statistical Science , 10:3–41 , 1995 .
[ 2 ] I . Cadez , D . Heckerman , C . Meek , P . Smyth , and
S . White . Visualization of navigation patterns on a web site using model based clustering . Technical Report MSR TR 00 18 , Microsoft Research , March . [ 3 ] B . Carlin and T . Louis . Bayes and Empirical Bayes
Methods for Data Analysis . Chapman and Hall , Boca Raton , FL , 2nd edition , 2000 .
[ 4 ] M . DeGroot . Optimal Statistical Decisions .
McGraw Hill , New York , 1970 .
[ 5 ] A . Doucet , N . de Freitas , and N . Gordon . Sequential
Monte Carlo Methods in Practice . Springer Verlag , 2001 .
[ 6 ] J . Elder and D . Pregibon . A statistical perspective on knowledge discovery in databases . In U . M . Fayyad , G . Piatetsky Shapiro , P . Smyth , and R . Uthurusamy , editors , Advances in Knowledge Discovery and Data Mining , chapter 4 . AAAI/MIT Press , 1996 .
[ 7 ] M . Figueiredo . Adaptive sparseness using Jeffreys prior . In Neural Information Processing Systems NIPS 2001 , 2001 .
[ 8 ] A . Gelman , J . Carlin , H . Stern , and D . Rubin .
Bayesian Data Analysis . Chapman Hall , New York , 1995 .
