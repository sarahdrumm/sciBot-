Tell Me What I Need to Know :
Succinctly Summarizing Data with Itemsets
Michael Mampaey
Nikolaj Tatti
Jilles Vreeken
Department of Mathematics and Computer Science
Universiteit Antwerpen
{firstnamelastname}@uaacbe
ABSTRACT Data analysis is an inherently iterative process . That is , what we know about the data greatly determines our expectations , and hence , what result we would find the most interesting . With this in mind , we introduce a well founded approach for succinctly summarizing data with a collection of itemsets ; using a probabilistic maximum entropy model , we iteratively find the most interesting itemset , and in turn update our model of the data accordingly . As we only include itemsets that are surprising with regard to the current model , the summary is guaranteed to be both descriptive and non redundant . The algorithm that we present can either mine the top k most interesting itemsets , or use the Bayesian Information Criterion to automatically identify the model containing only the itemsets most important for describing the data . Or , in other words , it will ‘tell you what you need to know’ . Experiments on synthetic and benchmark data show that the discovered summaries are succinct , and correctly identify the key patterns in the data . The models they form attain high likelihoods , and inspection shows that they summarize the data well with increasingly specific , yet non redundant itemsets .
Categories and Subject Descriptors H28 [ Database management ] : Database applications Data mining
General Terms Theory , Algorithms , Experimentation
1 .
INTRODUCTION
Knowledge discovery from data is an inherently iterative process . That is , what we already know about the data greatly determines our expectations , and therefore , which results we would find interesting and/or surprising . Early on in the process of analyzing a database , for instance , we are happy to learn about the generalities underlying the data , while later on we will be more interested in the specifics that build upon these concepts . Essentially , this process comes down to summarization : we want to know what is interesting in the data , and we want this to be reported succinctly and without redundancy .
As a simple example , consider supermarket basket analysis . Say , we just learned that pasta and tomatoes are very often sold together , and that we already know that many people buy wine . Then it is not very interesting to find out that the combination of these three items is also sold frequently . Even if we cannot predict this frequency exactly , we can say that this pattern is redundant . At the same time , at this stage of the analysis we are probably also not interested in highly detailed patterns , eg , an itemset representing the many ingredients of an elaborate Italian dinner . While its frequency may be surprising , it is also very specific , and may well be better explained by some more general patterns . Still , this itemset might be regarded as highly interesting further on in the discovery process , after we have learned those more general patterns , and if this is the case , we would like it to be reported at that time . Consequently , this is the approach we adopt in this paper ; we incrementally adjust our model as we discover new patterns , to obtain a non redundant summary . As natural as it may seem to update a knowledge model during the discovery process , few pattern mining techniques actually follow such a dynamic approach of discovering patterns that are surprising with regard to what we have learned so far . That is , while many techniques provide a series of patterns in order of interestingness , most score these patterns using a static model ; during this process the model , and hence the itemset scores , are not updated with the knowledge gained from previously discovered patterns . For instance , Tan et al . study 21 of the most well known interestingness measures , all of which are static , and most of which are based on the independence model [ 24 ] . The static approach gives rise to the typical problem of traditional pattern mining : overwhelmingly large and highly redundant collections of patterns .
Our objective is to find a succinct summary of a binary dataset , that is , to obtain a small , yet high quality set of itemsets that describes key characteristics of the data at hand , in order to gain useful insights . This is motivated by the fact that many existing algorithms often return too large collections of patterns with considerable redundancy , as discussed above . The view that we take in this paper on succinctness and non redundancy is therefore a fairly strict one . To model the data , we use the powerful and versatile class of maximum entropy models . We construct a maximum entropy distribution that allows us to directly calculate the expected frequencies of itemsets . Then , at each iteration , we return the itemset that provides the most information , ie , for which our frequency estimate was most off . We update our model with this new knowledge , and continue the process . The non redundant model that contains the most important information is thus automatically identified . Therefore , we paraphrase our method as ‘tell me what I need to know’ .
While solving the maximum entropy model is infeasible in general , we show that in our setting it can be solved efficiently , depending on the amount of overlap between the selected patterns .
Similarly , we give an efficient method for estimating frequencies from the model . Further , we provide an efficient convex heuristic for pruning the search space for the most informative itemsets . This approach allows us to mine our collection of itemsets on the fly , instead of picking them from a larger candidate set which would have to be mined and stored beforehand . Our approach is parameter free : no maximal error threshold needs to be provided , nor a minimum support or a significance level . The best model can automatically be determined through the Bayesian Information Criterion ( BIC ) ; alternatively , we can also mine the top k most interesting itemsets . Finally , the user can easily infuse background knowledge into the model ( in the form of itemset frequencies ) , to avoid redundancy with regard to what the user already knows .
2 . RELATED WORK
Selecting or ranking interesting patterns is a well studied field in data mining . Existing techniques can roughly be split in two groups . The first group consists of techniques that measure how surprising the support of an itemset is compared against some null hypothesis : the more the observed frequency deviates from the expected value , the more interesting it is . The simplest null hypothesis is the independence model [ 1 , 2 ] . More flexible models have been suggested , for example , Bayesian Networks [ 14 ] . The major caveat of these approaches is that the null hypothesis is static and hence we keep rediscovering the same information . As a result , this will lead to pattern collections with high levels of redundancy . The alternative approach is to select itemsets using a dynamic hypothesis . That is , when a new itemset is discovered , the model is updated such that we take the already discovered information into account .
The use of maximum entropy models in pattern mining has been proposed by several authors [ 15 , 26 , 28 , 30 ] . Discovering an itemset collection with a good BIC score was suggested by Tatti and Heikinheimo [ 28 ] . Alternatively , Tatti [ 27 ] samples collections and bases the significance of an itemset on its occurrence in the discovered collections . However , in order to guarantee that the score can be computed , the authors restrict themselves to downward closed and decomposable collections . The method of Tatti [ 26 ] uses local models , that is , to compute the support of an itemset X , we are only allowed to use sub itemsets of X , and it outputs a p value . A threshold is needed to determine whether X is important . Related , Webb [ 31 ] defines itemsets as self sufficient , if their support differs significantly from what can be inferred from their sub and supersets ; therefore such a model is also local . Wang and Parthasarathy [ 30 ] incrementally build a maximum entropy model by adding itemsets that deviate more than a given error threshold . The approach ranks and adds itemsets in level wise batches . This may still , however , lead to redundancy within a batch of itemsets . The method introduced by Kontonasios and De Bie [ 15 ] uses row and column margins to construct a maximum entropy model of the data , from which noisy tiles [ 9 ] are then discovered , using an MDL based information score . An important difference , however , is that the data is treated as a single sample from the space of datasets , whereas we consider distributions of transactions .
An alternative approach , called swap randomization , has been suggested by Gionis et al . [ 10 ] and Hanhijärvi et al . [ 13 ] . The former approach ranks itemsets using a static hypothesis , the latter uses a dynamic hypothesis . Here as well , the authors treat the whole data as a sample from the space of datasets , having the same certain set of statistics , including row and column margins . The authors use an MCMC approach to sample datasets and compute empirical p values . In both approaches , the framework needs a threshold for deciding which itemsets are significant .
The MINI algorithm by Gallo et al . [ 7 ] similarly uses row and column margins to rank itemsets . It first orders all potentially interesting itemsets by computing their p value according to these margins . Then , as subsequent itemsets are added , the p values are recomputed , and the itemsets are re ordered according to their new p values . This method , however , does not allow querying .
The method of Yan et al . [ 32 ] summarizes a collection of itemsets by clustering them , and then representing each cluster as a profile . The approach is different from ours , in that it summarizes a given set of patterns , rather than the data itself .
KRIMP , by Siebes et al . [ 23 ] , employs the MDL principle to select those itemsets that together compress the data best . As such , patterns that essentially describe the same part of the data are rejected . The models it finds are not probabilistic , and therefore cannot easily be used to calculate probabilities . Further , while non redundant from a compression point of view , many of the patterns it selects are variations of the same theme . Other differences to our method are that KRIMP considers its candidates in a static order , and that it is not trivial to make it consider background knowledge .
It should be noted that in contrast to the algorithm that we propose here , most of the above methods require the user to set one or several parameters , such as a maximum error threshold or a significance level . Many also cannot easily be used to estimate the frequency of an itemset . Further , all of them are two phase algorithms , ie , they require that the user provides a collection of candidate ( frequent ) itemsets to the algorithm , which must be completely mined and stored first , before running the actual algorithm .
3 . PRELIMINARIES AND NOTATION
This section provides some preliminaries and the notation that we will use throughout the paper .
By a transaction we mean a binary vector of size N generated by some unknown distribution . The ith element in a random transaction corresponds to an attribute or an item ai , a Bernoulli random variable . We denote the set of all items by A = {a1 , . . . , aN} . We denote the set of all possible transactions by T = {0 , 1}N . The input of our method is a binary dataset D , which is simply a sample of |D| ( not necessarily distinct ) transactions . Given the data D we define an empirical distribution qD(a1 = v1 , . . . , aN = vN ) = |{t ∈ D | t = v}|/|D| .
An itemset X is a subset of A . For notational convenience , given a distribution p , an itemset X = {x1 , . . . , xL} , and a binary vector v of length L , we often use p(X = v ) to denote p(x1 = v1 , . . . , xL = vL ) . If v consists entirely of 1 ’s , then we use the notation p(X = 1 ) . Given the data D , the frequency of an itemset X is defined fr ( X ) = qD(X = 1 ) . An indicator function SX : T → {0 , 1} of an itemset X maps a transaction t to a binary value such that SX ( t ) = 1 if and only if t contains X .
The entropy of a distribution p over T is defined as p(A = t ) log p(A = t ) ,
H(p ) = − t∈T where the base of the logarithm is 2 , and by convention 0 log 0 = 0 .
4 .
IDENTIFYING THE BEST SUMMARY
Our goal is to discover the set of itemsets C that provides the most important information about the data , while containing as little redundancy as possible . Here , we regard information as whether we are able to reliably predict the data using these itemsets and their frequencies . By non redundancy , we mean that any subset of C provides a significantly different description of the data . This is equivalent to requiring that the frequency of an itemset X ∈ C should be surprising with respect to C \ X . In other words , we do not want C as a collection to be unnecessarily complex , or capture spurious information . We want it to contain only those itemsets that we really need . Informally , assume that we have a score s(C ) which measures the quality of an itemset collection C . Then our aim is to find that C with the best score s(C ) . Analogously , if we only want to know k itemsets , we look for the set C of size at most k , with the best s(C ) . Next , we will detail how we define our models , how we define this score , provide theoretical evidence why it is a good choice , and discuss how to compute it efficiently .
EXAMPLE 1 . As a running example , assume we have a transaction dataset D with eight items , a to h . Furthermore , consider the set of itemsets C = {abc , cd , def } with frequencies 0.5 , 0.4 and 0.8 , respectively . Assume for the moment that based on C , our method predicts that the frequency of the itemset agh is 019 Now , if we observe in the data that fr ( agh ) = 0.18 , then we can safely say that agh is redundant because it does not contribute a lot . On the other hand , if fr ( agh ) = 0.7 , then the frequency of agh is surprising , and therefore C ∪ {agh} would give an improved description of D . 4.1 Maximum Entropy Model
In our approach we make use of maximum entropy models . This is a class of probabilistic models that are identified by the Maximum Entropy principle [ 4 ] as those models that make optimal use of the provided information . That is , they rely only on this information and are fully unbiased otherwise . This property makes these models very suited for identifying good patterns : by using maximum entropy models to measure the quality of a set of patterns , we know that our measurement only relies on the provided frequencies of the patterns , and that it will not be thrown off due to some spurious structure in the data . These models have a number of theoretically appealing properties , which we will discuss after a formal introduction . Assume that we are given a set of itemsets C = {X1 , . . . , Xk} . Each itemset Xi has a frequency fr ( Xi ) in the data . We are interested in distributions that satisfy these frequencies , that is , let us consider the following set of distributions
P = {p | p(Xi = 1 ) = fr ( Xi ) , i = 1 , . . . , k} .
Among these distributions we are interested in only one , namely the unique distribution that maximizes the entropy , p
∗ C = arg max p
{H(p ) | p ∈ P} .
For notational convenience we will omit C from p∗ whenever it is clear from the context . Although we restrict ourselves to itemset frequencies here , many other patterns or count statistics that can be expressed as linear combinations of transactions could be used , eg , transaction lengths [ 29 ] , association rule confidence , etc . Computing the maximum entropy model , however , is far from trivial , and is treated in Section 45 4.2 Model Scoring log p∗(D ) =
First we discuss how we will measure the quality of a model . A natural first choice would be to directly measure the goodness of fit , using the log likelihood of the maximum entropy model , that is , t∈D log p∗(A = t ) . However , this choice suffers from overfitting : larger collections of itemsets will always provide more information , hence allow for better estimates , and therefore have a better log likelihood . Consequently , we need to prevent our method from overfitting . Therefore , we use the well founded Bayesian Information Criterion ( BIC ) , which favors models that fit the data well with few parameters . It has a strong theoretical support in Bayesian model selection [ 22 ] as well as through the Minimum Description Length principle [ 12 ] . The BIC score of a collection C is defined as s(C ) = − log p
C(D ) + 1/2 |C| log |D| . ∗
The smaller this score , the better the model . The first term is simply the negative log likelihood of the model , while the second term is a penalty on the number of parameters—the number of itemsets in our case . Consequently , the best model is identified as the model that provides a good balance between high likelihood and low complexity . Moreover , we automatically avoid redundancy , since models with redundant itemsets are penalized for being too complex , without sufficiently improving the likelihood . 4.3 Properties of the Model
In this subsection we discuss some properties of the quality mea sure and the maximum entropy model .
We begin by stating a famous theorem that the maximum entropy model has an exponential form .
THEOREM 2
( THEOREM 3.1 IN [ 4] ) . Given a collection of itemsets C = {Xi}k i=1 with frequencies fr ( Xi ) , let us define P = {p | p(Xi = 1 ) = fr ( Xi)} . If there is a distribution in P that has only non zero entries , then the maximum entropy distribution p∗ can be written as
∗ p
( A = t ) = u0 uSX ( t ) X
,
X∈C where uX ∈ R , and u0 is a normalization factor .
This form will help us to discover the model and compute the likelihood term in the scoring function .
COROLLARY 3
( OF THEOREM 2 ) . The log likelihood of the maximum entropy distribution p∗ for a set of itemsets C is equal to
∗
( D ) = |D|(log u0 + log p fr ( X ) log uX ) = −|D|H(p
∗
) .
X∈C
Thus , to calculate the BIC score s(C ) , it suffices to compute the parameters uX and u0 of the distribution p∗ . 4.4 Reducing Redundancy
Here we show that our score favors itemset collections with low redundancy , and make a theoretical link with some existing redundancy reduction techniques for pattern mining .
A baseline technique for ranking itemsets is to compare the observed frequency against the expected value of some null hypothesis . The next theorem shows that if the observed frequency of an itemset X agrees with the expected value p∗(X = 1 ) , then X is redundant . THEOREM 4 . Let C be a collection of itemsets and let p∗ be the corresponding maximum entropy model . Let X /∈ C be an itemset such that fr ( X ) = p∗(X = 1 ) . Then s(C ∪ {X} ) > s(C ) .
PROOF . We will prove the theorem by showing that the likelihood terms for both collections are equal . Define the collection C1 = C ∪ {X} and let P1 be the corresponding set of distributions . 1 be the distribution maximizing the entropy in P1 . Note that Let p∗ since C ⊂ C1 , we have P1 ⊆ P and hence H(p∗ 1 ) ≤ H(p∗ ) . On the other hand , the assumption in the theorem implies that p∗ ∈ P1 and so H(p∗ ) ≤ H(p∗ 1 ) and since the distribution maximizing the entropy is unique , we have p∗ = p∗ 1 . This shows that the likelihood terms in s(C ) and s(C1 ) are equal . The BIC penalty term is larger in s(C1 ) which concludes the proof .
1 ) . Thus , H(p∗ ) = H(p∗
Algorithm 1 : ITERATIVESCALING(C ) input
:itemset collection C = {X1 , . . . , Xk} , frequencies fr ( X1 ) , . . . , fr ( Xk ) distribution p∗ output :parameters uX and u0 of the maximum entropy
C(Xi ) = fr ( Xi ) for all i
C satisfying p∗ for each X in C do
1 initialize p ; 2 while p has not converged do 3 4 5 6 compute p(X = 1 ) ; uX ← uX u0 ← u0 fr ( X ) p(X=1 ) 1−fr ( X ) 1−p(X=1 ) ;
1−p(X=1 ) 1−fr ( X ) ;
7 return p ;
Theorem 4 states that adding an itemset X to C improves the score only if its observed frequency deviates from the expected value . The amount of deviation required is determined by the penalty term . This gives us a convenient advantage over methods that are based solely on deviation , since they require a user specified threshold .
Two corollaries stated below follow directly from Theorem 4 . The first relates our approach to closed itemsets [ 21 ] . An itemset is closed if all of its supersets have a strictly lower support . An itemset is a generator if all of its subsets have a strictly higher support . The second corollary provides a similar relation with non derivable itemsets [ 3 ] . An itemset is called derivable if its support can be inferred exactly from the supports of all of its proper subsets .
COROLLARY 5
( OF THEOREM 4 ) . Let C be a collection of itemsets . Assume that X , Y ∈ C such that X ⊂ Y and fr ( X ) = fr ( Y ) = 0 . Assume that Z /∈ C such that X ⊂ Z ⊂ Y . Then s(C ∪ {Z} ) > s(C ) .
COROLLARY 6
( OF THEOREM 4 ) . Let C be a collection of itemsets . Assume that X /∈ C is a derivable itemset and all subitemsets of X are included in C . Then s(C ∪ {X} ) > s(C ) .
Corollaries 5 and 6 connect our approach with popular techniques that losslessly remove redundancy—so called condensed representations . The advantage of our method is that it does not have to be exact . For example , in Corollary 5 , fr ( X ) does not have to equal fr ( Y ) exactly in order to reject Z from C . This allows us to prune redundancy more aggressively . 4.5 Efficiently Computing the Model
Computing the maximum entropy model comes down to finding the u0 and uX parameters from Theorem 2 . To achieve this , we use the well known Iterative Scaling procedure [ 5 ] , which is given as Algorithm 1 . Simply put , it iteratively updates the parameters of the distribution , until it converges to the maximum entropy distribution p∗ which satisfies a given set of constraints—itemset frequencies in our case . The distribution is initialized with the uniform distribution , which is done by setting the uX parameters to 1 , and u0 = 2−N to normalize . Then , for each itemset X ∈ C , we adjust the corresponding parameter uX to enforce p(X = 1 ) = fr ( X ) ( line 5,6 ) . This process is repeated in a round robin fashion until p converges , and it can be shown [ 5 ] that p always converges to the maximum entropy distribution p∗ . Typically the number of iterations required for convergence is low ( usually < 10 in our experiments ) .
EXAMPLE 7 . In our running example , with C = {abc , cd , def } , the maximum entropy model has three parameters u1 , u2 , u3 , and a normalization factor u0 . Initially we set u1 = u2 = u3 = 1 and u0 = 2−N = 2−8 . Then we iteratively loop over the itemsets and scale the parameters . For instance , for the first itemset abc with frequency 0.5 , we first compute its current estimate to be 2−3 = 0125 Thus , we update the first parameter u1 = 1 · ( 0.5/2−3 ) · ( (1 − 2−3)/0.5 ) = 7 . The normalization factor becomes u0 = 2−8 · 0.5/(1 − 2−3 ) ≈ 2.2 · 10−3 . Next , we do the same for cd , and so on . After a few iterations , the model parameters converge to u1 = 28.5 , u2 = 0.12 , u3 = 85.4 , and u0 = 3 · 10−4 .
The main bottleneck of this procedure is the inference of an itemset ’s probability on line 4 of the algorithm , p(X = 1 ) = p(A = t ) . t∈T ;SX ( t)=1
Since this sum ranges over all possible transactions containing X , it is infeasible to do this in a brute force manner for any non trivial number of items N . In fact , it has been shown that querying the maximum entropy model is PP hard [ 25 ] .
Therefore , in order to be able to query the model efficiently , we introduce a partitioning scheme , which makes use of the observation that many transactions have the same probability . Remark that an itemset collection C partitions T into blocks of transactions that contain the same set of itemsets . That is , two transactions t1 and t2 belong to the same block T if and only if SX ( t1 ) = SX ( t2 ) for all X in C . Hence , from Theorem 2 we know p(A = t1 ) = p(A = t2 ) . This allows us to define SX ( T ) = SX ( t ) for any t ∈ T and X ∈ C . We denote the partition of T induced by C as TC . Now we can compute the probability of an itemset as p(X = 1 ) =
T∈TC ;SX ( T )=1 p(A ∈ T ) .
The sum has been reduced to a sum over blocks of transactions , and the inference problem has been moved from the transaction space T to the block space TC . In our setting we will see that |TC| |T | , which makes inference a lot more feasible . In the worst case , this partition may contain 2|C| blocks , however , through the interplay of the itemsets , it can be as low as |C| + 1 . As explained further on , we can exploit , or even choose to limit , the structure of C , such that practical computation is guaranteed . All we must do now is obtain the block probabilities p(A ∈ T ) . Since all transactions t in a block T have the same probability , it suffices to compute the number of p(A = t ) = u0 transactions in T to get p(A ∈ T ) . So , let us define e(T ) to be the number of transactions in T , then
X∈C uSX ( t )
X p(A ∈ T ) = p(A = t ) = e(T ) u0 uSX ( T ) X
.
X∈C t∈T
Algorithm 2 describes COMPUTEBLOCKSIZES . In order to compute the block sizes e(T ) , we introduce a partial order on TC . Let sets(T ;C ) = {X ∈ C | SX ( T ) = 1} be the itemsets in C that occur in the transactions of T . Note that every block corresponds to a unique subset of C , but conversely not every subset of C corresponds to a ( nonempty ) transaction block . We can now define the partial order on TC as follows ,
T1 ⊆ T2 if and only if sets(T1;C ) ⊆ sets(T2;C ) .
In order to compute the size e(T ) of a block , we first compute its cumulative size , e,T
,
T ⊇T c(T ) =
Algorithm 2 : COMPUTEBLOCKSIZES(C ) input output :block sizes e(T ) for each T in TC
:itemset collection C = {X1 , . . . , Xk}
I ←{X | X ∈ sets(T ;C)} ;
1 for T in TC do 2 c(T ) ← 2N−|I| ; 3 4 sort the blocks in TC ; 5 for Ti in TC do e(Ti ) ← c(Ti ) ; 6 for Tj in TC , with j < i do 7 8 9 10 return TC ; if Ti ⊂ Tj then e(Ti ) ← e(Ti ) − e(Tj ) ; itemsets in sets(T ;C ) . Let I = {X | X ∈ sets(T ;C)} . That which is the number of transactions that contain at least all the is , I are the items that occur in all transactions of T . Then it holds that c(T ) = 2N−|I| , where N is the total number of items . Finally , to extract the block sizes e(T ) from the cumulative sizes c(T ) , we use the inclusion exclusion principle . To that end , we topologically sort the blocks such that if T2 ⊂ T1 , then T1 occurs before T2 ( which can easily be ensured when constructing TC ) . Then we simply iterate over the blocks in reverse , and subtract the sizes of their super blocks , e(T ) = c(T ) − e,T
.
T T
EXAMPLE 8 . Assume again that we have a dataset with eight items ( a to h ) , and an itemset collection containing three itemsets C = {abc , cd , def } with frequencies 0.5 , 0.4 and 08 Table 1 shows the sizes of the transaction blocks . Note that while there are 256 transactions in T , there are only 7 blocks in TC , whose sizes and probabilities are to be computed . ( The eighth combination , abc and def but not cd , is clearly impossible . )
Let us compute the sizes of the first three blocks . For the first block , I = abcdef and therefore c(T ) = 4 , for the second block I = abcd , and for the third block I = abc . Since the first block is the maximum with respect to the order ⊆ , its cumulative size is simply its size , so e(T ) = 4 . For the second block , we subtract the first block , and obtain e(T ) = 16−4 = 12 . From the third block we subtract the first two blocks , and we have e(T ) = 32−12−4 = 16 . Now , to compute , say , p(abc = 1 ) , we simply need the sizes of the blocks containing abc , and the current model parameters , p(abc = 1 ) = 4(u0u1u2u3 ) + 12(u0u1u2 ) + 16(u0u1 ) .
Table 1 : Transaction blocks for the running example above , with X1 = abc , X2 = cd , and X3 = def . e(T ) 4 12 16 12 36 16 160
X1 X2 X3 1 1 0 1 0 1 0 1 0 0 1 0 0 0 u0u1u2u3 u0u1u2 u0u1 u0u2u3 u0u2 u0u3 u0 c(T ) 4 16 32 16 64 32 256
1 1 0 1 1 0 0 p(A = t ) that if X1 ∈ C1 and X2 ∈ C2 , then X1 ∩ X2 = ∅ . Let B =C1
Lastly , the algorithm can be significantly optimized as follows . Assume that we can divide C into two disjoint groups C1 and C2 , such be the set of items occurring in C1 . Theorem 2 implies that p∗(A ) = p∗(B)p∗(A\B ) . In other words , the maximum entropy distribution can be factorized into two independent distributions , namely p∗(B ) and p∗(A\ B ) , more importantly , the factor p∗(B ) depends only on C1 . Consequently , if we wish to compute the probability p∗(X = 1 ) such that X ∈ B , we can ignore all variables outside B and all itemsets outside C1 . The number of computations to perform by COMPUTEBLOCKSIZES can now be greatly reduced , since in the case of independence |TC| = |TC1| × |TC2| , and we can simply compute the block sizes for TC1 and TC2 separately . Naturally , this decomposition can also be applied when there are more than two of such disjoint groups of itemsets .
Further , in order to guarantee that we can apply the above separation , we could reduce the solution space slightly by imposing a limit on the number of items or itemsets per group , such that the number of blocks remains small . Alternatively , we could first partition the items of the dataset into smaller , approximately independent groups [ 16 ] , and then apply the algorithm for each group separately . Including Frequencies of Individual Items 4.6 Often it is useful to inspect the frequencies of the individual items ( ie , the column margins ) in a dataset , since they supply basic , yet intuitive and easily calculable information about the data . For instance , they say which combinations of items are more ( or less ) likely to occur together frequently . However , in our method we cannot add the set of all singleton itemsets I to a collection C , since the number of transaction blocks would become |TC∪I| = |T | = 2N , by which we would be back at square one . We sketch ( due to space restrictions ) how this can be solved easily . Let C = C ∪ I . We continue working with TC rather than TC . As before , the maximum entropy model has an exponential form : p∗ . The second prodC ( A = t ) = u0 uct defines an independence distribution v = v0 . Then C ( A ∈ T ) = v(A ∈ T ) u0 p∗ . Thus , we simply need to compute v(A ∈ T ) , which is computed very similar to e(A ∈ T ) with COMPUTEBLOCKSIZES—note that e(A = t ) is basically the uniform distribution multiplied with 2N . Hence , we can include the item frequencies at an only marginal additional cost . 4.7 Querying the Model We have seen how we can efficiently query the probability of an itemset X ∈ C when given the maximum entropy distribution p∗ . In order to compute the probability of an arbitrary itemset Y that is not a member of C , we do the following . We first set G = C ∪ {Y } and compute the block probabilities e(T ) or v(A ∈ T ) for T in TG by calling COMPUTEBLOCKSIZES . Then , we can simply use the parameters of p∗ to compute p∗(Y = 1 ) , v(A ∈ T )
X∈C uSX ( T )
X∈C uSX ( t ) i∈I vSi(t )
( Y = 1 ) = i vSi(t ) i
∗ p i
X uSX ( T ) X
.
X v0
T ∈TG
SY ( T )=1 u0 v0
X∈C
Thus , to obtain the probability of an itemset , it suffices to compute the block probabilities in TG , for which we know that |TG| ≤ 2|TC| . 4.8 Computational Complexity Let us analyze the complexity of ITERATIVESCALING . To this end , we define ps(C ) = |TC| as the number of blocks in a partition . Note that ps(C ) ≤ min . The computational complexity of COMPUTEBLOCKSIZES is O(ps(C)2 ) for a given
2|C| , 2N
Algorithm 3 : MTV(D ) input output :itemset collection C
:binary dataset D , background knowledge itemsets B , integer k if mining top k
1 I ← items in D ; 2 C ← B ; 3 while s(C ) decreases and |C| < k do 4 5 6 7 8 return C ;
X ← FINDBESTITEMSET(∅,I,∅ ) ; C ← C ∪ {X} ; C ← ITERATIVESCALING(C ) ; p∗ compute s(C ) ;
X∈Ci
X , it holds that ps(Ci ) ≤ min collection C . Assume now that we can partition C into L disjoint parts C = C1 ∪ ··· ∪ CL , such that if X ∈ Ci and Y ∈ Cj then X ∩ Y = ∅ . As mentioned in Section 4.5 , we can now simply compute L independent distributions at a lower total cost . Denoting . If Ci cannot be partitioned further , this usually means that either |Ci| is small , or the itemsets in Ci overlap a lot and ps(Ci ) 2|Ci| . The toi=1 ps(Ci)2 ) , where K is the number of iterations , which is usually low . The complexity of estimating the frequency of an itemset requires running i=1 ps(Ci)2 ) .
2|Ci| , 2|Bi| Bi = tal execution time of ITERATIVESCALING is O(KL COMPUTEBLOCKSIZES once and hence equals O(L
5 . PROBLEM STATEMENT
In this section we formally state the problem we intend to solve , based on the theory introduced above .
THE PROBLEM . Given a collection of itemsets B that represents our background knowledge of a dataset D , a collection of potentially interesting itemsets F , and an integer k , find the subset C ⊆ F of size at most k , such that s(B ∪ C ) is minimal .
Note that F can simply consist of all itemsets , or eg , be restricted to a collection of frequent itemsets . If we do not wish to constrain the size of C , and essentially disregard k , we can simply set k = ∞ . Also note that the problem statement does not require F to be explicitly available beforehand , ie , it does not have to be mined or materialized in advance ( we postpone the details to Section 62 )
6 . MINING SUCCINCT SUMMARIES j j=0
In Section 4 we described how to compute the maximum entropy model and its BIC score given a set of itemsets . Finding the optimal collection as stated in Section 5 , however , is clearly infeasible . The
,|F| ≤ 2|F| . If we do not restrict size of the search space isk the candidate itemsets , then the number of all non singleton itemsets is |F| = 2N−N−1 . Moreover , the score function is not monotonic , which prevents us from straightforwardly exploring the search space . Therefore , we resort to using a heuristic , greedy approach . Starting with a set of itemsets representing our background knowledge— for instance the singletons—we incrementally construct our summary by iteratively adding the itemset that reduces the BIC score the most . The algorithm stops either when k interesting itemsets are found , or when the score no longer decreases . The pseudocode for our MTV algorithm , which mines Maximally informaTiVe summaries , is given as Algorithm 3 . 6.1 A Heuristic for Scoring Itemsets
Finding the best itemset to add to the current collection is practically infeasible , since it involves solving the maximum entropy model for each and every candidate . This remains infeasible even if we restrict the search space ( for example , using only frequent itemsets ) . Therefore , instead of selecting the candidate that optimizes the BIC score directly , we select the candidate that maximizes a heuristic which expresses the divergence between its frequency and its estimate . To derive and motivate this heuristic we first need the following theorem .
THEOREM 9 . Given an itemset collection C , it holds that C∪{X} p ∗ ∗ arg min s(C ∪ {X} ) = arg max
X
X
KL,p KL,qD p
CC∪{X}
∗
= arg min butions , defined as KL(p q ) = where KL is the Kullback Leibler divergence between two distriq(x ) , and qD is the x p(x ) log p(x )
X empirical distribution of the data .
G(D ) = |D|H(p∗ G ) .
PROOF . Let us write G = C ∪ {X} . Corollary 3 states that − log p∗ In addition , we can show with a C ) − H(p∗ straightforward calculation that KL(p∗ G ) . Therefore , minimizing s(G ) is equivalent to maximizing the divergence KL(p∗
C ) . The second equality follows similarly .
C ) = H(p∗
G p∗
G p∗
Thus , we search for the itemset X such that the new distribution diverges maximally from the previous one , or equivalently , brings us as close to the empirical distribution as possible . The heuristic that we use is an approximation of the KL divergence , where we group the terms containing X in one term , and the terms not containing X into another term . We define h : [ 0 , 1 ] × [ 0 , 1 ] → R+ as h(x , y ) = x log
+ ( 1 − x ) log x y
1 − x 1 − y
.
We then pick the itemset maximizing h(fr ( X ) , p∗(X = 1) ) , which we will denote simply as h(X ) when fr and p∗ are clear from the context . To compute this heuristic , we only need the frequency of X , and its estimate according to the current p∗ distribution . This gives us a measure of the divergence between fr ( X ) and p∗(X = 1 ) , ie , its surprisingness given the current model .
The following theorem gives and indication of how KL and h relate to one another .
THEOREM 10 . For an itemset collection C and itemset X , it holds that
0 ≤ h(X ) ≤ KL,p
Moreover , h(X ) = 0 if and only if KL,p∗
C∪{X} p ∗
C .
∗ when fr ( X ) = p∗(X = 1 ) .
C∪{X} p∗
C = 0 , ie ,
PROOF . The second inequality follows from the log sum inequal ity . The equality to zero is trivially verified . 6.2 Looking for the Best Itemset
In order to find the itemset maximizing h , we take a depth first branch and bound approach . We exploit the fact that h is convex , and employ the bound introduced by Nijssen et al . [ 20 ] to prune large parts of the search space as follows . Say that for a candidate itemset X in the search space , its maximal possible extension in the branch below it is X ∪ Y ( denoted XY ) , then for any itemset W such that X ⊆ W ⊆ XY , it holds that h(W ) ≤ max{h ( fr ( X ) , p
∗
( XY ) ) , h ( fr ( XY ) , p
∗
( X))} .
If this bound is lower than the best value of h seen so far , we know that no ( local ) extension W of X can ever become the best itemset with respect to h , and therefore we can safely prune the branch of the search space below X . The algorithm is given in Algorithm 4 .
Algorithm 4 : FINDBESTITEMSET(X , Y , Z ) input output :itemset between X and XY maximizing h , or Z
:itemset X , remaining items Y , currently best set Z
Z ← X ;
1 compute fr ( X ) and p∗(X ) ; 2 if h(X ) = h(fr ( X ) , p∗(X ) ) > h(Z ) then 3 4 compute fr ( XY ) and p∗(XY ) ; 5 b ← max{h(fr ( X ) , p∗(XY ) ) , h(fr ( XY ) , p∗(X))} ; 6 if b > h(Z ) then for y ∈ Y do 7 8 9 10 return Z ;
Y ← Y \ {y} ; Z ← FINDBESTITEMSET(X ∪ {y} , Y , Z ) ;
Table 2 : Synthetic and real datasets used in the experiments . |F| |D| minsup 25 110 15 % 8 748 5 % 12 256 10 % 101 673 1 % 19 620 0.1 % 0.5 % 672 345 20 % 2 169 624 5 % 3 755 512 2 % 635 496
Independent Markov Mosaic Abstracts Chess ( kr k ) DNA Amplification Mammals Mushroom Paleo
100 000 100 000 100 000 859 28 056 4 590 2 183 8 124 124
|A| 50 20 50 3 933 58 391 121 119 139
An advantage of this approach is that we do not need to collect the frequencies of all candidate itemsets beforehand . Instead , we just compute them on the fly as we need them ( line 1 ) . For instance , if we wish to pick itemsets from a collection F of frequent itemsets for some minimum support threshold , we can integrate the support counting in the depth first traversal of the algorithm , rather than first mining and storing F in its entirety . Since mining real datasets with non trivial minimal support thresholds can easily yield billions of frequent itemsets , this is indubitably a great benefit .
7 . EXPERIMENTS
In this section we experimentally evaluate our method and empirically validate the quality of the returned summaries . We implemented a prototype of our algorithm in C++ , and provide the source code for research purposes.1 All experiments were executed on a six core Intel Xeon machine with 12GB of memory , running Linux . We evaluate our method on three synthetic datasets , as well as on six real datasets . Their basic characteristics are given in Table 2 . The Independent data has independent items with random frequencies between 0.2 and 08 In the Markov dataset each item is a noisy copy of the previous one , with a random copy probability between 0.2 and 08 The Mosaic dataset is generated by randomly planting five itemsets of size 5 with random frequencies between 0.2 and 0.5 , in a database with 1 % noise . The Abstracts dataset contains the abstracts of all accepted papers at the ICDM conference up to 2007 , where words have been stemmed and stop words removed . The Chess ( kr k ) dataset was obtained from the UCI ML Repository [ 6 ] , and converted into binary form . The DNA data contains information on DNA copy number amplifications . Such copies activate oncogenes and are hallmarks of nearly all advanced tumors [ 19 ] . The Mammals 1http://wwwadremuaacbe/implementations presence data consists of presence records of European mammals within geographical areas of 50×50 km2 [ 17 , 18 ] . The Mushroom dataset was obtained from the FIMI dataset repository [ 11 ] . Finally , Paleo is a dataset of fossil records .
Our method is inherently parameter free . That is , given enough time , it can select the best set of itemsets from the complete space of possible itemsets . However , although our algorithm is quite efficient , in practice it may not always be feasible to consider all itemsets for dense or large datasets . In general , choosing a larger candidate space , yields better models . In our experiments we therefore consider collections of frequent itemsets F mined at support thresholds as low as feasible . The actual thresholds and corresponding size of F are depicted in Table 2 . Note that the minsup threshold is used to limit the size of F , and is strictly speaking not a parameter of the algorithm itself . For the synthetic datasets , we let the algorithm decide on the best summary size , that is , we set k = ∞ . As for the real datasets , we do impose a maximum of k itemsets that our algorithm may select . We set k such that the runtime remains within one hour . In all experiments , we initialize C with the singleton itemsets , ie , we start from the independence model . 7.1 Model BIC Scores
In Table 3 we give the scores of top k summaries , the time required to compute them , and for comparison we include the score of the independence model . We see that for most datasets the BIC score ( and thus relatedly the negative log likelihood ) decreases a lot , which implies that the summaries we find are of high quality . For very structured datasets , such as DNA , this improvement is very large , while it only takes a handful of itemsets to achieve this . 7.2 Summary Evaluation
Here we inspect the discovered data summaries in closer detail . For the Independent dataset we see that the first itemset that the algorithm tries to add immediately increases the BIC score . Therefore , the summary contains only singleton itemsets , which correctly corresponds to the independence model .
With the Markov data we notice that the itemsets in the summary are all quite small , and consist of consecutive items . This is in line with expectations , since the items form a Markov chain . The algorithm finds that together with the individual items , a summary of 21 itemsets suffices .
The summary of the Mosaic data contains the itemsets that were used to construct the dataset . Figure 1 depicts the evolution of the BIC score . We see that as the five embedded itemsets are discovered , the BIC score is drastically reduced . Afterwards , some additional itemsets are discovered , which contain items from two or more of the generating itemsets . However , they are not noise , and are needed to
Table 3 : The BIC scores of the discovered models , compared to the independence model . ( Lower scores are better . )
Independent Markov Mosaic Abstracts Chess ( kr k ) DNA Amplification Mammals Mushroom Paleo k 0 21 19 24 15 132 13 15 13 time 10 s 4 834 s 686 s 2 774 s 3 104 s 3 303 s 1 826 s 1 817 s 2 307 s s(C ) 4 494 656 1 826 576 812 792 254 974 774 899 91 125 107 268 343 367 7 787 s(indep ) 4 494 656 2 000 143 2 168 276 256 937 787 078 185 499 120 132 441 903 8 822
Table 4 : Top 10 itemsets of the Abstracts dataset for our method ( top left ) , KRIMP [ 23 ] ( top right ) , Kontonasios and De Bie [ 15 ] ( bottom left ) , and Tiling [ 9 ] ( bottom right ) . machin support svm vector associ mine rule algorithm frequent mine pattern analysi discrimin lda linear algorithm cluster dimension high nearest neighbor bay naiv frequent itemset mine analysi compon princip algorithm experiment result set demonstr space larg databas consid problem knowledg discoveri demonstr experiment rule mine associ databas algorithm base approach cluster dimension high real subspac synthet vector machin support discov frequent effici pattern mine algorithm associ rule database mine algorithm train learn classifi perform set frequent itemset dimensional high cluster mine synthetic real seri time decis tree classifi experiment propos problem approach result state art global local algorithm mine algorithm base result set approach problem method propos result experiment algorithm perform base model set method algorithm gener data mining topics such as support vector machines , frequent itemset mining and principle component analysis . Further , there is little overlap between the itemsets , and there is no variations on the sametheme type of redundancy present .
For KRIMP we depict the itemsets from the code table which have the highest usage . From a compression point of view , the items in these sets co occur often , and thus result in small codes for the itemsets . Arguably , this does not necessarily make them the most interesting , however , and we observe that some rather general terms such as state [ of the ] art or consider problem are ranked highly . The results of Kontonasios and De Bie ’s algorithm , based on the Information Ratio of tiles , are different from ours , but seem to be more or less similar in quality for this particular dataset . Finally , for Tiling we provide the top 10 itemsets of size at least two . Without this size restriction , only singletons are returned , which , although having the largest area , are not very informative . Still , the largest discovered tiles are of size two , and contain quite some redundancy , for instance , the top 10 contains only 13 ( out of 20 ) distinct items .
8 . DISCUSSION
The approach introduced in this paper fulfills several intuitive expectations one might have about summarization , such as succinctness , providing a characteristic description of the data , and having little redundancy . The experiments show that quantitatively we can achieve good BIC scores with only a handful of itemsets , and that these results are highly qualitative and meaningful ; moreover , we can discover them in a relatively short amount of time .
In this paper we consider data mining as an iterative process . By starting off with what we already know , we can identify those patterns that are the most surprising . Simply finding the itemset that is most surprising , is a problem that Hanhijhärvi et al . summarize as ‘tell me something I don’t know’ . When we repeat this process , in the end , we will have identified a group of itemsets that ‘tell me all there is to know’ about the data . Clearly , this group strongly overfits the data . This is where BIC provides a solution , as it automatically identifies the most informative group . Hence , we paraphrase our approach as ‘tell me what I need to know’ .
The view that we take here on succinctness and non redundancy is fairly strict . Arguably , there are settings conceivable where limited redundancy ( at the cost of brevity ) can give some robustness to a technique , or provide alternative insights by restating facts differently . However , this is not the intention of this paper , and
Figure 1 : BIC scores for the Mosaic dataset for increasing k . The minimum BIC score is attained at k = 19 . explain the overlapping behavior of some of the generating itemsets . When k reaches 20 , the BIC score increases , and the algorithm stops . ( Due to the scale of the plot this is not clearly visible in Figure 1 . ) Therefore , the algorithm decides that the dataset can be best described with 19 itemsets , of which 5 ( the generating itemsets ) clearly provide the most information . The transactions in the Mammals data represent geographical areas of 50×50 km2 in Europe . The itemsets discovered here represent sets of mammals that co exist in these regions . Investigating the areas where these sets of mammals are present , reveals that many of them form contiguous geographically sound territories , eg , Scandinavia , the Iberian peninsula , or Eastern Europe . ( Pictures are not shown here due to lack of space . )
In the case of the DNA data , our algorithm reached more than 100 iterations within one hour . As this dataset is banded , it contains a lot of structure [ 8 ] . Our method correctly discovers these bands , ie , blocks of consecutive items corresponding to related genes , lying on the same chromosomes . The first few dozen sets are large , and describe the general structure of the data . Then , as we continue , we start to encounter smaller itemsets , which describe more detailed nuances in the correlations between the genes . Figure 2 depicts a detail of the DNA dataset ( note that the figure is transposed ) , together with a few of the itemsets from the discovered summary . 7.3 Comparison with Other Methods
In Table 4 , we give the top 10 itemsets in the Abstracts dataset , as discovered by our method ( top left ) , KRIMP [ 23 ] ( top right ) , Kontonasios and De Bie ’s method [ 15 ] ( bottom left ) , and Tiling [ 9 ] ( bottom right ) . We see that our algorithm discovers recognizable
) s e n e g o c n o ( s m e t I
Transactions ( patients )
Figure 2 : Detail of the DNA dataset ( right ) , along with some of the discovered itemsets ( left ) . ( Figure is rotated to the left . )
8010510106121061410616106181062010622106 0 2 4 6 8 10 12 14 16 18 20BIC scoreSummary size k we furthermore argue that to this end our method can perfectly be complemented by techniques such as redescription mining [ 33 ] .
There are a number of possible improvements for our method . We are interested in refining the penalty in our score . Our current score only penalizes the number of elements in C , not their complexity ( eg , their size ) . Such a refinement would make it more strict , and could provide better results . Another problem setting in which our method is applicable , is that of finding the best specialization of a given itemset X . That is , to identify the superset Y of X that provides the best score s(C ∪ {Y } ) . This setup allows experts to interactively discover interesting itemsets . As part of future work , we are currently investigating this in practice for finding patterns in proteomics and mass spectrometry data .
9 . CONCLUSION
In this paper we introduced a well founded method for iteratively mining a non redundant collection of interesting itemsets from transaction data . We employ the Maximum Entropy principle to build a probabilistic model of the data , use this model to iteratively identify the most surprising itemsets , and then update our model accordingly . As such , unlike static interestingness models , our approach does not return patterns that are redundant with regard to what we have learned , and keeps the result set succinct yet informative .
Experiments show that we discover succinct summaries , which correctly identify important patterns in the data . The resulting models attain high log likelihoods , and are easy to interpret .
Acknowledgements Michael Mampaey is supported by the Institute for the Promotion of Innovation through Science and Technology in Flanders ( IWTVlaanderen ) , Nikolaj Tatti and Jilles Vreeken are supported by PostDoctoral Fellowships of the Research Foundation—Flanders ( FWO ) .
10 . REFERENCES [ 1 ] C . C . Aggarwal and P . S . Yu . A new framework for itemset generation . In Proc . PODS’98 , pages 18–24 , 1998 .
[ 2 ] S . Brin , R . Motwani , and C . Silverstein . Beyond market baskets : Generalizing association rules to correlations . In Proc . ACM SIGMOD’97 , pages 265–276 , 1997 .
[ 3 ] T . Calders and B . Goethals . Non derivable itemset mining .
Data Min . Knowl . Disc . , 14(1):171–206 , 2007 .
[ 4 ] I . Csiszár . I divergence geometry of probability distributions and minimization problems . The Annals of Probability , 3(1):146–158 , Feb . 1975 .
[ 5 ] J . Darroch and D . Ratcliff . Generalized iterative scaling for log linear models . The Annals of Mathematical Statistics , 43(5):1470–1480 , 1972 .
[ 6 ] A . Frank and A . Asuncion . UCI machine learning repository . http://archiveicsuciedu/ml , 2010 .
[ 7 ] A . Gallo , N . Cristianini , and T . De Bie . MINI : Mining informative non redundant itemsets . In Proc . PKDD’07 , pages 438–445 , 2007 .
[ 8 ] G . C . Garriga , E . Junttila , and H . Mannila . Banded structure in binary matrices . In Proc . ACM SIGKDD’08 , pages 292–300 , 2008 .
[ 9 ] F . Geerts , B . Goethals , and T . Mielikäinen . Tiling databases .
In Proc . DS’04 , pages 278–289 , 2004 .
[ 10 ] A . Gionis , H . Mannila , T . Mielikäinen , and P . Tsaparas .
Assessing data mining results via swap randomization . Trans . Knowl . Disc . Data , 1(3 ) , 2007 .
[ 11 ] B . Goethals and M . Zaki . Frequent itemset mining dataset repository . http://fimiuaacbe/
[ 12 ] P . D . Grünwald . The Minimum Description Length Principle .
MIT Press , 2007 .
[ 13 ] S . Hanhijärvi , M . Ojala , N . Vuokko , K . Puolamäki , N . Tatti , and H . Mannila . Tell me something I don’t know : randomization strategies for iterative data mining . In Proc . ACM SIGKDD’09 , pages 379–388 , 2009 .
[ 14 ] S . Jaroszewicz and D . A . Simovici . Interestingness of frequent itemsets using bayesian networks as background knowledge . In Proc . ACM SIGKDD’04 , pages 178–186 , 2004 .
[ 15 ] K N Kontonasios and T . De Bie . An information theoretic approach to finding noisy tiles in binary databases . In Proc . SDM’10 , pages 153–164 , 2010 .
[ 16 ] M . Mampaey and J . Vreeken . Summarising data by clustering items . In Proc . ECML PKDD’10 , pages 321–336 , 2010 .
[ 17 ] A . Mitchell Jones , G . Amori , W . Bogdanowicz , B . Krystufek ,
P . H . Reijnders , F . Spitzenberger , M . Stubbe , J . Thissen , V . Vohralik , and J . Zima . The Atlas of European Mammals . Academic Press , 1999 .
[ 18 ] T . Mitchell Jones . Societas europaea mammalogica . http://wwweuropean mammalsorg
[ 19 ] S . Myllykangas , J . Himberg , T . Böhling , B . Nagy , J . Hollmén , and S . Knuutila . DNA copy number amplification profiling of human neoplasms . Oncogene , 25(55):7324–7332 , 2006 . [ 20 ] S . Nijssen , T . Guns , and L . De Raedt . Correlated itemset mining in ROC space : a constraint programming approach . In Proc . ACM SIGKDD’09 , pages 647–656 , 2009 .
[ 21 ] N . Pasquier , Y . Bastide , R . Taouil , and L . Lakhal . Discovering frequent closed itemsets for association rules . In Proc . ICDT’99 , pages 398–416 , 1999 .
[ 22 ] G . Schwarz . Estimating the dimension of a model . Annals of
Statistics , 6(2):461–464 , 1978 .
[ 23 ] A . Siebes , J . Vreeken , and M . van Leeuwen . Item sets that compress . In Proc . SDM’06 , pages 393–404 , 2006 .
[ 24 ] P . Tan , V . Kumar , and J . Srivastava . Selecting the right interestingness measure for association patterns . In Proc . ACM SIGKDD’02 , pages 32–41 . ACM , 2002 .
[ 25 ] N . Tatti . Computational complexity of queries based on itemsets . Inf . Proc . Letters , pages 183–187 , 2006 .
[ 26 ] N . Tatti . Maximum entropy based significance of itemsets .
Knowl . Inf . Sys . , 17(1):57–77 , 2008 .
[ 27 ] N . Tatti . Probably the best itemsets . In Proc . ACM
SIGKDD’10 , pages 293–302 . ACM , 2010 .
[ 28 ] N . Tatti and H . Heikinheimo . Decomposable families of itemsets . In Proc . ECMLPKDD’08 , pages 472–487 , 2008 . [ 29 ] N . Tatti and M . Mampaey . Using background knowledge to rank itemsets . Data Min . Knowl . Disc . , 21(2):293–309 , 2010 . [ 30 ] C . Wang and S . Parthasarathy . Summarizing itemset patterns using probabilistic models . In Proc . ACM SIGKDD’06 , pages 730–735 , 2006 .
[ 31 ] G . I . Webb . Self sufficient itemsets : An approach to screening potentially interesting associations between items . Trans . Knowl . Disc . Data , 4(1 ) , 2010 .
[ 32 ] X . Yan , H . Cheng , J . Han , and D . Xin . Summarizing itemset patterns : a profile based approach . In Proc . ACM SIGKDD’05 , pages 314–323 , 2005 .
[ 33 ] M . J . Zaki and N . Ramakrishnan . Reasoning about sets using redescription mining . In Proc . ACM SIGKDD’05 , pages 364–373 , New York , NY , USA , 2005 . ACM Press .
