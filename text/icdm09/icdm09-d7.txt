2009 Ninth IEEE International Conference on Data Mining
Inverse Time Dependency in Convex Regularized Learning
Zeyuan Allen Zhu12* , Weizhu Chen2 , Chenguang Zhu23 , Gang Wang2 , Haixun Wang2 , Zheng Chen2
1Fundamental Science Class ,
Department of Physics , Tsinghua University zhuzeyuan@hotmail.com
2Microsoft Research Asia
{v zezhu , wzchen , v chezhu , gawa , haixunw , zhengc}@microsoft.com
3Department of Computer Science and Technology ,
Abstractâ€”In the conventional regularized learning , training time increases as the training set expands . Recent work on L2 linear SVM challenges this common sense by proposing the inverse time dependency on the training set size . In this paper , we first put forward a Primal Gradient Solver ( PGS ) to effectively solve the convex regularized learning problem . This solver is based on the stochastic gradient descent method and the Fenchel conjugate adjustment , employing the well known online strongly convex optimization algorithm with logarithmic regret . We then theoretically prove the inverse dependency property of our PGS , embracing the previous work of the L2 linear SVM as a special case and enable the ğ“µğ’‘ norm optimization to run within a bounded sphere , which qualifies more convex loss functions in PGS . We further illustrate this solver logistic regression and regularized least square . Experimental results substantiate the property of the inverse dependency on training data size . in three examples : SVM ,
Keywords â€“ Primal Gradient Solver ; inverse time dependency ; learning ; online convex regularized
Fenchel conjugate ; optimization
I .
INTRODUCTION
In the regularized learning theory , in order to minimize the sum of the regularization part and the loss part , most of the research works are interested in the generalization objective rather than the empirical objective [ 12 ] [ 1 ] . The generalization objective , also known as the stochastic objective , is given with respect to a linear predictor ğ’˜âˆˆğ‘† , where ğ‘†âŠ‚â„ is the domain of ğ’˜ : ğ¹(cid:3097)(ğ’˜)=ğœâˆ™ğ‘Ÿ(ğ’˜)+ğ‘™(ğ’˜ ) =ğœâˆ™ğ‘Ÿ(ğ’˜)+ğ”¼ğœ½~(cid:3005)(cid:3046)(cid:3047)[ğ‘™(âŒ©ğ’˜,ğœ½âŒª;ğœ½ ) ] where ğ‘Ÿ(ğ’˜ ) is the regularizer with a positive weight ğœ , and ğ‘™(âŒ©ğ’˜,ğœ½âŒª;ğœ½ ) is a mapping that calculates the cost or regret by the linear predicting value âŒ©ğ’˜,ğœ½âŒª . The expectation is based on a random selection of the sample ğœ½ over the entire sample distribution ğ·ğ‘–ğ‘ ğ‘¡ . Note that the form ğœ½ is used in order to ensure the generality . As an example , ğœ½ can be in the form of ( ğ’™,ğ‘¦ ) where ğ’™ is a vector of features and ğ‘¦ is the class identity , adapting ( 1 ) to classifications . The loss function ğ‘™ can be for
ğ‘™(âŒ©ğ’˜,ğ’™âŒª,ğ‘¦)=max{0,1âˆ’ğ‘¦âŒ©ğ’˜,ğ’™âŒª} example the SVM hinge loss
( 1 )
Practically , an optimization approach for this sort of problem becomes to minimize the empirical objective
1550 4786/09 $26.00 Â© 2009 IEEE DOI 101109/ICDM200928
667
ğ¹(cid:3552)(cid:3097)(ğ’˜ ) 1 instead , where the average loss over a set of ğ‘š
Tsinghua University zcgcs60@gmailcom training samples is used to approximate the generalization loss .
ğ¹(cid:3552)(cid:3097)(ğ’˜)=ğœâˆ™ğ‘Ÿ(ğ’˜)+ğ‘™(cid:4632)(ğ’˜ ) =ğœâˆ™ğ‘Ÿ(ğ’˜)+1ğ‘š(cid:3533)ğ‘™(âŒ©ğ’˜,ğœ½ğ’ŠâŒª;ğœ½ğ’Š ) ( cid:3040 ) ( cid:2880 )
( 2 ) the and between
The accuracy of a given predictor on some unknown prediction set is strongly associated with equation ( 1 ) . This naturally leads to a two step research work : connect ( 1 ) and ( 2 ) as the step 1 , and effectively solve ( 2 ) as the step 2 . empirical stochastic estimation
Step 1 . Recently , LÃ©on Bottou et al [ 1 ] studied the correlation but unregularized objectives and divided the tradeoff into three parts , namely , and optimization tradeoff . For regularized learning , Karthik
Sridharan et al [ 12 ] stated that ğ¹(cid:3552)(cid:3097)(ğ’˜ ) converges with a rate of 1/ğ‘š to ğ¹(cid:3097)(ğ’˜ ) for strongly convex objectives . approximation ,
Step 2 . In 2004 , T . Zhang [ 13 ] introduced the stochastic gradient descent ( SGD ) algorithm to solve large scale linear prediction problems . It proves that a constant learning rate will numerically achieve some good accuracy , and states the correlation between SGD and online learning . In 2006 , Hazan et al [ 3 ] introduced a framework with logarithmic regret to solve online strongly convex problems , which is the tightest known regret bound for online optimization . Utilizing this result , Shai Shalev Shwartz et al [ 10 ] proposed an â„“(cid:2870) norm linear SVM algorithm called PEGASOS . for example , if we get a predictor with accuracy 95 % by accuracy of 95 % , but in less time .
On the basis of the above two steps , Shai Shalev Shwartz et al [ 11 ] presented a surprising result for PEGASOS : assuming the endurable accuracy is given and fixed , the training time has an inverse dependency on the size of the training data , ie the larger the dataset is , the faster the program runs to achieve this given accuracy . He claimed that , training one thousand samples , we can use the extra nine thousand samples to train and get a predictor also with
* This work was done when the first author was visiting Microsoft Research Asia . The first author is supported by the National Innovation Research Project for Undergraduates ( NIRPU ) . throughout this paper we will use Ì‚ to denote the empirical functions .
1 In order to distinguish between the two â€“ generalized and empirical ,
SUMMARY OF TERMINOLOGY
Generalization objective Regularizer Generalization loss Empirical objective Empirical loss
Temporal objective at iter . ğ‘¡ Temporal loss at iter . ğ‘¡
Optimization error
Generalization error
ğ¹(cid:3097)(ğ‘¤)=ğœâˆ™ğ‘Ÿ(ğ‘¤)+ğ‘™(ğ‘¤ ) ğ‘Ÿ(ğ‘¤ ) ğ‘™(ğ’˜)=ğ”¼ğœ½~(cid:3005)(cid:3046)(cid:3047)[ğ‘™(âŒ©ğ’˜,ğœ½âŒª;ğœ½ ) ] ğ¹(cid:3552)(cid:3097)(ğ’˜)=ğœâˆ™ğ‘Ÿ(ğ’˜)+ğ‘™(cid:4632)(ğ’˜ ) ğ‘™(cid:4632)(ğ’˜)= ( cid:3040)âˆ‘ ğ‘™(âŒ©ğ’˜,ğœ½ğ’ŠâŒª;ğœ½ğ’Š ) ( cid:3040)(cid:2880 ) ğ‘(cid:3047)(ğ’˜)=ğœâˆ™ğ‘Ÿ(ğ’˜)+ğ‘”(cid:3047)(ğ’˜ ) ğ‘”(cid:3047)(ğ’˜)= |(cid:3002)(cid:3295)|âˆ‘ ğ‘™(âŒ©ğ’˜,ğœ½âŒª;ğœ½ ) ğœ–(cid:3028)(cid:3030)(cid:3030 ) , satisfies ğœ½âˆˆ(cid:3002)(cid:3295 ) ğ¹(cid:3552)(cid:3097)(ğ°)â‰¤ğ¹(cid:3552)(cid:3097)(ğ’˜(cid:3549))+ğœ–(cid:3028)(cid:3030)(cid:3030 ) ğœ– , satisfies âˆ€ğ’˜ğŸâˆˆğ‘† , ğ‘™(ğ’˜(cid:3557))âˆ’ğ‘™(ğ’˜ğŸ)â‰¤ğœ–
Sample Training sample space
The domain of predictor ğ‘¤
Population optimum Empirical optimum Reference predictor Our generated predictor Average number of nonzero features per sample is Dimension of feature space
TABLE I .
ğœƒ ğ›¹={ğœƒ,â€¦ğœƒ(cid:3040)} ğ‘† ğ’˜âˆ—=argminğ’˜âˆˆ(cid:3020)ğ¹(cid:3097)(ğ’˜ ) ğ’˜(cid:3549)=argmin(cid:2933)âˆˆSğ¹(cid:3097)(cid:3554)(ğ‘¤ ) ğ’˜ğŸ ğ’˜(cid:3557 ) ğ‘‘ ğ‘›
( 3 )
Notice that Shai focuses solely on the â„“(cid:2870) norm linear SVM problem , partially because the â„“(cid:2870) norm is naturally a property into more general problems , like â„“(cid:3043 ) norm , other strongly convex function and the hinge loss in SVM is easy to be handled . However , applying this inverse dependency is to maintain the strong
ğ‘Ÿ(ğ’˜)=
( PGS ) , which employs the following regularizer :
In this paper , we introduce the Primal Gradient Solver loss functions , or other machine learning algorithms , is very desirable , but it is an under explored research problem .
12(ğ‘âˆ’1)â€–ğ’˜â€–(cid:3043)(cid:2870),ğ‘âˆˆ(1,2 ] â„ arbitrary Lipschitz continuous and convex loss function
Gradient Solver algorithm can achieve the inverse time dependency on the training data size . This conclusion is also verified in the experiments . We summarize the contributions of this paper as below : where the coefficient of 12(ğ‘âˆ’1 ) convexity of ğ‘Ÿ(ğ’˜ ) . At the same time , we consider the ğ‘™(âŒ©ğ’˜,ğœ½âŒª;ğœ½ ) . We prove that for a fixed accuracy , our Primal generalizes the state of the art â„“(cid:2870) SVM result [ 11 ] to â„“(cid:3043) norm and convex loss functions . Notice that â€¢ By bounding S ( the domain of ğ’˜ ) , PGS is able to Square Loss is ineligible for ğ‘†=â„ because of its for ğ‘†=(cid:3419)ğ’˜:â€–ğ’˜â€–(cid:3043)â‰¤ğµ(cid:3423 ) , where ğµ is a constant large enough to embrace the optimal solution of ğ’˜âˆ— in ğ‘† . the generalization the mathematical analysis utilizes a Fenchel conjugate of lacks an explicit expression in most circumstances .
It proposes a Primal Gradient Solver ( PGS ) and proves its inverse dependency property . This work unbounded gradient , but is proved to be acceptable support more loss functions . For example , Least regularizer , which is non trivial , since the
â€¢
â€¢
It firstly demonstrates that both logistic loss and least square loss can be adopted into the proposed solver and achieve the inverse dependency property . Extensive experimental results on two machine learning and regularized least square , substantiate the conclusion . algorithms , regression logistic in this section , we
II . MATH BACKGROUND AND TERMINOLOGY used in this paper in TABLE I . Considering the boundedness
The reminder of this paper is organized as follows . We first provide mathematical backgrounds on convex optimization theory in Section II . Next in Section III , we propose our main result by introducing our Primal Gradient Solver , and analyzing its inverse dependency property . We further demonstrate our solver in SVM , logistic regression and regularized least square in Section IV , and present experimental results in Section V to substantiate our findings . We provide the theoretical proofs of our main theorems in Section VI . We then raise some discussions in Section VII , and conclude the paper in Section VIII .
Next introduce some definitions frequently used in convex optimization , and a proposition to be used later .
Throughout this paper we assume norms to be ğ‘ norms , where ğ‘âˆˆ[1,âˆ)âˆª{âˆ} . We also summarize the notations of some vector ğ‘¥ , we will stick to the expression â€œ â€–ğ‘¥â€–(cid:3043 ) is bounded â€ instead of â€œ ğ‘¥ is bounded â€ for some explicit ğ‘.2 Definition 1 : A function ğ‘“:ğ‘†â†’â„ is called ğ¿ Lipschitz continuous wrt a norm â€–.â€– if âˆ€ğ’˜ğŸ,ğ’˜ğŸâˆˆğ‘† , |ğ‘“(ğ’˜ğŸ)âˆ’ğ‘“(ğ’˜ğŸ)|â‰¤ğ¿âˆ™â€–ğ’˜ğŸâˆ’ğ’˜ğŸâ€– Definition 2 : A function ğ‘“:ğ‘†â†’ğ‘… is called Ïƒ strongly convex wrt a norm â€–.â€– if âˆ€ğ’˜ğŸ,ğ’˜ğŸâˆˆğ‘†,ğ›¼âˆˆ[0,1 ] , ğ‘“(ğ›¼ğ’˜ğŸ+(1âˆ’ğ›¼)ğ’˜ğŸ ) â‰¤ğ›¼ğ‘“(ğ’˜ğŸ)+(1âˆ’ğ›¼)ğ¹(ğ’˜ğŸ ) âˆ’ğœ2ğ›¼(1âˆ’ğ›¼)â€–ğ’˜ğŸâˆ’ğ’˜ğŸâ€– Definition 3 : The Fenchel conjugate of a function ğ‘“:ğ‘†â†’ğ‘… âˆ€ğ‘,ğ‘âˆˆ[1,âˆ)âˆª{âˆ},âˆƒğ¶âˆˆâ„,âˆ€ğ‘¥,â€–ğ‘¥â€–(cid:3043)â‰¤ğ¶âˆ™â€–ğ‘¥â€–(cid:3044 )
2 This is because although in finite dimension , norms are pair wise however , the bounding ğ¶ may hide a constant up to ğ‘› . is defined as : bounded
( 5 )
( 4 )
668
2 .
1 .
( 6 ) and predictor
4 . 5 . 6 . 7 . 8 .
Figure 1 : The Primal Gradient Solver .
INPUT : training sample space ğ›¹={ğœƒ,â€¦ğœƒ(cid:3040)} ğ‘,ğœ,ğ‘‡,ğ‘˜ INITIALIZE : ğ’˜ğŸâ†0 , ğ€â†0 , ğ‘â†1/(1âˆ’1/ğ‘ ) 3 . FOR ğ‘¡ = 1,2,â€¦,ğ‘‡ Choose ğ´(cid:3047)âŠ‚ğ›¹ satisfying |ğ´(cid:3047)|=ğ‘˜ Set ğ‘”(cid:3047)(ğ’˜)â† |(cid:3002)(cid:3295)|âˆ‘ ğ‘™(âŒ©ğ’˜,ğœ½âŒª;ğœ½ ) Choose ğ€ğ’•âˆˆğœ•ğ‘”(cid:3047)(ğ’˜ğ’•ğŸ ) ğœ½âˆˆ(cid:3002)(cid:3295 ) Let ğ€â†ğ€âˆ’ğ€ğ’• Define ğ’˜ğ’•â†ğ›»ğ‘Ÿâˆ—(cid:4672 ) ğ€((cid:3047))(cid:3097)(cid:4673 ) where ğ‘Ÿ(ğ’˜)= ( cid:2870)((cid:3043))â€–ğ’˜â€–(cid:3043)(cid:2870 ) 9 . Return a random ğ’˜ğ’Šâˆˆ{ğ’˜ğŸ,â€¦ğ’˜ğ‘»} as linear ğ‘“âˆ—(ğœ½)=ğ‘ ğ‘¢ğ‘ğ’˜âˆˆ(cid:3020)âŒ©ğ’˜,ğœ½âŒªâˆ’ğ‘“(ğ’˜ ) Example 1 : When ğ‘†=â„ , for ğ‘âˆˆ(1,2 ] , the function ğ‘“(ğ’˜)= ( cid:2870)((cid:3043))â€–ğ’˜â€–(cid:3043)(cid:2870 ) is 1 strongly convex wrt the â„“(cid:3043 ) norm , its Fenchel conjugate ğ‘“âˆ—(ğœ½)= ( cid:2870)((cid:3044))â€–ğœ½â€–(cid:3044)(cid:2870 ) . Here ( cid:3043)+(cid:3044)=1 . Proofs can be found in [ 8 ] [ 2 ] . The strong convexity does not hold for ğ‘>2 . Definition 4 : The dual norm of the â„“(cid:3043 ) norm â€–ğ’™â€–(cid:3043)= ( âˆ‘|ğ‘¥|(cid:3043 ) )/(cid:2926 ) is the â„“(cid:3044 ) norm â€–ğ’™â€–(cid:3044)=(âˆ‘|ğ‘¥|(cid:3044 ) )/(cid:2927 ) if 1/p+ 1/q=1 . As a special case , â€–ğ’™â€–=âˆ‘|ğ‘¥|
â€–ğ’™â€–(cid:2998)=max|ğ‘¥| .
Definition 5 : A vector ğ€ is a sub gradient of a function ğ‘“ at ğ’˜ if for all ğ’˜(cid:4593)âˆˆğ‘† we have ğ‘“(ğ’˜(cid:4593))âˆ’ğ‘“(ğ’˜)â‰¥âŒ©ğ’˜(cid:4593)âˆ’ğ’˜,ğ€âŒª . The differential set of ğ‘“ at ğ’˜ consists of all the sub gradients and is denoted by âˆ‚ğ‘“(ğ’˜ ) . When ğ‘“ is differentiable at ğ’˜ , âˆ‚ğ‘“(ğ’˜ ) contains exactly one element âˆ‚ğ‘“(ğ’˜)={âˆ‡ğ‘“(ğ’˜)} . Proposition 1 : If a function ğ‘“:ğ‘†â†’â„ is L Lipschitz continuous wrt norm â€–.â€–(cid:3043 ) , then âˆ€ğ’˜âˆˆğ‘† , the sub gradient at ğ’˜ is bounded : â€–ğ€â€–(cid:3044)â‰¤ğ¿,âˆ€ğ€âˆˆğœ•ğ‘“(ğ’˜ ) , where 1/p+ 1/q=1 . continuity , we have for any ğ’˜(cid:4593)âˆˆğ‘† , âŒ©ğ’˜(cid:4593)âˆ’ğ’˜,ğ€âŒªâ‰¤ğ‘“(ğ’˜(cid:4593))âˆ’ğ‘“(ğ’˜)â‰¤ğ¿âˆ™â€–ğ’˜(cid:4593)âˆ’ğ’˜â€–(cid:3043 ) By the knowledge of HÃ¶lder inequality there exists a ğ’˜(cid:4593)âˆˆğ‘† such that âŒ©ğ’˜(cid:4593)âˆ’ğ’˜,ğ€âŒª=â€–ğ’˜(cid:4593)âˆ’ğ’˜â€–(cid:3043)â€–ğ€â€–(cid:3044 ) , and combining the above two we arrive at â€–ğ€â€–(cid:3044)â‰¤ğ¿ . âˆ
Proof : By the definition of differential set and Lipschitz is dual to
III . MAIN RESULT
In this section we first propose a Primal Gradient Solver and state the requirements for the regularizer and the loss function ; we then use two theorems to reveal the inverse time dependency , that is , the required running time decreases as the number of samples increases , when achieving a fixed generalization error .
669
1 . assuming regularized
3 . 4 . 5 . 6 . 7 .
( cid:3040 ) ( cid:2880 )
A . Primal Gradient Solver convex optimization problem , satisfies the following two assumptions : superscript of the form ( j ) to denote the jth coordinate of a vector
In this paper , we concentrate on the loss function that
INPUT : ğ€,ğ‘,ğ‘† . Let ğ‘› be the feature dimension . 2 . FOR ğ‘–=1,2,â€¦,ğ‘› ğ‘¤(cid:3047)()â† ( cid:3044)(cid:3436)âˆ‘(cid:4698 ) ( cid:3090)((cid:3285 ) ) ( cid:3440)(cid:3118)(cid:3292)âˆ™(cid:4698 ) ( cid:3090)((cid:3285 ) ) ( (cid:3047))(cid:3097)(cid:4698)(cid:3044 ) ( (cid:3047))(cid:3097)(cid:4698)(cid:3044)âˆ™sgnğœ†( ) IF ğ‘†=â„ , RETURN ğ’˜ğ’•
IF ğ‘†=(cid:3419)ğ’˜:â€–ğ’˜â€–(cid:3043)â‰¤ğµ(cid:3423 ) IF â€–ğ’˜ğ’•â€–(cid:3043)>ğµ THEN , ğ’˜ğ’•â† ( cid:3003)â€–ğ’˜ğ’•â€–(cid:3292)ğ’˜ğ’• RETURN ğ’˜ğ’• â„ Figure 2 : Explicit calculation for ğ’˜ğ’•=âˆ‡râˆ—(ğ›Œ(t+1)Ïƒ ) . We use the We first introduce the Primal Gradient Solver for the â„“(cid:2926 ) ğ‘âˆˆ(1,2 ] . By substituting the regularizer ( 3 ) into ( 2 ) , we ğœ2(ğ‘âˆ’1)â€–ğ’˜â€–(cid:3043)(cid:2870)+1ğ‘š(cid:3533)ğ‘™(âŒ©ğ’˜,ğœ½ğ’ŠâŒª;ğœ½ğ’Š ) have : ğ¹(cid:3552)(cid:3097)(ğ’˜)= â€¢ Convexity : ğ‘™(âŒ©ğ’˜,ğœ½âŒª;ğœ½ ) satisfies the convexity wrt ğ’˜ in ğ‘† . Pay attention that we do not require the â€¢ Lipschitz Continuity : ğ‘™(âŒ©ğ’˜,ğœ½âŒª;ğœ½ ) satisfies ğ¿ Lipschitz continuity wrt ğ’˜ and â€–.â€–(cid:3043 ) norm in ğ‘† , where ğ¿ is a constant . gradient ğœ•ğ’˜ğ‘™(âŒ©ğ’˜,ğœ½âŒª;ğœ½ ) is bounded wrt â€–â€–(cid:3044 ) This property the norm parameter ğ‘ , the weight of the regularizer Ïƒ , the number of iterations ğ‘‡ , and a given positive integer ğ‘˜ . Initially we set ğ’˜ğŸ=0 and a working vector ğ€=0 . At iteration t we randomly choose a set ğ´(cid:3047)âŠ‚Î¨,|ğ´(cid:3047)|=ğ‘˜ , and consider a temporal loss function ğ‘”(cid:3047)(ğ’˜ ) to approximate the empirical loss ğ‘™(cid:4632)(ğ’˜ ) : ğ€ğ’•âˆˆğœ•ğ‘”ğ‘¡(ğ’˜ğ’•âˆ’ğŸ ) , and subtract it from ğ€ by ğ€â†ğ€âˆ’ğ€ğ’• . The next ğ’˜ğ’• is calculated according to the gradient of the
ğ‘”(cid:3047)(ğ’˜)= 1|ğ´(cid:3047)|(cid:3533)ğ‘™(âŒ©ğ’˜,ğœ½âŒª;ğœ½ ) ğœ½âˆˆ(cid:3002)(cid:3295 ) ğ€(ğ‘¡+1)ğœ(cid:3440 ) ğ’˜ğ’•=ğ›»ğ‘Ÿâˆ—(cid:3436 )
Inspired by the work of PEGASOS [ 10 ] , we propose a Primal Gradient Solver ( Figure 1 ) . We take four parameters :
The solver then picks up an arbitrary sub gradient
We notice that with the help of Proposition 1 , the sub
Fenchel conjugate ( see Section II for definition ) : strong convexity here . will be used later .
( 8 )
( 9 )
( 7 )
Running time
Section III.A
ğ‘‡
Theorem 2
Theorem 1
Generalization error
Optimization error
â€¢
â€¢
â„
Figure 3 : Outline of the proof .
Assume the dimension of the feature space , ie , the these two cases cover most of the circumstances in the applications .
The above process is organized in Figure 1 . In Figure 2 , we write the explicit formula of Equation ( 9 ) for the two
Figure 2 ) . The proof of this can be found in the Appendix , by comparing the results of Corollary 2 and Corollary 3 . directly . The explicit form is shown on Line 3 in Figure 2 . cases ğ‘†=â„ and ğ‘†=(cid:3419)ğ’˜:â€–ğ’˜â€–(cid:3043)â‰¤ğµ(cid:3423 ) . We will show that If ğ‘†=â„ , we recall Example 1 in Section II , and calculate the gradient of ğ‘Ÿâˆ—(ğœ½)=â€–ğœ½â€–(cid:3044)(cid:2870 ) 2(ğ‘âˆ’1 ) If ğ‘†=(cid:3419)ğ’˜:â€–ğ’˜â€–(cid:3043)â‰¤ğµ(cid:3423 ) is bounded , we actually calculate ğ’˜ğ’• in the same way , but project it back to the ğ‘ norm sphere ğ‘† if it lies outside ğ‘† ( Line 6 of dimension of ğ’˜ , is ğ‘› , and the average number of non zero features per sample is ğ‘‘ . If the sub gradient ğœ•ğ‘”(cid:3047)(ğ’˜ ) can be computed efficiently in ğ‘‚(ğ‘‘ğ‘˜ ) , the time complexity for the Primal Gradient Solver is ğ‘‚(cid:3435)ğ‘‡(ğ‘‘ğ‘˜+ğ‘›)(cid:3439 ) since calculating the gradient of ğ‘Ÿâˆ— costs ğ‘‚(ğ‘› ) , as shown in in Figure 2 . the special case of ğ‘=2 , since the term ( cid:3435)âˆ‘â€¦ ( cid:3439)(cid:3118)(cid:3292 ) ( (cid:3047))(cid:3097)(cid:3628)(cid:3044)âˆ™sgnğœ†()â‡’ğ’˜ğ’•= ğ€((cid:3047))(cid:3097 ) ğ‘¤(cid:3047)((cid:2919))=(cid:3628 ) ( cid:3090)((cid:3285 ) ) In this case we no longer need ğ‘‚(ğ‘› ) to calculate âˆ‡ğ‘Ÿâˆ— , as we can use a variable to store the coefficient in front of ğ€ and update it in ğ‘‚(1 ) time , leaving the overall complexity ğ‘‚(ğ‘‡ğ‘‘ğ‘˜ ) . Gradient Solver for â„“(cid:2926 ) regularized convex optimization , and optimization error and the number of iterations ğ‘‡ , which will Theorem 1 ( To be proved in Section VI.A ) : If ğ‘Ÿ(ğ‘¤ ) = ( cid:3097)(cid:2870)((cid:3043))â€–ğ’˜â€–(cid:3043)(cid:2870 ) , ğ‘”(cid:3047)(ğ‘¤)= ( cid:3040)âˆ‘ ğ‘™(âŒ©ğ’˜,ğœ™(ğœ½ğ’Š)âŒª;ğœ½ğ’Š )
Notice that the calculation in Figure 2 gains a speed up in estimated the running time in terms of the number of iterations . Now we state the correlation between the give us a running time in terms of the optimization error ( see Figure 3 ) .
In the previous sub section , we introduced a Primal
B . Inverse Dependency on Training Data Size degenerates to 1 :
( cid:3040)(cid:2880 )
( 10 )
, the loss then satisfies the convexity and Lipschitz continuity , if
( 11 ) theorem ,
Based on the above the endurable logarithmic factors .
Figure 4 : Inverse time dependency with fixed generalization loss the predictor optimized by the Primal Gradient Solver . If the predictor , optimized by our Primal Gradient Solver , the most immediate reflection of its accuracy is the generalization
The following theorem actually bases on Theorem 1 to further give us a correlation between the generalization error and the number of iterations .
âˆ€ğ›¿âˆˆ(0,1 ) , with probability of at least 1âˆ’ğ›¿ over the choices of ğ´,â€¦ğ´ and the index ğ‘– , we have : ğ¹(cid:3552)(cid:3097)(ğ’˜ğ’Š)â‰¤ğ¹(cid:3552)(cid:3097)(ğ’˜(cid:3549))+ğ¶logğ‘‡ğœğ‘‡ğ›¿ optimization error is ğœ–(cid:3028)(cid:3030)(cid:3030 ) , and satisfies ğ¹(cid:3552)(cid:3097)(ğ’˜ğ’Š)â‰¤ğ¹(cid:3552)(cid:3097)(ğ’˜(cid:3549))+ ğœ–(cid:3028)(cid:3030)(cid:3030 ) , the algorithm needs ğ‘‡=ğ‘‚(cid:3560)(cid:4672 ) ( cid:3097)(cid:3083)(cid:3106)(cid:3276)(cid:3278)(cid:3278)(cid:4673 ) iterations ignoring The optimization error ğœ–(cid:3028)(cid:3030)(cid:3030 ) functions as a bridge to the study of the generalization error . We state that if ğ’˜(cid:3557 ) is some error ğœ– . In some other words,âˆ€ğ’˜ğŸâˆˆğ‘† , ğ‘™(ğ’˜(cid:3557))âˆ’ğ‘™(ğ’˜ğŸ)â‰¤ğœ– . Theorem 2 ( To be proved in Section VI.B ) : Suppose ğ’˜(cid:3557 ) is desired error rate ğœ– obeys ğ‘™(ğ’˜(cid:3557))â‰¤ğ‘™(ğ’˜ğŸ)+ğœ– ,âˆ€ğ’˜ğŸâˆˆğ‘† , then 1/ğ›¿ â€–ğ’˜ğŸâ€–(cid:3291)(cid:3118 ) âˆ’ğ‘‚(cid:3560)(cid:4672)(cid:3040)(cid:4673)(cid:3442 ) ( cid:2870)(cid:3106)(cid:3118)((cid:3043 ) ) Choosing3 ğ‘˜=1 and integrating ( 12 ) into the complexity â€¢ ğ‘=2 , the time complexity is ğ‘‚(cid:3438 ) ğ’˜ğŸ(cid:3291)(cid:3118 ) ( cid:3016)(cid:3560)(cid:4672)(cid:3117)(cid:3288)(cid:4673)(cid:3442 ) ( cid:3031)/(cid:3083 ) ( cid:3118)(cid:3354)(cid:3118)((cid:3291)(cid:3127)(cid:3117 ) ) â€¢ ğ‘âˆˆ(1,2 ) , the time complexity is ğ‘‚(cid:3438 ) ğ’˜ğŸ(cid:3291)(cid:3118 ) ( cid:3016)(cid:3560)(cid:4672)(cid:3117)(cid:3288)(cid:4673)(cid:3442 ) /(cid:3083 ) ( cid:3118)(cid:3354)(cid:3118)((cid:3291)(cid:3127)(cid:3117 ) ) from above , decreases as the sample count ğ‘š increases . This special case of ğ‘=2 with the SVM hinge loss . 3 We will discuss how to choose the best ğ‘˜ in the Section VII . is called the property of inverse time dependency on the training data size . This conclusion confirms the theoretical result in [ 11 ] which proves the inverse dependency in the
As illustrated in Figure 4 , the time complexity derived of the Primal Gradient Solver , we conclude that : the required number of iterations satisfies :
ğ‘‡=ğ‘‚(cid:3438 )
( 12 )
670
We state that this result comes from the perfect wedding of the following two : when the number of training samples increases â€¢ We expect a smaller gap between the empirical â€¢ We approximate the loss function more accurately objective and the generalization objective . using the random sampling .
IV . APPLICATIONS inequality we deduce that demonstrations of the loss functions .
â€¢ The SVM hinge loss : â€¢ The Logistic loss : we consider the Lipschitz continuity of the Least Square loss . It can be checked this property does not hold in the entire
The convexity of the three loss functions above and the Lipschitz continuity of first two loss functions can be easily
In this section we utilize the Primal Gradient Solver on three specific loss functions . We first consider the binary
If we consider the regression problem with instanceâ€¢ The Least Square loss : classification problem with instance label pairs ğœ½=(ğ’™,ğ‘¦ ) where ğ‘¦âˆˆ{âˆ’1,1} , we have the following two famous ğ‘™(âŒ©ğ’˜,ğœ½âŒª;ğœ½)=max{0,1âˆ’ğ‘¦âŒ©ğ’˜,ğ’™âŒª} ğ‘™(âŒ©ğ’˜,ğœ½âŒª;ğœ½)=log(cid:3435)1+ğ‘’(cid:3052)âŒ©ğ’˜,ğ’™âŒª(cid:3439 ) value pairs ğœ½=(ğ’™,ğ‘¦ ) where ğ‘¦âˆˆâ„ , we have ğ‘™(âŒ©ğ’˜,ğœ½âŒª;ğœ½)=(âŒ©ğ’˜,ğ’™âŒªâˆ’ğ‘¦)(cid:2870 ) verified mathematically , wrt the entire space ğ‘†=â„ . Now space ğ‘†=â„ , but we may constrain the space to ğ‘†= ( cid:3419)ğ‘¤:â€–ğ‘¤â€–(cid:3043)â‰¤ğ¶(cid:3423 ) . For any ğ’˜ğŸ,ğ’˜ğŸâˆˆğ‘† , using HÃ¶lder's ğ‘™(âŒ©ğ’˜ğŸ,ğœ½âŒª;ğœ½)âˆ’ğ‘™(âŒ©ğ’˜ğŸ,ğœ½âŒª;ğœ½ ) =âŒ©ğ’˜ğŸâˆ’ğ’˜ğŸ,ğ’™âŒª(âŒ©ğ’˜ğŸ,ğ’™âŒª+âŒ©ğ’˜ğŸ,ğ’™âŒªâˆ’2ğ‘¦ ) â‰¤â€–ğ’˜ğŸâˆ’ğ’˜ğŸâ€–(cid:3043)â€–ğ’™â€–(cid:3044)(cid:3435)2ğ¶â€–ğ’™â€–(cid:3044)+2|ğ‘¦|(cid:3439)â‰¤â€–ğ’˜ğŸâˆ’ğ’˜ğŸâ€–(cid:3043)âˆ™ğ¿ is fixed and thus â€–ğ’™â€–(cid:3044 ) and |ğ‘¦| are naturally bounded . All we ğ’˜(cid:3549 ) must lie in ğ‘†=(cid:3419)ğ’˜:â€–ğ’˜â€–(cid:3043)â‰¤ğµ(cid:3423 ) . This is because ğ‘Ÿ(ğ’˜âˆ—)â‰¤ ğ¹(cid:3097)(ğ’˜âˆ—)â‰¤ğ¹(cid:3097)(0)â‰¤(max|y|)(cid:2870 ) is bounded , where max|y| is the upper bound for |ğ‘¦| . write down ğ€ğ’• : ğœ†(cid:3047)= |(cid:3002)(cid:3295)|âˆ‘ ğ‘¦âˆ™ğ’™ ( ğ’™,(cid:3052))âˆˆ(cid:3002)(cid:3295),(cid:3052)âŒ©ğ’™,ğ’˜ğ’•âŒª(cid:2996 ) ğœ†(cid:3047)= |(cid:3002)(cid:3295)|âˆ‘ ğ’™ ( cid:3052)âˆ™(cid:3032)(cid:3127)(cid:3300)âŒ©ğ’™,ğ’˜ğ’•âŒª ( ğ’™,(cid:3052))âˆˆ(cid:3002)(cid:3295 ) ( cid:3032)(cid:3127)(cid:3300)âŒ©ğ’™,ğ’˜ğ’•âŒª 2(âŒ©ğ’˜,ğ’™âŒªâˆ’ğ‘¦)ğ’™ ğœ†(cid:3047)= |(cid:3002)(cid:3295)|âˆ‘ ( ğ’™,(cid:3052))âˆˆ(cid:3002)(cid:3295 ) restrict ğ‘† to some bounded sphere just like we did for the
Therefore , our solver can be properly adapted to these three loss functions . Note that the Lipschitz continuity of the loss function is an important requirement in the deduction ( see
Considering the algorithmic framework in Figure 1 , we â€¢ SVM hinge loss : the last inequality holds for the reason that the sample space left to do is to further verify the empirical optimum solution
Section VI ) . If this requirement is not met , we need to
â€¢ Least Square loss :
â€¢ Logistic loss :
Least Square loss . We emphasize that the introduction of
Acc>93 % QN LR Acc>94 % PGS LR Acc>94.5 % PGS LR Acc>94 % PGS 1.8LR g n i n i a r t n i s d n o c e S
80 70 60 50 40 30 20 10 0
0 x 100000
8
4 optimal Ïƒ .
2 Number of training samples
6 functions to be included as loss functions .
Figure 5 : Running time required to achieve given accuracy on CCAT for bounded ğ‘† enables more kinds of convex and continuous Taking the SVM loss with ğ‘=2 and ğ‘†=(cid:3419)ğ’˜:â€–ğ’˜â€–â‰¤ 1/âˆšğœ} as an example , our solver immediately gives the accuracy bound depends on the boundedness of ğ‘† . However , in ğ‘†=â„(cid:2924 ) case our algorithm can still run efficiently . It algorithm called PEGASOS [ 10 ] . In that paper the proof of the we used a slightly different Lemma 1 which tells us that even answers the question in footnote 2 of [ 11 ] on why the projection step can be skipped .
V . EXPERIMENTS in
In this section we further strengthen our theoretical result proposed the experimental results . We test our solver in three regularizer loss pairs : â„“(cid:2870) Logistic , â„“.(cid:2876) Logistic and â„“(cid:2870) LeastSquare . We do not use the SVM loss here since its â„“(cid:2870) norm counterpart the previous section by presenting has been well tested in [ 11 ] . All the following works are conducted on a computer with 2.4 GHz AMD Opteron Processor 852 and 32G RAM . We first introduce the dataset in the experiments : â€¢ The binary classification set CCAT retrieved from RCV1 collection [ 5 ] . We used 781,265 samples in training and performed prediction on 23,149 testing samples . A total of 47,236 features are in this dataset and with sparsity 016 % â€¢ Three toy binary classification sets with 200,000 samples are used where the number of features is 10 , 20 , and 40 separately . The samples with positive label and with negative label are generated from two Gaussian distributions with different means but the same covariance . Thus , the optimal separating plane is a linear function characterized by a unit vector ğ’˜âˆ— , returns a unit predictor ğ’˜ , we will use the error â€–ğ’˜âˆ—âˆ’ğ’˜â€–(cid:2870 ) to verify its correctness . count ğ‘š , we first choose an optimal Ïƒ(ğ‘š ) according to the
Throughout this section , for a given training sample and can be pre calculated . Assume the program maximal achievable accuracy on the testing set , and then rerun the program to retrieve the required running time to obtain some benchmark accuracies , like 93 % , 94 % , etc . We
671 g n i n i a r t n i s d n o c e S
200
150
100
50
0
2
3
Acc>94.525 % Acc>94.55 % Acc>94.575 % Acc>94.6 % Acc>94.625 % Acc>94.65 %
7 x 100000
4
6 Number of training samples
5
Figure 6 : Inverse dependency experiment of 2 norm logistic regression , on
CCAT dataset
600
450
300
150
0
1.5
2.5
Acc>94.525 % Acc>94.55 % Acc>94.575 % Acc>94.6 % Acc>94.625 % Acc>94.65 % g n i n i a r t n i s d n o c e S s n o i t a r e t i f o r e b m u N
672 g n i n i a r t n i s d n o c e s f o r e b m u N
200
150
100
50
0
1.5
2.5
Acc>94.525 % Acc>94.55 % Acc>94.575 % Acc>94.6 % Acc>94.625 % Acc>94.65 %
3.5
4.5
5.5
Number of training samples
6.5
7.5 x 100000
( PGS ) in Section VII . square , on CCAT dataset
Figure 7 : Inverse dependency experiment of 2 norm regularized least
In the first experiment we compare our Primal Gradient is not scientific [ 4 ] . See further discussion in Section VII for details .
Solver Regression ( LR ) against the L BFGS Quasi Newton ( QN ) method [ 7 ] for LR . The latter has been proved to be superior remark here that choosing a best ğœ according to the test data for â„“(cid:2870 ) and â„“.(cid:2876 ) regularized Logistic in training large scale â„“(cid:2870) regularized Logistic Regression by [ 6 ] . In PGS , we choose ğ‘˜=1 for ğ‘=2 and ğ‘˜=300 for ğ‘=18âˆˆ(1,2 ) The reason for this selection is discussed Solver does not increase as the sample size ğ‘š increases , for both ğ‘=2 and ğ‘=18âˆˆ(1,2 ) Although QN can achieve 94.5 % , its running time is above 600 seconds and we ignore of iterations inversely dependent on ğ‘š . However , because each iteration in QN has a time complexity related to ğ‘š , the number of iterations inversely dependent on ğ‘š , the time on ğ‘š . It is the combination of these two properties that total running time of QN still increases . On the contrary , PGS is profited by its stochastic behavior . Not only its it in Figure 5 for the sake of simplicity . It is worth noting that , in the experiment of QN , we also discover the number
As one can see from Figure 5 , except for the QuasiNewton algorithm , the running time of our Primal Gradient an accuracy of the same level as PGS , namely , higher than complexity of a single iteration in PGS is also independent contributes to the final inverse time dependency .
4.5
3.5 Number of training samples
5.5
6.5
7.5 x 100000
Figure 8 : Inverse dependency experiment of 1.8 norm logistic regression , on CCAT dataset
Toy10 Toy20 Toy40
10
0 0 0 0 1 x
7.5
5
2.5
0
0
0.5
1
1.5
Figure 9 : Inverse dependency experiment of 2 norm logistic regression , on
Number of training samples toy dataset
2 x 100000
In the second experiment we check the inverse time dependency for different sets of regularizer loss pairs against both CCAT data and our toy data . We run our program against a set of distinct sample sizes and record the number of seconds required to reach each accuracy benchmark . Due to the randomness of our Primal Gradient Solver we test our program at least 20 times and choose the median . Notice that although Equation ( 12 ) theoretically studies an upper bound in the training time , the decreasing of upper bound does not directly suggest the real time inverse dependency . Nevertheless , the experimental results in Figure 6 , Figure 7 , Figure 8 and Figure 9 all confirm the property in ( 12 ) .
Similar to the first experiment , we set for â„“(cid:2870) norm ğ‘˜=1 and for â„“.(cid:2876 ) norm ğ‘˜=300 . The median of 20 runs are used the number of iterations required for PGS of â„“(cid:2870 ) Logistic Regression to train our toy data to achieve an error â€–ğ’˜âˆ—âˆ’ ğ’˜â€–ğŸ of 005 The median of 150 runs are used . We state that independent on the number of training samples ğ‘š , so we use the time complexity at each iteration is constant and for Figure 6 , Figure 7 and Figure 8 . Figure 9 demonstrates the number of iterations to be the y axis for a better illustration in Figure 9 .
In the third experiment , we test our program in CCAT dataset against the optimal solution generated by QuasiNewton algorithm . We run the QN program with sufficient
Regularizer
TABLE II . THE RUNNING TIME AND ACCURACY OF OUR PRIMAL GRADIENT SOLVER USING AN OPTIMAL ğˆ ON CCAT . â„“(cid:2870 ) â„“.(cid:2876 ) â„“(cid:2870 )
Optimal ğˆ QN Accuracy
PGS Accuracy 094735Â±000042 094763Â±000035 094615Â±000060
0.94799 0.94808 0.94687 The program has been run 20 times and the accuracy is given by â€œ median Â± standard â€ deviation in the table .
LogisticRegression LogisticRegression
55sec 576sec 22sec
PGS Training Time
1E 6 4E 7 2E 5
Least Square
Loss
( 17 )
( 16 )
Line 9 of Figure 1 . the proof of theorem 1 .
We now start to calculate the expected optimization error ,
Now incorporating the Markov inequality , we provide substituting them into ( 16 ) and using the result of Lemma 1 we have
Proposition 1 , the â„“(cid:3044) norm of ğ€ğ’•âˆˆğœ•ğ‘”(cid:3047)(ğ’˜ğ’•ğŸ ) is bounded , arriving at our conclusion . âˆ based on the iid selection of subsets ğ´,â€¦ğ´ and the ğ’˜ğ’Š in ğ”¼[ğœ–(cid:3028)(cid:3030)(cid:3030)]=ğ”¼(cid:3002)(cid:3117),â€¦,(cid:3002)(cid:3269)ğ”¼(cid:3000)(cid:3000)(cid:3427)ğ¹(cid:3552)(cid:3097)(ğ’˜ğ’Š)(cid:3431)âˆ’ğ¹(cid:3552)(cid:3097)(ğ’˜(cid:3549 ) ) where the empirical optimum ğ’˜(cid:3549)=argminğ°âˆˆSğ¹(cid:3097)(cid:3553)(ğ’˜ ) Using a similar technique from [ 10 ] , we state that ğ”¼(cid:3002)(cid:3117),â€¦,(cid:3002)(cid:3269)ğ”¼(cid:3000)(cid:3000)(cid:3427)ğ¹(cid:3552)(cid:3097)(ğ’˜ğ’Š)(cid:3431)=ğ”¼(cid:3002)(cid:3117),â€¦,(cid:3002)(cid:3269)ğ”¼(cid:3000)(cid:3000)[ğ‘(ğ’˜ğ’Š ) ] and ğ¹(cid:3552)(cid:3097)(ğ’˜(cid:3549))=ğ”¼(cid:3002)(cid:3117),â€¦,(cid:3002)(cid:3269)(cid:3429)1ğ‘‡minğ’˜âˆˆ(cid:3020)(cid:3533)ğ‘(cid:3047)(ğ’˜ ) ( cid:3433 )
( cid:3047)(cid:2880 ) ğ”¼[ğœ–(cid:3028)(cid:3030)(cid:3030)]â‰¤ğ¶logğ‘‡ğœğ‘‡ Proof of Theorem 1 : The random variable ğœ–(cid:3028)(cid:3030)(cid:3030)=ğ¹(cid:3097)(cid:3553)(ğ’˜ğ’Š)âˆ’ ğ¹(cid:3097)(cid:3553)(ğ’˜(cid:3549))â‰¥0 is non negative , and we have ğ”¼[ğœ–(cid:3028)(cid:3030)(cid:3030)]â‰¤(cid:3004)(cid:2922)(cid:2925)(cid:2917)(cid:3097 ) , ( cid:4681)âˆ™ğ”¼[ğœ–(cid:3028)(cid:3030)(cid:3030)]ğ›¿ Pr(cid:4680)ğœ–(cid:3028)(cid:3030)(cid:3030)â‰¥ğ”¼[ğœ–(cid:3028)(cid:3030)(cid:3030)]ğ›¿ â‰¤ğ”¼[ğœ–(cid:3028)(cid:3030)(cid:3030 ) ] â‡’Pr(cid:3428)ğœ–(cid:3028)(cid:3030)(cid:3030)â‰¤ğ¶logğ‘‡ğœğ‘‡ğ›¿ ( cid:3432)â‰¥1âˆ’ğ›¿ 1âˆ’ğ›¿ , we have ğœ–(cid:3028)(cid:3030)(cid:3030)â‰¤(cid:3004)(cid:2922)(cid:2925)(cid:2917)(cid:3097)(cid:3083 ) . This immediately gives us the statement . âˆ ğ‘™(ğ’˜(cid:3557))âˆ’ğ‘™(ğ’˜ğŸ ) =(cid:3435)ğ¹(cid:3097)(ğ’˜(cid:3557))âˆ’ğ¹(cid:3097)(ğ’˜âˆ—)(cid:3439)+(cid:3435)ğ¹(cid:3097)(ğ’˜âˆ—)âˆ’ğ¹(cid:3097)(ğ’˜ğŸ)(cid:3439 ) ğœ2(ğ‘âˆ’1)â€–ğ’˜(cid:3557)â€–(cid:3043)(cid:2870)+ ğœ2(ğ‘âˆ’1)â€–ğ’˜ğŸâ€–(cid:3043)(cid:2870 ) âˆ’ here ğ’˜(cid:3557 ) is the solution given by our Primal Gradient Solver , optimum ğ’˜âˆ—=argminğ’˜âˆˆ(cid:3020)ğ¹(cid:3097)(ğ’˜ ) generalization loss ğ‘™(ğ’˜)=ğ”¼ğœ½~(cid:3005)[ğ‘™(âŒ©ğ’˜,ğœ½âŒª;ğœ½) ] .
B . Proof of Theorem 2 Proof of Theorem 2 : Following [ 12 ] , we decompose the generalization loss into four parts :
The above inequality shows that with probability at least then using the Markov inequality population and
( 19 )
( 18 )
, number of iterations to reach the convergent solution that minimizes the objective ( it takes more than 2 hours ) . Results in TABLE II . indicate that our Primal Gradient Solver can obtain the accuracy on the same level as Quasi Newton , while the training time is within 1 minute for â„“(cid:2870 ) regularized ones , and within 10 minutes for the â„“.(cid:2876 ) regularized one .
VI . PROOF OF THE MAIN THEOREMS
In this section we put forward the detailed proofs of the two theorems in Section III.B , using the best known logarithmic regret [ 4 ] for online convex optimization [ 15 ] , and the Oracle inequality in decomposing generalization loss [ 12 ] . A . Proof of Theorem 1
According to ( 8 ) , our temporal objective at iteration ğ‘¡ is We state that ğ‘Ÿ(ğ’˜)=â€–wâ€–(cid:2926)(cid:2870)/2(pâˆ’1 ) is 1 strongly convex ( Example 1 ) and a ğ‘”(cid:3047)(ğ’˜ ) is convex according to our requirement to ğ‘™ . This suggests ğ‘(cid:3047)(ğ’˜ ) be Ïƒ strongly convex ,
ğ‘(cid:3047)(ğ’˜)=ğœâˆ™ğ‘Ÿ(ğ’˜)+ğ‘”(cid:3047)(ğ’˜ ) given by
( 13 ) based on the additivity in [ 8 ] .
We next examine the counterpart of our problem in online convex optimization , introduced by [ 15 ] . In such problem , the ultimate purpose is to minimize the regret
ğ‘Ÿğ‘’ğ‘”ğ‘Ÿğ‘’ğ‘¡â‰”(cid:3533)ğ‘(cid:3047)(ğ’˜ğ’• )
( cid:3047)(cid:2880 )
âˆ’min(cid:2933)âˆˆS(cid:3533)ğ‘(cid:3047)(ğ’˜ )
( cid:3047)(cid:2880 ) algorithm defined in Figure 1 satisfies :
The following lemma gives a bound for the regret of our Primal Gradient Solver ( Figure 1 ) . Its proof can be seen in Theorem 2 in [ 4 ] .
Lemma 1 : Let ğ‘,â€¦ğ‘ be a sequence of Ïƒ strongly convex functions over some convex domain ğ‘† wrt the some norm â€–.â€–(cid:3043 ) . Assume â€–.â€–(cid:3044 ) is the dual norm of â€–.â€–(cid:3043 ) , then the ( cid:3533)ğ‘(cid:3047)(ğ’˜ğ’• ) âˆ’minğ’˜âˆˆ(cid:3020)(cid:3533)ğ‘(cid:3047)(ğ’˜ )
( cid:3047)(cid:2880 ) ( cid:3047)(cid:2880 ) Corollary 1 : If ğ‘(cid:3047 ) is defined according the requisites of the by ( cid:3004)(cid:2922)(cid:2925)(cid:2917)(cid:3097 ) , where ğ¶ is a constant . Proof : This boundedness is ensured if â€–ğ€ğ’•â€–(cid:3044)(cid:2870 ) is bounded by constant . Recall the Lipschitz continuity for ğ‘™(âŒ©ğ’˜,ğœ½âŒª;ğœ½ ) , which infers the Lipschitz continuity for ğ‘”(cid:3047 ) . Based on
â‰¤12(cid:3533)â€–ğ€ğ’•â€–(cid:3044)(cid:2870 )
ğ‘¡ğœ ( cid:3047)(cid:2880 )
Primal Gradient Solver , the above regret is further bounded
( 15 )
( 14 )
673
The second and third term of equation ( 19 ) is nonpositive , while the first term , the generalization objective difference , can be further bounded by the empirical objective difference according to the main result in [ 12 ] . Combining the results along with the optimization accuracy studied in the previous section ( Theorem 1 ) , we arrive at the following inequality
ğ‘™(ğ’˜(cid:3557))âˆ’ğ‘™(ğ’˜ğŸ ) â‰¤ğ‘‚(cid:3560)(cid:3436 ) 1ğœğ‘‡ğ›¿(cid:3440)+ If we choose ğœ=Î˜(cid:3561)(cid:4678)(cid:3495)(cid:2870)((cid:3043 ) ) ğ‘™(ğ’˜(cid:3557))âˆ’ğ‘™(ğ’˜ğŸ ) â‰¤ğ‘‚(cid:3560)(cid:4684)â€–ğ’˜ğŸâ€–(cid:3043)(cid:3496 ) Let ğœ– equal to the right side of this inequality , we immediately arrive at Theorem 2 . âˆ
ğœ2(ğ‘âˆ’1)â€–ğ’˜ğŸâ€–(cid:3043)(cid:2870)+ğ‘‚(cid:3560)(cid:3436)1ğœğ‘š(cid:3440 ) â€–ğ’˜ğŸâ€–(cid:3291)(cid:3118)(cid:3436)(cid:3083)+ğ‘‚(cid:3560)(cid:4672)(cid:3040)(cid:4673)(cid:3440)(cid:4679 ) , the right 12(ğ‘âˆ’1)(cid:4678)1ğ‘‡ğ›¿+ğ‘‚(cid:3560)(cid:3436)1ğ‘š(cid:3440)(cid:4679)(cid:4685 ) hand side is bounded as following :
( 20 )
( 21 )
VII . FURTHER DISCUSSION example : multiple regularizer learning . now are also suitable to be regularizers . In this paper we
( for instance , TABLE II . ) . The reason is still unknown and
In this section we dialectically analyze the limitation of our Primal Gradient Solver and propose some enhancements . We also discuss some problems raised in the previous sections . Why p norm ? In the Primal Gradient Solver , the strong convexity is a core requisite to ensure the convergence rate of ğŸ/ğ‘» . However , few strongly convex functions found up to examined the squared ğ’‘âˆˆ(ğŸ,ğŸ ] norms , and experimental results show that ğ’‘=ğŸ.ğŸ– does slightly better than others the choice of ğ’‘ may open an interesting field to study , for We notice that ğ’‘=ğŸ is not included in this paper for the ğ’“(ğ’˜)=âˆ‘ |ğ’˜ğ’Š|ğ¥ğ¨ğ |ğ’˜ğ’Š| ğ’ğ’Š(cid:2880)ğŸ under the assumption that ğ’˜ is a linear predictor . When ğ‘=2 , a common technique is to construct a mapping ğœ™ that calculation of âŒ©ğ’˜,ğœ™(ğ’™)âŒª needs a traverse on the support vector byâŒ©ğ’˜,ğœ™(ğ’™)âŒª=âˆ‘(cid:3435)ğ›¼ğ’¦(ğ’™ğ’Š,ğ’™)(cid:3439 ) reason that 1 norm itself has a poor convexity . However , 1norm has the often desired property of reducing the number of active features . In [ 8 ] [ 9 ] , Shai proposed a substitute that is strongly convex , which also works well in Primal Gradient Solver with advantages in feature selection . The adoption of Kernel . All the works above are verified maps from the feature space to the Reproducing Kernel Hilbert Space ( RKHS ) space , availing us a non linear separator . We emphasize that our Primal Gradient Solver can be slightly adjusted to cater for this assumption , as the
. However , due to the complexity cost for this inner product , the inverse time dependency property no longer holds . In a counterpart of this paper [ 14 ] we studied the performance of such kernel PGS ,
674 and the result shows that even without the inverse time dependency , the algorithm overwhelms the state of the art in both efficiency and accuracy . Incorporate with a biased term . In our algorithm defined above , we have ignored the biased term in the general loss ğ‘™ . biased term to the loss function like log(cid:3435)1+ğ‘’(cid:3052)âŒ©ğ’˜,(cid:3109)(ğ’™)âŒª(cid:3029)(cid:3439 ) ,
The most efficient way to compensate for it is to add this and at the same time modify the regularizer to
12(ğ‘âˆ’1)(cid:3435)â€–ğ‘¤â€–(cid:3043)(cid:3043)+ğ‘(cid:3043)(cid:3439)/(cid:3043 ) optimization problem [ 4 ] . in Section III.A , if the complexity of Primal Gradient Solver keeps the complexity unchanged but boosts the confidence while the time complexity remains the same and the accuracy is raised . used within the analysis . Actually , in each iteration we may use the Chernoff bound to boost the confidence and give a
Doing this allows us to preserve the strong convexity of the regularizer , but runs into a different way as the normal regularizer without this bias term . If we consistently ignore this term in the regularizer , the convergence rate of our solver will reduce to ğ‘‚(cid:3435)1/âˆšğ‘‡(cid:3439 ) like a generalized convex The selection of parameter ğ’Œ . From the above discussion we can see the number of selected samples ğ‘˜=|ğ´(cid:3047)| is never better bound than ğ‘‡=ğ‘‚(cid:3560)(cid:4672 ) ( cid:3097)(cid:3083)(cid:3106)(cid:4673 ) . Both theoretical analysis and experimental results show that in the ğ‘=2 case it is worthless to set ğ‘˜>1 ; as an alternative , we may choose one single sample each iteration and do ğ‘˜âˆ™ğ‘‡ iterations in total However , for ğ‘âˆˆ(1,2 ) it is not the case . As mentioned is ğ‘‚(cid:3435)ğ‘‡(ğ‘‘ğ‘˜+ğ‘›)(cid:3439 ) , we had better choose ğ‘˜=ğ‘‚(ğ‘›/ğ‘‘ ) which significantly . For the RCV1 dataset where ğ‘›=47,236 and ğ·â‰ˆ40 , we may choose ğ‘˜=300 , which greatly reduces the investigate the influence of ğ‘˜ more theoretically in the future . The selection of weight ğˆ . According to Eq ( 12 ) , the running time depends on an unknown vector ğ’˜ğŸ that is the optimal predictor in training . Similarly , the choice of ğœ also depends on ğ’˜ğŸ and we never have such a priori knowledge actually know ğœ we cannot run the program at all . Due to of the Primal Gradient Solver that will make ğœ self adapted . the â„“(cid:3043) norm regularized convex learning problems that can is proved to be ğ‘‚(ğ‘‘/ğœ–(cid:3028)(cid:3030)(cid:3030)ğ›¿ğœ ) for ğ‘=2 and ğ‘‚(ğ‘›/ğœ–(cid:3028)(cid:3030)(cid:3030)ğ›¿ğœ ) for ğ‘âˆˆ(1,2 ) , where ğ›¿ is the confidence parameter , ğœ is the regularization parameter , ğ‘‘ is the average number of non deal with any loss satisfying the convexity and Lipschitz continuity , including the famous SVM loss , Logistic loss and Least Square loss . For all of them the expected running time number of required iterations . Experimental results in Section V have confirmed this analysis and we will on how to choose it . A validation set does not work because we are optimizing the running speed and not until we this reason , we are currently working on a modified version
In this paper we analyzed a Primal Gradient Solver for
VIII . SUMMARY zero features for a sample , ğ‘› is the dimension size of the feature space , and ğœ–(cid:3028)(cid:3030)(cid:3030 ) is the desired optimization error . within 10 seconds for ğ‘=2 , and 20 seconds for ğ‘=1.8 ,
Experimental results on CCAT dataset in Reuters Corpus Volume 1 ( RCV1 ) show that our Primal Gradient Solver , for all of the three loss functions , approaches an accuracy of 94 % while the L BFGS Quasi Newton method needs 600 seconds to obtain the same accuracy .
The most important contribution of this paper is that , based on this Primal Gradient Solver , we proved it is not only more efficient than the traditional algorithms , but also endowed with inverse time dependency property on the number of training samples , for a fixed accuracy .
This result , confirmed by the dataset of RCV1 and three toy sets , reminds us that even a linear time algorithm might not theoretically meet the best efficiency . There might exist some algorithm , like our Primal Gradient Solver , whose time complexity is independent on the number of samples ğ‘š , and even inversely dependent on ğ‘š .
ACKNOWLEDGMENT
Zeyuan Allen Zhu wants to thank Shai Shalev Shwartz of Hebrew University for his valuable discussions . The authors also acknowledge Matt Callcut and all four anonymous reviewers for their fruitful comments . REFERENCE
[ 1 ] LÃ©on Bottou and Olivier Bousquet , "The Tradeoffs of Large Scale
Learning," in NIPS , 2007 .
[ 2 ] Stephen Boyd and Lieven Vandenberghe , Convex Optimization , 6th ed . : Cambridge University Press , 2008 .
[ 3 ] Elad Hazan , Adam Kalai , Satyen Kale , and Amit Agarwal , "Logarithmic Regret Algorithms for Online Convex Optimization," in COLT , 2006 .
[ 4 ] Sham Kakade and Shai Shalev Shwartz , "Mind the Duality Gap : Logarithmic regret algorithms for online optimization," in NIPS , 2009 . [ 5 ] David D . Lewis , Yiming Yang , Tony G . Rose , and Fan Li , "RCV1 : A New Benchmark Collection for Text Categorization Research," Journal of Machine Learning Research , vol . 5 , pp . 361 397 , 2004 .
[ 6 ] Thomas P . Minka , "A comparison of numerical optimizers for logistic regression," Microsoft Research , Technical Report 2003 .
[ 7 ] Jorge Nocedal and Stephen J . Wright , Numerical Optimization ,
Chapter 6 7 , 2nd ed . : Springer .
[ 8 ] Shai Shalev Shwartz , "Online Learning : Theory , Algorithms , and applications," The Hebrew University , PhD Thesis 2007 .
[ 9 ] Shai Shalev Shwartz and Yoram Singer , "Logarithmic Regret Algorithms for Strongly Convex Repeated Games," The Hebrew University , Technical Report 2007 .
[ 10 ] Shai Shalev Shwartz , Yoram Singer , and Nathan Srebro , "Pegasos :
Primal Estimated sub GrAdient SOlver for SVM," in ICML , 2007 .
[ 11 ] Shai Shalev Shwartz and Nathan Srebro , "SVM Optimization : Inverse
Dependence on Training Set Size," in ICML , 2008 .
[ 12 ] Karthik Sridharan , Nathan Srebro , and Shai Shalev Shwartz , "Fast
Rates for Regularized Objectives," in NIPS , 2008 .
[ 13 ] Tong Zhang , "Solving Large Scale Linear Prediction Problems Using
Stochastic Gradient Descent Algorithms," in ICML , 2004 .
[ 14 ] Zeyuan Allen Zhu , Weizhu Chen , Gang Wang , Chenguang Zhu , and Zheng Chen , "P packSVM : Parallel Primal grAdient desCent Kernel SVM," in ICDM , 2009 .
675
[ 15 ] Martin Zinkevich , "Online convex programming and generalized infinitesimal gradient ascent," in ICML , 2003 , pp . 928 936 .
( 22 )
APPENDIX and differentiable and
Its proof can be seen from Lemma 6 of [ 9 ] .
Lemma 2 : Let ğ‘“ be a closed and strongly convex function to norm â€–.â€– , then ğ‘“âˆ— is over ğ‘†âŠ‚â„ with respect âˆ‡ğ‘“âˆ—(ğœ½)=argmax âŒ©ğ’˜,ğœ½âŒªâˆ’ğ‘“(ğ’˜ ) ğ’˜âˆˆ(cid:3020 ) Theorem 3 : If ğ‘†=(cid:3419)ğ’˜:â€–ğ’˜â€–(cid:3043)â‰¤ğµ(cid:3423 ) and ğ‘“(ğ’˜)=(cid:2870)â€–ğ’˜â€–(cid:3043)(cid:2870 ) , let ( cid:3043)+(cid:3044)=1 , then 12â€–ğœ½â€–(cid:3044)(cid:2870 ) , â€–ğœ½â€–(cid:3044)â‰¤ğµ ğ‘“âˆ—(ğœ½)=(cid:3422 ) 12â€–ğœ½â€–(cid:3044)(cid:2870)âˆ’12(cid:3435)ğµâˆ’â€–ğœ½â€–(cid:3044)(cid:3439)(cid:2870 ) , â€–ğœ½â€–(cid:3044)>ğµ ( 23 ) ( cid:3435)âˆ‡ğ‘“âˆ—(ğœ½)(cid:3439)=min{ğµ,â€–ğœ½â€–(cid:3044)} ğœƒ(cid:3044)/(cid:3043 ) â€–ğœ½â€–(cid:3044)(cid:3044)/(cid:3043 ) Proof : For any given ğœ½ , using the HÃ¶lder's inequality we have âŒ©ğ’˜,ğœ½âŒªâ‰¤â€–ğ’˜â€–(cid:3043)âˆ™â€–ğœ½â€–(cid:3044 ) . Subtracting both sides of them by ( cid:2870)â€–ğ’˜â€–(cid:3043)(cid:2870 ) , we have âŒ©ğ’˜,ğœ½âŒªâˆ’12â€–ğ’˜â€–(cid:3043)(cid:2870)â‰¤â€–ğ’˜â€–(cid:3043)âˆ™â€–ğœ½â€–(cid:3044)âˆ’12â€–ğ’˜â€–(cid:3043)(cid:2870 ) =âˆ’12(cid:3435)â€–ğ’˜â€–(cid:3043)âˆ’â€–ğœ½â€–(cid:3044)(cid:3439)(cid:2870)+12â€–ğœ½â€–(cid:3044)(cid:2870 ) and substituting the definition of ğ‘“âˆ— , ie Eq ( 6 ) : ğ‘“âˆ—(ğœ½)=ğ‘ ğ‘¢ğ‘ğ’˜âˆˆ(cid:3020)âŒ©ğ’˜,ğœ½âŒªâˆ’12â€–ğ’˜â€–(cid:3043)(cid:2870 ) â‰¤ğ‘ ğ‘¢ğ‘ğ’˜âˆˆ(cid:3020)(cid:3436)âˆ’12(cid:3435)â€–ğ’˜â€–(cid:3043)âˆ’â€–ğœ½â€–(cid:3044)(cid:3439)(cid:2870)+12â€–ğœ½â€–(cid:3044)(cid:2870)(cid:3440 ) 12â€–ğœ½â€–(cid:3044)(cid:2870 ) , â€–ğœ½â€–(cid:3044)â‰¤ğµ =(cid:3422 ) 12â€–ğœ½â€–(cid:3044)(cid:2870)âˆ’12(cid:3435)ğµâˆ’â€–ğœ½â€–(cid:3044)(cid:3439)(cid:2870 ) , â€–ğœ½â€–(cid:3044)>ğµ explicit construction of ğ’˜ that satisfies the equality sign in HÃ¶lder's inequality . For a given norm ğ¶=min{ğµ,â€–ğœ½â€–(cid:3044)} , we construct ğ’˜âˆ— by letting ğ‘¤âˆ—= ( cid:3004)â€–(cid:3087)â€–(cid:3292)(cid:3292)/(cid:3291)ğœƒ(cid:3044)/(cid:3043 ) . It can be easily checked that â€–ğ’˜âˆ—â€–(cid:3043)=ğ¶ and âŒ©ğ’˜âˆ—,ğœ½âŒª=â€–ğ’˜âˆ—â€–(cid:3043)âˆ™â€–ğœ½â€–(cid:3044 ) , and the latter holds because ( (ğ‘¤âˆ—)(cid:3043),â€¦(ğ‘¤âˆ—)(cid:3043 ) ) and ( cid:3435)ğœƒ(cid:3044),â€¦ğœƒ(cid:3044)(cid:3439 ) are linear dependent . We remark here that we use ğ‘¥(cid:3043 ) for the abbreviation of |ğ‘¥|(cid:3043)âˆ™sgnğ‘¥ . This suffices to prove the
Actually , the equality of Eq ( 26 ) holds , because of an
( 24 )
( 25 )
( 26 ) equality of Eq ( 26 ) , ie Eq ( 23 ) .
2 :
Corollary
Regarding Eq ( 24 ) , we adopt Lemma 2 and see that
âˆ‡ğ‘“âˆ—(ğœ½)=argminğ°âˆˆS(cid:3435)â€–ğ’˜â€–(cid:3043)âˆ’â€–ğœ½â€–(cid:3044)(cid:3439)(cid:2870)=ğ’˜âˆ— . âˆ and ğ‘“(ğ’˜)= If ğ‘†=(cid:3419)ğ’˜:â€–ğ’˜â€–(cid:3043)â‰¤ğµ(cid:3423 ) ( cid:2870)((cid:3043))â€–ğ’˜â€–(cid:3043)(cid:2870 ) , let ( cid:3043)+(cid:3044)=1 , then ğ‘“âˆ—(ğœ½ ) 12(ğ‘âˆ’1)â€–ğœ½â€–(cid:3044)(cid:2870 ) , â€–(ğ‘âˆ’1)ğœ½â€–(cid:3044)â‰¤ğµ â©âªâªâ¨âªâªâ§ 12(ğ‘âˆ’1)â€–ğœ½â€–(cid:3044)(cid:2870)âˆ’ = â€–(ğ‘âˆ’1)ğœ½â€–(cid:3044)>ğµ ( 27 ) 12(ğ‘âˆ’1)(cid:3435)ğµâˆ’â€–(ğ‘âˆ’1)ğœ½â€–(cid:3044)(cid:3439)(cid:2870 ) , ( cid:3435)âˆ‡ğ‘“âˆ—(ğœ½)(cid:3439)=min{ğµ,â€–(ğ‘âˆ’1)ğœ½â€–(cid:3044)} ğœƒ(cid:3044)/(cid:3043 ) â€–ğœ½â€–(cid:3044)(cid:3044)/(cid:3043 ) Proof : Assume ğ‘”(ğ’˜)=(cid:2870)â€–ğ’˜â€–(cid:3043)(cid:2870 ) and we have known ğ‘”âˆ— according to Theorem 3 . Now we calculate ğ‘“âˆ— using ğ‘”âˆ— : ğ‘“âˆ—(ğœ½)=supğ’˜âˆˆâŒ©ğ’˜,ğœ½âŒªâˆ’ 1ğ‘âˆ’1ğ‘”(ğ’˜ ) and we make the calculation :
This immediately gives us Eq ( 27 ) after substituting Eq
( 23 ) and noticing that ğ‘âˆ’1= ( cid:3044 ) . Next , regarding Eq ( 28 ) ,
= 1ğ‘âˆ’1(cid:3436)supğ’˜âˆˆ(cid:3020)âŒ©ğ’˜,(ğ‘âˆ’1)ğœ½âŒªâˆ’ğ‘”(ğ’˜)(cid:3440 ) = 1ğ‘âˆ’1ğ‘”âˆ—(cid:3435)(ğ‘âˆ’1)ğœ½(cid:3439 ) ( cid:3435)âˆ‡ğ‘“âˆ—(ğœ½)(cid:3439)= 1ğ‘âˆ’1(cid:4672)âˆ‡ğœ½ğ‘”âˆ—(cid:3435)(ğ‘âˆ’1)ğœ½(cid:3439)(cid:4673 ) =(cid:4672)âˆ‡((cid:3043))ğœ½ ğ‘”âˆ—(cid:3435)(ğ‘âˆ’1)ğœ½(cid:3439)(cid:4673 ) =min(cid:3419)ğµ,â€–(ğ‘âˆ’1)ğœ½â€–(cid:3044)(cid:3423 ) ( ğ‘âˆ’1)(cid:3044)/(cid:3043)ğœƒ(cid:3044)/(cid:3043 ) â€–(ğ‘âˆ’1)ğœ½â€–(cid:3044)(cid:3044)/(cid:3043 ) =min{ğµ,â€–(ğ‘âˆ’1)ğœ½â€–(cid:3044)} ğœƒ(cid:3044)/(cid:3043 ) â€–ğœ½â€–(cid:3044)(cid:3044)/(cid:3043 ) completes the proof . âˆ Corollary 3 : If ğ‘†=â„ and ğ‘“(ğ’˜)= ( cid:2870)((cid:3043))â€–ğ’˜â€–(cid:3043)(cid:2870 ) , then ğ‘“âˆ—(ğœ½)= ( cid:2870)((cid:3044))â€–ğœ½â€–(cid:3044)(cid:2870 ) and ( cid:3435)âˆ‡ğ‘“âˆ—(ğœ½)(cid:3439)= ( cid:3044)â€–ğœ½â€–(cid:3044)(cid:3044)/(cid:3043)âˆ™ğœƒ(cid:3044)/(cid:3043 ) where the third equality is according to Eq ( 24 ) . This
( 28 )
676
