LSDIS Technical Report November 2005
Semantic WS Agreement Partner Selection
Nicole Oldham
LSDIS Lab
Dept . of Computer
Science
University of Georgia
Athens , GA , USA oldham@csugaedu
Kunal Verma
LSDIS Lab
Dept . of Computer
Science
University of Georgia
Athens , GA , USA verma@csugaedu
Amit Sheth LSDIS Lab
Dept . of Computer Science University of
Georgia
Athens , GA , USA amit@csugaedu
Farshad Hakimpour
LSDIS Lab
Dept . of Computer Science University of
Georgia
Athens , GA , USA farshad@hakimpour.com the to advance
ABSTRACT In a dynamic service oriented environment it is desirable for service consumers and providers to offer and obtain guarantees regarding their capabilities and requirements . WS Agreement defines a language and protocol for establishing agreements between two parties . To date , there has been very little work done tools available for WS Agreements . Existing tools are solely to facilitate the creation and monitoring of agreements . Some work has also been done in the area of agreement negotiation . The agreements are complex and expressive to the extent that the manual matching of these agreements would be expensive both in time and resources . It is to develop a method for matching agreements essential automatically . This work presents framework and implementation of an innovative tool for the dynamic partnering of WS Agreements . The approach utilizes Semantic Web technologies in combination with ARL rules to achieve rich and accurate matches . A key feature is the novel and flexible approach for achieving user personalized matches . Categories and Subject Descriptors H33 [ Information Systems ] Information Search and Retrieval the
General Terms Algorithms , Documentation , Design , Experimentation
Keywords WS Agreement , Semantic Policy Matching , Ontologies , OWL , ARL , Snobase , Agreement Matching
1 . INTRODUCTION In a service oriented environment it is advantageous for service consumers and providers to obtain guarantees regarding the services that they both require and offer . Usually these guarantees pertain to quality of service ( QoS ) aspects . WSDL does not provide a means to express these guarantees ; therefore such standards as WS Policy [ 20 ] and WSLA [ 22 ] exist to allow for the expression of additional nonfunctional attributes . However , these standards are not expressive enough to represent the truly complex nature of the relationship between a service consumer and provider . The WS Agreement specification [ 2 ] defines a language and protocol for capturing this intricate relationship with agreements between An agreement between a service consumer and a service provider specifies one or more service level objectives ( SLO ) which state two parties . the requirements and capabilities of each party on the availability of resources and service qualities . For example , an agreement may provide assurances on the bounds of service response time , service availability , or service reliability . WSAgreement is more expressive than the previous policy standards because in addition to service level objectives , an agreement contains scopes for which the guarantee holds , conditions which must exist in order for the guarantee on the SLO to be valid , and business values , such as penalties and rewards , which incur if the SLO is not satisfied . This is further complicated by the symmetry of these agreements such that each provider does not only state guarantees regarding capabilities but likely has requirements of its own . In addition , each agreement may contain multiple alternatives of guarantee sets . As each consumer seeking a suitable provider has many complex options to choose from , the manual partnering of these parties is time consuming , tedious , and error prone . With the increasing acceptance and popularity of WS Agreement and the ever present need to protect the quality of service with guarantees , the development of an approach for the automatic matching of these agreements is imperative . This paper defines and provides reasoning methods for the components of an agreement which must be compatible for quality matches . We present a powerful approach which uses OWL ontologies to represent domain knowledge in conjunction with rules the most accurate and consumer personalized matches . The contributions of this work are : to achieve
• Adding to the small body of work for WS Agreement by defining a framework and implementation for the matching of agreements which eliminates tedious and error prone manual matching .
• Developing a strategy for reasoning over the complex
• and multifaceted WS Agreements . Presenting a flexible approach for specifying and reasoning over user defined preferences which allows the matching to be modified and customized without changing code or possessing programming knowledge . The remainder of this paper is organized as follows . Section 2 briefly covers the WS Agreement schema and the general process of WS Agreement matching . Section 3 contains an example illustrating the need for semantics when creating and matching agreements . Section 4 is composed of details on our framework and implementation of Semantic WS Agreement Partner Selection ( SWAPS ) . Section 5 presents a real world situation which would benefit from the use of WS Agreements and illustrates the necessity of an efficient tool for matching consumers with providers . Section 6 discusses related work , and Section 7 provides conclusions and future work .
2 . MOTIVATION FOR A SEMANTIC APPROACH The current WS Agreement specification is XML based and therefore lacks the ability to express any formal meaning . A matcher only considering the syntax of the agreements without an understanding of the agreements is not able to correctly identify all matches . We illustrate the differences with the following example . Consider that a service consumer has the following requirement : the semantics of the terms within
•
Availability is greater than 95 % and a provider is offering the assurances :
• Mean Time to Recover equals 5 minutes • Mean Time between failures equals 15 hours
A syntactic matcher would perform a string comparison to determine if the provider can satisfy the consumer(cid:146)s request . The syntactic matcher would generally determine that these two services do not match on the grounds that the provider does not provide an assurance for availability . However , our semantic approach utilizes an ontology which provides a deeper understanding of the domain including the domain rules . For example , with respect to the above case :
•
Availability = Mean Time Between Failures/(Mean Time Between Failures + Mean Time To Recover )
Therefore the semantic approach reasons that the provider is actually offering the assurance :
•
Availability equals 994 %
Our matcher determines that this provider does in fact satisfy the requirements of the consumer . This example illustrates why incorporating semantics into matching yields much more accurate matches . Further justification is given in Section 4 as we describe how we extend WS Agreement to support semantics and provide a detailed technical example in Section 44
3 . WS AGREEMENT AND WSAGREEMENT MATCHING This section briefly describes the WS Agreement schema [ 2 ] , the extensions that have been added for this work , and a general overview of the significant elements of WS Agreement matching .
3.1 WS Agreement Schema Many protocols exist to express the capabilities and requirements of Web Services , the most widely accepted being WS Policy . Using this specification a Web Service who is requesting a service from a provider Web Service may use assertions to advertise capabilities and specify objectives which must be satisfied . For example , the consumer may require that all response times be less than 5 seconds . However , in a real world environment these capabilities and requirements cannot be guaranteed under every circumstance . For instance , a service might only be able to process a job in less than 5 seconds if the number of requests at that moment is less than a thousand . WSPolicy does not offer the ability to express these types of conditions or business values such as importance , penalties , and rewards . WS Agreement offers a richer language for stating the assurances and requirements of Web Services which is much more representative of the complicated nature of real world agreements as it , in addition to service level objectives , allows for the specification of conditions and business values .
WS Agreement Tag Obligated
ServiceScope
ServiceLevelObjective ( SLO )
QualifyingCondition
BusinessValueList
Purpose States the party responsible for the fulfillment of the guarantee . Value will be ServiceProvider or ServiceConsumer Describes to what service element specifically a service applies . An assertion over the terms of the agreement which represents the QoS aspect of the agreement . Usually defines bounds usually over QoS concepts such as response time , fault rate or cost . Optional condition which must exist in order for the SLO to be satisfied . Usually over external factors such as time of day . Optional values which represent the strength of commitment by stating penalties , rewards and importance
WS Agreements are written in XML and consist of alternative sets of guarantees denoted with the ( cid:147)ExactlyOne(cid:148 ) and ( cid:147)ALL(cid:148 ) tags . Due to the already complex nature of agreements , we save the WS Agreement(cid:146)s ( cid:147)OneOrMore(cid:148 ) tag for future work and assume that all agreements are written as a disjunction of alternative sets of guarantees . The guarantees are expressed within the ( cid:147)GuaranteeTerm(cid:148 ) tag and assert assurances or requirements on the quality associated with the service . Below is the Guarantee Term schema followed by Table 1 which describes the components of a guarantee term . <wsag:GuaranteeTerm Obligated=(cid:148)fi(cid:148)> <wsag:ServiceScope ServiceName=(cid:148)fi(cid:148)>fi </wsag:ServiceScope>* <wsag:ServiceLevelObjective> fi </wsag:ServiceLevelObjective> <wsag:QualifyingCondition>fi</wsag:QualifyingCondition> ? <wsag:BusinessValueList>fi</wsag:BusinessValueList> </wsag:GuaranteeTerm>
Table 1 . GuaranteeTerm Components
3.2 WS Agreement Extensions In order to achieve effective semantic matches , we extend the original WS Agreement schema with several additional tags . The new tags allow for the incorporation of semantics into WSAgreement and add additional structure for clarity during parsing and matching .
321 Adding Structure to SLO and Qualifying Conditions The WS Agreement specification was written with flexibility as one of the key goals and therefore lacks some structure in important areas such as the SLO and QualifyingCondition . The values within each of those tags can contain any possible expression . While this would be acceptable for an agreement which is intended to be read by a human user , additional structure must be added to the expressions in order to for a machine to automatically parse and reason over agreements . However , we added this structure while still preserving much of the flexibility specifically for domain specific predicates . For structure , we have added the expression , predicate , parameter , and value tags , as defined in the WSLA specification [ 22 ] . In addition there are the optional tags for unit and percent . Percent is used when a service level objective uses a percentage . For example , 99 % of responseTimes are less than 5 seconds .
Table 2 shows an example using the original schema as defined in [ 2 ] which is too ambiguous to parse and reason over . Our modified schema which adds structure is also shown in Table 2 . 322 Adding Semantics to the WS Agreement Agreements contain ambiguities which we clarify using an OntConcept annotation tag . In the original schema of the Terms section of the WS Agreement . Even though these variables have
Table 2 . SWAPS extensions to the WS Agreement schema WS Agreement Schema <ServiceLevelObjective> O L S duration1+duration2 < 5 s </ServiceLevelObjective>
SWAPS Schema <ServiceLevelObjective> <Expression> <Predicate type=(cid:148)less(cid:148)> <Parameter>duration1+duration2 < /Parameter> <OntConcept>qos::responseTime </OntConcept> <Value>5</Value> <Unit>time:seconds</Unit> </Predicate></Expression> </ServiceLevelObjective> <QualifyingCondition> <Expression> <Predicate type=(cid:148)equals(cid:148)> <Parameter>dayOfWeek </Parameter> <OntConcept>time:dayOfWeek </OntConcept> <Value>time:weekday</Value> </Predicate></Expression> </QualifyingCondition>
<QualifyingCondition> day of week weekday </QualifyingCondition> is a n o i t i d n o C g n i y f i l a u Q refer it may already been defined within the service description terms , it is unclear to what the summation of duration1 and duration2 actually refers . For example , it may refer to a QoS parameter responseTime or to a domain concept processOrderDuration . The addition of the OntConcept tag removes this ambiguity by linking this expression parameter directly to the concrete ontology concept . The value of OntConcept will be a concept from an ontology regardless of what variables are named and to what they refer . The agreement creators are required to include this tag to allow for semantic reasoning over the expression . This yields more effective matches than purely syntactic methods . The OntConcept tag clarifies the QoS or domain specific parameter to which the objective pertains . Figure 2 contains an example illustrating how the OntConcept tag remedies ambiguity . A syntactic matcher is not able ( duration1+duration2 ) and processTime each refer to the response time of the service which is the concept responseTime in the QoS ontology . Adding OntConcept allows the matcher to recognize that although the concepts are syntactically different , they are semantically the same . 323 Domain Specific Predicate Flexibility When extending the WS Agreement , we aimed to preserve much of the flexibility intended by the WS Agreement authors . We designed a unique method for using domain specific predicates in the expressions . Any predicate may be used as long as it is added to the ontology and a rule is created to define the semantics of that predicate . The tool is already aware of the WSLA predicates less , lessEqual , greater , greaterEqual , equals , true , false , before . However the user is not limited to only these predicates and can define additional predicates for the domain . to determine that
3.3 WS Agreement Matching In order for a provider to be considered a suitable partner match for a given consumer , its description must contain one alternative which may satisfy any of the consumer(cid:146)s alternatives as denoted by the ( cid:147)ExactlyOne(cid:148 ) and ( cid:147)ALL(cid:148 ) tags . An agreement A contains alternative sets of Guarantee Terms such that : A={Alt1 , Alt2 , fi , AltN} Alt={G1 , G2 , GN} and G={Scope , Obligated , SLO , QC , BV} qos:ResponseTime
QoS Ontology processTime ontConcept : qos : ResponseTime
Consumer duration1+duration2 ontConcept : qos:ResponseTime
Provider
Figure 1 . Illustrates the benefits of the ontConcept annotation .
We define the following functions to facilitate the description : ( cid:147)requirement(Alt , G)(cid:148 ) returns true if G is a requirement of Alt ( cid:147)capability(Alt , G)(cid:148 ) returns true if G is an assurance of Alt ( cid:147)scope(G)(cid:148 ) returns the scope of G ( cid:147)obligation(G)(cid:148 ) returns the obligated party of G ( cid:147)satisfies(Gj , Gi)(cid:148 ) returns true if the SLO of Gj is equivalent to or stronger than the SLO of Gi
An alternative Alt1 is a suitable match for Alt2 if : ( ∀Gi ) such that Gi ∈ Alt1 ∧ requirement(Alt1 , Gi ) ∧ ( ∃Gj ) such that Gj ∈ Alt2 ∧ capability(Alt2 , Gj ) ∧ scope(Gi ) = scope(Gj ) ∧ obligation(Gi ) = obligation(Gj ) ∧ satisfies(Gj , Gi )
Most users have preferences for conditions and business values and a tradeoff is decided . For instance , a user may choose an agreement with a less preferred condition but a higher penalty . Alternatively , a user with a high number of requests on the weekend would find a provider to be unsuitable if he has a condition which states that he is only able to satisfy a guarantee if it is a weekday . We consider the tradeoff between qualifying conditions and business values to be a matter of user preference and have designed a unique and flexible method for specifying these user preferences in order to yield the most suitable matches . Our approach is presented in detail in Section 4 .
4 . SEMANTIC WS AGREEMENT PARTNER SELECTION We present our framework and implementation in this section . We begin by describing the system architecture followed by how ontologies and rules were utilized to achieve better matches and to simplify the search algorithm . We then walkthrough an example which illustrates the reasoning methodology used by the tool .
Ontology Store
Ontologies are loaded into SNoBASE
1
3
Instances are created in SNoBASE
SNOBASE Domain
Knowledge and Rules
4.1 Architecture The system consists of three phases : parsing , matching and searching , which can be seen in Figure 2 . To reason about domain ontologies , we use Snobase [ 9 ] , an ontology based management system that offers DQL based [ 5 ] Java API for querying OWL ontologies . IBM(cid:146)s ABLE engine [ 3 ] is used by Snobase for inferencing and we use ABLE Rule Language ( ARL ) [ 3 ] to write the rules . The ontologies are loaded into Snobase followed by each provider(cid:146)s WS Agreement . We parse the agreements and load them into the system as instances of the WS Agreement ontology . As each of these new agreement instances is created , the ABLE rule engine within Snobase executes rules as the criteria for each rule is met . The additional assertions made by the rules are used to greatly simplify the search phase by making the match decisions a priori . These rules provide additional knowledge about the domain and , as described in Section 2 , play a significant role in the discovery of the most accurate match results . We discuss the rules in further detail in the next section . When a consumer seeks a partner , the consumer agreement is parsed and entered into the system as another agreement instance . The search phase begins as the algorithm considers the agreement instances and the assertions previously set by the rules and returns a list , ranked by preference , of all of the provider agreements which accurately matched the consumer(cid:146)s agreement .
Agreements
Ontologies , Agreement Instances , ABLE Rule Engine , ARL Rules
Agreement Match(es )
SNOBASE
Searching
Parsing
Figure 2 . The control flow throughout SWAPS illustrates the system architecture .
Figure 3 The main components of SWAPS include the ontology store , provider library , parser , ontology manager , and search engine . It is assumed that the consumer seeking a match has a library of agreement instances previously made between providers and is searching for the provider who is most able to satisfy the requirements . However it is also known that previously unknown providers , in the form of an agreement offer or a template , are constantly introduced into the set of options . Further details regarding the ontologies , rules and search engine are given in sections 4.2 and 43
4.2 WS Agreement and Rules Representation Ontologies allow the matcher to understand the semantics of the domain ; therefore enabling a much more accurate search than a syntactic approach . Rules allow for richer domain knowledge by stating additional domain rules and semantics and provide a high level of flexibility by stating customized user preferences .
Parser
User
Interface
4
Ontology Manager
Provider Library
2
Providers are given to the parser
Search Engine
5
OWL.arl Find matching agreements with the help of domain knowledge stored in SNOBASE
Consumer Agreement
Figure 3 . SWAPS Architecture the such schema as Guarantee , Scope ,
421 Knowledge Representation In order to realistically model the domains we employ several ontologies . We developed an OWL ontology to represent the WS Agreement schema . This ontology contains the concepts from and ServiceLevelObjective with relationships between them . In addition to the significant elements from the WS Agreement , we have also included the common predicates from the WSLA specification [ 22 ] . We allow the user to add additional predicates to this ontology to preserve flexibility . An instance of this ontology is created for each agreement that is introduced into the system where they can be queried and reasoned easily . Most of the guarantees are asserted over quality of service ( QoS ) concepts ; therefore the QoS ontology as described in [ 12 ] defines such concepts as failureRate , latency , throughput , availability , and responseTime . In addition to these ontologies a third OWL ontology represents domain specific knowledge . For our scenario in e commerce and its implementation we are using the RosettaNet [ 16 ] ontology , also represented in OWL . Depending on the application , alternative or additional domain ontologies could be used . Finally , we use the OWL time [ 13 ] ontology to interval , represent dayOfWeek , and seconds . These ontologies are used to provide a commonality of terms between agreement parties and to provide rich domain knowledge to the search engine so that it may achieve the best possible match results . temporal concepts such as endTime ,
422 Representation of Rules We enhance the efficiency and flexibility of our matches by defining several categories of rules . These rules are represented in ARL for ABLE inferencing . The rules assert new facts if the right conditions exist for executing the various rules . We use these rules to supplement domain knowledge , convert SLOs into a common comparable form , define the semantics of domain specific predicates , and specify user preferences . Using rules instead of writing Java code to perform all of the above allows us to separate the core implementation from the user so that he may customize the matcher to the domain and personal preferences without any programming ability . We define four categories of rules and show corresponding examples below . 1 . Conversion of Heterogeneous SLOs Often SLOs state the same objective but express it differently . We define a category of rules to address SLOs that have semantic similarity but are syntactically heterogeneous as in the example in Figure 4 . In the example , the provider is expressing an assurance predicate ( cid:147)PercentageLessThanThreshold(cid:148 ) and the consumer is expressing the same requirement more directly using the predicate ( cid:147)less(cid:148 ) . While a human reader can clearly see that the provider(cid:146)s SLO satisfactorily meets the heterogeneity of the predicates prevents the direct comparison of the provider and consumer SLOs . We define the following ARL rule , where x is a user defined threshold , to convert the provider(cid:146)s SLO so that it expresses the objective more directly : requirements , consumer(cid:146)s
WSLA using the the when : Agreement ( A ) and hasGuarantee ( A,G ) and hasSLO ( G , SLO ) and hasExpression(SLO , E ) and hasPredicate(E , hasType(P , ( cid:147)PercentageLessThanThreshold(cid:148 ) ) and hasPercentage(E , percent ) do : if ( percent<=x ) then assert hasType(P , ( cid:147)less(cid:148 ) ) else assert hasType(P , ( cid:147)greater(cid:148 ) ) and
P )
The above ARL rule looks for any expression which contains the predicate ( cid:147)PercentageLessThanThreshold(cid:148 ) and if the percentage less than x it changes the predicate to ( cid:147)less(cid:148 ) otherwise it changes it to ( cid:147)greater(cid:148 ) . In many cases the value of x is dependent upon the parameter . For example , a user may require a high percentage for responseTime but may be more lenient about other parameters . This feature can be further customized by adding additional statements in the when segment which perform parameter checks .
Provider : ( cid:147)99 % of response times < 5 seconds(cid:148 )
Consumer : ( cid:147)response seconds(cid:148 )
Figure 4 . Illustrates the Conversion of Heterogeneous SLOs
Predicate=percentageLessThanThreshold Parameter=(cid:148)qos:responseTime(cid:148 ) Value=5 Percent=99 Unit=(cid:148)time:Seconds
Predicate=less Parameter= qos:responseTime Value=6 Unit=(cid:148)time:Seconds
Predicate=less qos:responseTime Unit=(cid:148)time:Seconds
New Provider Assertion : ( cid:147)response time < 5 seconds(cid:148 )
Parameter= Value=6
Conversion Rule time < 6
2 . Semantics of Predicates Rules The second category of rules allows a user to utilize any domain specific predicates within an SLO by defining how two SLOs with that predicate should be compared . A semantics rule should compare SLOs according to the predicate semantics and assert an isStronger or isEquivalent triple into Snobase . The following ARL rule defines the semantics of the predicate ( cid:147)less(cid:148 ) . when : Agreement ( A1 ) and hasGuaranteeTerm(A1 , G1 ) and hasSLObjective(G1 , SLO1 ) and hasExpression
( SLO1 , E1 ) and hasPredicate(E1 , P1 ) and hasType(P1 , ( cid:147)less(cid:148 ) ) and hasParameter(E1 , p1 ) and hasValue(E1 , V1 ) and Agreement ( A2 ) where A1 != A2 and hasGuaranteeTerm(A2,G2 ) and hasSLO(G2 , SLO2 ) and hasExpression ( SLO2 , E2 ) and hasPredicate(E2 , P2 ) and hasType(P2 , ( cid:147)less(cid:148 ) ) and hasParameter(E2 , p2 ) and p2 == p1 and hasValue(E2 , V2 ) do : if ( V1<V2 ) assert [ E1 isStronger E2 ] else if ( V1>V2 ) assert [ E2 isStronger E2 ] else assert [ E1 isEquivalent E2 ]
The above rule compares the values of SLOs from different agreements with the same predicate and parameter and asserts isEquivalent if the values are the same otherwise it states which expression is stronger based on the semantics of the predicate ( cid:147)less(cid:148 ) . This rule can also be further customized by incorporating parameters or checking units to determine whether to do a string or numeric comparison . The benefit of this approach is two fold . First , it allows for domain predicate flexibility such that we do not restrict which predicates our matcher can compare but rather allow the user to introduce new predicates by defining the semantics with an ARL rule . Second , since rules are fired automatically as the agreements are being loaded into Snobase , the SLOs are compared much before the search process . This simplifies the search algorithm because to find a match for SLO1 we quickly query for all SLOs who have been asserted isStronger than or isEquivalent to SLO1 . The semantics of predicate rules have the lowest priority so that the other rules may execute before the final evaluation is performed . 3 . Domain Specific Rules The domain rules provide the matcher with richer knowledge of the domain . The following example is based on the scenario from Section 2 . Consider the following domain rule for Availability : MTBF is the Mean Time Between Failures MTTR is the Mean Time To Recover Availability = MTBF/(MTBF + MTTR ) Consider a provider agreement with the following guarantees : Guarantee1 : qos:MTBF=150 time:minutes , Qualifying Condition : numRequests<1000 , Penalty : 5 USD , Importance 8 Guarantee2 : time:minutes , Qualifying Condition : numUsers<500 , Penalty : 3 USD , Importance 4
SLO : qos:MTTR<5
SLO :
The ARL rule for Availability creates a new guarantee term for any agreement which has SLOs regarding both MTBF and MTTR . The new guarantee has an SLO for the Availability . Any Qualifying Conditions will a Penalty/Reward will be the higher of the two . If each has the business value importance , it will become the average of the two values . The following ARL rule accomplishes the above : compounded and be when : Agreement ( A ) and hasGuarantee ( A , G1 ) and hasSLO ( G1 , SLO1 ) and hasQualifyingCondition(G1 , QC1 ) and hasPenalty(G1 , P1 ) and hasImportance(G1 , I1 ) and hasParameter(E1 , ( cid:147)qos:MTBF(cid:148 ) ) and hasValue(E1 , X ) and hasGuarantee ( A , G2 ) and hasSLO ( G2 , SLO2 ) and hasExpression
( SLO1 ,
E1 ) and hasQualifyingCondition(G2 , QC2 ) and hasPenalty(G2 , P2 ) and hasImportance(G2 , I2 ) and hasExpression ( SLO2 , E2 ) and hasParameter(E2 , ( cid:147)qos:MTTR(cid:148 ) ) and hasValue(E2 , Y ) do : hasGuarantee ( A,G3 ) and hasSLO(G3 , SLO3 ) and hasExpression(SLO3 , E3 ) and hasParameter(E3 , ( cid:147)qos:Availability(cid:148 ) ) and hasVaule(E3 , X+Y ) and hasPenalty ( G3 , max(P1 , P2 ) ) and hasImportance(avg(I1,I2 ) )
The rule will be fired once the provider agreement is loaded into Snobase and will add the following guarantee to the agreement : Guarantee3 : SLO : qos:Availability=96.8 , Qualifying Condition : numUsers<500 AND numRequests<1000 , Penalty : 5 USD , Importance : 6
4 . User Preference Rules The preference rules enable user assertions over subjective personal preferences . There is no standard of comparison for Qualifying Conditions and Business Values as they are a matter of user preference . For example , one service may be more active during the weekend in which case a provider with a condition stating that the objective may only be guaranteed if it is a weekday would not be suitable for that user . The matcher is unaware of the personal circumstances of each user until they are defined using rules . A rule may assert one of two possible assertions which will have an impact on matching : isPreferred or notSuitable . A user may write a rule to assert that ( cid:147)a guarantee that has a condition that the day of the week must be a weekday is not suitable(cid:148 ) or ( cid:147)a guarantee with a condition involving transactionRate is preferred over a guarantee with a condition involving the day of the week(cid:148 ) . These rules have the flexibility to be more specific or generic . The following ARL rule asserts that a weekday condition is not suitable for this user : when : Agreement ( A ) and hasGuarantee ( A , G1 ) and hasQualifyingCondition(G1 , which hasExpression(QC1 , hasParameter(E1 , E1 ) ( cid:147)time:dayOfWeek(cid:148 ) ) and hasValue(E1 , ( cid:147)time:weekday(cid:148 ) ) do : assert Guarantee notSuitable G1
QC1 ) and
The above rule asserts that a guarantee is notSuitable if the parameter of the Qualifying Condition is the dayOfWeek and if the value is weekday . Conflicting rules are resolved by using optional priority and condition fields . 4.3 SWAPS Search Algorithm The system uses a two fold approach to finding the result set of providers . First , matching is automatically performed by the semantics of predicates rules as agreement instances are created . These rules significantly simplify the matching process because they compare the SLOs upon their entrance into Snobase . At this time assertions are made about which SLOs are stronger than or equivalent to other SLOs these assertions are queried by the search engine . Second , searching is done to determine which providers had agreements which were best suited for the consumer(cid:146)s agreement . We now detail the search algorithm . The following functions are defined to facilitate the expression of the search algorithm : ( cid:147)requirement(Alt , G)(cid:148 ) returns true if G is a requirement of Alt ( cid:147)capability(Alt , G)(cid:148 ) returns true if G is an assurance of Alt
( cid:147)scope(G)(cid:148 ) returns the scope of G ( cid:147)obligation(G)(cid:148 ) returns the obligated party of G ( cid:147)isStronger(Gj , Gi)(cid:148 ) returns true if the SLO of Gj has an assertion isStronger than the SLO of Gi ( cid:147)isEquivalent(Gi , Gj)(cid:148 ) returns true if the SLOs of the guarantees have the assertion isEquivalent ( cid:147)notSuitable(G)(cid:148 ) returns true if G has an assertion notSuitable As discussed in section 2.3 , matching two agreements is reduced to finding two matching alternatives and finding matching alternatives is reduced to finding matching guarantees .
( ∀Gi ) such that Gi ∈ Alt1 ∧ Alt1 ∈ A1 ∧ requirement ( Alt1 , Gi ) ∧ ( ∃Gj ) ST Gj ∈ Alt2 ∧ Alt2 ∈ A2 ∧ capability(Alt2 , Gj ) ∧ scope(Gi)=scope(Gj ) ∧ obligation(Gi)=obligation(Gj ) ∧ ( sStronger(Gj , Gi ) ∨ isEquivalent(Gi , Gj ) ) ∧ ¬notSuitable(Gj )
431 Classification of Results The search algorithm will yield a Vector of potential providers where each provider contains at least one alternative which can be fully satisfied and is also able to fulfill the requirements of the consumer . This set will not contain any providers which have conditions that would not be suitable for the consumer . As discussed earlier , each user will have a subjective personal preference regarding qualifying conditions and business values . If the method for stating preferences was utilized then there may be isPreferred assertions stated over some of the guarantees . We implement a preference score for each alternative which is incremented for each isPreferred statement asserted over one of the guarantees of the alternative . The agreements containing alternatives with the highest preference scores are displayed first .
4.4 Example In this section we present an example to illustrate our approach . Table 3 shows simplified set of guarantees for a consumer . The consumer is seeking the potential providers from the library of providers given in Table 4 . The tags and structure of the agreements are removed for simplicity and clarity .
441 Parsing , Instance Creation and Rule Execution When the tool is started , each of the provider agreement documents in the library given in Table 4 are parsed and loaded into Snobase . An agreement instance is created for each provider alternative . Provider 3 will have two agreement instances associated with it because it has two alternatives . As each agreement instance is loaded , the rule engine executes the rules as the criteria for each is met . The user(cid:146)s system includes all of the ARL rules from the previous examples in addition to a similar rule to define the semantics of ( cid:147)greater(cid:148 ) . An additional for responseTime = processTime + domain transmitTime which follows the same procedure as the previous domain rule for Availability but sums the values . The following rule defines the semantics of the ( cid:147)true(cid:148 ) and ( cid:147)false(cid:148 ) predicates : when any two guarantees from a different agreement instance have the same parameter and each predicate =(cid:148)true(cid:148 ) or each predicate=(cid:148)false(cid:148 ) assert [ SLO1 isEquivalent SLO2 ] rule exists
Table 5 shows the assertions as each agreement is parsed and entered into Snobase .
Table 4 . Summary of Guarantees from Provider Library
Provider1.wsag
Provider2.wsag ( Provider2a and Provider2b )
Scope : ProcessRequest Obligated : ServiceProvider SLO1 : qos:responseTime less 14 sec . QC : time:dayOfWeek equals weekday Penalty : 15 USD Scope : ProcessRequest Obligated : ServiceProvider SLO2 : qos:failurePerWeek less 7 Penalty : 10 USD
Scope : ProcessRequest Obligated : ServiceProvider SLO3 : qos:incompleteInputs true
Scope : ProcessRequest Obligated : ServiceConsumer SLO4:qos:availableMemory greater 12MB
Scope : ProcessRequest Obligated : ServiceProvider SLO5 : qos:transmitTime less 4 sec . QC:qos:maxNumUsers less 1000 Penalty : 1 USD
Scope : ProcessRequest Obligated : ServiceProvider SLO6 : qos:processTime less 5 sec . QC : qos:numRequests less 500 Penalty : 1 USD Scope : ProcessRequest Obligated : ServiceProvider SLO7 : qos:failurePerWeek less 16 Penalty : 2 USD Scope : ProcessRequest Obligated : ServiceProvider SLO8 : qos:incompleteInputs false
G1
G2
G3
G4
Table 3 . Summary of Consumer Guarantees
Consumer1.wsag
G1
G2
G3
G4
Scope : ProcessRequest , Obligated : ServiceConsumer SLOc1 : qos:availableMemory greater 12 MB Scope : ProcessRequest , Obligated : ServiceProvider SLOc2 : qos:failurePerWeek less 7 Scope : ProcessRequest , Obligated : ServiceProvider SLOc3 : qos:allowIncompleteInputs true Scope : ProcessRequest , Obligated : ServiceProvider SLOc4 : 99 % of qos:responseTime less 14 seconds
442 Searching The consumer is matched against each alternative of each provider . By querying for isStronger and isEquivalent assertions for the Provider(cid:146)s SLOs , the algorithm determines that Provider1 is able to satisfy the consumer(cid:146)s needs and the consumer can also satisfy the requirement expressed in G1 . However , Provider1 is dismissed as a potential match because one of the guarantees was asserted as notSuitable as highlighted in number 3 of Table 5 . Provider 2(cid:146)s first alternative is considered and the algorithm will determine that not all of the consumer(cid:146)s guarantees are satisfied as the provider does not have an isStronger or isEquivalent assertion for each of them and as one of the SLOs is weaker than the consumer SLO as highlighted in number 9 from Table 5 . The algorithm moves on to the next alternative of Provider 2 and determines that it is a match because all of the consumer(cid:146)s guarantees are satisfied and none of the relevant provider guarantees have been asserted as notSuitable . The algorithm returns Provider 2 as the only match . 443 Post Search Considerations There was only one potential match in the simplified example above . However , if there had been more compatible providers in the library , the algorithm would continue with additional steps . There are several issues of preference in the example above . If Provider1 had been a suitable match the responseTime is guaranteed to be less than 14 seconds with a very high penalty of 15 USD . Provider 2 offers a much faster responseTime of 9
1
2
3
4
5
6 7
8
9
10
11
12
13
O R
Scope : ProcessRequest Obligated : ServiceProvider SLO9 : qos:transmitTime less 4 sec . QC : qos:maxNumUsers less 1000 Penalty : 1 USD
Scope : ProcessRequest Obligated : ServiceProvider SLO10 : qos:processTime less 5 sec . QC : qos:numRequests less 500 Penalty : 1 USD Scope : ProcessRequest Obligated : ServiceProvider SLO11 : qos:failurePerWeek less 7 Penalty : 2 USD Scope : ProcessRequest Obligated : ServiceProvider SLO12 : qos:incompleteInputs true
Table 5 . SWAPS Matching
Guarantee Consumer G4
Provider1 G1
Fact/Rule PercentageLessThanT hreshold Conversion Rule Semantics of “ less ”
Provider1 G1
Provider1 G2
User Preference Rule weekday notSuitable Semantics of “ less ”
Provider1 G3
Semantics of “ true ”
Provider1 G4 Provider2a G1 and G2
Semantics of “ greater ” Domain for “ qos:ResponseTime ” rule
Provider2a G5 Provider2a G3 Provider2b G1 and G2
Semantics of “ less ”
Semantics of “ less ”
Domain “ qos:ResponseTime ” rull for
Provider2b G5 Provider2b G3 Provider2b G4
Semantics of “ less ”
Semantics of “ less ”
Semantics of “ true ”
Assertion qos:responseTime < 14 seconds
G4 isEquivalent isEquivalent isEquivalent
SLO1 SLOc4 Provider1 ’s notSuitable SLO2 SLOc2 SLO3 SLOc3 SLOc1 isStronger SLO4 Provider2a G5 SLO13 : qos:responseTime less 9 secs . , Qualifying Condition:numRequests <1000 AND numUsers<500 Penalty : 1 USD SLO13 SLOc4 SLOc2 isStronger SLO7 isStronger
Provider2b G5 SLO14 : qos:responseTime less 9 secs . , Qualifying Condition:numRequests <1000 AND numUsers<500 Penalty : 1 USD SLO14 SLOc4 SLO11 SLOc2 SLO12 SLOc3 isEquivalent isEquivalent isStronger seconds but a much lower penalty of 1 USD . Some users may desire efficiency while others may wish to merely satisfy the time a satisfactory guarantee has objective while sacrificing some efficiency for the potential of a high penalty payoff . Since this is a personal user preference , the user may define a rule which states that a guarantee isPreferred if the penalty is over some threshold . The user may also wish to state that if the penalties are the same then faster speeds are preferred . During the matching process , the preference score for each alternative is incremented each the isPreferred assertion . When multiple providers are able to satisfy the basic needs of a consumer , the results are ranked by highest preference scores so that the user may consider the most preferred providers first . This example showed the reasoning process while illustrating the flexibility provided by the user defined rules . 5 . APPLICATION OF AGREEMENTS AND AGREEMENT MATCHING This section does not attempt to show another technical example but rather describes how WS Agreements and our tool can be applied to remedy a challenging real world situation . The next sections will describe the problem , how WS Agreements can be applied , and how the WS Agreement matching tool can solve this problem . in to aid improve the effectiveness of decision making
5.1 Agriculture in India Agricultural trade in India is problematic for both Farmers and Merchants and there is a lack of effective use of IT to facilitate trade . Farmers spend time and resources growing goods and sending them to the markets without guarantee that they will be sold . The farmer pays for the transportation of the goods and the wastages that occur when the goods spoil during transport . Merchants have no assurances on the quality or availability of the goods that they seek to purchase . This problem is addressed in [ 4 ] and the authors describe an Agricultural Information System to the agriculture domain . A Web Services based business process management system developed the marketing of agricultural produce is described in [ 17 ] . Each party involved is represented as a Web Service . If each party is a Web Service , then the process of matching farmer to merchant can be reduced to one of Web Service composition and policy matching . Contract farming is one remedy currently being practiced to solve the dilemma and is described in [ 6 ] as a system for the production and supply of agricultural products under forward contracts between producers/suppliers and buyers . The cultivator makes a commitment to provide an agricultural commodity of a certain type , at a time and a price , and in the quantity required by a known and committed buyer . Using faming contracts , growers and buyers can agree to terms and conditions for the sale and purchase of goods . The buyer can make agreements to supply selected goods which sometimes also include land preparation and technical advice . The contracts ensure that the grower follows recommended production methods and cultivation and harvesting specifications . Conditions are frequently stated regarding the price and quality of goods and penalties in the form of discounts are offered for flaws or lack of quality . The situation for farmers is improved as they no longer must send goods to markets without a guarantee of acquisition . The farmer(cid:146)s price risk is reduced because the contracts specify the prices in advance . The buyers obtain more consistent quality and more reliable production than if purchases were made on the open market . When efficiently organized and managed , contract farming reduces risk and uncertainty for both parties as compared to buying and selling crops on the open market . The success stories of E Chaupal and Tata Kisan Sansar , who have implemented contract farming in India , are discussed in [ 17 ] . Just as Web Services can represent the farmers and merchants , the WS Agreement is well suited to represent the complex contracts drawn between the two . 5.2 Farming Contracts as WS Agreements The WS Agreement is perhaps the best suited standard for representing farming contracts . The protocol is functional for representing the guarantees which always include some objective and often contain conditions which must exist in order for the objective to be fulfilled . For example , a merchant may guarantee a price under the condition that the goods are of a certain quality . Business values such as penalties are often seen in contracts in the form of discounts . For example , a farmer may guarantee that the moisture percentage is than 10 % and may offer a discount for every bushel that contradicts that assurance . In this use case , a merchant is considered to be a service consumer and his guarantees and requirements can be proficiently represented using WS Agreement . The available merchants are the service providers . Table 6 contains an example of farming contracts as WS Agreements . It depicts the merchant as the consumer seeking the most suitable farmer , however , this tool can also be used by a farmer to find the ideal merchant . Section 5.3 will discuss how SWAPS can easily match a merchant with a farmer who will provide the required quality at a desired price .
5.3 WS Agreement Matching for the Agriculture Domain An ontology representing the Agriculture domain can provide the matcher with a complete understanding of the domain and the user can supplement this knowledge with rules specific to the domain . The user can also write any relevant conversion rules for
Table 6 . Farming Contracts represented with WS Agreement
Merchant Guarantee1 : SLO1 : Moisture is less inclusive 12 % Guarantee2 : SLO2 : splits is less inclusive 20 % Guarantee3 : SLO3 : test weight is greater than 54 lbs Guarantee4 : SLO4 : price lessEqual 10 cents per bushel
Farmer 1 Guarantee1 : SLO1 : Moisture is less 10 % Penalty : discount $10 each Guarantee2 : SLO2 : splits is less inclusive 20 % Penalty : splits of 5 % or more , discount $1 each Guarantee3 : SLO3 : test weight is greater than 60 lbs Guarantee4 : SLO4 : price greaterEqual 8
Farmer 2 Guarantee1 : SLO1 : Moisture is less inclusive 12 % Penalty : discount $15 each Guarantee2 : SLO2 : splits is less inclusive 20 % Penalty : splits of or more , discount $5 each Guarantee3 : SLO3 : test weight is greater than 58 lbs Guarantee4 : SLO4 : price greaterEqual 7
3 % measurements . For example , the user may write a rule to convert from ounces to grams or from bushels to pounds . For predicates , this user may which to use the basic predicates already defined within the system or can also add domain specific predicates . The simple example in Table 6 uses predefined predicates . In this domain , price is compared differently than moisture or splits because , with the latter , both parties specify that the number must be less than some value because while moisture may vary per bushel it must always be less than some value . Price , however , is a fixed price per bushel . Therefore , when comparing price , expressions with different predicates may still be compatible . For example , the merchant is willing to pay five cents or less but the farmer is asking 4 cents or greater per bushel . Since a parameter such as price will be reasoned over differently than a parameter like moisture , a separate rule must be defined to define the procedure for comparing price . The user will surely have personal preferences and may define these as rules . In Table 6 , Farmer 1 clearly offers better quality goods while Farmer 2 offers much higher penalties . The merchant may specify the tradeoff as an ARL rule which states that high penalties are preferred . This causes Farmer 2 to be presented as a higher match than Farmer 1 . This tool can effectively narrow down the hundreds of farmers into a group which contains only those farmers offering what the merchant requires . The merchant can specify additional preferences and aspects which are notSuitable to further narrow down the search . Finally the merchant is presented with one or more farmers , in order of preference , from which to choose . This feature greatly reduces the search effort for both farmers and merchants . It can ensure that each farmer and merchant gets the best possible deal tailored to their individual needs and preferences .
6 . RELATED WORK WS Agreement There has been very little work done in the area of WSAgreement . A formal definition of the WS Agreement is given in [ 1 ] and the schema is extended by adding tags to accommodate states for negotiation . Cremona [ 11 ] is a tool for the creation and monitoring of WS Agreements . Both contributions do not consider partnering agreements . To our knowledge , ours is the only work on WS Agreement matching .
Syntactic Matching Major work in the domain of Service Level Agreement ( SLA ) matching is purely syntactic . [ 23 ] developed a methodology for matching Web Service Level Agreements ( WSLA ) . This work syntactically matches SLAs by parsing them into syntax trees . The authors have designed a matching algorithm which compares these trees node by node . Heterogeneous SLAs are handled by referencing a table containing instructions which the code must execute in order to convert them into the same format . Such syntactic approaches must take a more exhaustive and laborious approach to matchmaking and are challenged by less obvious matches . Since our agreements are parsed into instances of the WS Agreement OWL ontology , we are able to reason over the ontology and retrieve data via ontology queries with much less effort . In addition , the semantics defined by this ontology result in more accurate matches . This work focuses on matching Service Level Objectives , where , our work considers compatible scopes and SLOs to be the most essential criteria for matching but also reason over qualifying conditions and business values . GlueQoS [ 21 ] extends the grammar of WS Policy to add qualifying conditions . This approach uses only XML based models which limits the expressivity of the assertions . Since XML cannot express formal meaning , the matching is purely syntactic which greatly limits efficiency of the matching process . Our work uses the combination of OWL ontologies and ARL rules to provide our matcher with detailed knowledge of the domain , QoS , and agreements which leads to better matches .
Policy with Rules The following work uses rules without semantics to represent policies . [ 15 ] uses a rule based SLA language ( RBSLA ) to express Service Level Agreements . RBSLA is an extension of RuleML tailored to satisfy the requirements of the SLA domain . The rules are based on the logic components of Derivation , Event Condition , Event Calculus , Courteous Logic , Deontic Logic , and Description Logic . Rule based SLAs can be written and modified using the management tool ( RBSLM ) which also enables the management , maintenance and monitoring of contract rules . Policy matching is not considered in the scope of this approach .
Semantic Policies There has also been some work that has benefited from using Semantic Web technologies . [ 18 ] has developed KAOS for the specification , management , analysis , and enforcement of policies . The policy is represented using concepts from an OWL ontology . Role value maps are added to later work to compensate for some of the limitations in expressiveness of OWL . The trust and privacy of Web services is handled with a rule based engine in [ 7 ] , and in [ 8 ] , the authors discuss the combination of OWL ontologies and SWRL rules . [ 14 ] presents the OWL ontology developed for representing policies however they do not utilize rules .
Semantics with Rules [ 10 ] applies a very interesting approach to Access Control Policy specification . Access Control Policies are designed and expressed using a combination of OWL and SWRL . Policies are defined using an ontology . SWRL is introduced to enhance OWL with additional expressiveness and deducible ability . Access control policies are designed in the form of rules using concepts defined in the ontology and relationships such as isPermittedDoWith to express which kinds of agents have permission to access resources . This work aims to express policies and does not consider the matching of these policies . [ 19 ] presents a successful approach to policy matching by combining semantics with rules to achieve efficient matches . WS Policy is extended to incorporate semantics and policies are represented using an OWL ontology . SWRL rules express additional domain concepts and expand the matching ability . Our work applies a similar approach to WS Agreement and extends it to also reason over scope , qualifying conditions and business values . We provide matching flexibility by allowing users to define their own predicates and preferences .
7 . CONCLUSION AND FUTURE WORK This work presents a novel contribution to the area of WSAgreement and agreement matching . To date , no work has been done to automate the tedious chore of matching WS Agreements . With the framework and implementation described throughout this paper , service providers and consumers may automatically make the most accurate and effective partnerships which are tailored to user preferences . While other works consider only objectives , we contribute by defining reasoning methods for the Scopes , Obligations , SLOs , Qualifying Conditions , and Business Values of the Guarantee Terms . We consider the subjectivity of the latter two and implement a feature which allows for the specification of what the user prefers and what the user considers unsuitable . We effectively match complex agreements containing multiple alternatives and symmetry such that both consumer and provider have capabilities and requirements . This work utilizes an effective combination of ARL rules with multiple Ontologies in order to achieve flexibility and accuracy . We define several categories of rules to enhance domain specific knowledge , efficiently handle heterogeneous SLOs , allow the definition of user preferences , and flexibly allow domain specific predicates while greatly simplifying the matching process . These rules are a powerful addition because they allow the matching process to be changed and customized at any time without any modifications to the code or programming knowledge . As WS Agreement is a new and emerging specification , much work is left to be done in this area . Since a key feature of our work is to customize the matching process with user defined rules , this work will benefit from a module which converts rules defined with SWRL to ARL rules to facilitate the definition of rules by user . This tool can be extended to incorporate negotiations as defined by the protocol in [ 2 ] . Suitable agreements can be identified by the current tool and negotiations between parties could ensue . This tool can also be augmented to support other standards for policy specification such as WSPolicy . This would allow consumer to provider matches regardless of the specification used .
Acknowledgements : We thank Dr . Heiko Ludwig ( IBM ) , a member of WS Agreement committee , for his guidance and review of this work . Prof . Sanjay Chaudhari of DA IICT , India provided guidance related to the agriculture scenario . We also acknowledge partial support of this work by IBM Eclipse Innovation Grant and the collaboration with the METEOR S team , of which this research is a component .
8 . REFERENCES [ 1 ] Aiello , M . , Frankova , G . , and Malfatti , D . What ’s in an Agreement ? An Analysis and an Extension of WSAgreement . ( 2005 ) Int . Conf . on Service Oriented Computing ( ICSOC ) 2005
[ 2 ] Andrieux , A . , Czajkowski , C . , Dan , A . , Keahey , K . , Ludwig , H . , Pruyne , J . , Rofrano , J . , Tuecke , S . , Xu , M . , WebServices Agreement Specification ( WS Agreement ) . June 29th 2005
[ 3 ] Bigus , JP , Schlosnagle , DA , Pilgrim , J.R , Mills III , WN , and Diao , Y . ABLE : A toolkit for building multiagent autonomic systems , IBM Systems Journal , Volume 41 , Number 3 , 2002
[ 4 ] Chaudhary , S . , Sorathia , V . , Laliwala , Z . , Architecture of
Sensor based Agricultural Information System for Effective Planning of Farm Activities . IEEE SCC 2004 : 93 100
[ 5 ] DQL Technical Committee 2003 . DAML Query Language
( DQL ) . http://wwwdamlorg/dql
[ 6 ] Eaton , C . , Shepherd , A . , Contract Farming Partnerships for
Growth FAO Agricultural Services Bulletin 145
[ 7 ] Kagal , L . , Paoucci , M . , Srinivasan , N . , Denker , G . , Finin , T . , and Sycara , K . Authorization and Privacy for Semantic Web Services , AAAI Spring Symposium on SW S , 2004 [ 8 ] Kagal , L . , Finin , T . , and Joshi , A . Declarative Policies for
Describing Web Service Capabilities and Constraints , Proceedings of W3C Workshop on Constraints and Capabilities for Web Services
[ 9 ] Lee J . , Goodwin R . T . , Akkiraju R . , Doshi P . , Ye Y . Snobase : A Semantic Network based Ontology Ontology Management http://alphaWorksibmcom/tech/Snobase 2003
[ 10 ] Li , H . , Zhang , X . , Wu , H . , Yuzhong , Q . , Design and Application of Rule Based Access Control Policies . Proceedings of the Semantic Web and Policy Workshop , held in conjunction with the 4th International Semantic Web Conference , 7 November , 2005 , Galway , Ireland .
[ 11 ] Ludwig , H . , Dan , A . , Kearney B . : Cremona : An Architecture for Creation and Monitoring of WSand Library Agreements . In : M . Aiello , M . Aoyama , F . Curbera , M . Papazoglou : Proceedings of International Conference on Service Oriented Computing ( ICSOC 2004 ) , pp . 65 74 , ACM Press . New York , 2004 the 2nd
[ 12 ] Maxemilien , M . , Singh , M . , A Framework and Ontology for Dynamic Web Services Selection . IEEE Internet Computing 8(5):84 93 , September October 2004
[ 13 ] Pan , F . , Hobbs , J . OWL Time http://wwwisiedu/~ pan/damltime/time entry.owl
[ 14 ] Parsia , B . , Kolovski , V . , Hendler , J . Expressing WS
Policies in OWL . Submitted to Policy Management for the Web Workshop , 14th International World Wide Web Conference , Chiba , Japan , May 2005
[ 15 ] Paschke , A . , Dietrich , J . , Kuhla , K . A Logic Based SLA Management Framework . Proceedings of the Semantic Web and Policy Workshop , held in conjunction with the 4th International Semantic Web Conference , 7 November , 2005 .
[ 16 ] RosettaNet Ontology , LSDIS Lab , http://lsdiscsugaedu/~azami/pipshtml
[ 17 ] Sorathia , V . , Laliwala , Z . , and Chaudhary , S . ( cid:147)Towards
Agricultural Marketing Reforms : Web Services Orchestration Approach(cid:148 ) , IEEE International Conference on Services Computing ( SCC 2005 ) , vol ( cid:150 ) I , pp 260 267 , 2005 [ 18 ] Uszok , A . , Bradshaw , JM , Jeffers , R . , Johnson , M . , Tate , A . , Dalton , J . , Aitken , S . Policy and Contract Management for Semantic Web Services , The Proceedings of the AAAI Spring Symposium on Semantic Web Services , 2004
[ 19 ] Verma , K . , Akkiraju , R . , Goodwin , R . Semantic Matching of Web Service Policies , ( SDWP 2005 )
[ 20 ] The Web Service Policy Framework , http://www
106ibmcom/developerworkds/library/ws polfram
[ 21 ] Wohlstadter , E . , Tai , S . , Mikalsen , T . , Rouvello , I . ,
Devanbu , P . GlueQoS : Middleware to Sweeten Quality ofService Policy Interactions , The Proceeding of ( ICSE 2004 ) , pp . 189 199
[ 22 ] The WSLA Specification , http://wwwresearchibmcom/wsla/WSLASpecV120030128pdf
[ 23 ] W . Yang , H . Ludwig , A . Dan : Compatibility Analysis of
WSLA Service Level Objectives . Proceedings of the
Workshop on the Design of Self Managing Systems . Supplemental Volume of the 2003 International Conference on Dependable Systems and Networks . pp . W26 W3
