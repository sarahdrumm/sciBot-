Nestedness and Segmented Nestedness
Heikki Mannila
HIIT
Helsinki University of Technology and
University of Helsinki , Finland mannila@cshelsinkifi
ABSTRACT Consider each row of a 0 1 dataset as the subset of the columns for which the row has an 1 . Then a dataset is nested , if for all pairs of rows one row is either a superset or subset of the other . The concept of nestedness has its origins in ecology , where approximate versions of it has been used to model the species distribution in different locations . We argue that nestedness and its extensions are interesting properties of datasets , and that they can be applied also to domains other than ecology .
We first define natural measures of nestedness and study their properties . We then define the concept of k nestedness : a dataset is ( almost ) k nested if the set of columns can be partitioned to k parts so that each part is ( almost ) nested . We consider the algorithmic problems of computing how far a dataset is from being k nested , and for finding a good partition of the columns into k parts . The algorithms are based on spectral partitioning , and scale to moderately large datasets . We apply the methods to real data from ecology and from other applications , and demonstrate the usefulness of the concept .
Categories and Subject Descriptors : F22 [ ANALYSIS OF ALGORITHMS AND PROBLEM COMPLEXITY ] : Nonnumerical Algorithms and Problems ; H28 [ DATABASE MANAGEMENT ] : Database Applications— Data mining
General Terms : Algorithms , Experimentation , Theory
Keywords nestedness , 0 1 matrices , presence/absence data
1 .
INTRODUCTION
The analysis of 0 1 data is one of the recurring themes in data mining . One of the key issues in the area is to look for ∗Work done while the author was at HIIT , University of Helsinki , Finland .
IBM Almaden Research Center
Evimaria Terzi∗ San Jose , CA , USA eterzi@usibmcom interesting concepts that would be useful to compute from such datasets .
In this paper , we consider the concept of nestedness of 0 1 matrices . The concept has its origins in ecology ; in the study of presence/absence matrices of sites ( locations ) and species . There , the nestedness hypothesis states that the species found in a site with few species should be a subset of the species found in a site with more species . That is , the sets of species found in the different sets should form a chain of subsets . Since the original publication [ 19 ] , the nestedness concept has been studied a lot ; see , eg , [ 4 , 11 , 14 ] for some recent work.1
In general , consider each row of a 0 1 dataset as the subset of the columns for which the row has an 1 . Then a dataset is nested , if for all pairs of rows one row is either a superset or subset of the other . Equivalently , the dataset is nested if the rows and the columns can be reordered so that in the reordered matrix the 1s in each row form a contiguous segment starting from the first column .
Nestedness is of course an extreme state , and there has also been some interesting work on quantifying the degree of nestedness in a dataset [ 6 , 5 , 23 , 9 , 21 ] . See Figure 1 for examples of datasets that are completely nested , almost nested , and very far from being nested . In the figure the rows and columns have been ordered so that the degree of nestedness is easy to see ; in general , it is not easy to determine the degree of nestedness .
Figure 1 : Examples of fully nested , almost nested and non nested datasets . Black = 1 , white = 0 .
Nestedness is a concept that makes sense also for other types of datasets than ecological presence/absence data . Consider for example data about students and courses . Then , assuming that students follow a suggested study program with no electives , the set of courses that a student has taken is a sub or a superset of the set of courses taken by another student . Deviations from this behavior tell us something about the students , the courses , or both . 1Note that this concept of nestedness is different from the concept of nestedness of model classes that is sometimes used in model selection .
As another example , consider a set of documents about a single theme , say probability . Most documents contain the basic terms “ probability ” , “ random variable ” , “ expectation ” etc . , while fewer contain terms such as “ limit theorems ” , and still fewer documents contain terms such as “ martingales ” . The set of terms in a document talking about martingales is most likely to be a superset of the set of terms in a document about the basic concepts of probability . In general , if the collection of documents is about a single topic and there are terms of different levels of difficulty or specialty , then the dataset can be expected to be nested .
Most datasets are not nested , but identifying the degree of their nestedness can give useful insight into the processes that produced the datasets .
In some cases the whole dataset might not be nested , but when limited to a subset of the variables , it is . Starting again with an ecological example , consider presence/absence data of species in sites distributed widely over space , say from north to south . Then the dataset as a whole is not nested : the northernmost and southernmost sites might each have many species , but very few species are found in both places . Thus , the subset/superset phenomenon does not occur .
However , the set of species can be partitioned into two sets such that when projected on those sets the data is nested . In this example the sets of species could be the ones that are prevalent in the south and those that are prevalent in the north . Such segmented nestedness has not , to our knowledge , been considered in the literature . See Figure 2 for an example .
5
10
15
20
25
30
35
40
5
10
15
20
25
30
35
40
Figure 2 : Example of a dataset that has segmented nestedness .
Segmented nestedness can be applied to other domains , as well . For example , in the course data we can find that the courses can be partitioned into two sets so that on those sets the data is nested ; this would correspond to two different curricula . In the document example we could find that the terms can be divided into two sets in such a way that the use of the terms from both sets fall into a nested pattern .
In this paper we consider the concepts of nestedness and segmented nestedness , their use in data analysis , and the algorithmic properties of the concepts . We argue that nestedness and its extensions are interesting properties of datasets that can be applied also to domains other than ecology . We study the algorithmic properties of computing how far from being nested a dataset is . We then define the concept of k nestedness : a dataset is ( almost ) k nested if the set of columns can be partitioned to k parts so that each part is ( almost ) nested . We consider the algorithmic problems of computing how far a dataset is from being k nested , and for finding a good partition of the columns into k parts . The algorithms are based on spectral partitioning . We apply the methods to real data from ecology and from other applications , and demonstrate the usefulness of the concept .
The rest of this paper is organized as follows . In Section 2 we give the definitions of almost nestedness and segmented nestedness . Section 3 gives the algorithms , and Section 4 the empirical results . Section 5 discusses related work , and Section 6 is a short conclusion .
2 . PROBLEM DEFINITION
2.1 Nestedness
Consider an n × m 0 1 matrix M . In an ecological application , the rows could correspond to sites and columns to species . In a course enrollment data , the rows would correspond to students and the columns to courses . We denote the ith row of M by Mi and the jth column of M by M j . The rows and the columns of matrix M have also set interpretations . That is , Mi , except for being a 0 1 vector , is also used to denote the subset of the species that appear in the i th site . We use vector and set interpretation of the rows and columns of M interchangeably .
Definition 1 . An n × m 0 1 matrix M is fully nested if for any two rows i and j we have Mi ∩ Mj ∈ {Mi , Mj} . i ⊇ M π
That is , any two rows of a fully nested matrix have a subset superset relationship . Alternatively , a matrix M is fully nested if there is a permutation of the rows of M such that in the permuted matrix M π , M π j for every i < j . From the definition above , it is obvious that checking if a matrix is fully nested can be done in polynomial time . In practice , the input matrices are not expected to be fully nested . Therefore , we need to define a measure of how far a 0 1 matrix is from being fully nested . We do so by looking at the minimum number of 0s that need to be transformed into 1s so that the matrix M becomes nested and we denote this by N ( M ) . Therefore , for a fully nested matrix N ( M ) = 0 . We loosely call matrices with non zero , but small values of N , almost nested . Next , we formally define the corresponding optimization problem that we call the Minimum Nestedness Augmentation ( or Mna ) .
Problem 1
( Minimum Nestedness Augmentation ) . Given a 0 1 matrix M , find the minimum number of 0s that have to be transformed into 1s so that M becomes fully nested .
We have the following .
Proposition 1 . The Minimum Nestedness Augmen tation problem is NP complete .
The hardness proof of the problem is easy if we consider the graph theoretic interpretation of the Mna problem . The input matrix M defines a bipartite graph G(M ) = ( B , S , E ) . Every node b ∈ B corresponds to a row in M and every node s ∈ S corresponds to a column in M . There exists an undirected edge between b and s if and only if M ( b , s ) = 1 . Therefore , |B| = n , |S| = m and |E| is the number of 1s in M .
A bipartite graph ( B , S , E ) is a chain graph [ 26 ] if there is a bijection π : {1 , . . . , |B|} → B ( an ordering of B ) such that Γ ( π(1 ) ) ⊇ Γ ( π(2 ) ) ⊇ . . . ⊇ Γ ( π(|B|) ) , where Γ is a function that maps a node to its neighbors .
The Minimum Chain Completion problem is as follows . Given a bipartite graph G(M ) , find the minimum set of edges F that need to be added in G(M ) such that the bipartite graph ( B , S , E ∪ F ) is a chain graph . This problem is NP hard [ 26 ] . It is easy to see that the Minimum Chain Completion problem is equivalent the Minimum Nestedness Augmentation problem , and hence Mna is also NPhard . It is trivially in NP .
The equivalence of the matrix and graph formulations also implies the following result .
Proposition 2 . For any matrix M we have N ( M ) =
N ( M T ) , where M T denotes the transpose of M .
Lemma 1 in [ 26 ] states that a bipartite graph is a chain graph if and only if it does not contain a pair of edges that do not share any endpoints ( independent edges ) . We can restate this lemma in terms of the 0 1 matrix M as follows .
Lemma 1 . A 0 1 matrix M is fully nested if and only if it does not contain any submatrix of the form
. . . 0 . . . 1 . . .
0
BBBBBBBB@
. . . 1 . . . 0 . . .
1
CCCCCCCCA
.
We call such submatrices switch boxes . We show in Section 3 how we use Lemma 1 to design a greedy algorithm for Mna . Note that Mna considers only transformations of 0s into 1s , and charges for each such transformation . The reason for this is that in the paleontological/ecological datasets there is high certainty associated with 1s and low certainty associated with 0s . In terms of problem definitions , we can generalize Mna so that we allow changes of 1s into 0s as well . We call this generalized version of Mna , Bidirectional Mna problem ( or BMna ) , and we formally define it as follows .
Problem 2
( BMna ) . Given a 0 1 matrix M , find the minimum number of 0s or 1s that have to be transformed into 1s or 0s , respectively , so that M becomes fully nested .
We denote by B(M ) the cost of the optimal solution of the BMna problem for input matrix M . The complexity of the BMna problem is unknown ( see [ 17] ) . Although the focus of the paper is on the Mna problem , we also show how algorithms for Mna can be adopted to solve the BMna problem as well . It is rather easy to see the following straightforward relationship between the optimal solutions to the Mna and BMna problems .
Proposition 3 . For a 0 1 matrix M we have
N ( M ) ≥ B(M ) . 2.2 Segmented nestedness
In this subsection we consider the problem of finding a good partition of the columns of a matrix so that the projections of the dataset to the parts are ( almost ) nested .
Consider the 0 1 matrix shown in Figure 2 . Clearly , this matrix is not almost nested . However , there are evidently two almost nested submatrices that are induced by the first and the last 20 columns of the input matrix .
As mentioned in the introduction , such matrices motivate the definition of the segmented version of the Mna problem.2 In the segmented version of the problem we wish to partition columns of the matrix into k parts so that the submatrices induced by each part are fully or almost nested . If {P1 , . . . , Pk} is a partition of the columns of M into k parts , we denote by M [ Pi ] the matrix of size n×|Pi| obtained from M by just considering the columns in Pi . We can extend the definitions of the fully and almost nested matrices for segmented nestedness .
Definition 2 . An n × m 0 1 matrix M is fully k nested if there is a partition of its columns into k parts {P1 , . . . , Pk} such that each M [ Pi ] is fully nested .
An immediate consequence of the above definition is the following .
Proposition 4 . For integers k2 , k1 with k2 > k1 , if a 0 1 matrix M is fully k1 nested , then it is also fully k2 nested .
The matrices that appear in practice are not expected to be fully k nested , but rather almost k nested . That is , the submatrices M [ Pi ] are almost nested .
For input matrix M , the segmented version of the Mna problem asks for a partition {P1 , . . . , Pk} of the columns of M such that the total number of conversions of 0s to 1s in the M [ Pi ] ’s is minimized . We call this problem the k Mna problem and we formally define it as follows .
Problem 3
( k Mna ) . Given a 0 1 matrix M and an integer k , find a partition of the columns of M into k parts {P1 , . . . , Pk} , such that
Nk(M ) = kX i=1
N ( M [ Pi ] ) is minimized .
Therefore , fully k nested datasets have Nk(M ) = 0 , while almost k nested datasets have small values of Nk(M ) . Figure 2 is an example of a dataset M that has high value of N ( M ) but a small value of N2(M ) .
Proposition 5 . For a 0 1 matrix M and integers k1 , k2 such that k2 > k1 we have Nk1 ( M ) ≥ Nk2 ( M ) .
Since the k Mna is a generalization of the Mna problem , k Mna is also NP hard .
Instead of looking for a partition of the columns that defines nested submatrices one can alternatively define the problem of removing the minimum number of rows and columns from the input matrix , so that the remaining ( maximal ) submatrix is almost nested . By using the results of [ 25 ] one can show that this variation of the segmented nestedness problem is also NP hard . In the case where we are restricted in removing only rows or only columns of the input matrix , the problem becomes solvable in polynomial time . The relationship between these alternatives and the k Mna problem is the following : while k Mna looks for groups of columns ( or rows ) so that there is a nesting structure within each group , 2The term segmented comes from the definition of “ Segmentation Problems ” given in [ 15 ] . the aforementioned variants look for removal of columns and rows so that a nesting structure appears . Therefore , if one thinks of the k Mna problem as an analogue for clustering , then the above alternatives correspond to problems like outlier detection or finding a single cluster .
We will also refer to the segmented version of Problem 2 as the k BMna problem . The problem definition and the corresponding properties are in accordance to those of Problem 3 and thus omitted . For input matrix M , we use Bk(M ) to denote the optimal solution of the k BMna problem for M .
3 . ALGORITHMS
3.1 Algorithms for estimating nestedness
In this section we consider algorithms for estimating N ( M ) for a matrix M . As the task is NP hard , we cannot hope for an exact solution ; rather , we will compute scores bN ( M ) that are upper bounds for N ( M ) .
Two simple heuristics have been used in the ecology literature for the nestedness and related problems [ 6 , 5 ] . The first algorithm is RowSum . For input matrix M , the algorithm counts the number of 1s in each row and reorders the rows of M in decreasing order of their row sums . The algorithm then converts the necessary 0s to 1s so that the final matrix becomes fully nested . The complexity of the algorithm is O(mn + n log n ) . The following example shows the cost of the solution output by the RowSum algorithm can be arbitrarily bad compared to the cost of the optimal solution .
Example 1 . Consider the ( p + 2 ) × ( 3m ) matrix M that has the following structure
M =
0
BBBBB@
0 . . . 0 1 . . . 1 1 . . . 1 1 . . . 1 1 . . . 1 0 . . . 0 1 . . . 1 1 . . . 1 0 . . . 0 1 . . . 1 0 . . . 0 1 . . . 1
1
CCCCCA
The RowSum algorithm can keep the order of the rows of M unchanged , causing a cost of 2m + mp . The cost of the optimal solution would be just 2m , achieved by moving the last row of M on top . Therefore , the performance ration of RowSum is
2m+mp , which goes to 0 as p grows .
2m
Some straightforward alternatives to RowSum can be the ColSum and the BestSum algorithms . The ColSum is exactly the same as the RowSum but it operates on the columns of M . That is , the columns of M are rearranged in decreasing order of their column sums and the necessary 0s are converted into 1s so that the final matrix is fully nested . For given input matrix M , the BestSum algorithm is the best of RowSum and ColSum for the given input . Both these algorithms can give solutions with cost arbitrarily bad with respect to the optimal with input the matrix given in Example 1 .
Some other algorithms for quantifying nestedness have also been considered in the ecological literature ( see , eg , [ 23 , 9 , 21] ) , but they are fairly heuristic and difficult to analyze .
In the rest of the section we give a simple greedy algorithm for the Mna problem . We also show how we can adopt this algorithm to solve the BMna problem as well .
Consider an input matrix M of size n × m . By Lemma 1 , M is fully nested if it does not contain any switch boxes . Given this , we can design a greedy algorithm that switches 0s into 1s one at a time . At every step , the algorithm converts the 0 that participates in the largest number of distinct switch boxes . Consider entry ( i , j ) of the matrix . The coverage C(i , j ) of entry ( i , j ) is the number of switch boxes this entry participates in . By converting the value in ( i , j ) from 0 to 1 , all the C(i , j ) switch boxes are resolved .
After each conversion , the algorithm recalculates the coverages of the remaining 0s in the matrix and proceeds in the next greedy step . Algorithm 1 gives an outline of the Greedy algorithm .
1 : Input : An n × m 0 1 matrix M .
Algorithm 1 The Greedy algorithm for computing bN ( M ) . 2 : Output : bN ( M ) , an approximation of N ( M ) . 3 : bN ( M ) = 0 ;
C(i , j ) = coverage of entry ( i , j ) with M ( i , j ) = 0 ; end for for j = 1 to n do
4 : for i = 1 to m do 5 : 6 : 7 : 8 : end for 9 : while M is not fully nested do 10 : 11 : M ( i , j ) = 1 12 : 13 : 14 : end while bN ( M )++ 15 : return bN ( M ) update the coverages ;
( i , j ) = the entry with the largest coverage ;
The running time of the Greedy algorithm is O(mn + IT1T2 ) , where I is the number of iterations of the while loop , T1 the time required for finding the maximum coverage , and T2 the time required for updating the coverages .
By using a heap , T1 is O(1 ) and T2 is O ( mn log(mn) ) . When entry ( i , j ) is converted from 0 to 1 , we only have to make the following updates : ( i ) decrease by 1 the coverages of entries ( v , u ) with Mvu = 0 , Miu = 1 , and Mvj = 1 ; ( ii ) increase by 1 the coverages of entries ( i , u ) and ( v , j ) with Mvu = 1 , Miu = 0 , and Mvj = 0 . These are due to ( i ) switch boxes that ( i , j ) participated in and that are removed , and ( ii ) switch boxes that are created by the conversion .
As the maximum number of iterations is O(mn ) , the total time is O((mn)2 log(mn) ) . In practice the number of iterations is much smaller than O(mn ) , indicating that the method scales reasonably well .
The same greedy principle can be used for solving the BMna problem . The corresponding Bi Greedy algorithm is essentially the same as the Greedy algorithm above , with the only difference that since both 0s are transformed into 1s and 1s into 0s , the coverages of both 0 and 1 entries are computed in the beginning and updated in every iteration . Whenever entry ( i , j ) is converted from 0 to 1 the following updates need to be done by the Bi Greedy algorithm : ( i ) decrease by 1 the coverages of entries ( v , u ) with Mvu = 0 , Miu = 1 , and Mvj = 1 ; ( ii ) increase by 1 the coverages of entries ( v , u ) with Mvu = 1 , Miu = 0 , and Mvj = 0 ; ( iii ) increase by 1 the coverages of entries ( i , u ) and ( v , j ) with Mvu = 1 , Miu = 0 , and Mvj = 0 ; ( iv ) decrease by 1 the coverages of entries ( i , u ) and ( v , j ) with Mvu = 0 , Miu = 1 , and Mvj = 1 . The complementary updates are made when entry ( i , j ) is converted from 1 to 0 . The running time of the Bi Greedy algorithm is of the same order as the running time of the Greedy algorithm discussed above . Note that the algorithm is designed so that at most one conversion is allowed per entry . 3.2 Algorithms for estimating segmented nestedness
In this section we give algorithms for the k Mna problem . The algorithms for the k BMna problem are easily developed using the same principles , and thus their discussion is omitted . Remember that the task is to find a partition {P1 , . . . , Pk} of the columns of the matrix M so that the projections M [ Pi ] of M to these columns have a small value of N ( M ) . Again , as the problem is NP hard , we have to be content with producing upper bounds bNk(M ) for Nk(M ) .
We approach the problem as a clustering problem for the columns of the input matrix M . When should two columns be placed to the same group in the partition ? Obviously , if the columns a and b are similar , ie , they tend to have 1s in the same rows , then it makes sense to have them in the same part Pi . On the other hand , if a and b are independent or negatively correlated , then they should be in different parts of the partition .
This simple observation leads to an algorithm for computing an approximation to N2(M ) : define a similarity notion between columns , use a spectral bisection method [ 22 ] to obtain the two parts of the partition , and then compute the score for both parts using the Greedy algorithm . By recursive applications of the algorithm we obtain a way of approximating Nk(M ) as well .
We first define two simple and intuitive similarity functions between the columns of the input matrix M . Then , we combine these functions with a simple spectral bisection algorithm to solve the 2 Mna problem .
One straightforward measure of similarity that serves our purposes is the correlation similarity . We define the correlation similarity between two columns M a and M b as
CorrS(M a , M b ) = 1 + ρab ,
( 1 ) where ρab is the Pearson correlation between columns a and b . As ρab takes values in the range [ −1 , 1 ] , CorrS takes values in [ 0 , 2 ] . Value 2 is obtained if the columns are identical , and value 0 when they are perfectly anticorrelated .
Alternatively , we use the following inclusion similarity be tween columns M a and M b :
InclS(M a , M b ) =
M a ∩ M b min{|M a| , |M b|}
.
( 2 )
The inclusion similarity captures our intuition that two columns need to be in the same cluster if the one includes the other . For example , when column a is included in column b ( or vice versa ) , then InclS(M a , M b ) = 1 , and thus columns a and b are considered very similar . Similarly , the inclusion similarity of two non intersecting columns is zero . Spectral algorithms are important tools for a wide range of problems such as , solving linear systems [ 20 ] , ordering problems [ 1 , 16 ] , data clustering [ 18 , 10 ] and many more . Before describing the spectral bisection algorithm we use , we give some background for the spectral method in general . Consider a weighted undirected graph G = ( V , E ) where each ( i , j ) ∈ E has a weight wij . Let A be the matrix with A(i , j ) = wij if ( i , j ) ∈ E and A(i , j ) = 0 otherwise . The
Laplacian of A is defined to be the symmetric and zero sum matrix L = D − A , where D is a diagonal matrix whose
( i , i) th entry is di = P(i,j)∈E wij . The eigenvalues of L are real and nonnegative , and the smallest eigenvalue is 0 ( corresponding to the eigenvector of all 1s ) . The eigenvector v that corresponds to the second smallest eigenvalue of L is also known as the Fiedler vector .
We consider the graph A , whose nodes are the columns of the input matrix M . There is an edge between all pairs of nodes , and the weight of the edge ( a , b ) is CorrS(M a , M b ) ( Equation ( 1 ) ) or InclS(M a , M b ) ( Equation ( 2) ) . We form the Laplacian matrix LA of the graph A and compute the Fiedler vector v . Then v is a vector with m components .
Each element va of v defines a partition by P1 = {b|vb ≤ va} and P2 = {b|vb > va} . For each va , we evaluate bN ( M [ P1 ] ) + bN ( M [ P2 ] ) and return the partition with the smallest value of the sum .
The algorithm can be augmented by local moves . That is , we start from the initial partition given by the spectral bisection method , and then repeatedly search for columns that can be moved from one part to the other so that the score improves .
If k > 2 , then we recursively call the algorithm on each of the parts to check which one should be divided further . The method , called Partition , is described also in Algorithm 2 .
Algorithm 2 The Partition algorithm for computing bNk(M ) .
1 : Input : An n × m 0 1 matrix M , and an integer k > 1 . 2 : Output : A partition of the columns of M to k parts and an upper bound bNk(M ) for Nk(M ) .
3 : Compute the similarity graph A , with entries A(a , b ) =
CorrS(a , b ) .
4 : Form the Laplacian LA of A , and compute the Fiedler vector v .
5 : Find the column a such that the bisection P1 = {b|vb ≤ va} and P2 = {b|vb > va} has the best score of bN ( M [ P1 ] ) + bN ( M [ P2] ) ;
6 : if k > 2 then 7 :
Recursively call Partition on the restriction of M to P1 and to P2 to check which gives the larger decrease in the bN2(M ) score
8 : end if 9 : Do local moves : for each column a , test whether it can be moved to another part of the partition so that the score improves
Every call of the Partition algorithm requires time O(Tλ +mTp ) , where Tλ is the time needed for the eigenvalue computation and Tp is the time required for the approximation of N at step 5 of the algorithm . The dominating factor is the computation of bN for k = 1 for both sets of m different partitions , resulting a total time complexity of O(m3n2 log(mn) ) . In practice the method scales to datasets of moderate size , as the above bound is a worst case one .
We will compare the performance of the Partition algorithm with the CorrS and InclS similarity functions with two straightforward heuristics , the kmeans and the InclS kmeans . The kmeans algorithm performs a clustering of the columns considering each column as an observation consisting of n attributes ( where n is the number of rows of the input matrix ) . We use the Hamming distance func tion as the optimization criterion for the kmeans algorithm . The InclS kmeans again clusters the columns of the input matrix , this time using as input the similarity matrix induced by the InclS function . In this case , the centers of the k means procedure are bound to be from the input points , since only the similarity matrix is given as input . 3.3 Selecting the value of k
The concept of k Mna has the parameter k that can vary . For any dataset M , we have Nk(M ) ≥ Nk+1(M ) , as the ability to divide the columns into k + 1 sets instead of k sets will make it easier to have small number of nestedness violations . At the limit , when k = m , the number of columns in M , we have Nm(M ) = 0 . So how should a good value of k be chosen ?
This is , of course , a classical example of the model selection problem . Different solutions abound : one can use MDL , BIC , AIC , cross validation , etc . ( see , eg , [ 12 ] for a description of some of the methods ) .
Here we use a fairly simple alternative : we monitor the change of the score bNk(M ) as a function of k ; when the score flattens , the correct value of k is reached . This , of course , is a heuristic approach , but seems to be sufficient . We also compare the change in the score with the change in the score bNk(M π ) , where M π is a dataset obtained from M by permuting each column of M independently at random.3 That is , we test whether the score on real data drops clearly faster than for random data with the same density . Other methods of selecting k are left for further study .
4 . EXPERIMENTS
In this section , we give experimental evidence of the utility of the nestedness concept . For this , we use both synthetic and real datasets ; the latter come from a variety of application domains like ecology , paleontology and students’ course enrollment data . 4.1 Synthetic datasets
To test the behavior of the algorithms we generated synthetic data as follows . For given n and m we first generate a fully nested 0 1 matrix by first sampling row counts ri uniformly between 0 and m , and sorting them so that ri ≥ rj for every i < j . Then we generate rows so that row i has 1s in its first ri columns and 0s in the other columns . Let such a matrix be H , and let H 1 be all the cells in H that have value 1 and H 0 all the cells that have value 0 . Given H we generate our synthetic matrices by altering entries of H 1 from 1 to 0 , and entries of H 0 from 0 to 1 . An entry in H 1 keeps its original value with probability 1 − p , and it is converted to 0 with probability p . Similarly , the entries in H 0 are switched to 1 with probability q and they maintain their original value with probability 1 − q . Thus , p is the probability of an 0 entry in H 1 and q the probability of an 1 entry in H 0 . The interesting parameter values are ones where p > q and q is fairly close to 0 ; this is due to the asymmetry of 0s and 1s mentioned earlier . Figure 3 shows the relative performance of the three algorithms Greedy , RowSum and ColSum algorithms for synthetic datasets generated as above . Note that when p = 0 and q = 0 , the generated
3Note that in a fully nested dataset there are no switch boxes ; thus we cannot use the swap randomization method [ 13 ] .
)
B
(
N
18000
16000
14000
12000
10000
8000
6000
4000
2000
0 q = 0.05
RowSum ColSum Greedy BiGreedy
0.1
0.2
0.3
0.4
0.5 p
0.6
0.7
0.8
0.9
0.95
Figure 3 : Comparative performance of algorithms for Mna problem on synthetic datasets for q = 005 the input M for RowSum , ColSum and Greedy algorithm x axis : parameter p ; y axis : the quantity bN ( M ) of and the quantity bB(M ) for Bi Greedy algorithm . matrices are fully nested and all algorithms find the optimal solution that has cost 0 . In Figure 3 we compare the number of flips done by the different algorithms for datasets generated with q = 0.05 and p ∈ [ 0.1 , 095 ] Among these three algorithms we can clearly see that the Greedy algorithm consistently outperforms the other two , and the difference is fairly high especially for smaller values of p . In the same figure we additionally report the cost of the Bi Greedy algorithm using cost function B instead of N . Note that although the results of Bi Greedy are not comparable with the results of the other algorithms , they are given here for completeness . 4.2 Habitat datasets
We have also tested the relative performance of the different algorithms for Mna by using a set of real datasets available by AICS Research Inc , University Park , New Mexico , and The Field Museum , Chicago . The datasets are available online4 and they have been used for a wide range of ecological studies [ 3 , 9 , 7 , 2 , 23 ] . The collection contains 280 datasets in the form of presence/absence matrices , that cover a wide variety of taxa ( mammals , bats , land and freshwater birds , reptiles and amphibians , fish , terrestrial arthropods , terrestrial mollusks , plants and other miscellaneous species ) . Figure 4 serves as a summary of comparisons between the Greedy algorithm and the best of the RowSum and ColSum algorithms ( BestSum ) . For the purposes of the experiment , we group the datasets with respect to their densities ( number of 1 ’s in the matrix divided by the size of the matrix ) . For each density range , we count the number of datasets in the range for which Greedy performs better , equal or worse than BestSum algorithm . For most datasets with small density the Greedy algorithm performs considerably better than BestSum , and throughout the datasets Greedy is only seldom worse than BestSum . Figure 5 shows
4http://wwwaics researchcom/nestedness/
Fullglas dataset ; Input
Fullglas dataset ; Rearranged by BestSum
Fullglas dataset ; Rearranged by Greedy
10
20
30
40
50
60
70
80
90
100
10
20
30
40
50
60
70
80
90
100
10
20
30
40
50
60
70
80
90
100
5
10
15
20
25
30
35
5
10
15
20
25
30
35
5
10
15
20
25
30
35
( a ) Fulglas dataset ; Input matrix
( b ) Fulglas dataset ; Rearrangement by BestSum
( c ) Fulglas dataset ; Rearrangement by Greedy
Figure 5 : Rearrangements of the Fulglas dataset matrix s t e s a t a d f o #
40
35
30
25
20
15
10
5
0
0
0.1
0.2
0.3
Habitat datasets
Greedy BestSum Greedy = BestSum
0.4
0.5 density of the dataset
0.6
0.7
0.8
0.9
1
Figure 4 : The performance of the algorithms on the habitats datasets . The columns show the number of datasets for which the Greedy algorithm or the BestSum algorithm ( the better of RowSum and ColSum ) gives better results or whenever they are equal . an indicative example of this performance for the Fullglas dataset . The dataset has 102 rows , 39 columns and 1503 non zero entries . Figure 5(a ) renders the input matrix . The matrix corresponds to presence/absence information of prairie plants ( goldenrods , milkweeds , and legumes ) in 102 prairie fragments in Iowa and Minnesota . The BestSum algorithm makes 2026 conversions , while the Greedy only needs 959 . The rearranged matrices output by the two algorithms are shown in Figures 5(b ) and 5(c ) . The example above illustrates the philosophy of the Greedy algorithm . Instead of a rearrangement that brings rows with larger row sum before rows with smaller row sum , it rather prefers bringing some sparse rows on the top for the sake of creating a matrix with a clear triangular form . Notice that the rearranged matrices output by the Greedy algorithm have no 1s in their right lower part . 4.3 Segmented nestedness
In this section we test the algorithms for computing bNk(M ) . There are two problems to consider : whether the al gorithm is able to recognize the cases where the dataset has a clear k nested structure , and whether there are clear cases of k nested structure in real data . We evaluate the algorithms
1 and M ′ for approximating Nk(M ) via experiments on both synthetic and real datasets . We generate the synthetic datasets using the same method described in Section 41 For given m and n , we use the method described in Section 4.1 to generate two matrices M1 and M2 of sizes n × m1 and n × m2 , such that m1 + m2 = m . By random permutations of the rows and the columns of M1 and M2 , we obtain the permuted matrices M ′ 2 . The final matrix M is obtained by concatenating the i th row of M ′ 1 with the i th row of M ′ 2 . The matrices generated in such a way are almost 2 nested , ie , they have a small value of N2(M ) . We use such matrices as input to the bisection algorithms we described in Section 32 The same technique can be used to generate almost k nested datasets for any k . Figure 6 shows the performance of the Partition algorithm using the CorrS and InclS similarity functions and the effect of the local moves . We compare the performance of these algorithms with the performance of two straightforward heuristics , the kmeans and the InclS kmeans ( see Section 32 ) As a baseline , we also compare the quantity bN2 returned by the algorithms to the ground truth , ie , the value determined by the generation process . As shown in Figure 6 the Partition algorithm for both the similarity measures defined in Section 3.2 outperforms the other heuristics . This performance is independent of how balanced the sizes of the planted nests are ( Figure 6(a ) ) or the noise level of the dataset ( Figure 6(b) ) . The cost achieved by the Partition algorithm is quite close to the ground truth . The effect of the local moves step becomes more obvious for datasets generated to have components of unequal sizes . the Partition algorithm with local moves and the InclS similarity function is better than the score obtained by the ground truth partition .
In many cases , the bNk score of
The next experiment investigates the selection of the correct value of k . We generated datasets that have 1 , 2 , or k = 1 , 2 , 3 , 4 , 5 . Table 1 shows the results , together with the results for the permuted version of the datasets . We
3 nested structure , and tested the values of bNk and bBk for observe that for 1 nested data the score bNk stays about the bNk(M ) drops a lot when moving from k = 1 to k = 2 , and for 3 nested data the score bNk(M ) drops a lot when moving from k = 1 to k = 2 and k = 3 . Ie , the drop rate can be used as an indication of the correct value of k . The same same for all values of k , while for 2 nested data the score
)
M
(
N
2 x 104
Bisection algorithms
InclS−kmeans kmeans InclS−Spectral CorrS−Spectral Local−Moves GTruth
2.2
2.1
2
1.9
1.8
1.7
1.6
1.5
1.4 10/190 20/180 30/170 40/160 50/150 60/140 70/130 80/120 90/110 100/100
Bipartitions x 104
3
Bisection algorithms
InclS−kmeans kmeans InclS−Spectral CorrS−Spectral Local−Moves GTruth
2.5
2
1.5
1
)
M
(
N
2
0.5
0.1
0.2
0.3
0.4
0.5 p
0.6
0.7
0.8
0.9
Figure 6 : Comparative performance of bisection algorithms for approximating N2 . Upper panel : Data set generated with p = 0.5 and q = 0.01 ( see text ) , with two matrices of 200 rows and varying number columns in two nested parts . x axis : the sizes of set generated with q = 0.01 and varying p ; 200 rows , and two nested parts of 100 columns . x axis : the the nested parts ; y axis : bN2 . Lower panel : Data value of p ; y axis : bN2 . Algorithms : kmeans and the
InclS kmeans : see Section 3.2 ; InclS Spectral and CorrS Spectral : the Partition algorithm with the InclS and CorrS similarity metrics , but without local moves ; Local Moves : the Partition algorithm with the InclS similarity metric and with local moves ; GTruth : the ground truth from the data generation process . patterns are observed even more clearly for the values of bBk . ( The drop in the score of the permuted datasets tells us something about how large changes should be expected on the average . ) Table 2 shows the same type of results k 1 2 3 4 5 k 1 2 3 4 5 k 1 2 3 4 5 bNk(M )
6643 5263 4202 3944 3789 bNk(M )
12790 7163 6270 5744 5481 bNk(M )
14622 10442 6579 6248 5842 bNk(M π )
18717 18523 17383 16731 15954 bNk(M π )
18107 17814 17395 16037 15353 bNk(M π )
18768 18532 17508 16816 15824 true k=1 std 67 45 330 587 354 bBk(M )
2194 2170 2156 2139 2121 true k=2 std 51 68 246 92 225 bBk(M )
6021 2212 2200 2186 2166 true k=3 std 73 56 194 524 44 bBk(M )
7405 4525 2195 2183 2155 bBk(M π )
9861 9810 9741 9661 9561 bBk(M π )
10162 10134 10079 10023 9906 bBk(M π )
10280 10256 10216 10077 10088 std 25 54 40 53 59 std 55 46 12 59 51 std 49 32 40 10 37
Table 1 : The k nestedness count on generated datasets with 1 , 2 , or 3 components . True k : the number of components in the data ; k : the input the Mna ( BMna ) score for the dataset where each column has been permuted in parameter given to the Partition algorithm ; bNk(M ) ( bBk(M ) ) : the Mna ( BMna ) score of the partition ; bNk(M π ) ( bBk(M π) ) : dependently ; std : standard deviation of bNk(M π ) and bBk(M π ) . The size of the generated data is 200 rows and 200 columns . The parameters are p = 0.1 and q = 0.01 ( see text ) . for the paleontological and course datasets . We observe that the drop continues until k = 3 for the paleontological data and until k = 2 for the course data , but levels off after that . In all cases the drop is larger for the real dataset than for the permuted one . The interpretation of the results is fairly clear for both real datasets . The paleontological dataset has a 3 nested structure , and the same is true also for the course dataset . In the course dataset there are actually students from two different curricula : the names of the courses have changed , and some students have moved from one system to another . This explains why there are clearly more than one components in the data .
Figure 7 shows the results on the paleontological dataset . Panels ( a ) and ( b ) show the results of partitioning the columns into two or three parts so as to maximize nestedness . The dataset is drawn so that the order of the rows corresponds to the temporal order of the sites , and the order of the columns corresponds to the order of the occurrence times of the species . The sets of columns are nicely consecutive in the figure , indicating the expected result that the nested subsets of columns are temporally connected . Panel ( c ) shows how the subsets of the data projected to 3 parts look like , with the rows reordered so as to show maximum nestedness . We observe a quite strong nested structure in each plot .
20
40
60
80
100
120
20
40
60
80
100
120
( a ) Paleo dataset ; 2 partitioning of the columns , with 64 and 75 columns .
20
40
60
80
100
120
20
40
60
80
100
120
( b ) Paleo dataset ; 3 partitioning of the columns , with 25 , 47 , and 61 columns
( c ) The three subsets of the columns of the paleontological dataset , with rows and columns reordered by the Greedy algorithm .
Figure 7 : Segmented nestedness in the paleontological dataset . k 1 2 3 4 5 k 1 2 3 4 5 bNk(M )
12156 6375 4674 3933 3505 bNk(M )
105814 66196 60713 49420 47485
Paleo data bNk(M π )
12534 10662 9058 7971 7360 std 92 66 163 73 295 bBk(M )
1749 1566 1397 1277 1181
Course data bNk(M π )
140310 126990 109660 93397 86102 std 892 345 331 1140 1201 bBk(M )
20013 16546 14124 13842 13503 bBk(M π )
1912 1829 1773 1720 1673 bBk(M π )
27676 27069 26831 26555 26407 std 13 21 26 15 14 std 65 85 35 92 109
Table 2 : The k nestedness count on real datasets . k : the input parameter given to the Partition al gorithm ; bNk(M ) ( bBk(M ) ) : the Mna ( BMna ) score of the partition ; bNk(M π ) ( bBk(M π) ) : the Mna ( BMna ) bNk(M π ) and bBk(M π ) . The data sizes are paleontolog score for the dataset where each column has been permuted independently ; std : standard deviation of ical : 124 × 139 and course : 2401 × 106 .
5 . RELATED WORK
The concept of nestedness has its roots in ecological studies where nested subsets have been observed in presence/absence matrices of species in biotas . The main focus of the ecological studies has been applying the concept to the study of species distribution . In more computationally oriented work , the main effort has been towards defining measures of nestedness and devising randomization tests for checking whether the nestedness score of a given matrix is significant or whether it can appear by chance .
Several indices of nestedness have been proposed like for example the temperature of a matrix [ 3 ] , the N0 index [ 19 , 24 ] the N1 index [ 8 , 24 ] , the NC index [ 24 ] , the U index [ 8 ] and lately the discrepancy [ 5 ] . Many of these indices are rather informally defined .
Randomization tests have been developed for comparing the nestedness index of a given matrix with that of matrices generated using an underlying generative model . The models used and tested in the ecological literature include those that produce matrices with the same density , or the same row or ( or and ) column margins [ 5 , 19 , 24 ] . The randomization tests indicate whether the nestedness evaluated using one of the above indices are significant or they could have occurred by chance . The nestedness indices and the randomization methods have been subject to extensive comparisons and have been applied to a wealth of ecological datasets ; see [ 23 ] for a review .
The study of the computational problems related to the computation of the nestedness indices has been limited . For example , [ 6 ] studies the properties of discrepancy for a given family of 0 1 matrices that have decreasing row and column sums . However , the computational problem of finding the right rearrangement of rows and columns so that the rearranged matrix has the minimum discrepancy has not , to our knowledge , been addressed before . Also , the concept of segmented nestedness and its computational analysis is new .
6 . CONCLUSIONS
We have studied the concepts of nestedness and segmented nestedness , arguing that they are useful also outside the field of ecology . We defined the measures that quantify how far a dataset is from being k nested and studied the properties of the corresponding optimization problem . For the case k = 1 , we proposed a simple greedy algorithm that clearly outperforms existing algorithms on generated and real data . For the case k > 1 , we showed how spectral methods can be used to obtain partitions that give good results . We evaluated the methods both on synthetic and real data . The algorithms scale to moderately sized datasets .
There are obviously many open questions . One of the most interesting ones is the selection of the correct value of k ; here we were content to use a simple heuristic , but it is interesting to study the behavior of more disciplined methods . The usefulness of the concept of segmented nestedness on real data seems clear , and additional experiments on , eg , ecological and document data are of interest .
7 . REFERENCES [ 1 ] Atkins , J . E . , Boman , E . G . , and Hendrickson ,
B . A spectral algorithm for seriation and the consecutive ones problem . SIAM J . Comput . 28 , 1 ( 1998 ) , 297–310 .
[ 2 ] Atmar , W . , and Patterson , B . Nestedness temperature calculator .
[ 3 ] Atmar , W . , and Patterson , B . On the measure of order and disorder in ecological communities on archipelagos . Oecologia 96 ( 1993 ) , 539–547 .
[ 4 ] Bascompte , J . , Jordano , P . , Melian , C . , and Olesen , J . The nested assembly of plant animal mutualistic networks . Proceedings of the National Academy of Sciences 100 ( 2003 ) , 9383–9387 .
[ 5 ] Brualdi , R . , and Sanderson , J . Nested species subsets , gaps , and discrepancy . Oecologia 119 , 2 ( 1999 ) , 256–264 .
[ 6 ] Brualdi , R . A . , and Shen , J . Discrepancy of
Matrices of Zeros and Ones . Electr . J . Comb . 6 ( 1999 ) .
[ 7 ] Cutler , A . The dynamics of nested patterns of species distribution . Biodiversity dynamics .
[ 8 ] Cutler , A . Nested biotas and biological conservation : metrics , mechanisms , and meaning of nestedness . Conserv . Biol . 5 ( 1991 ) , 496–505 .
[ 9 ] Cutler , A . Nested biotas and biological conservation : metrics , mechanisms , and meaning of nestedness . Landscape and Urban Planning 28 ( 1994 ) , 73–82 .
[ 10 ] Ding , C . H . Q . , and He , X . Linearized cluster assignment via spectral ordering . In ICML ( 2004 ) .
[ 11 ] Donlan , C . , Knowlton , J . , Doak , D . , and
Biavaschi , N . Nested communities , invasive species and holocene extinctions : evaluating the power of a potential conservation tool . Oecologia 145 , 3 ( 2005 ) , 475–485 .
[ 12 ] Duda , R . , Hart , P . , and Stork , D . Pattern
Recognition . Wiley , 2001 .
[ 13 ] Gionis , A . , Mannila , H . , Mielik¨ainen , T . , and
Tsaparas , P . Assessing data mining results via swap randomization . In KDD ( 2006 ) , pp . 167–176 .
[ 14 ] Ibanez , J . , Caniego , J . , and Garcia Alvarez , A .
Nested subset analysis and taxa range size distributions of pedological assemblages : implications for biodiversity studies . Ecological Modelling 182 , 3/4 ( 2005 ) , 239–256 .
[ 15 ] Kleinberg , J . , Papadimitriou , C . , and Raghavan ,
P . Segmentation problems . Journal of the ACM ( 2004 ) , 263–280 .
[ 16 ] Koren , Y . , and Harel , D . Multi scale algorithm for the linear arrangement problem , 2002 .
[ 17 ] Natanzon , A . , Shamir , R . , and Sharan , R .
Complexity classification of some edge modification problems . Discrete Applied Mathematics 113 , 1 ( 2001 ) , 109–128 .
[ 18 ] Ng , A . Y . , Jordan , M . I . , and Weiss , Y . On spectral clustering : Analysis and an algorithm . In NIPS ( 2001 ) , pp . 849–856 .
[ 19 ] Patterson , B . , and Atmar , W . Nested subsets and the structure of insular mammalian faunas and archipelagos . Biological Journal of the Linnean Society 28 , 1 2 ( 1986 ) .
[ 20 ] Pothen , A . , Simon , H . , and Wang , L . Spectral nested dissection . Tech . Rep . CS 92 01 , 1992 .
[ 21 ] Rodriguez Girones , M . A . , and Santamaria , L .
A new algorithm to calculate the nestedness temperature of presence absence matrices . Journal of Biogeography 33 , 5 ( 2006 ) , 924–935 .
[ 22 ] Spielman , D . A . , and Teng , S H Spectral partitioning works : Planar graphs and finite element meshes . In FOCS ( 1996 ) , pp . 96–105 .
[ 23 ] Wright , D . , Patterson , B . D . , Mikkelson ,
G . M . , Cutler , A . , and Atmar , W . A comparative analysis of nested subset patterns of species composition . Oecologia 113 ( 1998 ) , 1–20 .
[ 24 ] Wright , D . , and Reeves , J . On the meaning and measurement of nestedness in species assemblages . Oecologia 92 ( 1992 ) , 257–264 .
[ 25 ] Yannakakis , M . The node deletion problem for hereditary properties is NP complete . J . Comput . System Sci . 20 ( 1980 ) , 219–230 .
[ 26 ] Yannakakis , M . Computing the Minimum Fill In is
NP Complete . SIAM Journal on Algebraic and Discrete Methods 2 , 1 ( 1981 ) , 77–79 .
