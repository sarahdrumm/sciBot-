Debiasing Crowdsourced Batches
Honglei Zhuang , Aditya Parameswaran , Dan Roth , Jiawei Han
{hzhuang3 , adityagp , danr , hanj}@illinois.edu
Department of Computer Science
University of Illinois at Urbana Champaign
ABSTRACT Crowdsourcing is the de facto standard for gathering annotated data . While , in theory , data annotation tasks are assumed to be attempted by workers independently , in practice , data annotation tasks are often grouped into batches to be presented and annotated by workers together , in order to save on the time or cost overhead of providing instructions or necessary background . Thus , even though independence is usually assumed between annotations on data items within the same batch , in most cases , a worker ’s judgment on a data item can still be affected by other data items within the batch , leading to additional errors in collected labels . In this paper , we study the data annotation bias when data items are presented as batches to be judged by workers simultaneously . We propose a novel worker model to characterize the annotating behavior on data batches , and present how to train the worker model on annotation data sets . We also present a debiasing technique to remove the effect of such annotation bias from adversely affecting the accuracy of labels obtained . Our experimental results on synthetic and real world data sets demonstrate that our proposed method can achieve up to +57 % improvement in F1 score compared to the standard majority voting baseline .
Categories and Subject Descriptors H28 [ Database Applications ] : Data mining
Keywords Crowdsourcing ; annotation bias ; worker accuracy model
1 .
INTRODUCTION
Crowdsourcing provides an efficient method to annotate data on a large scale for various machine learning tasks , by employing a massive workforce drawn from global Internet users . Popular online crowdsourcing platforms include Amazon Mechanical Turk1 and CrowdFlower2 . However , while crowdsourcing is relatively
1https://wwwmturkcom/ 2http://wwwcrowdflowercom/ cheap compared to employing experts , getting large quantities of labeled data annotated by crowds ( say thousands , or millions of data items ) can be rather expensive .
A key mechanism , often employed in practice for reducing costs , is batching , ie , grouping multiple data items ( to be annotated together ) into one single task as a batch . Batching can save significant monetary costs , since the necessary instructions and background for completing the task needs to be provided just once for the entire batch . Thus , the worker will spend less time on reviewing these instructions , and more time on annotating data items , and therefore will be able to annotate more data items within the same time . For instance , consider a scenario where a worker has to judge whether a comment is relevant to a document . Here , making a judgment for each comment requires reading through the entire document . Instead , with batching , the worker only needs to read the entire document once , and then make a judgment for all the comments in the batch . In fact , even from the workers’ point of view , it is also more attractive to label batches of data items as they can save time on switching between different tasks .
However , even though batching is an attractive option in practice due to its cost and time savings , having workers annotate batches can lead to severe correlation between annotations within batches . For example , say we have a task of annotating whether a review of the movie “ The Imitation Game ” crawled from IMDb is positive . As illustrated in Figure 1(a ) , if we only show one review to be judged as part of each crowdsourcing unit task , workers will have to spend some time looking up the movie before they can make a single judgment on a review . Although judgments are likely to be independent , this way of assigning work is too costly to be practical . Instead , if we assemble multiple reviews of the same movie into a batch , as shown in Figure 1(b ) , workers can make multiple judgments after they look up a movie . Nevertheless , in this case , the annotation of different reviews might interfere with each other . For example , the review “ Average In The Extreme ” does not seem like a positive review per se ( Cf . top right in Figure 1(a) ) , while grouped with the review “ Stack of Lies ” , it looks much more like a positive review ( Cf . top in Figure 1(b) ) . Similarly , when the review “ Good enough but historically sketchy ” looks quite positive by itself ( Cf . bottom left in Figure 1(a) ) , it does not look as positive as a strongly effusive review simply saying “ Great movie ” , as shown in the bottom of Figure 1(b ) . Thus , overall these effects might be undesirable and misleading as it is inconsistent with the case when workers make independent judgments . Therefore , it is challenging to ascertain true labels of data items in batches .
So far , there has been little to no work in exploring the the possible annotation error introduced by grouping data items into batches . Although batching data items has been adopted in many crowdsourced tasks such as sorting [ 17 ] , object recognition [ 32 ] or clus
1593 ( a ) Data items judged independently
( b ) Data items judged in a batch
Figure 1 : Example of correlation between annotations on data items in the same batch . Workers are asked to label whether a review on the movie “ The Imitation Game ” crawled from IMDb is positive . Assign each review movie pair to different workers separately can be costly , while assigning a batch of reviews together with a movie to workers might affect workers’ judgments . tering [ 10 ] , and anecdotally very widely used in practice , the assumption is often that the annotations are collected independently , which is not the case . While there is limited work on judging data items in sequence [ 18 , 26 , 27 ] , it is not directly applicable to our setting where a batch of data items are presented and annotated in parallel . Our previous research [ 36 ] identified batch annotation bias , and demonstrated that in a binary classification , annotations on about 35 % of positive items and 5 % of negative items might be biased . Here , we focus on developing debiasing techniques . We defer the detailed discussion of the related work to Section 7 .
There are several research challenges in solving this problem . First , how do we model workers’ behavior when they make judgments in batches ? Second , how do we leverage the model to debias the crowdsourced annotation of data batches ? We make the following contributions in answering these questions :
1 . Proposing an interpretable worker annotation model on batches of data . We propose a novel worker model for binary annotation behavior with data items presented as batches . The model incorporates independent judgments and batch judgments based on ranking .
2 . Debiasing annotation data obtained as batches . Based on our proposed worker model , we provide an algorithm to debias the inferred labels when they are collected from data items in batches .
3 . Conducting experiments on a real world crowdsourcing platform . We conduct experiments on both synthetic and real world crowdsourcing data sets and show that our proposed debiasing strategy , with a small training set , can achieve up to +57 % improvement in terms of F1 score compared to the majority voting strategy , and up to +15 17 % improvement if we tune the majority voting strategy based on a given training set .
The rest of this paper is organized as follows : Section 2 introduces the basic concepts and formalizes the research problem ; Section 3 proposes the worker model for annotating batches of data ; Section 4 presents a strategy to debias batch annotations ; Section 5 describes experimental results ; Section 6 discusses extensions of our proposed method ; Section 7 presents related work and Section 8 concludes .
2 . PRELIMINARIES
In this section , we formally define the concepts and notations we use in this paper ; we then formalize the problem of debiasing crowdsourced batches . 2.1 Basic Concepts and Terminology
First we need to formalize several basic concepts in a crowdsourcing platform . Suppose we are given a set of data items X = {xi} , where i = 1 , . . . , n . Each data item is associated with a label yi ∈ Y , and we thereby define Y = {yi}n i=1 . In following discussion , we focus on a binary classification task , where Y = {0 , 1} , but our framework generalizes to multi class or rating cases seamlessly ( Cf . Section 6 ) . According to a standard formalization in learning theory for binary classification , we suppose each ( xi , yi ) is generated from a joint probability distribution PXY . We define an inherent score ηxi to be the conditional probability P ( yi = 1|xi ) . For simplicity , we denote the inherent score as ηi . In a job or task submitted to a crowdsourcing platform , we can assemble several data items into a batch . Each batch bj is represented by a set of indices of data items in the batch , denoted as {bj1 , . . . , bjk} , where k is the size of a batch . To be strict , data items in the batch should be represented by xj = {xbj1 , . . . , xbjk} . However , for simplicity , we denote data items in the batch specified by bj as {xj1 , . . . , xjk} . Similarly , we define yj = {yj1 , . . . , yjk} to be true labels associated with data items in xj , where yjl is the true label of xjl according to Y , ∀1 ≤ l ≤ k . In CrowdFlower language , a batch corresponds to a single “ unit ” , where a worker has to judge the entire unit at the same time ; in Mechanical Turk language , a batch corresponds to a single “ HIT ” ( short for Human Intelligence Task ) . Usually , data items in the same batch might share the same context , background , or the same instruction , in order to reduce the overhead . For example , if one is asked to judge whether a review about a restaurant is positive or negative , it might save time for workers by grouping reviews of the same restaurant into the same batch , as they only need to read the description of the restaurant once before they can make multiple judgments on different reviews .
As we assemble data items into batches , each worker has to judge the entire batch as a single judgment . Given a batch bj , the judgment provided by a worker can be represented as y j =
Label positive reviews on the movie “ The Imitation Game ” ý Stack of Lies Label positive reviews on the movie “ The Imitation Game ” ý Average In The Extreme Label positive reviews on the movie “ The Imitation Game ” þ Good enough but historically sketchy Label positive reviews on the movie “ The Imitation Game ” þ Great movie , worth a watch Label positive reviews on the movie “ The Imitation Game ” ý Stack of Lies þ Average In The Extreme Label positive reviews on the movie “ The Imitation Game ” ý Good enough but historically sketchy þ Great movie , worth a watch 1594 jk} , where y
{y jl ∈ Y is the annotation of data item corj1 , . . . , y responding to xjl , provided by the worker . Noting that the worker annotation y j can be different from the true label yj . We refer to worker annotation as “ annotation ” , while the ground truth label is referred to as simply the “ label ” .
In CrowdFlower , as a judgment can only be made based on a unit , workers are not allowed to submit partial results on a batch ( as with Mechanical Turk ) . However , one can always add an “ unknown ” option for every data item , so that the workers can provide partial results on a batch . For simplicity , we consider no partial judgments in the rest of the paper .
Now , we are in a position to give a formal definition for a batch of data items :
DEFINITION 1
( BATCH ) . Given a data set ( X , Y ) , a batch of data items with size k extracted from the given data set can be represented as ( bj , xj , yj , y j ) , where bj = ( bj1 , . . . , bjk ) is a set of indices for X and Y ; xj = {xj1 , . . . , xjk} is a set of all the data items , indexed by bj ; yj = {yj1 , . . . , yjk} consists of the jk} corresponding true labels of data items in xj ; y is the worker annotation on the set of the batch . j1 , . . . , y j = {y
Additionally , a set of batches can be defined as : j=1 . j}m
B = {y
DEFINITION 2 . Given a data set ( X , Y ) , a set of batches is denoted as A = j=1 consists of the indices of j=1 is the set of data item batches , with j=1 and worker anno extracted from the given data set B ) , where B = {bj}m ( B , XB , YB , Y each batch ; XB = {xj}m their corresponding true labels YB = {yj}m tations Y Remarks . 1 ) Notice that a data item xi ∈ X may certainly appear in multiple batches in A . That is , xjl and xjl may refer to the same data item as long as bjl = bjl ; 2 ) For the sake of fully utilizing the workforce of crowds , without loss of generality , we focus on the scenario when all batches have the identical size k . However , our model generalizes to the case when batches have different sizes ; 3 ) In some real world crowdsourcing platforms , a batch can actually be judged by multiple workers , which means there could be multiple y j ’s associated to a single ( bj , xj , yj)— for instance , this is referred to as multiple assignments on Mechanical Turk . However , for the purposes of debiasing , it is equivalent to regard a single batch as multiple batches with identical ( bj , xj , yj ) but associated with judgments made by different workers y j . 2.2 Problem Definition
Based on the concepts described thus far , we can formalize the problem of debiasing crowdsourced batches as the following :
PROBLEM 1
( DEBIASING CROWDSOURCED BATCHES ) . Suppose we have a labeled data set ( XL , YL ) with YL known , as well as its extracted batches and their crowdsourced annotation ( BL , XBL , YBL , Y BL ) . If we are then given another unlabeled data set XU , as well as its extracted batches and crowdsourced annotation ( BU , XBU , Y BU ) , the objective is to infer the true labels YU associated with XU from the crowdsourced annotation .
Notice that our problem formulation as described above requires as input labeled and annotated data items for training purposes . In practice , the labeled data for training can be collected from the “ test questions ” with ground truth labels , inserted by the crowdsourcing platform for the purpose of quality control and monitoring of workers . The usage of test questions is standard practice : As an example , in CrowdFlower , all workers have to attempt a certain number
Notation Description
Table 1 : Notation description .
X Y bj xj yj y B XB j
YB Y
B l=1 i=1 l=1 where xjl is extracted
Set of all the data items {xi}n Set of all true labels associated with data items in X A set of data item indices {bjl}k A data item batch {xjl}k from the data item in X with index specified by bjl A label batch consists of true labels {yjl}k ated with data items in xj Worker annotation collected from a crowdsourcing platform for data items in xj Set of all the batches {bj}m i=1 Set of all the data item batches Set of all the true labels associated with data item batches in XB Set of all the worker annotation from crowds on data item batches in XB l=1 associ of test questions with correct labels and need to achieve an accuracy over a certain threshold ( eg 70 % ) before they can proceed to work on the regular task(s ) . Also , additional hidden data items with known labels can be inserted into the regular tasks to monitor their accuracy . In our setting , worker behavior on these test questions or labeled data can additionally be used for training purposes .
Also notice that in this version of our problem formulation , we assume identical worker behavior . This is a more standard setting in crowdsourcing practice as there is usually not enough work done by each worker to ascertain individual behavior . Also , it is straightforward to extend our model when different workers have different behavior when working on tasks .
3 . BATCH ANNOTATION MODEL
In this section , we first describe our model for workers’ annotation behavior on a batch of data items ; then we introduce how to train the model based on a training data set . The basic idea is , workers might be biased when they make annotations by ranking data items in the same batch . Plackett Luce model . Before we delve into our model , we first recap a probability model for generating rankings based on scores associated with items , namely the classical Plackett Luce model [ 15 , 21 ] introduced in the 70s . Without loss of generality , suppose we are given a set of items x1 , . . . , xk . Each item xi is associated with a certain score s(xi ) > 0 . Here the score s(xi ) models the tendency of ranking xi higher in a randomly generated ranking and can be viewed as a measure of the inherent “ goodness ” of the item . A ranking of these items can be represented as a bijection π : {i}k i=1 , that maps the i to the data item at the i th position in the ranking . The corresponding ranking list can be represented as π(1 ) ··· π(k ) . In Plackett Luce model , the probability of generating a ranking π is : i=1 → {xi}k k i=1 s(xi)k r=i s(xr )
( 1 )
P ( π ) =
The equation above can be interpreted as the following process : Initially , we have a pool A of all the data items . Each time one picks an item xi from a pool A of data items with a probability
1595 proportional to its score , namely :
P ( picking xi from A ) = s(xi ) xr∈A s(xr )
This item is then removed from the pool A and placed at the next position in the ranking . Repeat this operation until A becomes empty . The probability of generating a ranking list according to this process is equivalent to the probability described in the PlackettLuce model . Worker model . We now introduce our worker model for annotating batches of data items . Again , without loss of generality , suppose we are given a batch xj where xjl = xl , namely the given data item batch can be denoted as xj = {x1 , . . . , xk} . Also , recall that for each data item xi , we denote P ( yi = 1|xi ) as its inherent score ηi , which is not explicitly known .
When a worker starts to work on a certain batch of data items , they may choose to use one of two strategies :
• Independent judging .
If the worker is making judgments based on the absolute value of ηi for each data item , we suppose the worker judges each data item xi ∈ xj independently by drawing the annotation y i = 1 with probability ηi i = 0 with probability ( 1 − ηi ) . and y
• Relative judging . If the worker is making judgments by comparing data items within the same batch , we suppose the worker chooses to first rank all the data items in the batch based on their inherent scores , then annotates several topranked items as positive , leaving the other items annotated as negative . To be precise , the worker generates a ranking π for k items in the batch according to the Plackett Luce model , with the scoring function defined as s(xi ) = ηi . Then the worker draws an integer 0 ≤ τ ≤ k from a certain distribution , where pτ denotes the probability of drawing the integer τ . For data items ranked as top τ in the ranking , denoted as xi ∈ {π(1 ) , . . . , π(τ )} ( could be empty if τ = 0 ) , the worker annotates them as y i = 1 , while other data items not within the top τ of the ranking π are annotated as y i = 0 .
To combine these two different scenarios , we suppose the worker chooses to make independent judgments with a certain probability 0 < λ < 1 , while with probability ( 1 − λ ) the worker makes relative judgments .
The intuition of this model is to capture two behavior patterns of workers . In the independent judging scenario , workers can remain independent in judging different data items in the same batch , with each data item being judged based on its inherent score ηi . Nevertheless , sometimes workers might judge data items within a batch by comparison . In the relative judging scenario , workers simply judge the relative relationships between data items in the same batch , which is captured by the Plackett Luce model for generating the ranking . In order to determine the labels of data items , they have an expectation of label distribution , which is reflected by the distribution of generating τ , as it characterizes the probability of having τ positives within k data items . For instance , if workers expect there to be few positive items , then the probability of τ being low is high , while if workers expect the batches to be balanced , then the probability of τ being close to k/2 is high comparing to other values of τ . However , this distribution does not necessarily reflect the correct label distribution . When they try to apply their expectation of the label distribution on the batch , bias might occur . We summarize the process of generating annotation for a batch of data items in our proposed model as below :
1 . Toss a coin Z ∼ Bernoulli(λ ) .
If Z = 1 , go to Step 2 ; otherwise go to Step 3 .
2 . For each xi , generate y i ∼ Bernoulli(ηi ) .
Output the results and exit .
3 . Generate a ranking π based on Plackett Luce model for data items xi in the batch . 4 . Draw τ ∼ M ult(pτ ) . 5 . For the top τ items in ranking π , generate y i = 1 ; otherwise generate y i = 0 . Output the results and exit .
Model learning . The parameters that need to be determined in this worker model include : the probability of making independent judgments λ , and the distribution of the number of positive annotation when making relative judgments , represented by p0 , . . . , pk , where 0 ≤ pτ ≤ 1 and pτ = 1 . We assume these parameters are fixed for each new application of our techniques . However , for different applications , these parameters might be different — for instance , these parameters for content moderation may be different from the same parameters for sentiment analysis . Suppose we are given a set of nL items XL with their true labels YL , or more ideally , their inherent scores {ηi}xi∈XL . If the inherent score of a data item ηi is not given , but only the binary label yi is known , we can define ηi = ( yi + )/(1 + 2 ) where is a small constant , which is set to 10−3 in our experiments . Then , we form them into mL batches represented by BL , send them to the crowds , and obtain their annotation from workers , denoted as Y For each batch bj ∈ BL , we denote the set of items annotated jt = 1} , and the set of items jt = 0} . by workers as positive as X 1 annotated as negative as X 0 j = {xjt|y j = {xjt|y
We train the model by maximum likelihood estimation . The like
BL . lihood of the obtained annotation can be written as : jt ( 1 − ηjt)(1−yjt )
ηyjt independent judging
+(1 − λ ) pτj P ( X 1 j X 0 j ) relative judging mL j=1 k t=1
L =
λ where τj = |X 1 P ( X 1 π that rank items in X 1 j X 0
( 2 ) j | is the number of positive annotation in batch bj ; j ) denotes the probability of generating any rankings j higher than any items in X 0 j X 0 j ) =
P ( π )
P ( X 1 j , namely :
π∈R(X1 j ,X0 j ) where R(X1 , X0 ) = {π|π−1(x0 ) > π−1(x1),∀x1 ∈ X1 , x0 ∈ X0} ; and P ( π ) is defined by the Plackett Luce model , as presented j in ( 1 ) . Notice that the calculation of the exact value of P ( X 1 j ) is hard when k is large . In our experiments , k is small enough X 0 to enumerate entire set R(X 1 j ) . If k is large , we can apply Monte Carlo method to estimate the value of P ( X 1 j X 0 j ) . Applying an EM algorithm , where at E step , we can have j , X 0
ˆλk t=1 ηyjt jt ( 1 − ηjt)(1−yjt )
ˆλj = t=1 ηyjt jt ( 1 − ηjt)(1−yjt ) + ( 1 − ˆλ)ˆpτj P ( X 1 mL where ˆZ =mL
And at M step , we update the parameters ˆλ and ˆpτ by ( 1 − ˆλj)1{|X1 mL j=1(1 − ˆλj ) .
1 mL
ˆpτ =
ˆλ =
1 ˆZ
ˆλj , j=1 j=1 j X 0 j ) ( 3 ) j |=τ}
( 4 )
ˆλk
1596 ( 5 )
∂Q(η )
∂ηi
ˆηi =
( 6 ) where
4 . DEBIASING ANNOTATION
In this section , we introduce our method that debiases annotations collected for batches of data given the trained worker model . More precisely , given a set of nU unlabeled data items XU , assembled into mU batches represented by BU , as well as their annotations obtained from the crowds Y BU , how do we infer their true labels YU ? The basic idea is , based on the given worker model , we infer ηi for each xi ∈ XU . Then , we simply apply the Bayes classifier to determine the inferred label , which yields ˆyi = 1 if ηi > 0.5 , or ˆyi = 0 if ηi ≤ 05
We again adopt a maximum likelihood estimation techique . The log likelihood of the obtained annotation is : mU j=1 log L(η ) = log
ˆλ
ηjt1 j xjt1
∈X1
∈X0 xjt0 j X 0 +(1 − ˆλ)ˆpτj P ( X 1 j ) j
( 1 − ηjt0 ) j X 0
Notice that ˆλ and ˆpτj are parameters learned from Section 3 , and j ) is also a function of ηi ’s . Similar to the previous P ( X 1 section , we apply an EM algorithm here by first calculating ˆλj for each batch at the E step according to ( 3 ) but replacing λ and pτ by the value we learned during the training step . Then we have : log L(η ) ≥ mU mU j=1
+
ˆλj
( 1 − ˆλj).log ˆpτj + log P ( X 1 log ηjt1 +
∈X1 xjt0 xjt1 j
∈X0 j j )fi j X 0 log(1 − ηjt0 ) j=1 j X 0 where the second term includes log P ( X 1 j ) , which is hard to optimize . We apply the idea of the EM algorithm again here . j ) . For each π ∈ Rj , we We use notation Rj to represent R(X 1 can calculate its conditional probability given X 1 j , denoted as ˆqπ by : j X 0 j , X 0
ˆqπ = P ( π|X 1 j X 0 j ; ˆη ) =
P ( π ; ˆη ) π∈Rj
P ( π ; ˆη )
( 7 ) which is the E step . According to Jensen ’s inequality we have : log P ( X1 X0 ) = log
P ( π )
π∈Rj
≥
π∈Rj
ˆqπ log P ( π )
( 8 ) where the last inequality yields the objective function we want to optimize . The correctness of EM algorithm guarantees the convergence of optimizing this function .
Furthermore , according to the minorization maximization ( MM ) algorithm used in [ 11 ] , we obtain the lower bound for log P ( π ) , which is defined by the Plackett Luce model , by : log P ( π ) = log ηπ(t ) − log
ηπ(s ) k−1
≥ k−1 t=1 t=1 k k k s=t s=t ηπ(s ) s=t ˆηπ(s ) log ηπ(t ) −
( 9 ) where ˆηi is the estimated parameter of last iteration . to optimize as :
By combining ( 6 ) , ( 8 ) and ( 9 ) , we obtain the objective function mU mU j=1
ˆλj
∈X1 j xjt1 ( 1 − ˆλj ) j=1
ˆqπ
π∈Rj log ηjt1 + k−1 t=1
∈X0 j xjt0 log ηπ(t ) − log(1 − ηjt0 ) k k s=t ηπ(s ) s=t ˆηπ(s )
Q(η ) =
+
( 10 )
Notice that Q(η ) is actually a lower bound of the original loglikelihood function ( 5 ) . Moreover , for two EM step and one MMstep we apply in deriving Q(η ) , it is proven that by improving Q(η ) from this iteration Q(ˆη ) , the improvement of the log likelihood is no less than the improvement we achieve on Q(η ) . Therefore optimizing Q(η ) can also optimize the log likelihood .
Take the derivative , we obtain
1 ηi
=
− mU j=1 j∈M1(i )
( 1 − ˆλj )
ˆλj 1 − ηi
− j∈M0(i )
ˆqπ
π∈Rj
|X1 j | t=1
( 11 ) k
1{π−1(i)≥t} s=t ˆηπ(s ) where M1(i ) and M0(i ) are defined as My(i ) = {j : xi ∈ X y j } for y ∈ {0 , 1} . The updating rule can be obtained by solving ∂Q(η)/∂ηi = 0 , namely
T1 + T2 + T3 −(T1 + T2 + T3)2 − 4T1T3
( 12 )
T1 = |M1(i)| , mU j=1
T3 =
( 1 − ˆλj )
ˆqπ
2T3 j∈M0(i )
|X1 j | t=1
T2 =
π∈Rj
ˆλj k
1{π−1(i)≥t} s=t ˆηπ(s )
By iteratively updating the scores to optimize the likelihood of the annotation on test data , we can obtain the inferred ˆηi of each item . Based on this , we can determine the inferred binary label for each data item by assigning y i = 0 otherwise . Notice that we do not further tune the threshold in this step , as the scores we learned here are expected to be a reasonable estimate of the true ηi ’s . Therefore , if the inherent scores are known , learning theory guarantees us that by using Bayes classifier ( namely to take 0.5 as threshold ) is supposed to achieve the best expected performance in terms of square loss . i = 1 if ˆηi > 0.5 , or y
The entire process of training model and leveraging the model to debias the obtained annotations are summarized in Algorithm 1 .
5 . EXPERIMENTAL RESULTS
In this section , we conduct experiments on a synthetic data set and a real data set to verify the effectiveness of our proposed worker model and debiasing technique . 5.1 Experimental Data Sets
We first introduce the data sets we used in this experiments . A summary is provided in Table 2 . Synthetic data set . We construct synthetic data sets following the worker annotation model we propose in Section 3 . Suppose we have n items in X , we first generate their inherent scores ηi for each
1597 Input : Data batches BU = {bj} , crowdsourced annotation j} ; training data batches BL , crowdsourced
= {y Y BU annotation Y BL
, true labels YBL .
Output : Inferred labels YU . // Training work model ; Initialize ˆλ and ˆpτ by random values ; repeat
Update ˆλj bfor ∀1 ≤ j ≤ mL by ( 3 ) ; Update ˆλ and ˆpτ by ( 4 )
1 2 3 4 5 until L converged ; // Calculate debiased labels ; repeat Update ˆλj bfor ∀1 ≤ j ≤ mU by ( 3 ) ; Update ˆηi for ∀1 ≤ i ≤ nU by ( 12 ) ;
6 7 8 9 10 11 Algorithm 1 : Debiasing crowdsourced annotation on batches of data items . until Q(η ) converged ; yi ← 1{ˆηi>0.5} for ∀1 ≤ i ≤ nU ; Output YU . xi ∈ X from a Beta distribution Beta(α , β ) , then generate the true labels Y by drawing yi from a Bernoulli distribution parameterized by ηi for each i . In our synthetic data set , we set α = 2 and β = 4 to simulate the case when negative data items overwhelm positive data items .
Then , we generate m batches of size k by sampling without replacement for each batch . Notice that by the phrase “ without replacement ” we mean there are no identical data items within the same batch , while the same item can still appear in multiple batches as we do replace the items back into the pool after a batch is generated . Thereby we obtain the set of batches B . For each bj in B , we generate the workers’ annotation y j from our proposed batch annotation model . The probability of making independent judgments λ is set as 05 The distribution of determining number of positive annotations pτ is also assigned to be : pτ ∝ ( τ + 1 )
−ρ where ρ is positive constant , set as 2 in our experiments . Comments data set . We utilize a real world crowdsourcing data set for annotating comments , which is used in [ 36 ] . The original crowdsourcing task was to identify inappropriate comments on LinkedIn posts published by companies or LinkedIn influencers . Inappropriate comments are defined as comments containing promotional , profane , blatant soliciting , random greeting comments , as well as comments with only web links and contact information . In order to collect annotation of comments , for each post , k comments are sampled and sent to CrowdFlower as a batch ( unit ) . Workers are also provided with a codebook ( ie , a sequence of instructions ) explaining how to annotate the data items . Each comment is regarded as a data item and can be annotated as positive ( inappropriate comment ) or negative ( acceptable comment ) . Each batch is annotated by 5 or more workers .
In order to provide test questions and track the performance of each worker , some of the batches are annotated by 9 trained LinkedIn employees ( experts ) with the same codebook and interface as used for crowd workers . The average Cohen ’s kappa for all expert pairs is 07881 For this experiments , we only adopt the batches with all of their data items annotated by both crowds and experts as we can use the experts’ annotation as ground truth ( aggregated by majority voting ) . Out of these batches , the 1,099 batches that are annotated before a worker actually starts on the job
Data set Synthetic Comments
Table 2 : Data set statistics . k 5 5 nL 1,000 110
10,000 1,099 nU 5,000 651 mL mU 50,000 5,267 are utilized as training data set BL . while the other 5,267 batches are utilized as the test data set BU to infer the 651 data items the 5,267 batches covered . 5.2 Experimental Setup Methods evaluated . We compare the performance of our proposed method with several baselines :
• Majority Voting ( MV ) . For each data item in the test data set , simply determine its inferred label by its annotation given by the majority of workers . This aggregation strategy is often used in practice ( eg [ 28] ) .
• Majority Voting with Tuned Threshold ( MVT ) . Instead of simply applying majority voting , we calculate the ratio of positive annotation on each item as a score , and tune the threshold for determining the binary inferred label . Based on a given training set of annotation and true labels , we find the threshold yielding the best F1 score on training data set , and apply the same threshold on the test data set .
• Plackett Luce Model ( PL ) . A strategy is to fit the PlackettLuce model on the test data by inferring the scores s(xi ) associated with each data items . We regularize the inferred scores to be 0 ≤ s(xi ) ≤ 1 . We then infer a positive label to each data item with an inferred score s(xi ) > 0.5 and a negative label otherwise .
* Batch Annotation Model ( BAM ) . The debiasing strategy pro posed in Section 3 and 4 .
Evaluation methodology . For baselines without training , we directly apply them on the test data set ; for our proposed method as well as MVT , we first train the worker model on the training data set , then apply the debiasing strategy based on the trained worker model on the test data set . We compare the inferred labels to the ground truth and evaluate the performance in terms of accuracy , precision , recall and F1 score . Trials and setup . For our proposed model , in training phase , we randomly initialize λ and pτ ; in debiasing phase , we initialize the all the inferred scores as 01 For training the worker model , we set a fixed number of iteration as 100 . Our experimental results presented later show the model converges within a number of iterations much fewer than 100 . For debiasing , we calculate the log likelihood of the model and stop when the relative change of log likelihood is within 10−5 . 5.3 Experimental Results
Now we present the experimental results . We first verify the learning algorithm of our model on the synthetic data set , then present the learned model parameters on a real data set ; we also evaluate the effectiveness of our debiasing strategy on both synthetic data set and real data set , which demonstrates an improvement in terms of F1 score ; finally we conduct a study on different configurations of experiments as a guideline for setting up a batched crowdsourcing task .
1598 ( a ) Parameter comparison of pτ ’s
( b ) Convergence analysis
( a ) Parameter analysis of pτ ’s
( b ) Convergence analysis
Figure 2 : Learning worker model from the synthetic training data set .
Figure 4 : Learning worker model from the comments training data set .
Table 3 : Performance comparison of Majority Voting ( MV ) , Plackett Luce Model ( PL ) and Batch Annotation Model ( BAM ) . All results are shown as percents .
Data set
Method
( a ) Estimation error of λ
( b ) Estimation error of pτ
Figure 3 : Analysis of estimation error of parameters in the worker model under different configurations .
Comments
Synthetic
MV MVT PL BAM MV MVT PL BAM
Acc . 83.04 88.06 82.74 89.88 95.55 96.16 94.62 96.77
Prc . 98.91 64.69 52.25 70.93 93.75 92.31 85.45 93.40
Rcl . 00.10 80.06 92.75 78.04 79.65 84.96 83.19 87.61
F1 17.67 71.56 66.85 74.31 86.12 88.48 84.30 90.41
Worker model learning . We first verify the effectiveness of learning our proposed worker model . On our synthetic data set , the “ true ” value of probability of making independent judgments λ is set to 05 We learn the model from the synthetic training data and obtain the inferred ˆλ as 0.4998 , which reasonably recovers the original value . We also compare the original model parameters pτ ’s to the inferred parameters in Figure 2(a ) . The black dashed line represents the original parameters used for generating synthetic annotation data , while the red solid line shows the inferred parameters of worker model , which seems as a precise fit of the original parameter . We also show the curve of log likelihood of the training data set , which seems to converge within 20 iterations .
To further confirm the robustness of our learning method , we modify the configuration of synthetic data generation , and train the worker model on different data sets to check if they can recover the original parameters . We still take the same configuration of nL = 1 , 000 and mL = 10 , 000 . The estimation error analysis is shown in Figure 3 . Figure 3(a ) shows the difference between the inferred parameter ˆλ and the “ true ” parameter λ , given the annotation data generated by λ varying from 0.1 to 09 It can be observed that the error is reasonable small , basically within 01 Figure 3(b ) shows the 2 norm of the difference between the estimated distribution ˆpτ and the “ true ” distribution pτ , when pτ is generated with respect to different ρ varying from 1 to 3 . In most of the settings , the error is below 2 × 10−3 , which is fairly low . Although we only instantiate pτ ’s using a power law distribution , as the learning method does not confine the learned distribution to be parametric , it can be directly applied to any other type of distributions . Learned model on real data set . Given the effectiveness of our learning method verified , we apply the worker model trying to fit the data set of annotating inappropriate comments . The learned probability of a worker making independent judgments ˆλ on comments data set is 07877 The learned distribution for determining the number of positive annotations in a batch is presented in Figure 4(a ) . It shows that a worker tends to annotate the entire batch as negative ( ie acceptable comment ) with a probability over
0.6 , while picking only 1 of them as positive ( ie inappropriate comment ) also occurs with a relative high probability around 025 The workers tend to annotate no more than 1 comments in a size 5 batch . This is coherent with most people ’s intuition that inappropriate comments are rare comparing to the entire set of comments . The convergence analysis is shown in Figure 4(b ) . The model converges within 50 iterations . Performance comparison . We proceed to evaluate the performance of different aggregation strategies on both data sets . The overall performance results are shown in Table 3 . In both data sets , our proposed debiasing strategy is a clear winner in terms of F1score , and also achieves the best accuracies .
In synthetic data set , majority voting , without tuning the threshold ( default set to 0.5 ) , fails to identify most of the positive data items , and therefore achieves an extremely low recall . Only after the threshold is tuned on a training data set can it achieve a reasonable F1 score of 71 % . PL model , in contrast , achieves a relatively low precision of 52 % . Our proposed method is able to achieve the best overall performance in terms of F1 score and accuracy . Notice that we do not directly apply any threshold tuning for our method and simply takes the threshold as 05
In comments data set , the naïve majority voting strategy again obtains a poor recall below 80 % . After tuning the threshold , its recall rises to around 85 % , but still lower than our proposed method . The scores learned by PL model yield a comparable recall to majority voting with tuned threshold , but fail to achieve a high precision . Our proposed method achieves a comparable precision of 93 % and a higher recall of 87 % , and therefore beat all the other baselines in terms of F1 score ( 90% ) . Batch number m vs . An interesting question to study is , for a certain number of items , how many ( random ) batches of data items does one need to label to obtain an aggregated result accurate enough . We study this question by generating synthetic data sets with different settings of number of batches mL and mU while number of data items nL and nU are fixed . In this item number n .
012345τ0001020304050607pτGenerativeparametersLearnedparameters020406080100Iterationnumber−2410−2408−2406−2404−2402−2400−2398−2396−2394−2392Log likelihood(103)000204060810λ−04−02000204ˆλ−λ1015202530ρ000000020004000600080010kˆpτ−pτk2012345τ0001020304050607pτLearnedparameters020406080100Iterationnumber−600−595−590−585−580−575−570−565Log likelihood1599 ( a ) Accuracy with different m/n ratio
( b ) F1 score with m/n ratio different
( a ) Accuracy with different sizes of training data set
( b ) F1 score with different sizes of training data set
Figure 5 : Performance of debiasing strategies on synthetic data sets generated by setting both mL/nL and mU /nU as 2 , 5 , 10 , 20 respectively .
( a ) Accuracy with different sizes of training data set
( b ) F1 score with different sizes of training data set
Figure 6 : Performance of debiasing strategies on synthetic data sets generated by different size of training data set nL ( mL = 10nL ) , while the size of testing data set remains nU = 5 , 000 and mU = 50 , 000 . experiments , we set nL = 1 , 000 and nU = 5 , 000 , and generate synthetic data sets with mL/nL = mU /nU = 2 , 5 , 10 , and 20 . We then apply all the strategies on these data sets . To minimize randomness , for each setting we repeat the data generation and debiasing for 10 times , then report the average performance .
Results are shown in Figure 5 . As we can observe , under all the different settings , the proposed method consistently outperforms other baselines , in terms of both accuracy and F1 score . Majority voting with tuned threshold ( MVT ) is able to achieve comparable results to our proposed method when m/n are large enough ( eg m/n = 20 ) . However , when m/n is relatively small , our proposed method can achieve much better results than most of other baselines . When m/n = 2 , it achieves an accuracy approximately 9 % higher than MVT , and an F1 score around 5 % more than MVT . An exception is the naïve majority voting strategy that achieves the best accuracy when m/n = 2 . This is due to the skewed distribution of data labels , and by simply labeling all the data items as negative can get an accuracy of approximately 80 % . In comparison , the F1 score of MV is only around 30 % .
Another observation that we can make about Figure 5(b ) is that the performance of majority voting drops as m/n increases . This result indicates when workers are biased and no debiasing techniques are applied , increasing the quantity of annotations collected does not help . Size of training data set . As our method requires a small set of training data , there might be some concerns about how large a training data set is sufficient . We test the performance of two methods that rely on training data sets — MVT and our proposed method — on synthetic data sets and the comments data set . For the synthetic data set , we keep the size of test data set as nU = 5 , 000 and mU = 50 , 000 , and vary the size of training data set by setting nL as 10 , 20 , 50 , 100 , 200 , 500 , and 1 , 000 , while setting mL as
Figure 7 : Performance of debiasing strategies on comments data set where the training data set is randomly sampled from the original training set with different size of mL , while the testing data set remains the same . 10nL . For each configuration , we generate synthetic data sets 10 times and utilize the average performance on these 10 data sets to evaluate the debiasing performance . For the comments data set , we randomly sample mL batches from the training data set , where mL is set to 100 , 200 , . . . , 1000 . Again , for each configuration of training data size , we repeat the random sampling for 10 times and report the average performance .
The results of synthetic data set are shown in Figure 6 . As observed , when training data set is small ( eg nL = 10 ) , the performance of MVT drops in terms of both accuracy and F1 score ( 73 % and 56 % respectively ) . As the size of training data set increases , the performance of MVT becomes comparable to our proposed method . In comparison , the performance of our proposed method is relatively stable even when there are only 10 items and 100 batches as training data . The results imply our proposed method can obtain very high performance with a small cost of labeling ground truth data for collecting training data .
The results for the comments data set are shown in Figure 7 . Again , when training data size is extremely small ( eg mL = 100 ) , the performance of MVT drops substantially ( 89 % in accuracy and 75 % in F1 score ) , while its performance gets more and more comparable to our method as the training data size increases . In contrast , our proposed method maintains a fairly stable performance ( 96 % in accuracy and 90 % in F1 score ) for different sizes of the training data set . This verifies again the ability of our proposed method to yield high quality results with a sufficiently small training data set .
6 . EXTENSIONS
In this section , we discuss several straightforward extensions of our proposed worker model and debiasing strategies , with respect to some useful applications other than binary classification : rating estimation and multi class classification . We also discuss how to extend our model to the more general case when different workers have different biases . Rating estimation . In rating estimation , each data item xi is no longer associated with a discrete label from a finite set of labels , but instead , a real value yi ∈ R . Although we do not explicitly formalize our problem for a rating task , with some straightforward modifications , our techniques can still be applied if the workers are asked to rate data items in batches . Without loss of generality , we can assume 0 < yi < ∞ . If the actual rating can be negative , we can always apply a certain sigmoid function to normalize the scores to be positive values . For independent judging , we can design a distribution wrt yi from where a worker draws a rating y i for xi , eg a Gaussian distribution N ( yi , 1 ) . For relative judging , we can still assume that the
05101520m/n065070075080085090095AccuracyMVMVTPLBAM05101520m/n010203040506070809F1 scoreMVMVTPLBAM101102103nL070075080085090095AccuracyMVTBAM101102103nL055060065070075080F1 scoreMVTBAM1002003004005006007008009001000mL086088090092094096098AccuracyMVTBAM1002003004005006007008009001000mL074076078080082084086088090092F1 scoreMVTBAM1600 worker generates a ranking from Plackett Luce model with parameters yi ’s , and introduce another distributions wrt the ranking of each data item π−1(xi ) from where a worker generates the ratings . i ∼ N ( π−1(xi ) , 1 ) . Once the design of model For example , y is accomplished , it is straightforward to apply the same technique described in this paper to derive the debiasing strategy . Multi class classification . In a multi class classification problem , the label set Y may contain more than 2 possible labels . Workers are usually requested to assign data items with different labels . This is a natural extension from binary classification problem . If the labels in Y are ordinal , for example , judging whether a review is “ very helpful ” , “ helpful ” or “ not helpful ” , the problem reduces to a rating estimation problem , where the possible values of rating are discrete values . We can simply apply the extended strategy described above . If the labels in Y do not have an order , the problem can be reduced to several binary classification problems , which is straightforward to apply our strategy for debiasing workers’ annotations . Personalized worker model . To address different behaviors of different workers , we may want to employ different worker model separately for different workers , instead of using an identical model for all the workers . This can be achieved by rewriting ( 5 ) as
W mw w=1 j=1 log L(η ) = log
ˆλw
∈X1
ηjt1 wj xjt1 xjt0 +(1 − ˆλw)ˆpwτj P ( X 1 wj X 0 wj )
∈X0 wj
( 1 − ηjt0 ) where each w corresponds a worker and each worker annotates mw batches .
7 . RELATED WORK
In this section , we first introduce existing studies on annotation bias of crowds , when data items are presented either independently , or in a sequence or batches ; we then introduce rank aggregation techniques and their application on crowdsourced ranking or rating . Annotation bias in independent judgments . A number of studies have been conducted on verifying and quantifying annotation bias of crowd workers . Snow et al . [ 29 ] explore the performance of annotations by non expert workers for several NLP tasks . Demeester et al . [ 8 ] discuss the disagreement between different users on assessment of web search results .
There are also extensive studies on modeling worker behaviors . Raykar et al . [ 23 , 24 , 25 ] study how to learn a model with noisy labeling . Specifically , they employ a logistic regression classifier , and insert hidden variables indicating whether a worker tells the truth . Karger et al . [ 12 ] propose an iterative algorithm to infer workers’ reliability and aggregating their answers . Whitehill et al . [ 35 ] model the annotator ability , data item difficulty , and infer the true label from the crowds in a unified model . Most of these studies also propose various generative model to capture worker behavior . However , they assume judgments on different data items are independent , which is not necessarily true when data items are grouped into batches .
Venanzi et al . [ 33 ] propose a community based label aggregation model to identify different types of workers , and correct their labels correspondingly . Das et al . [ 7 ] address the interactions of opinions between people connected by networks . They focus on another aspect of dependencies , which is the dependencies between workers , while in our studies , we are more concerned about dependencies between data items and their judgments .
Annotation bias in sequential and batch judgments . A few researchers also notice the correlation between judgments on different data items , but their work are mainly developed in the setting when data items are reviewed in a sequence . Scholer et al . [ 26 , 27 ] study the annotation disagreements in a relevance assessment data set . They discover correlations between annotations of similar data items . They also explore “ threshold priming ” in annotation , where the annotators tend to make similar judgments or apply similar standard on consecutive data items they review . However , their work focuses on the scenario when data items are organized in a long sequence . It confines the dependencies to exist only between consecutive data items . Also , they focus more on qualitative conclusions , without a quantitative model to characterize and measure the discovered factors . Carterette et al . [ 4 ] provide several assessor models for the TREC data set . Mozer et al . [ 18 ] study the similar “ relativity of judgments ” phenomenon on sequential tasks instead of batches . Again , their focus is more on data items presented as a long sequence , while we focus more on data items presented in batches simultaneously .
Our recent work [ 36 ] also considers a similar setting when data items are organized in batches ; we verify the existence of annotation bias caused by batching data items . Our focus in that paper was to design an active learning algorithm to smartly assemble batches , aiming to improve the performance of the classifier trained on their annotations . Our focus was not on improving the quality of labels collected , and we still used majority voting to obtain labels for data items . In this paper , we focus on debiasing the obtained annotations , which can trigger a broader range of application including both training and evaluating classifiers . Crowdsourced ranking and rating . In our model , we employ the Plackett Luce model to capture worker behavior , and aggregate worker annotations on batches as rankings in order to infer true labels . There is a related thread of work on rank aggregation ; however , to the best of our knowledge , we are the first to model crowds’ annotating behavior on batches by ranking , and propose a debiasing strategy .
Studies on aggregating multiple rankings into a consistent ranking can be dated back to the seminal work of Arrow [ 2 ] . Negahban et al . [ 19 ] study how to aggregate pairwise comparisons into a ranking by utilizing the Bradley Terry model [ 3 ] , which is a simplified version of Plackett Luce model utilized in this paper . Hunter et al . [ 11 ] propose the minorization maximization ( MM ) algorithm to infer Plackett Luce model from multiple partial orderings . Soufiani et al . [ 30 ] generalize Negahban et al . ’s work and propose a class of generalized method of moments ( GMM ) algorithm to infer parameters of Plackett Luce model from multiple orderings , and compare the performance against MM algorithm . They then further extend their algorithm to be applied to a more general class of ranking models called random utility models ( RUMs ) [ 31 ] . In addition , the technique for rank aggregation has also been studied in context of information retrieval [ 9 , 13 , 14 , 22 , 34 ] . These studies do not explicitly address the crowdsourcing settings to actually model the worker behavior . Directly applying their techniques ( eg [ 11 ] ) may not lead to better performance , as shown in our experiments .
There is related research on aggregating multiple rankings or leveraging crowds’ power to obtain ranking of data items . Chen et al . [ 6 ] study aggregating crowdsourced annotation on pairwise comparison to obtain a ranking on data items . Mao et al . [ 16 ] show how aggregated results of noisy voting obtained from crowdsourcing platform may differ by using different aggregating strategies . However , their objective is just to obtain a ranking , while our model incorporates a ranking model but the ultimate goal is still to collect labels for data items .
1601 papers also
Several consider crowdsourced rating . Parameswaran et al . [ 20 ] focused on crowdsourced rating on items , and applied their system on a peer evaluation data set of a MOOC course . Crowdsourcing has also been utilized for rating multimedia content quality [ 5 ] and relevance assessment [ 1 ] . However , they do not explicitly study the scenario when data items are grouped into batches .
8 . CONCLUSION
In this work we study a specific type of annotation bias in crowdsourcing , which occurs when data items are grouped into batches and submitted to workers to be judged simultaneously . We propose a novel worker model designed to capture this type of bias , and show how to train the worker model on annotation data . We also present how to debias the label obtained from crowds given a trained worker model . We conduct experiments on both synthetic data and real world data , and observe that our proposed debiasing technique , with a fairly small training data set , can achieve up to +57 % F1 score improvement in the synthetic data set compared to the naïve majority voting strategy , and +17 % improvement over a tuned majority voting strategy . On a real data set , our technique can also achieve up to +15 % improvement on F1 score over the tuned majority voting strategy .
The observation of batch annotation bias might exist in many scenarios other than crowdsourcing , and therefore the debiasing strategy can trigger a broad range of applications . For example , the conference paper review system where each reviewer is assigned a batch of papers can also be regarded as a batch annotation .
There are several interesting directions to extend this work . For example , one can extend the model to further incorporate workers’ different demographical attributes and adjust the debiasing strategy accordingly . Also , it would be interesting to see if it is possible to improve the efficiency of debiasing by actively assemble a batch of data items to collect the desired labels , instead of sending randomly formed batches to the crowds . Acknowledgments . Research was sponsored in part by the US Army Research Lab . under Cooperative Agreement No . W911NF 09 2 0053 ( NSCTA ) , National Science Foundation IIS 1017362 , IIS 1320617 , IIS 1354329 , and IIS 1513407 , HDTRA1 101 0120 , and grant 1U54GM114838 awarded by NIGMS through funds provided by the trans NIH Big Data to Knowledge ( BD2K ) initiative ( wwwbd2knihgov ) , the Faculty Research Award provided by Google , and MIAS , a DHS IDS Center for Multimodal Information Access and Synthesis at UIUC .
9 . REFERENCES [ 1 ] O . Alonso , D . E . Rose , and B . Stewart . Crowdsourcing for relevance evaluation . In SIGIR Forum , volume 42 , pages 9–15 . ACM , 2008 . [ 2 ] K . J . Arrow . Social choice and individual values . Yale university press , 1963 .
[ 3 ] R . A . Bradley and M . E . Terry . Rank analysis of incomplete block designs : I . the method of paired comparisons . Biometrika , pages 324–345 , 1952 .
[ 4 ] B . Carterette and I . Soboroff . The effect of assessor error on ir system evaluation . In SIGIR , pages 539–546 . ACM , 2010 .
[ 5 ] K T Chen , C C Wu , Y C Chang , and C L Lei . A crowdsourceable qoe evaluation framework for multimedia content . In Multimedia , pages 491–500 . ACM , 2009 .
[ 6 ] X . Chen , P . N . Bennett , K . Collins Thompson , and E . Horvitz .
Pairwise ranking aggregation in a crowdsourced setting . In WSDM , pages 193–202 . ACM , 2013 .
[ 7 ] A . Das , S . Gollapudi , R . Panigrahy , and M . Salek . Debiasing social wisdom . In KDD , pages 500–508 . ACM , 2013 .
[ 8 ] T . Demeester , R . Aly , D . Hiemstra , D . Nguyen , D . Trieschnigg , and
C . Develder . Exploiting user disagreement for web search evaluation : an experimental approach . In WSDM , pages 33–42 . ACM , 2014 .
[ 9 ] C . Dwork , R . Kumar , M . Naor , and D . Sivakumar . Rank aggregation methods for the web . In WWW , pages 613–622 . ACM , 2001 .
[ 10 ] R . G . Gomes , P . Welinder , A . Krause , and P . Perona .
Crowdclustering . In NIPS , pages 558–566 , 2011 .
[ 11 ] D . R . Hunter . Mm algorithms for generalized bradley terry models .
Annals of Statistics , pages 384–406 , 2004 .
[ 12 ] D . R . Karger , S . Oh , and D . Shah . Iterative learning for reliable crowdsourcing systems . In NIPS , pages 1953–1961 , 2011 . [ 13 ] A . Klementiev , D . Roth , and K . Small . Unsupervised rank aggregation with distance based models . In ICML , pages 472–479 . ACM , 2008 .
[ 14 ] Y T Liu , T Y Liu , T . Qin , Z M Ma , and H . Li . Supervised rank aggregation . In WWW , pages 481–490 . ACM , 2007 .
[ 15 ] R . D . Luce . Individual choice behavior : A theoretical analysis .
Wiley , 1959 .
[ 16 ] A . Mao , A . D . Procaccia , and Y . Chen . Better human computation through principled voting . In AAAI , 2013 .
[ 17 ] A . Marcus , E . Wu , D . Karger , S . Madden , and R . Miller .
Human powered sorts and joins . Proceedings of the VLDB Endowment , 5(1):13–24 , 2011 .
[ 18 ] M . C . Mozer , H . Pashler , M . Wilder , R . V . Lindsey , M . C . Jones , and
M . N . Jones . Decontaminating human judgments by removing sequential dependencies . NIPS , 23 , 2010 .
[ 19 ] S . Negahban , S . Oh , and D . Shah . Iterative ranking from pair wise comparisons . In NIPS , pages 2474–2482 , 2012 .
[ 20 ] A . Parameswaran , S . Boyd , H . Garcia Molina , A . Gupta ,
N . Polyzotis , and J . Widom . Optimal crowd powered rating and filtering algorithms . VLDB , 2014 .
[ 21 ] R . L . Plackett . The analysis of permutations . Applied Statistics , pages
193–202 , 1975 .
[ 22 ] T . Qin , X . Geng , and T Y Liu . A new probabilistic model for rank aggregation . In NIPS , pages 1948–1956 , 2010 .
[ 23 ] V . C . Raykar and S . Yu . Ranking annotators for crowdsourced labeling tasks . In NIPS , pages 1809–1817 , 2011 .
[ 24 ] V . C . Raykar , S . Yu , L . H . Zhao , A . Jerebko , C . Florin , G . H .
Valadez , L . Bogoni , and L . Moy . Supervised learning from multiple experts : whom to trust when everyone lies a bit . In ICML , pages 889–896 . ACM , 2009 .
[ 25 ] V . C . Raykar , S . Yu , L . H . Zhao , G . H . Valadez , C . Florin , L . Bogoni , and L . Moy . Learning from crowds . JMLR , 11:1297–1322 , 2010 .
[ 26 ] F . Scholer , D . Kelly , W C Wu , H . S . Lee , and W . Webber . The effect of threshold priming and need for cognition on relevance calibration and assessment . In SIGIR , pages 623–632 . ACM , 2013 .
[ 27 ] F . Scholer , A . Turpin , and M . Sanderson . Quantifying test collection quality based on the consistency of relevance judgements . In SIGIR , pages 1063–1072 . ACM , 2011 .
[ 28 ] V . S . Sheng , F . Provost , and P . G . Ipeirotis . Get another label ? improving data quality and data mining using multiple , noisy labelers . In KDD , pages 614–622 . ACM , 2008 .
[ 29 ] R . Snow , B . O’Connor , D . Jurafsky , and A . Y . Ng . Cheap and fast—but is it good ? : evaluating non expert annotations for natural language tasks . In EMNLP , pages 254–263 , 2008 .
[ 30 ] H . A . Soufiani , W . Chen , D . C . Parkes , and L . Xia . Generalized method of moments for rank aggregation . In NIPS , pages 2706–2714 , 2013 .
[ 31 ] H . A . Soufiani , D . Parkes , and L . Xia . Computing parametric ranking models via rank breaking . In ICML , pages 360–368 , 2014 .
[ 32 ] H . Su , J . Deng , and L . Fei Fei . Crowdsourcing annotations for visual object detection . In Human Computation Workshops at AAAI , 2012 .
[ 33 ] M . Venanzi , J . Guiver , G . Kazai , P . Kohli , and M . Shokouhi .
Community based bayesian aggregation models for crowdsourcing . In WWW , pages 155–164 , 2014 .
[ 34 ] M . N . Volkovs and R . S . Zemel . A flexible generative model for preference aggregation . In WWW , pages 479–488 . ACM , 2012 .
[ 35 ] J . Whitehill , T f Wu , J . Bergsma , J . R . Movellan , and P . L . Ruvolo . Whose vote should count more : Optimal integration of labels from labelers of unknown expertise . In NIPS , pages 2035–2043 , 2009 . [ 36 ] H . Zhuang and J . Young . Leveraging in batch annotation bias for crowdsourced active learning . In WSDM , pages 243–252 . ACM , 2015 .
1602
