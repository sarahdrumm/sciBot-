Mining High Speed Data Streams
Pedro Domingos
Geoff Hulten
Dept . of Computer Science & Engineering
Dept . of Computer Science & Engineering
University of Washington
Box 352350
Seattle , WA 98195 2350 , USA pedrod@cswashingtonedu
University of Washington
Box 352350
Seattle , WA 98195 2350 , USA ghulten@cswashingtonedu
ABSTRACT Many organizations today have more than very large databases ; they have databases that grow without limit at a rate of several million records per day . Mining these continuous data streams brings unique opportunities , but also new challenges . This paper describes and evaluates VFDT , an anytime system that builds decision trees using constant memory and constant time per example . VFDT can incorporate tens of thousands of examples per second using off the shelf hardware . It uses Hoeffding bounds to guarantee that its output is asymptotically nearly identical to that of a conventional learner . We study VFDT ’s properties and demonstrate its utility through an extensive set of experiments on synthetic data . We apply VFDT to mining the continuous stream of Web access data from the whole University of Washington main campus .
Categories and Subject Descriptors H28 [ Database Management ] : Database Applications| data mining ; I26 [ Artificial Intelligence ] : Learning| concept learning ; I52 [ Pattern Recognition ] : Design Methodology|classifier design and evaluation
General Terms Decision trees , Hoeffding bounds , incremental learning , diskbased algorithms , subsampling
INTRODUCTION
1 . Knowledge discovery systems are constrained by three main limited resources : time , memory and sample size . In traditional applications of machine learning and statistics , sample size tends to be the dominant limitation : the computational resources for a massive search are available , but carrying out such a search over the small samples available ( typically less than 10,000 examples ) often leads to overfitting or \data dredging" ( eg , [ 22 , 16] ) . Thus overfitting avoidance becomes the main concern , and only a fraction of the available computational power is used [ 3 ] . In contrast , in many ( if not most ) present day data mining applications , the bottleneck is time and memory , not examples . The latter are typically in over supply , in the sense that it is impossible with current KDD systems to make use of all of them within the available computational resources . As a result , most of the available examples go unused , and underfitting may result : enough data to model very complex phenomena is available , but inappropriately simple models are produced because we are unable to take full advantage of the data . Thus the development of highly efficient algorithms becomes a priority .
Currently , the most efficient algorithms available ( eg , [ 17 ] ) concentrate on making it possible to mine databases that do not fit in main memory by only requiring sequential scans of the disk . But even these algorithms have only been tested on up to a few million examples . In many applications this is less than a day ’s worth of data . For example , every day retail chains record millions of transactions , telecommunications companies connect millions of calls , large banks process millions of ATM and credit card operations , and popular Web sites log millions of hits . As the expansion of the Internet continues and ubiquitous computing becomes a reality , we can expect that such data volumes will become the rule rather than the exception . Current data mining systems are not equipped to cope with them . When new examples arrive at a higher rate than they can be mined , the quantity of unused data grows without bounds as time progresses . Even simply preserving the examples for future use can be a problem when they need to be sent to tertiary storage , are easily lost or corrupted , or become unusable when the relevant contextual information is no longer available . When the source of examples is an open ended data stream , the notion of mining a database of fixed size itself becomes questionable .
Ideally , we would like to have KDD systems that operate continuously and indefinitely , incorporating examples as they arrive , and never losing potentially valuable information . Such desiderata are fulfilled by incremental learning methods ( also known as online , successive or sequential methods ) , on which a substantial literature exists . However , the available algorithms of this type ( eg , [ 20 ] ) have significant shortcomings from the KDD point of view . Some are reasonably efficient , but do not guarantee that the model learned will be similar to the one obtained by learning on the same data in batch mode . They are highly sensitive to example ordering , potentially never recovering from an unfavorable set of early examples . Others produce the same model as the batch version , but at a high cost in efficiency , often to the point of being slower than the batch algorithm .
This paper proposes Hoeffding trees , a decision tree learning method that overcomes this trade off . Hoeffding trees can be learned in constant time per example ( more precisely , in time that is worst case proportional to the number of attributes ) , while being nearly identical to the trees a conventional batch learner would produce , given enough examples . The probability that the Hoeffding and conventional tree learners will choose different tests at any given node decreases exponentially with the number of examples . We also describe and evaluate VFDT , a decision tree learning system based on Hoeffding trees . VFDT is I/O bound in the sense that it mines examples in less time than it takes to input them from disk . It does not store any examples ( or parts thereof ) in main memory , requiring only space proportional to the size of the tree and associated sufficient statistics . It can learn by seeing each example only once , and therefore does not require examples from an online stream to ever be stored . It is an anytime algorithm in the sense that a ready to use model is available at any time after the first few examples are seen , and its quality increases smoothly with time .
The next section introduces Hoeffding trees and studies their properties . We then describe the VFDT system and its empirical evaluation . The paper concludes with a discussion of related and future work .
2 . HOEFFDING TREES The classification problem is generally defined as follows . A set of N training examples of the form ( x ; y ) is given , where y is a discrete class label and x is a vector of d attributes , each of which may be symbolic or numeric . The goal is to produce from these examples a model y = f ( x ) that will predict the classes y of future examples x with high accuracy . For example , x could be a description of a client ’s recent purchases , and y the decision to send that customer a catalog or not ; or x could be a record of a cellular telephone call , and y the decision whether it is fraudulent or not . One of the most effective and widely used classification methods is decision tree learning [ 1 , 15 ] . Learners of this type induce models in the form of decision trees , where each node contains a test on an attribute , each branch from a node corresponds to a possible outcome of the test , and each leaf contains a class prediction . The label y = DT ( x ) for an example x is obtained by passing the example down from the root to a leaf , testing the appropriate attribute at each node and following the branch corresponding to the attribute ’s value in the example . A decision tree is learned by recursively replacing leaves by test nodes , starting at the root . The attribute to test at a node is chosen by comparing all the available attributes and choosing the best one according to some heuristic measure . Classic decision tree learners like ID3 , C4.5 and CART assume that all training examples can be stored simultaneously in main memory , and are thus severely limited in the number of examples they can learn from . Disk based decision tree learners like SLIQ [ 10 ] and SPRINT [ 17 ] assume the examples are stored on disk , and learn by repeatedly reading them in sequentially ( effectively once per level in the tree ) . While this greatly increases the size of usable training sets , it can become prohibitively ex pensive when learning complex trees ( ie , trees with many levels ) , and fails when datasets are too large to fit in the available disk space .
Our goal is to design a decision tree learner for extremely large ( potentially infinite ) datasets . This learner should require each example to be read at most once , and only a small constant time to process it . This will make it possible to directly mine online data sources ( ie , without ever storing the examples ) , and to build potentially very complex trees with acceptable computational cost . We achieve this by noting with Catlett [ 2 ] and others that , in order to find the best attribute to test at a given node , it may be sufficient to consider only a small subset of the training examples that pass through that node . Thus , given a stream of examples , the first ones will be used to choose the root test ; once the root attribute is chosen , the succeeding examples will be passed down to the corresponding leaves and used to choose the appropriate attributes there , and so on recursively.1 We solve the difficult problem of deciding exactly how many examples are necessary at each node by using a statistical result known as the Hoeffding bound ( or additive Chernoff bound ) [ 7 , 9 ] . Consider a real valued random variable r whose range is R ( eg , for a probability the range is one , and for an information gain the range is log c , where c is the number of classes ) . Suppose we have made n independent observations of this variable , and computed their mean r . The Hoeffding bound states that , with probability 1 , ffi , the true mean of the variable is at least r , ffl , where ffl =   R2 ln(1=ffi )
2n
( 1 )
The Hoeffding bound has the very attractive property that it is independent of the probability distribution generating the observations . The price of this generality is that the bound is more conservative than distribution dependent ones ( ie , it will take more observations to reach the same ffi and ffl ) . Let G(Xi ) be the heuristic measure used to choose test attributes ( eg , the measure could be information gain as in C4.5 , or the Gini index as in CART ) . Our goal is to ensure that , with high probability , the attribute chosen using n examples ( where n is as small as possible ) is the same that would be chosen using infinite examples . Assume G is to be maximized , and let Xa be the attribute with highest observed G after seeing n examples , and Xb be the second best attribute . Let G = G(Xa ) , G(Xb ) 0 be the difference between their observed heuristic values . Then , given a desired ffi , the Hoeffding bound guarantees that Xa is the correct choice with probability 1 , ffi if n examples have been seen at this node and G > ffl.2 In other words , if the ob
1We assume the examples are generated by a stationary stochastic process ( ie , their distribution does not change over time ) . If the examples are being read from disk , we assume that they are in random order . If this is not the case , they should be randomized , for example by creating a random index and sorting on it . 2In this paper we assume that the third best and lower attributes have sufficiently smaller gains that their probability of being the true best choice is negligible . We plan to lift this assumption in future work . If the attributes at a given node are ( pessimistically ) assumed independent , it simply involves a Bonferroni correction to ffi [ 11 ] . served G > ffl then the Hoeffding bound guarantees that the true G G , ffl > 0 with probability 1 , ffi , and therefore that Xa is indeed the best attribute with probability 1 , ffi . This is valid as long as the G value for a node can be viewed as an average of G values for the examples at that node , as is the case for the measures typically used . Thus a node needs to accumulate examples from the stream until ffl becomes smaller than G . ( Notice that ffl is a monotonically decreasing function of n . ) At this point the node can be split using the current best attribute , and succeeding examples will be passed to the new leaves . This leads to the Hoeffding tree algorithm , shown in pseudo code in Table 1 .
The counts nijk are the sufficient statistics needed to compute most heuristic measures ; if other quantities are required , they can be similarly maintained . Pre pruning is carried out by considering at each node a \null" attribute X ; that consists of not splitting the node . Thus a split will only be made if , with confidence 1,ffi , the best split found is better according to G than not splitting . The pseudo code shown is only for discrete attributes , but its extension to numeric ones is immediate , following the usual method of allowing tests of the form \(Xi < xij)?," and computing G for each allowed threshold xij . The sequence of examples S may be infinite , in which case the procedure never terminates , and at any point in time a parallel procedure can use the current tree HT to make class predictions . If d is the number of attributes , v is the maximum number of values per attribute , and c is the number of classes , the Hoeffding tree algorithm requires O(dvc ) memory to store the necessary counts at each leaf . If l is the number of leaves in the tree , the total memory required is O(ldvc ) . This is independent of the number of examples seen , if the size of the tree depends only on the \true" concept and is independent of the size of the training set . ( Although this is a common assumption in the analysis of decision tree and related algorithms , it often fails in practice . Section 3 describes a refinement to the algorithm to cope with this . )
A key property of the Hoeffding tree algorithm is that it is possible to guarantee under realistic assumptions that the trees it produces are asymptotically arbitrarily close to the ones produced by a batch learner ( ie , a learner that uses all the examples to choose a test at each node ) . In other words , the incremental nature of the Hoeffding tree algorithm does not significantly affect the quality of the trees it produces . In order to make this statement precise , we need to define the notion of disagreement between two decision trees . Let P ( x ) be the probability that the attribute vector ( loosely , example ) x will be observed , and let I( : ) be the indicator function , which returns 1 if its argument is true and 0 otherwise .
Definition 1 . The extensional disagreement e between two decision trees DT1 and DT2 is the probability that they will produce different class predictions for an example :
Table 1 : The Hoeffding tree algorithm .
Inputs : S X G( : ) ffi is a sequence of examples , is a set of discrete attributes , is a split evaluation function , is one minus the desired probability of choosing the correct attribute at any given node .
Output : HT is a decision tree .
Procedure HoeffdingTree ( S ; X ; G ; ffi ) Let HT be a tree with a single leaf l1 ( the root ) . Let X1 = X [ fX;g . Let G1(X ; ) be the G obtained by predicting the most frequent class in S .
For each class yk
For each value xij of each attribute Xi 2 X
Let nijk(l1 ) = 0 .
For each example ( x ; yk ) in S
Sort ( x ; y ) into a leaf l using HT . For each xij in x such that Xi 2 Xl
Increment nijk(l ) .
Label l with the majority class among the examples seen so far at l .
If the examples seen so far at l are not all of the same class , then Compute Gl(Xi ) for each attribute Xi 2 Xl , fX;g using the counts nijk(l ) .
Let Xa be the attribute with highest Gl . Let Xb be the attribute with second highest Gl . Compute ffl using Equation 1 . If Gl(Xa ) , Gl(Xb ) > ffl and Xa 6= X ; , then
Replace l by an internal node that splits on Xa . For each branch of the split
Add a new leaf lm , and let Xm = X , fXag . Let Gm(X ; ) be the G obtained by predicting the most frequent class at lm .
For each class yk and each value xij of each attribute Xi 2 Xm , fX;g Let nijk(lm ) = 0 .
Return HT . from a leaf . Consider also that two paths through trees are different if they differ in length or in at least one node .
Definition 2 . The intensional disagreement i between two decision trees DT1 and DT2 is the probability that the path of an example through DT1 will differ from its path through DT2 :
i(DT1 ; DT2 ) =
P ( x)I[Path1(x ) 6= Path2(x ) ] where Pathi(x ) is the path of example x through tree DTi .
  x
e(DT1 ; DT2 ) =
  x
P ( x)I[DT1(x ) 6= DT2(x ) ]
Consider that two internal nodes are different if they contain different tests , two leaves are different if they contain different class predictions , and an internal node is different
Two decision trees agree intensionally on an example iff they are indistinguishable for that example : the example is passed down exactly the same sequence of nodes , and receives an identical class prediction . Intensional disagreement is a stronger notion than extensional disagreement , in the sense that 8DT1;DT2 i(DT1 ; DT2 ) e(DT1 ; DT2 ) .
Let pl be the probability that an example that reaches level l in a decision tree falls into a leaf at that level . To simplify , we will assume that this probability is constant , ie , 8l pl = p , where p will be termed the leaf probability . This is a realistic assumption , in the sense that it is typically approximately true for the decision trees that are generated in practice . Let HTffi be the tree produced by the Hoeffding tree algorithm with desired probability ffi given an infinite sequence of examples S , and DTfi be the asymptotic batch decision tree induced by choosing at each node the attribute with true greatest G ( ie , by using infinite examples at each node ) . Let E[ i(HTffi ; DTfi ) ] be the expected value of i(HTffi ; DTfi ) , taken over all possible infinite training sequences . We can then state the following result .
Theorem 1 . If HTffi is the tree produced by the Hoeffding tree algorithm with desired probability ffi given infinite examples ( Table 1 ) , DTfi is the asymptotic batch tree , and p is the leaf probability , then E[ i(HTffi ; DTfi ) ] ffi=p .
1 ( x ) ; N H
Proof . For brevity , we will refer to intensional disagreement simply as disagreement . Consider an example x that falls into a leaf at level lh in HTffi , and into a leaf at level ld in DTfi . Let l = minflh ; ldg . Let PathH ( x ) = ( N H 2 ( x ) ; : : : ; N H l ( x ) ) be x ’s path through HTffi up to level l , where N H i ( x ) is the node that x goes through at level i in HTffi , and similarly for PathD(x ) , x ’s path through DTfi . If l = lh then N H l ( x ) is a leaf with a class prediction , and similarly for N D l ( x ) if l = ld . Let Ii represent the proposition \PathH(x ) = PathD(x ) up to and including level i," with I0 = True . Notice that P ( lh 6= ld ) is included in P ( N H l ( x)jIl,1 ) , because if the two paths have different lengths then one tree must have a leaf where the other has an internal node . Then , omitting the dependency of the nodes on x for brevity , l ( x ) 6= N D
P ( PathH ( x ) 6= PathD(x ) ) 2 6= N D 1 _ N H 1 jI0 ) + P ( N H
= P ( N H = P ( N H
1 6= N D 1 6= N D
2 _ : : : _ N H l 2 6= N D
2 jI1 ) + : : :
6= N D l )
+P ( N H l l
6= N D l jIl,1 )
P ( N H i
6= N D i jIi,1 )
=
 i=1 l
 i=1 ffi = ffil
( 2 )
Let HTffi(S ) be the Hoeffding tree generated from training sequence S . Then E[ i(HTffi ; DTfi ) ] is the average over all infinite training sequences S of the probability that an example ’s path through HTffi(S ) will differ from its path through DTfi :
E[ i(HTffi ; DTfi ) ]
P ( S )
P ( x ) I[PathH(x ) 6= PathD(x ) ]
=
=
=
  x
  S   x  i=1  x2Li
1
P ( x ) P ( PathH ( x ) 6= PathD(x ) )
P ( x ) P ( PathH(x ) 6= PathD(x ) )
( 3 ) where Li is the set of examples that fall into a leaf of DTfi at level i . According to Equation 2 , the probability that an example ’s path through HTffi(S ) will differ from its path through DTfi , given that the latter is of length i , is at most ffii ( since i l ) . Thus
1
E[ i(HTffi ; DTfi ) ]
=
P ( x)(ffii )
1
 i=1  x2Li  i=1
( ffii )
 x2Li
P ( x )
( 4 )
P ( x ) is the probability that an example x The sum will fall into a leaf of DTfi at level i , and is equal to ( 1 , p)i,1p , where p is the leaf probability . Therefore x2Li
E[ i(HTffi ; DTfi ) ]
1
( ffii)(1 , p)i,1p = ffip i(1 , p)i,1
1
 i=1
1
( 1 , p)i,1 +
( 1 , p)i,1 +
 i=2 ( 1 , p)i,1 +
 i=1
= ffip 1
1
 i=1  i=k
+
1 p
= ffip
+
1 , p p
+ +
( 1 , p)k,1 p
+
= ffi
1 + ( 1 , p ) + + ( 1 , p)k,1 +
= ffi
1
 i=0
( 1 , p)i = ffi p
( 5 )
This completes the demonstration of Theorem 1 .
An immediate corollary of Theorem 1 is that the expected extensional disagreement between HTffi and DTfi is also asymptotically at most ffi=p ( although in this case the bound is much looser ) . Another corollary ( whose proof we omit here in the interests of space ) is that there exists a subtree of the asymptotic batch tree such that the expected disagreement between it and the Hoeffding tree learned on finite data is at most ffi=p . In other words , if ffi=p is small then the Hoeffding tree learned on finite data is very similar to a subtree of the asymptotic batch tree . A useful application of Theorem 1 is that , instead of ffi , users can now specify as input to the Hoeffding tree algorithm the maximum expected disagreement they are willing to accept , given enough examples for the tree to settle . The latter is much more meaningful , and can be intuitively specified without understanding the workings of the algorithm or the Hoeffding bound . The algorithm will also need an estimate of p , which can easily be obtained ( for example ) by running a conventional decision tree learner on a manageable subset of the data . How practical are these bounds ? Suppose that the best and second best attribute differ by 10 % ( ie , ffl=R = 0:1 ) . Then , according to Equation 1 , ensuring ffi = 0:1 % requires 380 examples , and ensuring ffi = 0:0001 % requires only 345 additional examples . An exponential improvement in ffi , and therefore in expected disagreement , can be obtained with a linear increase in the number of examples . Thus , even with very small leaf probabilities ( ie , very large trees ) , very good agreements can be obtained with a relatively small number of examples per
  node . For example , if p = 0:01 % , an expected disagreement of at most 1 % can be guaranteed with 725 examples per node . If p = 1 % , the same number of examples guarantees a disagreement of at most 001 %
This is accomplished by , at regular intervals , scanning through all the active and inactive leaves , and replacing the least promising active leaves with the inactive ones that dominate them .
3 . THE VFDT SYSTEM We have implemented a decision tree learning system based on the Hoeffding tree algorithm , which we call VFDT ( Very Fast Decision Tree learner ) . VFDT allows the use of either information gain or the Gini index as the attribute evaluation measure . It includes a number of refinements to the algorithm in Table 1 :
Ties . When two or more attributes have very similar G ’s , potentially many examples will be required to decide between them with high confidence . This is presumably wasteful , because in this case it makes little difference which attribute is chosen . Thus VFDT can optionally decide that there is effectively a tie and split on the current best attribute if G < ffl < , where is a user specified threshold .
G computation . The most significant part of the time cost per example is recomputing G . It is inefficient to recompute G for every new example , because it is unlikely that the decision to split will be made at that specific point . Thus VFDT allows the user to specify a minimum number of new examples nmin that must be accumulated at a leaf before G is recomputed . This effectively reduces the global time spent on G computations by a factor of nmin , and can make learning with VFDT nearly as fast as simply classifying the training examples . Notice , however , that it will have the effect of implementing a smaller ffi than the one specified by the user , because examples will be accumulated beyond the strict minimum required to choose the correct attribute with confidence 1 , ffi . ( This increases the time required to build a node , but our experiments show that the net effect is still a large speedup . ) Because ffi shrinks exponentially fast with the number of examples , the difference could be large , and the ffi input to VFDT should be correspondingly larger than the target .
Memory . As long as VFDT processes examples faster than they arrive , which will be the case in all but the most demanding applications , the sole obstacle to learning arbitrarily complex models will be the finite RAM available . VFDT ’s memory use is dominated by the memory required to keep counts for all growing leaves . If the maximum available memory is ever reached , VFDT deactivates the least promising leaves in order to make room for new ones . If pl is the probability that an arbitrary example will fall into leaf l , and el is the observed error rate at that leaf , then plel is an upper bound on the error reduction achievable by refining the leaf . plel for a new leaf is estimated using the counts at the parent for the corresponding attribute value . The least promising leaves are considered to be the ones with the lowest values of plel . When a leaf is deactivated , its memory is freed , except for a single number required to keep track of plel . A leaf can then be reactivated if it becomes more promising than currently active leaves .
Poor attributes . Memory usage is also minimized by dropping early on attributes that do not look promising . As soon as the difference between an attribute ’s G and the best one ’s becomes greater than ffl , the attribute can be dropped from consideration , and the memory used to store the corresponding counts can be freed .
Initialization . VFDT can be initialized with the tree produced by a conventional RAM based learner on a small subset of the data . This tree can either be input as is , or over pruned to contain only those nodes that VFDT would have accepted given the number of examples at them . This can give VFDT a \head start" that will allow it to reach the same accuracies at smaller numbers of examples throughout the learning curve .
Rescans . VFDT can rescan previously seen examples . This option can be activated if either the data arrives slowly enough that there is time for it , or if the dataset is finite and small enough that it is feasible to scan it multiple times . This means that VFDT need never grow a smaller ( and potentially less accurate ) tree than other algorithms because of using each example only once .
The next section describes an empirical study of VFDT , where the utility of these refinements is evaluated .
4 . EMPIRICAL STUDY 4.1 Synthetic data A system like VFDT is only useful if it is able to learn more accurate trees than a conventional system , given similar computational resources . In particular , it should be able to use to advantage the examples that are beyond a conventional system ’s ability to process . In this section we test this empirically by comparing VFDT with C4.5 release 8 [ 15 ] on a series of synthetic datasets . Using these allows us to freely vary the relevant parameters of the learning process . In order to ensure a fair comparison , we restricted the two systems to using the same amount of RAM . This was done by setting VFDT ’s \available memory" parameter to 40MB , and giving C4.5 the maximum number of examples that would fit in the same memory ( 100k examples).3 VFDT used information gain as the G function . Fourteen concepts were used for comparison , all with two classes and 100 binary attributes . The concepts were created by randomly generating decision trees as follows . At each level after the first three , a fraction f of the nodes was replaced by leaves ; the rest became splits on a random attribute ( that had not been used yet on a path from the root to the node being considered ) . When the decision tree reached a depth of 18 , all the remaining growing nodes were replaced with leaves . Each leaf was randomly assigned a class . The size of the resulting concepts ranged from 2.2k leaves to 61k leaves with a median of 126k A stream of training examples was then
3VFDT occasionally grew slightly beyond 40MB because the limit was only enforced on heap allocated memory . C4.5 always exceeded 40MB by the size of the unpruned tree . generated by sampling uniformly from the instance space , and assigning classes according to the target tree . We added various levels of class and attribute noise to the training examples , from 0 to 30%.4 ( A noise level of n % means that each class/attribute value has a probability of n % of being reassigned at random , with equal probability for all values , including the original one . ) In each run , 50k separate examples were used for testing . C4.5 was run with all default settings . We ran our experiments on two Pentium 6/200 MHz , one Pentium II/400 MHz , and one Pentium III/500 MHz machine , all running Linux .
Figure 1 shows the accuracy of the learners averaged over all the runs . VFDT was run with ffi = 10,7 , = 5 % , nmin = 200 , no leaf reactivation , and no rescans . VFDTboot is VFDT bootstrapped with an over pruned version of the tree produced by C45 C4.5 is more accurate than VFDT up to 25k examples , and the accuracies of the two systems are similar in the range from 25k to 100k examples ( at which point C4.5 is unable to consider further examples ) . Most significantly , VFDT is able to take advantage of the examples after 100k to greatly improve accuracy ( 88.7 % for VFDT and 88.8 % for VFDT boot , vs . 76.5 % for C45 ) C4.5 ’s early advantage comes from the fact it reuses examples to make decisions on multiple levels of the tree it is inducing , while VFDT uses each example only once . As expected , VFDT boot ’s initialization lets it achieve high accuracy more quickly than without it . However , VFDT boot ’s performance is surprising in that its accuracy is much higher than C4.5 ’s at 100k examples , when VFDT boot has not seen any examples that C4.5 did not . An explanation for this is that many of the experiments reported in Figure 1 contained noise , and , as Catlett [ 2 ] showed , over pruning can be very effective at reducing overfitting in noisy domains .
Figure 2 shows the average number of nodes in the trees induced by each of the learners . Notice that VFDT and VFDT boot induce trees with similar numbers of nodes , and that both achieve greater accuracy with far fewer nodes than C45 This suggests that using VFDT can substantially increase the comprehensibility of the trees induced relative to C45 It also suggests that VFDT is less prone than C4.5 to overfitting noisy data .
Figure 3 shows how the algorithms respond to noise . It compares four runs on the same concept ( with 12.6k leaves ) , but with increasing levels of noise added to the training examples . C4.5 ’s accuracy reports are for training sets with 100k examples , and VFDT and VFDT boot ’s are for training sets of 20 million examples . VFDT ’s advantage compared to C4.5 increases with the noise level . This is further evidence that use of the Hoeffding bound is an effective pruning method .
4The exact concepts used were , in the form ( f , noise level , #nodes , #leaves ) : ( 0.15 , 0.10 , 74449 , 37225 ) , ( 0.15 , 0.10 , 13389 , 6695 ) , ( 0.17 , 0.10 , 78891 , 39446 ) , ( 0.17 , 0.10 , 93391 , 46696 ) , ( 0.25 , 0.00 , 25209 , 12605 ) , ( 0.25 , 0.20 , 25209 , 12605 ) , ( 0.25 , 0.30 , 25209 , 12605 ) , ( 0.25 , 0.00 , 15917 , 7959 ) , ( 0.25 , 0.10 , 31223 , 15612 ) , ( 0.25 , 0.15 , 16781 , 8391 ) , ( 0.25 , 0.20 , 4483 , 2242 ) , ( 0.28 , 0.10 , 122391 , 61196 ) , ( 0.28 , 0.10 , 6611 , 3306 ) , ( 0.25 , 0.10 , 25209 , 12605 ) . The last set of parameters was also used as the basis for the lesion studies reported below .
90
85
80
75
70
65
60
% y c a r u c c A
55
100
C4.5 VFDT VFDT boot
1000
10000 100000 1e+006 1e+007 1e+008
No . Examples
Figure 1 : Accuracy as a function of the number of training examples .
C4.5 VFDT VFDT boot
25000
20000
15000
10000
5000 s e d o N
. o N
0 100
1000 10000 100000 1e+006 1e+007 1e+008
No . Examples
Figure 2 : Tree size as a function of the number of training examples .
% y c a r u c c A
95
90
85
80
75
70
65
60
55
C4.5 VFDT VFDT boot
0
5
10
15
20
25
30
Noise %
Figure 3 : Accuracy as a function of the noise level .
Figure 4 shows how the algorithms compare on six concepts of varying size.5 All the training sets had 10 % noise . As before , C4.5 ’s results are for learning on 100k examples , while VFDT and VFDT boot ’s are for 20 million . Both versions of VFDT do better than C4.5 on every concept size considered . However , contrary to what we would expect , as concept size increases the relative benefit seems to remain approximately constant for VFDT and VFDT boot . Looking deeper , we find that with 20 million examples VFDT and VFDT boot induce trees with approximately 9k nodes regardless of the size of the underlying concept . This suggests that they would take good advantage of even more training examples .
We carried out all runs without ever writing VFDT ’s training examples to disk ( ie , generating them on the fly and passing them directly to VFDT ) . For time comparison purposes , however , we measured the time it takes VFDT to read examples from the ( 0.25 , 0.10 , 25209 , 12605 ) data set from disk on the Pentium III/500 MHz machine . VFDT takes 5752 seconds to read the 20 million examples , and 625 seconds to process them . In other words , learning time is about an order of magnitude less than input time . On the same runs , C4.5 takes 36 seconds to read and process 100k examples , and VFDT takes 47 seconds .
Finally , we generated 160 million examples from the ( 0.25 , 0.10 , 25209 , 12605 ) concept . Figure 5 compares VFDT and C4.5 on this data set . VFDT makes progress over the entire data set , but begins to asymptote after 10 million examples ; the final 150 million examples contribute 0.58 % to accuracy . VFDT took 9501 seconds to process the examples ( excluding I/O ) and induced 21.9k leaves . In the near future we plan to carry out similar runs with more complex concepts and billions of examples .
4.2 Lesion studies We conducted a series of lesion studies to evaluate the effectiveness of some of the components and parameters of the VFDT system . Figure 6 shows the accuracy of the learners on the ( 0.25 , 0.00 , 25209 , 12605 ) data set . It also shows a slight modification to the VFDT boot algorithm , where the tree produced by C4.5 is used without first over pruning it . All versions of VFDT were run with ffi = 10,7 , = 5 % , nmin = 200 , no leaf reactivation , and no rescans . C4.5 does better without noise than with it , but VFDT is still able to use additional data to significantly improve accuracy . VFDT boot with the \no over prune" setting is initially better than the over pruning version , but does not make much progress and is eventually overtaken . We hypothesize that this is because it has difficulty overcoming the poor low confidence decisions C4.5 made near its leaves .
In the remainder of the lesion studies VFDT was run on the ( 0.25 , 0.10 , 25209 , 12605 ) data set with ffi = 10,7 , = 5 % , nmin = 200 , no leaf reactivation , and no rescans . We evaluated the effect of disabling ties , so that VFDT does not make any splits until it is able to identify a clear winner .
5The concept ( 0.15 , 0.10 , 74449 , 37225 ) turned out to be atypically easy , and is not included in the graph to avoid obscuring the trend . The observed accuracies for this concept were : C4.5 { 83.1 % ; VFDT { 89.0 % ; VFDT boot { 897 %
% y c a r u c c A
100
95
90
85
80
75
70
65
C4.5 VFDT VFDT boot
0
10000 20000 30000 40000 50000 60000 70000
Concept size ( leaves )
Figure 4 : Accuracy as a function of the complexity of the true concept .
% y c a r u c c A
90 85 80 75 70 65 60 55 50
0 0 1
0 0 0 1
0 0 0 0 1
C4.5 VFDT
7 0 0 + e 1
8 0 0 + e 1
9 0 0 + e 1
0 0 0 0 0 1
6 0 0 + e 1
No . Examples
Figure 5 : VFDT trained on 160 million examples .
% y c a r u c c A
95 90 85 80 75 70 65 60 55 50 45
C4.5 VFDT VFDT boot No over prune
0 0 1
0 0 0 1
0 0 0 0 1
0 0 0 0 0 1
No . Examples
6 0 0 + e 1
7 0 0 + e 1
8 0 0 + e 1
Figure 6 : Effect of initializing VFDT with C4.5 with and without over pruning .
We conducted two runs , holding all parameters constant except that the second run never split with a tie . Without ties VFDT induced a tree with only 65 nodes and 72.9 % accuracy , compared to 8k nodes and 86.9 % accuracy with ties . VFDT boot without ties produced 805 nodes and 83.3 % accuracy , compared to 8k nodes and 88.5 % accuracy with ties . We also carried out two runs holding all parameters constant except nmin , the number of new examples that must be seen at a node before G ’s are recomputed . The first run recomputed G every 200 examples ( nmin = 200 ) , and the second did it for every example ( nmin = 1 ) . Doing the G computations for every example , VFDT gained 1.1 % accuracy and took 3.8 times longer to run . VFDT boot lost 0.9 % accuracy and took 3.7 times longer . Both learners induced about 5 % more nodes with the more frequent G computations . We then carried out two runs holding all parameters but VFDT ’s memory limit constant . The first run was allowed 40 MB of memory ; the second was allowed 80 MB . VFDT and VFDT boot both induced 7.8k more nodes with the additional memory , which improved VFDT ’s accuracy by 3.0 % and VFDT boot ’s by 32 % Finally , we carried out two runs holding all parameters but ffi constant . The first run had a delta of 10,2 , and the second had a delta of 10,7 . With the lower ffi , VFDT and VFDT boot both induced about 30 % fewer nodes than with the higher one . VFDT ’s accuracy was 2.3 % higher and VFDT boot ’s accuracy was 1.0 % higher with the lower ffi .
4.3 Web data We are currently applying VFDT to mining the stream of Web page requests emanating from the whole University of Washington main campus . The nature of the data is described in detail in [ 23 ] . In our experiments so far we have used a one week anonymized trace of all the external web accesses made from the university campus . There were 23,000 active clients during this one week trace period , and the entire university population is estimated at 50,000 people ( students , faculty and staff ) . The trace contains 82.8 million requests , which arrive at a peak rate of 17,400 per minute . The size of the compressed trace file is about 20 GB.6 Each request is tagged with an anonymized organization ID that associates the request with one of the 170 organizations ( colleges , departments , etc . ) within the university . One purpose this data can be used for is to improve Web caching . The key to this is predicting as accurately as possible which hosts and pages will be requested in the near future , given recent requests . We applied decisiontree learning to this problem in the following manner . We split the campus wide request log into a series of equal time slices T0 ; T1 ; : : : ; Tt ; : : : ; in the experiments we report , each time slice is an hour . For each organization O1 ; O2 ; : : : ; Oi ; : : : ; O170 and each of the 244k hosts appearing in the logs H1 ; : : : ; Hj ; : : : ; H244k , we maintain a count of how many times the organization accessed the host in the time slice , Cijt . We discretize these counts into four buckets , representing \no requests," \1 { 12 requests," \13 { 25 requests" and \26 or more requests." Then for each time slice and host accessed in that time slice ( Tt ; Hj ) we generate an example with attributes t mod 24 ; C1;jt ; : : : ; Cijt ; : : : C170;jt
6This log is from May 1999 . Traffic in May 2000 was double this size ; a one week log was approximately 50 GB compressed .
% y c a r u c c A
74.4 74.2 74 73.8 73.6 73.4 73.2 73 72.8 72.6 72.4
VFDT boot
0
0 0 0 0 0 5
6 0 0 + e 1
6 0 0 + e 5 . 1
6 0 0 + e 2
6 0 0 + e 5 . 2
6 0 0 + e 3
6 0 0 + e 5 . 3
6 0 0 + e 4
No . Examples
Figure 7 : Performance on Web data . and class 1 if Hj is requested in time slice Tt+1 and 0 if it is not . This can be carried out in real time using modest resources by keeping statistics on the last and current time slices Ct,1 and Ct in memory , only keeping counts for hosts that actually appear in a time slice ( we never needed more than 30k counts ) , and outputting the examples for Ct,1 as soon as Ct is complete . Using this procedure we obtained a dataset containing 1.89 million examples , 61.1 % of which were labeled with the most common class ( that the host did not appear again in the next time slice ) .
Testing was carried out on the examples from the last day ( 276,230 examples ) . VFDT was run with ffi = 10,7 , = 5 % , and nmin = 200 . All runs were carried out on a 400 MHz Pentium machine . A decision stump ( a decision tree with only one node ) obtains 64.2 % accuracy on this data . The decision stump took 1277 seconds to learn , and VFDT took 1450 seconds to do one pass over the training data ( after being initialized with C4.5 ’s over pruned tree ) . The majority of this time ( 983 seconds ) was spent reading data from disk . The bootstrap run of C4.5 took 2975 seconds to learn on a subsample of 74.5k examples ( as many as would fit in 40 MB of RAM ) and achieved 73.3 % accuracy . Thus VFDT learned faster on 1.61 million examples than C4.5 did on 75k . We also used a machine with 1 GB of RAM to run C4.5 on the entire 1.61 million training examples ; the run took 24 hours and the resulting tree was 75 % accurate . Figure 7 shows VFDT boot ’s performance on this dataset , using 1 GB of RAM . We extended VFDT ’s run out to 4 million examples by rescanning . The x axis shows the number of examples presented to VFDT after the C4.5 bootstrap phase was complete . Accuracy improves steadily as more examples are seen . VFDT is able to achieve accuracy similar to C4.5 ’s in a small fraction of the time . Further , C4.5 ’s memory requirements and batch nature will not allow it to scale to traces much larger than a week , while VFDT can easily incorporate data indefinitely . The next step is to apply VFDT to predicting page requests from a given host . We also plan to address issues related to time changing behavior and then set VFDT running permanently , learning and relearning as dictated by the data stream .
5 . RELATED WORK Previous work on mining large databases using subsampling methods includes the following . Catlett [ 2 ] proposed several heuristic methods for extending RAM based batch decisiontree learners to datasets with up to hundreds of thousands of examples . Musick , Catlett and Russell [ 13 ] proposed and tested ( but did not implement in a learner ) a theoretical model for choosing the size of subsamples to use in comparing attributes . Maron and Moore [ 9 ] used Hoeffding bounds to speed selection of instance based regression models via cross validation ( see also [ 12] ) . Gratch ’s Sequential ID3 [ 6 ] used a statistical method to minimize the number of examples needed to choose each split in a decision tree . ( Sequential ID3 ’s guarantees of similarity to the batch tree were much looser than those derived here for Hoeffding trees , and it was only tested on repeatedly sampled small datasets . ) Gehrke et al . ’s BOAT [ 5 ] learned an approximate tree using a fixed size subsample , and then refined it by scanning the full database . Provost et al . [ 14 ] studied different strategies for mining larger and larger subsamples until accuracy ( apparently ) asymptotes . In contrast to systems that learn in main memory by subsampling , systems like SLIQ [ 10 ] and SPRINT [ 17 ] use all the data , and concentrate on optimizing access to disk by always reading examples ( more precisely , attribute lists ) sequentially . VFDT combines the best of both worlds , accessing data sequentially and using subsampling to potentially require much less than one scan , as opposed to many . This allows it to scale to larger databases than either method alone . VFDT has the additional advantages of being incremental and anytime : new examples can be quickly incorporated as they arrive , and a usable model is available after the first few examples and then progressively refined .
As mentioned previously , there is a large literature on incremental learning , which space limitations preclude reviewing here . The system most closely related to ours is Utgoff ’s [ 20 ] ID5R ( extended in [ 21] ) . ID5R learns the same tree as ID3 ( a batch method ) , by restructuring subtrees as needed . While its learning time is linear in the number of examples , it is worst case exponential in the number of attributes . On the simple , noise free problems it was tested on , it was much slower than ID3 ; noise would presumably aggravate this . Thus ID5R does not appear viable for learning from high speed data streams .
A number of efficient incremental or single pass algorithms for KDD tasks other than supervised learning have appeared in recent years ( eg , clustering [ 4 ] and association rule mining [ 19] ) . A substantial theoretical literature on online algorithms exists ( eg , [ 8] ) , but it focuses on weak learners ( eg , linear separators ) , because little can be proved about strong ones like decision trees .
6 . FUTURE WORK We plan to shortly compare VFDT with SPRINT/SLIQ . VFDT may outperform these even in fully disk resident datasets , because it can learn in less than one scan while the latter require multiple scans , and the dominant component of their cost is often the time required to read examples from disk multiple times . VFDT ’s speed and anytime character make it ideal for interactive data mining ; we plan to also study its application in this context ( see [ 18] ) . Other directions for future work include : further developing the application of VFDT to Web log data ; studying other applications of VFDT ( eg , intrusion detection ) ; using nondiscretized numeric attributes in VFDT ; studying the use of post pruning in VFDT ; further optimizing VFDT ’s computations ( eg , by recomputing G ’s exactly when we can tell that the current example may cause the Hoeffding bound to be reached ) ; using adaptive ffi ’s ; studying the use of an example cache in main memory to speed induction by reusing examples at multiple levels ; comparing VFDT to ID5R and other incremental algorithms ; adapting VFDT to learn evolving concepts in time changing domains ; adapting VFDT to learning with imbalanced classes and asymmetric misclassification costs ; adapting VFDT to the extreme case where even the final decision tree ( without any stored sufficient statistics ) does not fit in main memory ; parallelizing VFDT ; applying the ideas described here to other types of learning ( eg , rule induction , clustering ) ; etc .
7 . CONCLUSION This paper introduced Hoeffding trees , a method for learning online from the high volume data streams that are increasingly common . Hoeffding trees allow learning in very small constant time per example , and have strong guarantees of high asymptotic similarity to the corresponding batch trees . VFDT is a high performance data mining system based on Hoeffding trees . Empirical studies show its effectiveness in taking advantage of massive numbers of examples . VFDT ’s application to a high speed stream of Web log data is under way .
Acknowledgments This research was partly funded by an NSF CAREER award to the first author .
8 . REFERENCES [ 1 ] L . Breiman , J . H . Friedman , R . A . Olshen , and C . J .
Stone . Classification and Regression Trees . Wadsworth , Belmont , CA , 1984 .
[ 2 ] J . Catlett . Megainduction : Machine Learning on Very
Large Databases . PhD thesis , Basser Department of Computer Science , University of Sydney , Sydney , Australia , 1991 .
[ 3 ] T . G . Dietterich . Overfitting and undercomputing in machine learning . Computing Surveys , 27:326{327 , 1995 .
[ 4 ] M . Ester , H P Kriegel , J . Sander , M . Wimmer , and
X . Xu . Incremental clustering for mining in a data warehousing environment . In Proceedings of the Twenty Fourth International Conference on Very Large Data Bases , pages 323{333 , New York , NY , 1998 . Morgan Kaufmann .
[ 5 ] J . Gehrke , V . Ganti , R . Ramakrishnan , and W L
Loh . BOAT : optimistic decision tree construction . In Proceedings of the 1999 ACM SIGMOD International Conference on Management of Data , pages 169{180 , Philadelphia , PA , 1999 . ACM Press .
[ 6 ] J . Gratch . Sequential inductive learning . In
[ 15 ] J . R . Quinlan . C4.5 : Programs for Machine Learning .
Proceedings of the Thirteenth National Conference on Artificial Intelligence , pages 779{786 , Portland , OR , 1996 . AAAI Press .
[ 7 ] W . Hoeffding . Probability inequalities for sums of bounded random variables . Journal of the American Statistical Association , 58:13{30 , 1963 .
[ 8 ] N . Littlestone . Learning quickly when irrelevant attributes abound : A new linear threshold algorithm . Machine Learning , 2:285{318 , 1997 .
[ 9 ] O . Maron and A . Moore . Hoeffding races :
Accelerating model selection search for classification and function approximation . In J . D . Cowan , G . Tesauro , and J . Alspector , editors , Advances in Neural Information Processing Systems 6 . Morgan Kaufmann , San Mateo , CA , 1994 .
[ 10 ] M . Mehta , A . Agrawal , and J . Rissanen . SLIQ : A fast scalable classifier for data mining . In Proceedings of the Fifth International Conference on Extending Database Technology , pages 18{32 , Avignon , France , 1996 . Springer .
[ 11 ] R . G . Miller , Jr . Simultaneous Statistical Inference .
Springer , New York , NY , 2nd edition , 1981 .
[ 12 ] A . W . Moore and M . S . Lee . Efficient algorithms for minimizing cross validation error . In Proceedings of the Eleventh International Conference on Machine Learning , pages 190{198 , New Brunswick , NJ , 1994 . Morgan Kaufmann .
[ 13 ] R . Musick , J . Catlett , and S . Russell . Decision theoretic subsampling for induction on large databases . In Proceedings of the Tenth International Conference on Machine Learning , pages 212{219 , Amherst , MA , 1993 . Morgan Kaufmann .
[ 14 ] F . Provost , D . Jensen , and T . Oates . Efficient progressive sampling . In Proceedings of the Fifth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining , pages 23{32 , San Diego , CA , 1999 . ACM Press .
Morgan Kaufmann , San Mateo , CA , 1993 .
[ 16 ] J . R . Quinlan and R . M . Cameron Jones .
Oversearching and layered search in empirical learning . In Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence , pages 1019{1024 , Montreal , Canada , 1995 . Morgan Kaufmann .
[ 17 ] J . C . Shafer , R . Agrawal , and M . Mehta . SPRINT : A scalable parallel classifier for data mining . In Proceedings of the Twenty Second International Conference on Very Large Databases , pages 544{555 , Mumbai , India , 1996 . Morgan Kaufmann .
[ 18 ] P . Smyth and D . Wolpert . Anytime exploratory data analysis for massive data sets . In Proceedings of the Third International Conference on Knowledge Discovery and Data Mining , pages 54{60 , Newport Beach , CA , 1997 . AAAI Press .
[ 19 ] H . Toivonen . Sampling large databases for association rules . In Proceedings of the Twenty Second International Conference on Very Large Data Bases , pages 134{145 , Mumbai , India , 1996 . Morgan Kaufmann .
[ 20 ] P . E . Utgoff . Incremental induction of decision trees .
Machine Learning , 4:161{186 , 1989 .
[ 21 ] P . E . Utgoff . An improved algorithm for incremental induction of decision trees . In Proceedings of the Eleventh International Conference on Machine Learning , pages 318{325 , New Brunswick , NJ , 1994 . Morgan Kaufmann .
[ 22 ] G . I . Webb . OPUS : An efficient admissible algorithm for unordered search . Journal of Artificial Intelligence Research , 3:431{465 , 1995 .
[ 23 ] A . Wolman , G . Voelker , N . Sharma , N . Cardwell , M . Brown , T . Landray , D . Pinnel , A . Karlin , and H . Levy . Organization based analysis of Web object sharing and caching . In Proceedings of the Second USENIX Conference on Internet Technologies and Systems , pages 25{36 , Boulder , CO , 1999 .
