Discovering Meta Paths in Large Heterogeneous Information Networks
Changping Meng∗ Purdue University West Lafayette , US meng40@purdue.edu
Reynold Cheng
University of Hong Kong
Pokfulam Road , Hong Kong ckcheng@cshkuhk
Silviu Maniu∗
Noah ’s Ark Lab , Huawei Science Park , Hong Kong silviumaniu@huaweicom
Pierre Senellart
Télécom ParisTech ; CNRS LTCI
& NUS ; CNRS IPAL pierre@senellart.com
ABSTRACT The Heterogeneous Information Network ( HIN ) is a graph data model in which nodes and edges are annotated with class and relationship labels . Large and complex datasets , such as Yago or DBLP , can be modeled as HINs . Recent work has studied how to make use of these rich information sources . In particular , meta paths , which represent sequences of node classes and edge types between two nodes in a HIN , have been proposed for such tasks as information retrieval , decision making , and product recommendation . Current methods assume meta paths are found by domain experts . However , in a large and complex HIN , retrieving meta paths manually can be tedious and difficult . We thus study how to discover meta paths automatically . Specifically , users are asked to provide example pairs of nodes that exhibit high proximity . We then investigate how to generate meta paths that can best explain the relationship between these node pairs . Since this problem is computationally intractable , we propose a greedy algorithm to select the most relevant meta paths . We also present a data structure to enable efficient execution of this algorithm . We further incorporate hierarchical relationships among node classes in our solutions . Extensive experiments on real world HIN show that our approach captures important meta paths in an efficient and scalable manner .
1 .
INTRODUCTION
Heterogeneous Information Networks ( HINs ) , such as Yago [ 17 ] and DBpedia [ 2 ] , has attracted plenty of attention in recent years . These graph data sources , which contains a gigantic number of interrelated facts , enables discovery of interesting knowledge . Yago , for instance , stores over 10 million entities and 120 million facts [ 17 ] . Figure 1 illustrates a knowledge base , a kind of HIN , which captures the relationships among entities ( or graph nodes ) . Each node and edge is associated with a “ label ” , indicative of the node class and edge type , respectively . For example , Barack Obama ( node 1 ) has class labels USPresident and Writer . One of his offsprings is ∗Work mainly done while the authors were affiliated with University of Hong Kong .
Copyright is held by the International World Wide Web Conference Committee ( IW3C2 ) . IW3C2 reserves the right to provide a hyperlink to the author ’s site if the Material is used in electronic media . WWW 2015 , May 18–22 , 2015 , Florence , Italy . ACM 978 1 4503 3469 3/15/05 . http://dxdoiorg/101145/27362772741123 .
Wangda Zhang
University of Hong Kong
Pokfulam Road , Hong Kong wdzhang2@cshkuhk
Figure 1 : HIN with class hierarchy
Malia Obama ( node 5 ) , as indicated by the hasChild edge . A class hierarchy describes the relationships among node class labels , as shown in Figure 1(a ) .
The problem of understanding the vast amount of information modeled in HINs has received a lot of interest . In particular , the concept of meta paths has been proposed [ 10,19,20 ] to explain how nodes are related . A meta path is a sequence of node classes and edge types between two given nodes . In Figure 1 , Barack Obama and Michelle Obama are connected by the following three different meta paths:1
USPresident hasChild USPresident memberOf
−−−−−−→ USFirstLady ,
−−−−−−→ Person hasChild−1 −−−−−−→ USPoliticalParty memberOf−1 −−−−−−−−→ USFirstLady , −−−−−→ Country citizenOf−1
−−−−−−−→ USFirstLady .
USPresident citizenOf
1We use hasChild−1 to denote the opposite direction of the edge labeled hasChild .
USPresidentLeaderUSFirstLadyPersonWriterUSPoliticalPartyPartyObjectCountry1110432198765BObamaMObamaGWBushLBushBPBushJ BushMAObamaNObamaDPartyRPartyUS1011memberOfcitizenOfhasChild13122495678 Meta paths can be used to predict the closeness , or similarity , among graph nodes . This is especially useful when an edge between two nodes does not exist . As in Figure 1 , assume , for the sake of argument , that there is no edge between Barack Obama and Michelle Obama . However , the two nodes are closely related , as illustrated by the three meta paths above . Notice that a meta path can have a path length of more than one . Thus , it can be used to explain sophisticated relationships among nodes that cannot be depicted by a single edge . Recently , researchers have studied how to use meta paths between two heterogeneous graph nodes to quantify their similarity . They have proposed meta path–based similarity measures ( eg , path count ( PC ) [ 19 ] , path constraint random walk ( PCRW ) [ 10 ] , and HeteSim ( HS ) [ 16] ) . These metrics on metapaths between two nodes can be used for link prediction , product recommendation , and decision making . For example , in bibliography networks ( eg , DBLP [ 11] ) , these measures can be used to predict relationships among authors and research topics . In a recommendation system that stores salesperson , customer , and product information , these similarity values can be used to suggest products to be promoted to customers , and advise salespersons about potential customers [ 10 , 19 , 20 ] . Prior works . Although meta paths are useful , the important issue of how to generate them has not been well studied . Most existing work assumes that meta paths are provided by domain experts . While this assumption may be true for a relatively simple HIN ( eg , DBLP [ 11] ) , we question its validity for larger ones such as Yago and DBpedia . For these cases , millions of nodes and edges are annotated with thousands of labels , and node class labels exhibit complex hierarchical relationships ( as in Figure 1 ) . Moreover , long meta paths can be extremely difficult to discover , especially if this is done without the aid of machines . The only meta path generation solution is proposed in [ 10 ] , and yields meta paths within a fixed length l . However , it is not clear how l should be set . As we found in our experiments , the performance and effectiveness of their approach is very sensitive to l . In [ 5 ] , a method called AMIE was proposed to mine association rules from HIN . While association rules are similar to meta paths , the output of AMIE is “ global ” , ie , the individual preferences of a user are not considered . On the contrary , our method can be customized ; a user can provide her opinions about the meta paths to be generated , through example node pairs , as we discuss next . Moreover , AMIE does not use in any special manner the hierarchy of node classes , which we found to be very important in understanding relationships .
Our goal is to develop a systematic and user friendly solution for efficiently discovering important meta paths in large knowledge bases . In our approach , users provide example pairs of nodes that exhibit high proximity ( eg , George W . Bush and Laura Bush ) . They do not need to specify a maximum length l . Meta paths that best explain the similarity between these node pairs are then automatically generated . A simple way to do this is to enumerate all the possible meta paths and the possible meta path subsets between the given node pairs , and select those that have the highest similarity . Unfortunately , this solution is impractical . As pointed out in [ 10 ] , the number of possible meta paths for a given heterogeneous graph grows exponentially with the length of a meta path . Even if all these meta paths are known , selecting the most important subsets among them is an NP complete problem [ 10 ] . There is thus a need for a better approach that avoids enumerating all possible meta paths . Our solutions . We develop the Forward Stagewise Path Generation algorithm ( or FSPG ) , which derives meta paths that best predict the similarity between the given node pairs . Inspired by machine learning algorithms used for feature selection [ 4 ] , FSPG
Figure 2 : System framework contains greedy strategies that generate the most relevant subset of meta paths under a given regression model . Another advantage of FSPG is that it supports existing meta path based similarity measures – PC and PCRW . This is because FSPG adopts our proposed metric , called Biased Path Constrained Random Walk , or BPCRW , which generalizes PC and PCRW . We will explain how parameters of BPCRW can be tuned to get the best out of these two measures . To facilitate the efficient execution of FSPG , we investigate a data structure called the GreedyTree . This data structure is easily constructed and efficiently supports the online generation of relevant meta paths . We further explain how to extend our solution to incorporate class hierarchy information in our solutions .
We have performed extensive experiments on two real knowledge bases , namely DBLP and Yago . Our results show FSPG allows for a significant improvement in the accuracy of link prediction – between 10 % and 15 % . Moreover , FSPG detects new meta paths not provided by experts , and this leads to better results than only using the meta paths provided by experts . We show that FSPG computes meta paths in an efficient and scalable manner , and achieves an improvement in time of up to two orders of magnitude . We further demonstrate that class hierarchy information significantly increases accuracy of the similarity model , with negligible overhead . We show that FSPG discovers more association rules than AMIE . We further perform a case study , where human users provide opinions on generated meta paths ; FSPG did well in this experiment .
Figure 2 illustrates our high level approach for discovering metapaths . In Step 1 , users provide example pairs to FSPG . This algorithm generates meta paths ( Step 2 ) , which are then used to generate new node pairs ( Step 3 ) , eg , via similarity search and join operations [ 18 , 27 ] . From these node pairs , users select those that are indeed similar ( Step 4 ) . The accepted node pairs are then input to FSPG to iteratively refine the meta paths generated ( Step 5 ) . An advantage of this framework is flexibility : users can review and change the meta paths generated in Step 2 ; they can also provide new example pairs later after the meta paths are generated . In this paper , we focus on the design and implementation of FSPG ( Step 2 ) . The rest of this paper is organized as follows . We introduce the formal settings and similarity measures in Section 2 . We present FSPG and GreedyTree in Section 3 , and evaluate them experimentally in Section 4 . We review the related work in Section 5 , and conclude in Section 6 .
2 . META PATH BASED SIMILARITY
We now discuss the formal model of HINs and our problem settings . We then review existing meta path based similarity functions , and present a method to generalize them . 2.1 Problem Definition
We model the heterogeneous information network as in [ 20 ] :
DEFINITION 1
( HETEROGENEOUS INFORMATION NETWORK ) .
A Heterogeneous Information Network is a directed graph G =
( V,E,Φ,Ψ ) , where V is the set of nodes ( or entities ) of the graph ; E ⊆ V ×V is the set of edges connecting the nodes in V ; and Φ and Ψ are functions for labeling nodes and edges . We have Φ : V → 2A , where A is the set of node classes , and Ψ : E → 2R , where R is the set of edge types .
Many graph datasets can be modeled as HIN such as : ontologies ( Yago [ 17 ] , DBPedia [ 2] ) , and bibliographic networks ( DBLP [ 11] ) . Here , we mainly work with knowledge bases ( KB ) as an instance of HINs .
EXAMPLE 1 . Let us revisit the HIN in Figure 1 , where a triple of the form : ( Barack Obama , hasChild,Natasha Obama ) can be represented as an edge having type : Ψ(Barack Obama,Natasha Obama ) = {hasChild} . Each entity can be mapped to multiple types : Φ(Barack Obama ) = {USPresident , Writer , Person} .
Moreover , in most HINs on the Web – Yago and DBpedia being prime examples – the classes of the entities are organized in a hierarchical manner . For instance , USPresident is a subclass of Leader , and Leader is a subclass of Person . All the classes have a single root , eg , Object . They are usually organized in KBs as nodes in the graph , linked with edges of type subclassOf . Figure 1 shows an example of hierarchical organization of node classes . This hierarchical organization can affect how one chooses the classes of nodes in a KB , as we shall see later .
Given a path in G between two entities , there is a corresponding meta path that can be derived :
DEFINITION 2
( META PATH [ 20] ) . Given a HIN G = ei−→ . . . Cn . We say that a path P = v1
( V,E,Φ,Ψ ) , a meta path Π1n is a sequence of node class sets e1−→ . . . C1 , . . . , Cn , connected by link types e1 , . . . , en−1 : Π1n = C1 Ci e1−→ . . .vi e1−→ . . . Ci ei−→ . . .vn satisfies a metaei−→ . . . Cn if ∀i ∈ {1 , . . . ,n} , Ci ∩ Φ(vi ) = path Π = C1 /0 , and ∀i ∈ {1 , . . . ,n− 1} , {vi,vi+1} ∈ E and ei ∈ Ψ(vi,vi+1 ) . In other words , each entity on the path has a class that exists in the corresponding class set on the meta path , and each edge on the path has a corresponding type .
EXAMPLE 2 . In Figure 1 , USPresident hasChild
−−−−−→ Person hasChild−1 −−−−−−→ USFirstLady is satisfied by the path Barack Obama −−−−−→ Natasha Obama hasChild−1 −−−−−−→ MichelleObama . Another metahasChild path that is satisfied by a path between these two nodes is USPresident −−−−−−→ USPoliticalParty memberOf−1 −−−−−−−−→ USFirstLady , since Barack memberOf and Michelle Obama are both members of the Democratic Party . Two entities can have paths that satisfy different meta paths between them . The challenge then is finding them and including them in a model that can describe accurately the relationship between the nodes . Moreover , we wish to do this when multiple pairs are given : ( RELEVANT META PATHS ) . Given a HIN G = ( V,E,Φ,Ψ ) and a set of e example node pairs Λ = {(si,ti ) | 1 i e} , find a set of p meta paths Θ = {Πi | 1 i p} which accurately predicts Λ for a given similarity scoring function σ ( s,t | Θ ) .
PROBLEM 1
For instance , in Yago , the user can provide several pairs of entities of types Person and Country . A citizenOf link between entities of these types shows that a person is a citizen of a country . When this link is missing , the examples might implicitly suggest a relationship of residency in a country , as explained by a combination of meta paths Person livedIn−−−−→ Country and Person worksAt −−−−−→ Institution locatedIn
−−−−−→ Country .
The challenge is then : ( i ) to find all and only the relevant metapaths , and ( ii ) to train a model able to predict the examples pairs . Each path between the entities in the examples pairs that is satisfied by a meta path in the model contributes to the similarity between the example entities . Next , we study meta path based similarity measures . 2.2 Similarity Function σ
We now explain how to use a combination of meta paths to derive a similarity measure between two entities in a HIN . The similarity score between two entities s and t is a real number , computed by an aggregate function F of the similarity scores for each meta path of a set Θ : σ ( s,t | Θ ) = F ( {σ ( s,t | Πi ) | 1 i p} ) , where σ ( s,t | Πi ) is a similarity score measuring how “ strong ” the connection between two entities s and t given meta path Πi , Θ = {Π1 , . . . ,Πp} , and F is an aggregate function over the meta path scores . Let us start by explaining how to compute σ ( s,t | Π ) , and discuss the function F later . We first review the state of the art of meta path– based similarity definitions on HINs , and then introduce our general formulation of these similarity measures . Path Count ( PC ) [ 19 ] . The simplest form of similarity between two nodes is the count of the different paths which satisfy a given meta path Π . The intuition behind this measure is that the larger the number of paths satisfy a given configuration is , the more similar the entities are . Path Constrained Random Walk ( PCRW ) [ 10 ] . For a ei−→ . . . Cn , the similarity score between meta path Π = C1 two entities s and t is defined by the random walk starting at s and following only paths satisfying Π . It is defined recursively as follows , with a slight modification to allow for choosing node classes : e1−→ . . . Ci
σ ( vi,t | Πin ) =
σ ( t,t | Πnn ) = 1 ,
1
|ρei ( vi , Ci+1)| ∑ x∈ρei ( vi,Ci+1 )
σ ( x,t | Πi+1n ) , where ρei ( vi , Ci+1 ) is the set of nodes x which have classes in Ci+1 and are linked by an edge of type ei from vi , and Πin is the metapath Π truncated to the sub path between Ci and Cn . The evaluation starts at σ ( s,t | Π ) = σ ( s,t | Π1n ) Essentially , PCRW indicates the probability that a walker constrained on a particular meta path reaches the target node .
PC emphasizes the absolute number of paths satisfying a metapath while PCRW weighs the paths based on the neighbourhoods of nodes along them . Both measures can be generalized in a single measure , the Biased Path Constrained Random Walk ( BPCRW ) , defined in a manner similar to PCRW as follows :
σ ( vi,t | Πin ) =
1
|ρei ( ui , Ci+1)|α
∑ x∈ρei ( vi,Ci+1 )
σ ( x,t|Πi+1n ) ,
( 2.1 )
σ ( t,t | Πnn ) = 1 . When α = 0 , BPCRW is the same as PC ; when α = 1 , the same as PCRW . If α ∈ ( 0,1 ) , α balances the number of meta paths to be counted and the contribution of neighbors . Particularly , when α is large , we care more about the number of similar neighbors for a node ; when α is small , we place more emphasis on the number of paths between two nodes . We will evaluate the effect of α on BPCRW experimentally in Section 4 .
Remarks . Our solutions do not consider two recently proposed metrics , PathSim and HeteSim . The PathSim measure [ 20 ] obtains similar nodes ( or the so called “ peer objects ” ) for single symmetric meta paths . It is not clear how PathSim can handle non symmetric meta paths , which are common in KBs . The HeteSim metric [ 15,16 ] measures the relevance of a single meta path . Since it does not have the form of BPCRW ( Equation 2.1 ) , it is not supported by our FSPG solution . We experimentally compare BPCRW and HeteSim for a given single meta path in Section 4 . An interesting future work is to extend FSPG to support HeteSim . 2.3 Similarity Aggregate Function F
Following the previous work on meta path–based link prediction [ 10 , 19 ] , we use a linear regression model for F , which trains a linear model of the form : w j · σ,s,t | Π j
+ w0 ,
( 2.2 )
σ ( s,t | Θ ) = ∑ 1 jp where w0 , . . . ,wp are real valued coefficients . The function F forms the basis of our meta path selection algorithm .
3 . GENERATING META PATHS
We now study efficient algorithms for solving Problem 1 . As a matter of fact , an optimal solution for this problem is likely to be intractable [ 24 ] . Even if the paths are known in advance , selecting only the most relevant paths is difficult : it has been proved in [ 1 , 24 ] that the problem is NP hard , and it cannot be approximated within a constant factor unless P=NP . Therefore , we study efficient algorithms that do well in the average case . Since relevant paths may not be known initially , we propose a greedy framework that starts from a regression model with no meta paths . We then insert meta paths to the model , until a desired accuracy is attained . This method is inspired by the design of forward selection algorithms [ 9 ] in machine learning . As we will explain , forward selection enables meta paths to be generated as needed . Algorithm Framework . Our solution consists of two phases . The first phase ( Section 3.1 ) generates meta paths with only edge types . To support this step efficiently , we develop an appropriate data structure ( Section 32 ) In the second phase ( Section 3.3 ) , we augment the meta paths generated in Phase 1 with node class information , by considering the node class hierarchy . Let us now study these in detail . 3.1 Phase 1 : Link Only Path Generation
This phase generates meta paths with only edge types , by using Forward Stagewise Path Generation ( or FSPG ) . We greedily select the next most relevant meta path , and add it as a feature to the regression model , until the model can fit the example pairs . Specifically , we build a regression model for the input example pairs ; it uses meta paths ( with only link types ) as features and assigns a weight for each feature . We train this model based on a modified version of the Least Angle Regression [ 4 ] ( LARS ) . This method tests the addition of each feature against the model constructed , repeatedly adding the feature that improves the model the most , until no more features can be added . While LARS needs to know the whole feature space at the beginning of regression which means you need to enumerate all possible meta paths , we propose a heuristic to avoid this .
To support LARS and to avoid generating irrelevant meta paths , we propose a greedy method that iteratively returns the meta path with the largest correlation with the partially constructed model . We initialize the model with the first meta path found by our greedy method . Then , at each stage , we continue testing the next meta path , by computing its correlation to the currently constructed model . As in LARS , the criterion for choosing a feature is correlation – each time we choose the feature that has the largest correlation with the expected output at this step , so that we can approach the expected output fastest . At each stage , we insert the meta path that has the largest correlation value with the current residual ( explained below ) , based on a standard cosine function : cos(m,r ) = m· r m×r
( 3.1 ) where m is the resulting vector of a certain meta path Π on the training examples ( each entry of m is a BPCRW score σ ( s,t | Π ) for input pair ( s,t) ) , and r is the vector of residual values , denoting the difference between the values of the ground truth examples ( input pairs ) and the model results m . Initially , r is equal to the ground truth {1 , . . . ,1,−1 , . . . ,−1} of length |Λ| with values 1 for positive example pairs , and −1 for negative example pairs .
We now explain the process of generating training data . We require the user to provide positive examples only . One does not need to state negative examples , which can be difficult . However , if only positive examples are used , the resulting meta paths may characterize how the node pairs are connected by the largest number of metapaths , instead of how they are uniquely connected . Consider two positive examples : ( B . Obama,M . Obama ) , and ( G . W . Bush,L . Bush ) , which can be predicted by the three meta paths : 1 ) they have the same children , 2 ) they belong to the same political party , and 3 ) they are both US citizens . Although all these meta paths describe the relationship of the two node pairs , meta path 1 ) is more rare and important than meta path 3 ) . To reflect this , our algorithm generates negative node pairs that are pertinent to the positive examples .
One simple way to generate negative examples is to randomly select nodes pairs from the KB . Unfortunately , these examples may be totally irrelevant . For instance , a random pair ( J . Cameron , Avatar ) is unrelated to the positive examples above . In our solution , the number of negative examples is the same as that of the positive ones . We randomly extract entities that share the same Lowest Common Ancestor ( or LCA ) label in the class hierarchy as the entities present in the positive pairs . In Figure 1 , the LCA of the entities used in our examples , namely B . Obama and G . W . Bush , is USPresident . We then randomly select nodes that have the LCA USPresident ( eg , B . Clinton and R . Reagan in Figure 3 ) . Similarly , since the LCA of M . Obama and L . Bush is USFirstLady ( Figure 1 ) , two candidates for negative examples are B . Ford and B . Bush ( Figure 3 ) . These selected nodes are then combined randomly to form negative examples : ( B . Clinton , B . Ford ) and ( R . Reagan , B . Bush ) . Although this process might give us some false negative pairs , this chance is shown to be low in our experiments .
Algorithm 1 details the procedure of obtaining the set of metapaths with their weights , for an input vector of positive example pairs Λ . We denote all selected meta paths and their scores in a feature matrix : X = ( m0 , . . . ,mk ) . In this matrix , each column mk is the BPCRW scores of some meta path for all examples in Λ , and k is the number of meta paths generated . For each meta path feature , we return its weight in another vector w . After initializing the residual and weight vectors in Step 1 , we obtain the first metapath by invoking GreedyTree in Step 2 . This method , which we will explain , returns the meta path with the largest correlation value . Steps 4–11 , we iterate with the meta path with the next largest correlation .
Note that LARS iterates until every feature has been processed . In our case , the number of features ( meta paths ) is unknown , and it is difficult to generate them efficiently . Hence , we modify LARS , and incrementally build the regression model by using a new stopping condition : we iterate until the residual r is negligible ( ie , |r| ε in Step 4 ) . In our implementation , traversing the entire space of meta paths just to find that no path has been found is practically
Figure 3 : Selected negative example pairs impossible . So , we also establish a maximal number of iterations – 50 in our experiments – that forces the algorithm to stop even if convergence has not been achieved . This is enough , since most models contain a lot of small meta paths ; having more than 50 features start to add noise to the model . In our experiments , this threshold is rarely reached ; FSPG terminates within 20 iterations . In each iteration , we obtain the next meta path ( Step 6 ) having the largest correlation with r , and put it to matrix X ( Step 7 ) . Next , we compute the correlation of newly added meta path feature with the current residual ( Steps 8 ) , obtaining direction vector u and stepsize γ : fl u = X(X T X)−1(1T ( X T X)−11)1/21 corr− cos(mj,r )
( 1T ( X T X1)1/2)− mjT u ,
γ =
+ min 0 j<k
( 3.2 ) corr + cos(mj,r )
( 1T ( X T X1)1/2 + mjT u where 1 is a vector of 1 ’s of length k and min+ is the minimal positive value . While these equations appear in LARS [ 4 ] , we made two changes . First , we use the existing feature matrix X to heuristically represent the entire feature matrix . Second , when computing γ , we also only consider the existing meta path features vectors , or ( mj)0 j<k in the kth iteration .
Algorithm 1 : FSPG(G,Λ ) Input : network G , example pairs Λ Output : meta paths Π0,,k , path weight vector w 1 r ← {1 , . . . ,−1} ; w ← 0 ; k ← 0 ; 2 Π0,m0 ← GreedyTree(G,Λ,r ) ; 3 k ← 0 ; 4 while |r| > ε do k ← k + 1 ; 5 Πk,mk ← GreedyTree(G,Λ,r ) ; 6 X ← X ∪ mk ; 7 corr ← cos(mk,r ) ; 8 compute u , γ using Eq ( 3.2 ) ; 9 r ← r− Xuγ ; 10 w ← w + uγ ; 11 12 return Π0,,k,w
3.2 The GreedyTree Structure
Next , we study how to find the meta path mk with the largest correlation , by applying the GreedyTree algorithm . GreedyTree has three major advantages . First , it can reduce the search space by applying search heuristics . Second , when starting from multiple example nodes , it minimizes the redundancy in computing the common path sequences that may appear , by using the tree structure to store such paths . Third , the tree structure can be re used for multiple expansions in the run of the algorithm . Let us illustrate the algorithm by using the previous example . The positive example pairs are {(1,2 ) , ( 3,4)} in Figure 1 and negative example pairs are {(12,13 ) , ( 14,15)} in Figure 3 . The algorithm
Figure 4 : GreedyTree works by expanding a tree structure , where each tree edge is annotated with an edge type , and each tree node stores a list of node pairs with their BPCRW values and a priority score S . Here , the list stores tuples in the form(u,v),σ ( u,v | Π)ff where ( u,v ) represents a path in the graph by its starting and current graph nodes , respectively ; Π is the edge only meta path starting from u to v . The edges of the tree are edge types in the graph . σ ( u,v | Π ) is the BPCRW score for this meta path . We compute the value of S as a heuristic on the correlation value , as follows :
∑u+ σ ( u,v | Π)· r(u,∗ )
∑u σ ( u,v | Π)2 ×|r| · β L ,
S =
( 3.3 ) where r is the current residual vector , u+ signifies the starting node u in ( u,v ) which belongs to positive examples ( for instance , u+ ∈ {1,3} in Figure 4 ) , and r(u,∗ ) is the largest value in the residual vector for example pairs starting from u ( initially r(u,∗ ) = 1 ) . β is a decay factor ranging from 0 to 1 , and L is the length of current meta path . Unlike the homogeneous graph , there is no guarantee that the current node is on the correct route to reach the target nodes of the example pairs . We add this decay factor β , to avoid the meta path expanding to an infinite length . As shown in Figure 4(a ) with β = 0.8 , initially the root of the GreedyTree contains all the starting nodes in the input example pairs , and has S = 04 After one step of moving in the graph in Figure 4 , it passes through three types of edges – citizenOf , hasChild , and memberOf – and generates three new tree nodes in the GreedyTree ( Figure 4(b) ) . It also computes the priority score and all the BPCRW values . Then , it greedily selects the tree node with the largest priority to expand – in this example , we continue to expand the node through hasChild−1 link , since it has the largest priority score S = 064
After this expansion , we see in Figure 4(c ) that ( 1,2 ) and ( 3,4 ) are already an input pair . Thus , we find a link only meta path Π : −−−−−→ ? hasChild−1 −−−−−−→ ? and we compute the actual value of the ? hasChild correlation , as well as the resulting vector m on example pairs . If this value of S is larger than the priority scores of the other two tree leaf nodes ( the upper bounds of their own correlations , ie , 0.32 ) , then Π is the best meta path currently found and is then returned along with its m vector . If other priority scores are larger , then we continue to expand the tree node with the largest score , and repeat this procedure until this condition is satisfied or the tree cannot be expanded .
We preserve the expanded tree structure for subsequent iterations of Algorithm 1 . Before resuming tree expansions , we need to first
1213141591011memberOfUSDPartyRPartycitizenOfBClintonBBushRReaganBFordmemberOfmemberOf(3,3)(12,12)(14,14)(1,1)1111S:04citizenOfhasChild(a)(u,v)BPCRWS : Priority ScoreStep 1(3,3)(12,12)(14,14)(1,1)1111S:04(3,11)(12,11)(14,11)(1,11)1111S:032(1,6)(3,7)(3,8)(1,5)05050505S:064(3,10)(12,9)(14,10)(1,9)1111S:032citizenOfhasChild(3,3)(12,12)(14,14)(1,1)1111S:04(3,11)(12,11)(14,11)(1,11)1111S:032(1,6)(3,7)(3,8)(1,5)05050505S:064(3,10)(12,9)(14,10)(1,9)1111S:032(3,4)(1,2)11S:036hasChild 1Node StructureStep 2Step 3(a)(b)(c ) update the priority scores of the leaf nodes , since the residual vector r has been changed by the addition of a new meta path feature . By a linear scan of the node pair list in a leaf node , we can efficiently compute the summation in Equation ( 3.3 ) , and update the value of S . Then , we continue to expand the tree starting from the node with highest S .
Algorithm 2 : GreedyTree(G,Λ,r ) Input : KB G , example pairs Λ , residual vector r Output : meta path Π having largest correlation with r , and its result vector m
Data : pattern tree T m(u,v ) ← σ ( u,v | Π ) ; if m has non zero entry then M.S ← cos(m,r ) ( Eq ( 3.1) ) ; if M.S ≥ maxT.lea f S then
M ← node with largest score S in T ; m ← {0 , . . . ,0} ; foreach tuple p in M do if p.(u,v ) ∈ Λ then
1 update priority scores of leaf nodes in T with r ; 2 while T can be expanded do 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 return Π,m
Π ← the meta path from root to M ; break ; foreach tuple p in M do else foreach out neighbor w of p.v on graph G do e ← link type from p.v to w ; if M has no child N linked by e then Π ← the meta path from root to N ; insert tuple(p.u,w),σ ( p.u,w | Π)ff to N ; create new child tree node N of M ; update N.S according to Eq ( 3.3 ) ;
We present the detailed steps of GreedyTree in Algorithm 2 . First , we check and update the priority scores of leaf nodes changed by new residual vector r ( Step 1 ) . Then , we expand the tree by moving to out neighbor nodes on the graph until a meta path can be found or the graph is completely traversed ( Steps 2–21 ) . We target the tree node with largest priority ( Step 3 ) and examine whether its tuples are example pairs ( Step 6 ) . If so , we store BPCRW scores in m ( Step 7 ) , compute the actual correlation value as M.S ( Step 9 ) , and determine if we have found a proper meta path ( Steps 10–12 ) . If no example pairs are encountered ( Step 13 ) , then we extend each node pair by moving to an out neighbor ( Step 15 ) . We insert this new pair with its BPCRW score to a child node ( Steps 17–20 ) , and update its priority score ( Step 21 ) . 3.3 Phase 2 : Node Class Generation
Existing methods ( eg , [ 10 , 20 ] ) often assume that each KB node has only one class . In complex and real KBs , nodes can have multiple classes . For instance , Barack Obama is not only a president , but also a lawyer and writer . As introduced , these node classes are organized in a hierarchy . For example , in Yago ( see Figure 1 ) , Leader and Writer are subclasses of Person . This increases the number of possible paths for satisfying a meta path . In the previous section , the meta paths generated do not specify node classes . Here we present ways to assign node classes .
One option is to simply disregard the node classes . So the meta path contains only edge types generated in Phase 1 , without any node class constraints . However , the link only meta path is generally too common in a large KB , thus introducing more false positive results . For instance , ? liveIn−−−→ ? is a much more common meta path than Scientist liveIn−−−→ CapitalCity . Since link only meta paths are less specific to input pairs , they will eventually impair the result quality .
A better method is to choose the classes which are the Lowest Common Ancestor ( LCA ) in the type hierarchy . For instance , in Figure 1(a ) , the LCA of USPresident and Writer is Person . Another example is that the LCA of Harvard and Yale is IvyLeague . This way , if given some pairs of persons who graduated from Harvard and Yale , we can generate meta paths showing they both graduated from IvyLeague . Thus , for every KB node satisfying a certain meta path node , we generate LCAs for all its possible classes , and use them in the model . The LCAs of KB nodes can simply be recorded in each node of the GreedyTree . Thus , while we expand the GreedyTree , we just need to find the LCA of the current node and its parent node . This approach has the advantage of preserving the same weights as the ones trained in Algorithm 1 , at the cost of only a bottom up traversal in the class hierarchy .
Finally , we can combine the score of the classes on the hierarchy tf ( ϕ ) in a tf idf like manner , for a given label ϕ : score(ϕ ) = logof ( ϕ ) , where tf ( ϕ ) is the count , or frequency , of the label ϕ in the positive examples , and of ( ϕ ) the overall count of ϕ in the entire KB .
For instance , in the first node of the GreedyTree in Figure 4 , tf ( USPresident ) is 2 since it contains nodes 1 and 3 – as the labels of nodes can be easily obtained from the type hierarchy in Figure 1(a ) . On the other hand , of ( USPresident ) is 42 , since there are 42 nodes which have label USPresident in the entire KB , and then score(USPresident ) = 1.23 , which is much higher than other labels for these example nodes . In terms of performance , of can be easily pre computed by counting all the labels in the HIN , as a pre processing step .
We show in the next section that this selection mechanism im proves considerably the accuracy of the similarity model .
4 . EXPERIMENTS Datasets and setup . In this section , we perform experiments on two representative datasets for online HIN : DBLP and Yago .
DBLP [ 11 ] is a bibliographic information network which is frequently used in the study of heterogeneous networks . Our dataset [ 20 , 25]is a subset containing scientific papers in four areas : databases , data mining , artificial intelligence , and information retrieval . The dataset has four classes of nodes : Paper , Author , Topic , and Venue . It also has four edge types : authorOf , publishedIn , containsTopic , and cites . It contains 14,376 papers , 14,475 authors , 8,920 topics , and 20 venues . There are 170,794 links in total .
Yago is a large scale knowledge base derived from Wikipedia , WordNet , and GeoNames [ 17 ] . In our experiments , we use the “ CORE Facts ” part of this dataset , which contains 4 million facts ( network links ) of 125 types , made from 2.1 million entities . These entities have 365,000 node classes , organized in a hierarchy tree . A fact is a triple of the form : ( Entity , relationship , Entity ) , eg , ( Barack Obama , hasChild , Malia Obama ) .
We validate our algorithm ’s efficiency and effectiveness mainly by performing link prediction tasks ( additional experiments on rule mining and a user study are also presented at the end of this section ) . We stress that our models are not only usable for link prediction , but for a variety of other tasks , such as search and similarity joins . We chose link prediction for the evaluation because it provides for a measurable and objective way to evaluate the similarity models and algorithms .
For a certain type of link in Yago , for instance citizenOf , we remove all such links and try to predict them with the model that our FSPG algorithm learns . We randomly select a number of pairs of objects as training data , and validate the model using a test set of an equal number of pairs . In our experiments , we set the value of ε in Algorithm 1 to 001 We have found that even low values of
Table 1 : 5 most relevant meta paths for Yago citizenOf meta path
Person bornIn−−−−→ City locatedIn
−−−−−→ Country
Person livesIn−−−→ Country
Person graduateOf
−−−−−−−→ University locatedIn
−−−−−→ Country
Person diedIn−−−→ City locatedIn happenedIn−1 −−−−−−−−→ Event
−−−−−→ Country happenedIn
−−−−−−−→ Country
Person bornIn−−−−→ City w
5.477 0.361 0.023 0.245 0.198 this parameter allow for a reasonable number of features selected , usually lower than 20 . If ε is set to a higher value , the models will be smaller but also less accurate . We compared FSPG with PCRW to models which generate paths of finite length in {1,2,3,4} , as used in [ 10 ] . The PCRW models use the logistic regression model to combine these meta paths , in order to be coherent with previous work in the area and to allow fair comparisons . For node class selection ( Section 3.3 ) , we use the LCA of entities’ classes . Finally , unless otherwise specified , the similarity function was BPCRW with a value for α of 05 We found this value approximates both PC and PCRW well , and also that it helps to keep the vector of meta path similarity values normalized . We use β as 0.6 in GreeyTree to avoid the meta path expanding infinitely . Effectiveness . We present in Figure 5 the results for link prediction for three types of links : citizenOf and advisorOf for Yago , and authorOf for DBLP . For each of these links , we generated 100 training and 100 test pairs , as described above . Each figure shows the Receiver Operating Characteristic ( ROC ) curve , where the larger area signifies a larger accuracy in prediction .
The figure shows that fixed length PCRW suffers from several issues . When the maximum length is too small ( 1 or 2 ) , meta paths cannot connect example pairs , and as such the model is not better than a random guess and the model will have low recall . When the maximum length is too big , the model introduces too many meta paths . For length 3 , there are 135 meta paths , and over 2,000 for length 4 . In DBLP , length 4 ( measured by link hop ) metapaths – equivalent to the method presented in [ 20 ] – for authorship prediction work poorly when training pairs are randomly chosen , due to the low number of paths connecting them .
FSPG is clearly better in predicting the links , and it generates only a limited number of meta paths . For instance , the citizenOf link in Yago has a model of only 15 meta paths . Moreover , these meta paths are highly relevant and serve as good explanation of the similarity links . Table 1 shows the most relevant 5 meta paths for the citizenOf similarity model . Unsurprisingly , the meta path illustrating the fact that a person has been born in a city of a country is the best predictor of citizenship , but other , longer , paths are also highly relevant . Compared with PCRW with maximum length 2 , it has higher recall because it also detected longer important meta paths , −−−−−−−→ for instance , Person bornIn−−−−→ City happenedIn Country . We found that in Yago some facts are missing . For −−−−−→ France is instance , a fact denoted by the direct link Paris locatedIn missing . 2 In this case , our algorithm can be useful to predict it via −−−−−−−→ Country . longer paths , such as City Whereas considering direct links is widely done when querying ontologies , multi hop meta paths can in some cases improve query result accuracy . For instance , in citizenOf prediction ( Figure 5 ) , only one type of direct links between people and country exists , namely , 2Although other 2 hop links from Paris to France exist , they were not −−−−−−−→ Country . ranked as high as City happenedIn−1 −−−−−−−−→ Event happenedIn−1 −−−−−−−−→ Event happenedIn−1 −−−−−−−−→ Event happenedIn happenedIn liveIn . As a result , most information in predicting the citizenship is lost when limiting to direct connections , causing low recall and AUC score . For advisorOf prediction , there is even no direct link between the example pairs . This means resorting to multi hop meta paths is necessary . Efficiency . Figure 6 show the running time of FSPG compared to models with fixed length , and when varying the number of example pairs given as input . It can be observed that generally , the algorithm running time increases sub linearly in the number of example pairs . The increase is due to the PCRW random walks which need to be performed concurrently for each example pair , but the number of meta paths in the model does not increase at the same rate .
In Yago , the algorithm performs better than models of paths longer than 2 by a factor of up to 2 orders of magnitude . However , the models of short path length have limited predictive power , despite their better running time . In comparison , our algorithm is capable of finding even longer paths , for an increase in accuracy without much sacrifice in running time .
In DBLP , the running time of FSPG is comparable to length 5 for smaller test set sizes , and comparable to length 4 for larger example set sizes . This is not unexpected , considering that the DBLP KB is very small in size – both as number of types and as graph size – and fixed length models will have reasonably sized number of features . However , even if the running time is worse , we already saw that FSPG on DBLP has generally better accuracy , making it very useful even in very small KBs . Input set size and precision@k . We turn now to evaluating the influence of the input set size on the accuracy of the models . We compare in terms of Area Under the Curve ( AUC ) two methods , our FSPG algorithm and PCRW of length 2 . We chose length 2 because it was consistently the best performer out of all fixed length models in Yago . The evaluation was done on the same Yago node classes , advisorOf and citizenOf . In Figure 7 and Figure 8 , “ a FSPG" represents the advisorOf prediction using FSPG while “ c FSPG" represents for citizenOf prediction using FSPG . The same abbreviation rule also applies to “ a PCRW" and “ c PCRW" .
Figure 7 shows the results . It can be seen that the set size does not greatly influence the accuracy of the model , which suggests that even in more realistic scenarios in which users or experts give very few examples the models will be reliable . It can also be seen that FSPG keeps its advantage over PCRW of fixed length , regardless of the input set size . Please note that , for each positive input set size , we have generated an equal number of negative example using the methodology described before .
Figure 8 shows the difference between FSPG and PCRW of path length 2 , with an input set size of 100 negative and positive pairs , in the following scenario : we sort the results by their similarity and check the number of true positives at a given value of k in the sorted list . FPSG achieved considerably high precision of predicted pairs at low values of k , suggesting that this method is practically usable especially since similarity search results sets are usually low in numbers . For cases in which prediction is easy – eg , citizenOf – PCRW becomes competitive only at high values of k . This does not happen in the case of advisorOf , as it is harder to predict . Improving expert meta paths . Our method can also be used to improve on expert meta path models , and we show here how it behaves for authorship prediction in DBLP . In our experiments , we started from the meta paths defined by experts in DBLP , as explained in [ 20 ] . Starting from the already existing model of metapaths , we first build the corresponding GreedyTree , we compute the residual vector r and “ resume ” the execution of FSPG .
( a ) Yago citizenOf
( b ) Yago advisorOf
( c ) DBLP authorOf
Figure 5 : ROC for link prediction
( a ) Yago citizenOf
( b ) Yago advisorOf
( c ) DBLP authorOf
Figure 6 : Running time of FSPG
Figure 7 : AUC for varying number of example pairs
Figure 8 : Precision@k
Figure 9 : ROC of Expert
Figure 10 : ROC of label selection
( a ) advisorOf
( b ) citizenOf
( a ) advisorOf
( b ) citizenOf
Figure 11 : ROC of BPCRW for various α values
Figure 12 : ROC of HeteSim on a single meta path
00204060810020406081False Positive RateTrue Positive Rate FSPGPCRW1PCRW2PCRW3PCRW400204060810020406081False Positive RateTrue Positive Rate FSPGPCRW 2PCRW 3PCRW 400204060810020406081False Positive RateTrue Positive Rate FSPGPCRW 2PCRW 3PCRW 4PCRW 5102050100200102103104105106107Number of Example PairsRunning Time ( ms ) FSPGPCRW 1PCRW 2PCRW 3PCRW 4102050100200103104105106107Number of Example PairsRunning Time ( ms ) FSPGPCRW 2PCRW 3PCRW 4103050100101102103104105106Number of Example PairsRunning Time ( ms ) FSPGPCRW 2PCRW 3PCRW 4PCRW 50204060801000020406081Training Data SizeAUC Score a FSPGc FSPGa PCRWc PCRW0204060801000020406081TOP KPrecision a FSPGc FSPGa PCRWc PCRW00204060810020406081False Positive RateTrue Positive Rate FSPGExpertFSPG+Expert000200400600801001020304050607False Positive RateTrue Positive Rate Without NodeLCATFOF000100200300102030405False Positive RateTrue Positive Rate 003050810020406081x 10 3002040608False Positive RateTrue Positive Rate 003050810000200040006000800100050101502025False Positive RateTrue Positive Rate HeteSimBPCRW0020406081x 10 30005010150202503035False Positive RateTrue Positive Rate HeteSimBPCRW We show the resulting ROC curves in Figure 9 . It can be seen that starting from expert meta paths slightly improves the accuracy of FSPG , but greatly improves the accuracy of the expert only model . This is because the algorithm is able to generate relatively long metapaths , which are missed by experts , as partially shown in Table 2 . This result shows that the algorithm can readily be employed as an expert tool , to suggest meta paths which might be missed by experts . Class label selection . Figure 10 shows the accuracy of our model , depending on which class selection from Section 3.1 is chosen . Each training set was generated as before , with corresponding negative pairs . It can be seen that not restricting the class nodes on meta paths significantly impacts the accuracy . The tfof method of generating class labels is better for high precision queries , but LCA is better than it for higher recall rates . Influence of α . To illustrate the difference between the choice of α values , we illustrate in Figure 11 their power in predicting links of Yago , given a value of α for the BPCRW , for two types of links : advisorOf and citizenOf . The choice of α has a considerable impact on the link effectiveness . It also shows that – even in the same knowledge base – there is no single choice of α which always “ wins ” over the other similarity models , and it highly depends on the example pairs being given by users . For instance , the best value for advisorOf seems to be 0.8 , while for citizenOf it is 1 because they have the largest AUC score .
Due to the low running times of FSPG the best value of α can simply be generated by a loop over reasonable values of α increments , eg , every 0.1 , and choosing the model which has the best fit with the training pairs . HeteSim . Figure 12 compares BPCRW and HeteSim [ 15 , 16 ] in terms of relationship prediction . As explained in Section 2.2 , HeteSim is not supported in FSPG , and we study HeteSim on one single meta path only . We select Person bornIn−−−−→ City locatedIn −−−−−→ Country for citizenship prediction , since it is the most important meta path −−−−−−−−→ graduateFrom ( Table 1 ) . For advisor prediction , we use Person University workAt−1 −−−−−−→ Scientist , since it is also the most important one as found from another experiment . We observe that BPCRW is comparable to HeteSim . Moreover , the prediction quality is much worse using a single meta path than considering multiple meta paths . In Figure 5 , for citizenship prediction , using a single meta path yields 34 % recall , while using multiple meta path generates 65 % recall . This shows why it is important to use multiple meta paths , as adopted by our approach . AMIE . The FSPG method can also be used for mining association rules in heterogeneous graphs , since the meta paths associated to a given node pair can be interpreted as an association rule for that pair . To evaluate this use case , we compare FSPG with AMIE , which is used to generate association rules in knowledge bases .
We generate the association rules for the citizenOf , advisorOf and ivyLeagueAlumnus links 3 , and show the ROC curve results in Figure 13 . We first evaluate the association rules by performing link prediction , ie , we use the association rules generated by AMIE and combine them through logistic regression – just as with the paths generated with FSPG . Our method shows generally better ROC curves for citizenOf and advisorOf . For citizenOf , AMIE produces 8 association rules , while FSPG can produce 3 more association rules −−−−−→ Object . locatedIn such as Object For advisorOf , AMIE produces 4 association rules and FSPG 3This link does not exist in YAGO . We simulate it by creating a link between every pairs of graduates from Ivy League universities .
−−−−−→ Object locatedIn
−−−−−→ Object wasBorn
Table 3 : Missed association rules in AMIE for advisorOf meta path Person influence−1 −−−−−−−→ Person
Person diedIn−−−→ City diedIn−1
Person workAt−−−−→ University Person liveIn−−−→ Country isCitizenOf−1 −−−−−→ Object worksAt graduatedFrom
−−−−−→ Person −−−−−−−−−→ Person −−−−−−−−→ Person
−−−−−−−−−→ Object . graduatedFrom adds 4 more , such as Object Table 3 shows other association rules missed by AMIE and generated by FSPG for advisorOf .
However , the most important advantage for FSPG lies in its ability to generate rules for the personalized case , where few pairs are given as input . We illustrate this on the link ivyLeagueAlumnus – which does not exist in YAGO . We input these pairs connected by this virtual link ivyLeagueAlumnus . AMIE will look for global rules , and thus generates general rules which fail to distinguish Ivy League alumni from the alumni of any other university . In contrast , our method achieved a ROC of 0.989 , and was able to generate more specific association rules such as −−−−−−−−→ IvyLeague graduateFrom −−−−−−−→ Organization isAffiliatedTo graduateFrom−1 −−−−−−−−−→ Object or isAffiliatedTo−1 −−−−−−−−−→ Object .
Object User study . Finally , we conduct a user study to determine whether meta paths learned by FSPG are of interest to users .
Object
We use the data from the Time Magazine ’s “ 100 Most Important People of the 20th Century ” [ 21 ] . Ten volunteers , who are students and research assistants of the CS department of HKU , are asked to select pairs of similar persons . The volunteers have selected 10 pairs of people which are similar , eg , pairs such as ( Franklin D . Roosevelt , Theodore Roosevelt ) and ( Mao Zedong , Ho Chi Minh ) . Based on the input pairs , we use FSPG to generate the meta paths . After the model is trained , we shuffle the most relevant meta paths with randomly selected , but reasonable , meta paths and ask the same volunteers to rank them into three categories : Relevant , Somewhat Relevant , Not Relevant . We assign each answer a point value of 1 for Relevant , 0.5 for Somewhat Relevant and 0 for Not Relevant . We then average the ranking over all question for the FSPG returned meta paths and the most well ranked random meta path for each question . The FSPG generated meta path score average was 0.471(σ = 0.229 ) and for the random paths it was 0.285(σ = 0100 ) Statistical significance was estimated using the one tailed Student ’s t test , yielding a p value of 009 This value is satisfactory , taking into account the fact that the users were not always familiar with the historical figures .
At a qualitative level , the result also showed that our generated meta paths rank consistently higher than the random meta paths . For instance , the most important meta path between Franklin D . Roosevelt and Theodore Roosevelt is A isPoliticianO f −1 −−−−−−−−−→ B , and the most important meta path between Mao Zedong and Ho Chi Minh is A
−−−−−−−−→ country isPoliticianO f in f luence−1 −−−−−−−→ person
−−−−−→ B . in f luence
5 . RELATED WORK Knowledge bases . Yago [ 17 ] is a semantic knowledge base derived from Wikipedia , with more than 10 million entities ( or nodes ) of different types . Links among these entities represent more than 120 million facts about them . Constructed from Wikipedia and the Web in a similar way , DBpedia [ 2 ] is another widely used knowledge base . Since both entities and links have a variety of types , a simple homogeneous graph ( with only one type of node
Table 2 : Missed meta paths by experts in DBLP authorship prediction meta path
Author
−−−−−→ Paper authorO f publishedIn−1 −−−−−−−−→ Paper containsTopic−1 −−−−−−−−−→ Paper cites−−→ Paper cites−−→ Paper authorO f −1 −−−−−−−→ Author authorO f −1 −−−−−−−→ Author
−−−−−−−−→ Topic containsTopic containsTopic−1 −−−−−−−−−→ Paper authorO f −1 −−−−−−−→ Author
Author
Author
−−−−−→ Paper authorO f −−−−−→ Paper authorO f cites−−→ Paper cites−−→ Paper cites−−→ Paper −−−−−−→ Venue publishedIn
−−−−−−→ Venue publishedIn −−−−−−−−→ Topic containsTopic publishedIn−1 −−−−−−−−→ Paper
( a ) citizenOf
( b ) advisorOf
( c ) ivyLeagueAlumnus
Figure 13 : ROC of FSPG and AMIE or edge ) is unable to capture the rich information contained in a knowledge base .
Generating Meta Paths . The issue of generating good metapaths has not been satisfactorily addressed . A simple method is to first enumerate all possible meta paths , by traversing the schema graph [ 20 ] , and then use the paths as features to train a regression model that best fits the user provided example pairs . However , the cost of generating all path patterns is prohibitive when the number of node types and edge types is large . Second , the high dimensionality of the resulting data means that , for each feature and example pair , we need to generate the similarity measures by performing the random walks described in Section 22 Moreover , the number of features is highly likely to introduce noise due to the curse of dimensionality [ 6 ] . On the contrary , our method only generates relevant meta paths . The same authors in [ 20 ] also suggest to hire domain experts to define meta paths . As we have explained , this may not be feasible for very large HIN . Another problem with this approach is that the paths defined in this way are global . In our solution , users can participate in the process of generating metapaths by suggesting example pairs .
Another approach for generating meta paths is proposed by [ 10 ] . Their solution enumerate all the meta paths within a fixed length l . However , it is not clear how l should be set . More importantly , l can significantly affect the meta paths generated : ( i ) if l is large , then many redundant meta paths may be returned , leading to curse ofdimensionality effects ; and ( ii ) if l is small , important meta paths with length larger than l might be missed . Our experiments have shown that the running time of the meta path generation process grows exponentially with length l . Moreover , the accuracy can also drop with increase in l . Our solution does not require users to provide the value of l .
Link Prediction . Since the main focus of our work is to generate meta paths , we only use link prediction to quantify our advantage compared with the existing meta path generation methods , as demonstrated in Section 4 . Compared with [ 14 ] , our method predicts the relationship between different entities , rather than predicting the types of entities . [ 13 ] used the factorization of a three way tensor to perform relational learning ; it only considered simple node types and is not applicable to our experiment which has both complex node classes and edge types . Node similarity . To measure the proximity between graph nodes , neighborhood based metrics such as common neighbors and Jaccard ’s coefficient were proposed [ 12 ] . Other widely used graphtheoretic measures that are based on random walks between nodes include personalized PageRank [ 3 ] , SimRank [ 8 ] , hitting times [ 27 ] , and random walk with restart [ 22 ] . These measures do not consider the class labels of nodes and edges present in a HIN . Several similarity metrics have been designed for HIN : path count ( PC ) [ 19 ] and path constraint random walk ( PCRW ) [ 10 ] . We propose a general form of these two metrics , called the BPCRW . As discussed in Section 2.2 , PathSim [ 20 ] and HeteSim [ 15 , 16 ] are two other recently proposed meta path based measures . Query by example . We studied the problem of using example node pairs to generate meta paths . These node pairs can also be used to facilitate query evaluation . In [ 7 ] , Jayaram et al . examined how to find query graphs that can yield node pairs . It would be interesting to see how our meta path–based similarity metrics can be used to enhance their solutions . In [ 23 , 26 ] , the problem of generating queries from user provided example query results in a relational database was investigated . 6 . CONCLUSIONS
We examined the problem of generating meta paths from a given set of node pairs , using a general form of meta path based measures . We proposed the FSPG algorithm , and developed GreedyTree to facilitate its execution . Our experiments showed that FSPG generates important meta paths efficiently . In the future , we will study the theoretical feasibility of meta path selection for other non linear similarity functions . We will also examine query algorithms for similarity search and join on large HINs , based on meta path similarity measures . Acknowledgments Reynold Cheng , Silviu Maniu , Changping Meng , and Wangda Zhang were supported by RGC ( Project HKU 711110 ) and HKU ( Project 201311159095 ) . We thank the reviewers for their comments .
00204060810020406081False Positive RateTrue Positive Rate FSPGAMIE00204060810020406081False Positive RateTrue Positive Rate FSPGAMIE00204060810020406081False Positive RateTrue Positive Rate FSPGAMIE 7 . REFERENCES [ 1 ] E . Amaldi and V . Kann . On the approximability of minimizing nonzero variables or unsatisfied relations in linear systems . Theor . Comp . Sci . , 209(1 2 ) , 1998 .
[ 2 ] S . Auer , C . Bizer , G . Kobilarov , J . Lehmann , R . Cyganiak , and Z . Ives . DBpedia : a nucleus for a Web of open data . In The Semantic Web . Springer , 2007 .
[ 3 ] S . Chakrabarti . Dynamic personalized PagRank in entity relation graphs . In WWW , 2007 .
[ 4 ] B . Efron , T . Hastie , I . Johnstone , and R . Tibshirani . Least angle regression . Annals of Statistics , 32(2 ) , 2004 .
[ 5 ] L . A . Galárraga , C . Teflioudi , K . Hose , and F . Suchanek .
AMIE : Association rule mining under incomplete evidence in ontological knowledge bases . In WWW , 2013 .
[ 6 ] G . F . Hughes . On the mean accuracy of statistical pattern recognizers . IEEE Trans . Information Theory , 14(1 ) , 1968 .
[ 7 ] N . Jayaram , A . Khan , C . Li , X . Yan , and R . Elmasri . Querying knowledge graphs by example entity tuples . CoRR , abs/1311.2100 , 2013 .
[ 8 ] G . Jeh and J . Widom . SimRank : a measure of structural context similarity . In KDD , 2002 .
[ 9 ] D . Koller . Toward optimal feature selection . In ICML , 1996 . [ 10 ] N . Lao and W . W . Cohen . Relational retrieval using a combination of path constrained random walks . Mach . Learn . , 81(1 ) , 2010 .
[ 11 ] M . Ley . DBLP : some lessons learned . PVLDB , 2(2 ) , 2009 . [ 12 ] D . Liben Nowell and J . Kleinberg . The link prediction problem for social networks . J . Assoc . Inf . Sci . Technol . , 58(7 ) , 2007 .
[ 13 ] M . Nickel , V . Tresp , and H P Kriegel . A three way model for collective learning on multi relational data . In ICML , 2011 .
[ 14 ] M . Nickel , V . Tresp , and H P Kriegel . Factorizing YAGO : Scalable machine learning for linked data . In WWW , 2012 .
[ 15 ] C . Shi , X . Kong , Y . Huang , P . S . Yu , and B . Wu . Hetesim : A general framework for relevance measure in heterogeneous networks . TKDE , 2014 .
[ 16 ] C . Shi , X . Kong , P . Yu , S . Xie , and B . Wu . Relevance search in heterogeneous networks . EDBT , 2012 .
[ 17 ] F . M . Suchanek , G . Kasneci , and G . Weikum . Yago : A core of semantic knowledge . In WWW , New York , NY , USA , 2007 .
[ 18 ] L . Sun , R . Cheng , X . Li , D . W . Cheung , and J . Han . On link based similarity join . PVLDB , 4(11 ) , 2011 .
[ 19 ] Y . Sun , R . Barber , M . Gupt , C . Aggarwal , and J . Han .
Co author relationship prediction in heterogeneous bibliographic networks . In ASONAM , 2011 .
[ 20 ] Y . Sun , J . Han , X . Yan , P . S . Yu , and T . Wu . PathSim : Meta path based top k similarity search in heterogeneous information networks . PVLDB , 4(11 ) , 2011 .
[ 21 ] TIME . One Century , 100 Remarkable People . http://contenttimecom/time/specials/ packages/0,28757,2020772,00.html , 2008 .
[ 22 ] H . Tong , C . Faloutsos , and J Y Pan . Fast random walk with restart and its applications . ICDM , 2006 .
[ 23 ] Q . T . Tran , C Y Chan , and S . Parthasarathy . Query by output .
In SIGMOD , 2009 .
[ 24 ] K . S . Van Horn and T . R . Martinez . The minimum feature set problem . Neural Networks , 7(3 ) , 1994 .
[ 25 ] X . Yu , Q . Gu , M . Zhou , and J . Han . Citation prediction in heterogeneous bibliographic networks . In SDM , 2012 .
[ 26 ] M . Zhang , H . Elmeleegy , C . M . Procopiuc , and D . Srivastava . Reverse engineering complex join queries . In SIGMOD , 2013 . [ 27 ] W . Zhang , R . Cheng , and B . Kao . Evaluating multi way joins over discounted hitting time . ICDE , 2014 .
