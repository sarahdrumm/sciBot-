The K clique Densest Subgraph Problem
Charalampos E . Tsourakakis
Harvard School of Engineering and Applied Sciences babis@seasharvardedu
ABSTRACT Numerous graph mining applications rely on detecting subgraphs which are large near cliques . Since formulations that are geared towards finding large near cliques are NP hard and frequently inapproximable due to connections with the Maximum Clique problem , the poly time solvable densest subgraph problem which maximizes the average degree over all possible subgraphs “ lies at the core of large scale data mining ” [ 10 ] . However , frequently the densest subgraph problem fails in detecting large near cliques in networks .
In this work , we introduce the k clique densest subgraph problem , k ≥ 2 . This generalizes the well studied densest subgraph problem which is obtained as a special case for k = 2 . For k = 3 we obtain a novel formulation which we refer to as the triangle densest subgraph problem : given a graph G(V , E ) , find a subset of vertices S∗ such that t(S ) τ ( S∗ ) = max |S| , where t(S ) is the number of triangles S⊆V induced by the set S .
On the theory side , we prove that for any k constant , there exist an exact polynomial time algorithm for the kclique densest subgraph problem . Furthermore , we propose an efficient 1 k approximation algorithm which generalizes the greedy peeling algorithm of Asahiro and Charikar [ 8 , 18 ] for k = 2 . Finally , we show how to implement efficiently this peeling framework on MapReduce for any k ≥ 3 , generalizing the work of Bahmani , Kumar and Vassilvitskii for the case k = 2 [ 10 ] . On the empirical side , our two main findings are that ( i ) the triangle densest subgraph is consistently closer to being a large near clique compared to the densest subgraph and ( ii ) the peeling approximation algorithms for both k = 2 and k = 3 achieve on real world networks approximation ratios closer to 1 rather than the pessimistic 1 k guarantee . An interesting consequence of our work is that triangle counting , a well studied computational problem in the context of social network analysis can be used to detect large near cliques . Finally , we evaluate our proposed method on a popular graph mining application .
Copyright is held by the International World Wide Web Conference Committee ( IW3C2 ) . IW3C2 reserves the right to provide a hyperlink to the author ’s site if the Material is used in electronic media . WWW 2015 , May 18–22 , 2015 , Florence , Italy . ACM 978 1 4503 3469 3/15/05 . http://dxdoiorg/101145/27362772741128 .
Categories and Subject Descriptors G22 [ Graph Theory ] : Graph Algorithms ; H28 [ Database Applications ] : Data mining
General Terms Theory , Experimentation
Keywords Densest subgraph problem ; Graph algorithms ; Graph Mining ; Near clique extraction
1 .
INTRODUCTION
A wide variety of data mining applications relies on extracting dense subgraphs from large graphs . In bioinformatics dense subgraphs are used for detecting protein complexes in protein protein interaction networks [ 9 ] and for finding regulatory motifs in DNA [ 24 ] . They are also used for detecting link spam in Web graphs [ 26 ] , graph compression [ 17 ] and mining micro blogging streams [ 6 ] .
Among the various formulations for finding dense subgraphs , the densest subgraph problem ( DS Problem ) stands out for the facts that is solvable in polynomial time [ 28 ] and 1 2 approximable in linear time [ 18 , 40 ] . To state the DS Problem we first introduce the necessary notation . In this work we focus on simple unweighted , undirected graphs . Given a graph G = ( V , E ) and a subset of vertices S ⊆ V , let G(S ) = ( S , E(S ) ) be the subgraph induced by S , and let e(S ) = |E(S)| be the size of E(S ) . Also , the edge density of the set S is defined as fe(S ) = e(S)/,|S| 2 . The DS Problem maximizes the degree density e(S ) |S| over all subgraphs S ⊆ V . Notice that this is equivalent to maximizing the average degree1 . The DS Problem is a powerful primitive for many graph applications including social piggybacking [ 27 ] , reachability and distance query indexing [ 19 , 37 ] . However , a large number of applications aims to find subgraphs which are large near cliques rather than the subgraph that maximizes the average degree . Frequently the DS Problem fails in finding large near cliques because it favors large subgraphs with low high edge density fe . For
1 In graph theory the term edge density refers by default to fe = e(S)/,|S| 2 ∈ [ 0 , 1 ] . However , since direct maximization of fe is not a meaningful problem ( even a single edge achieves the maximum possible edge density ) , the DSProblem maximizes the average degree . In the following , we refer to the average degree of a set as its degree density . this reason other formulations have been proposed , see Section 2 . Unfortunately , these formulations are NP hard and also inapproximable due the connections with the Maximum Clique problem [ 32 ] .
The main contribution of this work is a family of tractable formulations which attacks efficiently the problem of extracting large near cliques and in contrast to well performing heuristics comes with strong theoretical guarantees . In detail , our contributions are summarized as follows . New formulation : We introduce the k clique densest subgraph problem ( k Clique DS Problem ) which generalizes the well studied DS Problem [ 18 , 25 , 28 , 40 ] . The goal is to maximize the average number of k cliques induced by a set S ⊆ V over all possible vertex subsets . Notice that the DS Problem is obtained as a special case for k = 2 . We introduce also the special case obtained for k = 3 as the triangle densest subgraph problem ( TDS Problem ) . Exact algorithms . We present two exact algorithms for the TDS Problem . The algorithm which achieves the best running time is based on maximum flow computations and uses O(n + t ) space . It is worth outlining that Goldberg ’s network construction for the DS Problem which uses O(n+ m ) space [ 25 , 28 ] does not generalize to the TDS Problem . The slower one is based on supermodular maximization and uses linear space O(n + m ) . Here , n , m , t are the number of vertices , edges and triangles in the input graph . Our algorithms can be modified to yield polynomial time algorithms for the k Clique DS Problem when k = Θ(1 ) . Approximation algorithm . We propose a 1 algorithm for the TDS Problem which runs asymptotically faster than any of the exact algorithms . We also propose a 3+3ǫ approximation algorithm for any ǫ > 0 which can be implemented efficiently in MapReduce . The algorithm requires O(log(n)/ǫ ) rounds and is MapReduce efficient [ 39 ] due to the existence of efficient MapReduce triangle counting algorithms , eg , [ 48 ] . Our algorithms can be adapted to the k Clique DS Problem for any k = Θ(1 ) . Experimental evaluation . We evaluate our exact and approximation algorithms on numerous real world networks . Among our findings , we observe that the optimal triangle densest subgraph is consistently closer to being a large nearclique compared to the optimal densest subgraph . For instance , in the Football network ( see Table 1 for a description of the dataset ) the DS Problem returns the whole graph as the densest subgraph , with fe = 0.094 whereas the TDSProblem returns a subgraph on 18 vertices with fe = 048 We also observe that the peeling approximation algorithms for both k = 2 and k = 3 achieve on real world networks approximation ratios closer to 1 rather than the pessimistic 1 k guarantee . Graph mining application . We propose a modified version of the TDS Problem , the constrained triangle densest subgraph problem ( Constrained TDS Problem ) , which aims to maximize the triangle density subject to the constraint that the output should contain a specified set of vertices Q . We show how to solve exactly the TDS Problem . This variation is useful in various data mining and bioinformatics tasks , see [ 49 ] .
1
3 approximation methods exists : heuristics [ 49 , 52 , 54 ] , algorithmic contributions on NP hard formulations [ 5 , 12 , 22 , 40 , 49 ] and poly time solvable formulations [ 18 , 40 , 49 ] . We focus on the latter . Densest Subgraph . In the densest subgraph problem we are given a graph G and we wish to find the set S ⊆ V which maximizes the average degree [ 28 , 38 ] . The densest subgraph can be identified in polynomial time by solving a maximum flow problem [ 25 , 28 ] . Charikar [ 18 ] proved [ 8 ] that the greedy algorithm proposed by Asashiro et al . produces a 1 2 approximation of the densest subgraph in linear time . Asashiro et al . study the complexity of finding dense subgraphs by introducing a generalization of the DSProblem and the maximum clique problem [ 7 ] . A k core is a maximal connected subgraph of G in which all vertices have degree at least k . It is worth remarking that the same algorithm provides a k core decomposition of the graph and solves the problem of finding the degeneracy [ 11 ] . In the case of directed graphs , the densest subgraph problem is solved in polynomial time as well [ 18 ] . Khuller and Saha [ 40 ] provide a linear time 1 2 approximation algorithm for the case of directed graphs among other contributions . Two interesting variations of the DkS problem were introduced by Andersen and Chellapilla [ 5 ] . The two problems ask for the set S that maximizes the density subject to |S| ≤ k ( DamkS ) and |S| ≥ k ( DalkS ) . When restrictions on the size of S are imposed the problem becomes NP hard [ 40 ] . Finally , the densest subgraph problem has been considered in various settings , including MapReduce [ 10 ] , the streaming [ 10 ] , the dynamic setting [ 21 , 45 ] and their combination recently [ 13 ] . Triangle Counting and Listing . The state of the art algorithm for exact triangle counting is due to Alon , Yuster 2ω and Zwick [ 4 ] and runs in O(m ω+1 ) , where currently the fast matrix multiplication exponent ω is 2.3729 [ 53 ] . Thus , their algorithm currently runs in O(m1.4081 ) time . The best known listing algorithm until recently was due to Itai and Rodeh [ 33 ] which runs in O(mα(G ) ) time , where α(G ) is the graph arboricity . Since α(G ) = O(√m ) , the running time is always O(m3/2 ) . Recently , Bj¨orklund , Pagh , Williams and Zwick gave refined algorithms which are output sensitive algorithms [ 14 ] . Finally a wealth of approximate triangle counting methods exist [ 35 , 41 , 44 , 51 ] .
3 . PROBLEM DEFINITION
We define the notion of average triangle density .
Definition 1
( Triangle Density ) . Let G(V , E ) be an undi rected graph . For any S ⊆ V we define its triangle density τ ( S ) as τ ( S ) = t(S ) s , where t(S ) is the number of triangles induced by S and s = |S| . Notice that 3τ ( S ) is the average number of ( induced ) triangles per vertex in S . The optimization problem we focus on follows .
Problem 1 subset of vertices S∗ such that τ ( S∗ ) = τ ∗ maxS⊆V τ ( S ) .
( TDS Problem ) . Given G(V , E ) , find a G =
G where τ ∗
2 . RELATED WORK
Since dense subgraph discovery constitutes a main research topic in graph analysis , a wide variety of related
It is clear that the DS Problem and the TDS Problem in general can result in radically different solutions . Consider for instance a graph G on 2n + 3 vertices which is the union of a triangle K3 and of a bipartite clique Kn,n . The optimal solutions of the DS Problem and the TDSProblem are the bipartite clique and the triangle respectively . Therefore , the interesting question is whether maximizing the average degree and the triangle density result in different results in real world networks . Our results in Section 5 indicate that the answer is positive since the triangle densest subgraph compared to densest subgraph is smaller which exhibits a stronger near clique structure .
4 . PROPOSED METHOD
Section 4.1 provides two algorithms which solve the TDSProblem exactly . Sections 4.2 and 4.3 provide two approximation algorithms for the TDS Problem . Finally , Section 4.4 provides a generalization of the DS Problem and the TDS Problem to maximizing the average k clique density and shows how the results from previous Sections adapt to this problem .
4.1 Exact Solutions
Let n , m , t be the number of vertices , edges and triangles in graph G respectively . The algorithm presented in Section 411 achieves the best running time . We present an algorithm which relies on the supermodularity property of our objective in Section 412 The latter algorithm , even if slower , requires O(n+m ) space , whereas the former O(n+t ) space . In real world networks , typically m ≪ t . Finally , it is worth mentioning that Charikar ’s linear program , see §2 in [ 18 ] , can be extended to a linear program ( LP ) which solves the TDS Problem , see [ 50 ] for the details . 411 An O,m3/2 + nt + min ( n , t)3 time exact solution Algorithm 1 triangle densest subgraph(G ) 1 : List the set of triangles T ( G ) , t = |T ( G)| 2 : l ← t 3 : S∗ ← ∅ 4 : while u ≥ l + 1 5 : 6 : Hα ← Construct Network(G , α,T ( G ) ) 7 : 8 : 9 : 10 : 11 : 12 : 13 : 14 : 15 : end while
α ← l+u ( S , T ) ← minimum st cut in Hα if S = {s} then else u ← α l ← α S∗ ← ,S\{s} ∩ V ( G ) end if Return S∗ n , u ← ( n−1)(n−2 )
2
6 n(n−1 ) do
Our main theoretical result is the following theorem . proof is constructive .
Its
Theorem 1 . There exists an algorithm which which solves the TDS Problem and runs in O,m3/2 + nt + min ( n , t)3time .
The first term O(m3/2 ) comes from using the Itai Rodeh algorithm [ 33 ] as our triangle listing blackbox . If we use the naive O(n3 ) triangle listing algorithm then the running time expression is simplified to O(n3 + nt ) . On the other hand , if we use the algorithms of Bj¨orklund et al . [ 14 ] the first term
Algorithm 2 Construct Network ( G , α,T ( G ) ) 1 : V ( H ) ← {s} ∪ V ( G ) ∪ T ( G ) ∪ {t} . 2 : For each vertex v ∈ V ( G ) add an arc of capacity 1 to each triangle ti it participates in . 3 : For each triangle ∆ = ( u , v , w ) ∈ T ( G ) add arcs to 4 : Add directed arc ( s , v ) ∈ A(H ) of capacity tv for each 5 : Add weighted directed arc ( v , t ) ∈ A(H ) of capacity 3α 6 : Return network H(V ( H ) , A(H ) , w ) , s , t ∈ V ( H ) . v ∈ V ( G ) . for each v ∈ V ( G ) . u , v , w of capacity 2 . becomes for dense graphs ˜O,nω+n3(ω−1)/(5−ω)t2(3−ω)/(5−ω)and for sparse graphs ˜O,m2ω/(ω+1 ) +m3 ω+1 , where ω is the matrix multiplication exponent . Currently ω < 2.3729 due to [ 53 ] . We maintain [ 33 ] as our black box to keep the expressions simpler . However , the reader should keep in mind that the result presented in [ 14 ] improves the total running time of the first term .
ω−1 ω+1 t
3−ω
We work our way to proving Theorem 1 by first proving the next key lemma . Then , we remove the logarithmic factor .
Lemma 1 . Algorithm 1 solves the TDS Problem and runs in O,m3/2 + ( nt + min ( n , t)3 ) log(n) time .
Algorithm 1 uses maximum flow computations to solve the TDS Problem . It is worth outlining that Goldberg ’s maximum flow algorithm [ 28 ] for the DS Problem is based on a network construction that does not adapt to the case of the TDS Problem . Algorithm 1 returns an optimal subgraph S∗ , ie , τ ( S∗ ) = τ ∗ . The algorithm performs a binary search on the triangle density value α . Specifically , each binary search query corresponds to querying does there exist a set S ⊆ V such that t(S)/|S| > α ? . For each binary search , we construct a bipartite network H by invoking Algorithm 2 . Let T ( G ) be the set of triangles in G . The vertex set of H is V ( H ) = {s}∪ A∪ B ∪{t} , where A = V ( G ) and B = T ( G ) . Notice that we overload the notation in order to use the frequently used notation for the sink vertex t . It should always be clear from the context to which entity ( number of triangles vs . sink vertex ) we refer to . For the purpose of finding T ( G ) , a triangle listing algorithm is required [ 14 , 33 ] . The arc set of graph H is created as follows . For each vertex r ∈ B corresponding to triangle ∆(u , v , w ) we add three incoming and three out coming arcs . The incoming arcs come from the vertices u , v , w ∈ A which form triangle ∆(u , v , w ) . Each of these arcs has capacity equal to 1 . The outgoing arcs go to the same set of vertices u , v , w , but the capacities are equal to 2 . In addition to the arcs of capacity 1 from each vertex u ∈ A to the triangles it participates in , we add an outgoing arc of capacity 3α to the sink vertex t . From the source vertex s we add an outgoing arc to each u ∈ A of capacity tv , where tv is the number of triangles vertex v participates in G . As we have already noticed , H can be constructed in O(m3/2 ) time [ 33 ] . It is worth outlining that after computing H for the first time , subsequent networks need to update only the arcs that depend on the parameter α , something not shown in the pseudocode for simplicity . To prove that Algorithm 1 solves the TDS Problem and runs in O,m3/2 + ( nt + min ( n , t)3 ) log(n) time we proceed in steps .
For the sake of the proof , we introduce the following definitions and notation . For a given set of vertices S let ti(S ) be the number of triangles that involve exactly i vertices from S , i ∈ {1 , 2 , 3} . Notice that t3(S ) is the number of induced triangles by S , for which we have been using the simpler notation t(S ) so far .
We use the following claim as our criterion to set the initial values l , u in the binary search . n ≤ τ ( S ) ≤ ( n−1)(n−2 ) Claim 1 . t The lower bound is obvious since τ ( V ) = t n . The upper bound also follows trivially by observing that τ ( S ) ≤ ,n 3 /n for any ∅ 6= S ⊆ V . This suggests that the optimal value τ ∗ is always O(n2 ) . The next claim serves as a criterion to decide when to stop for any S ⊆ V .
6 the binary search . Claim 2 The smallest possible difference among two distinct values τ ( S1 ) , τ ( S2 ) is equal to To see why , notice that the difference δ between two possible different triangle density values is n(n−1 ) .
1
δ = t(S1)|S2| − t(S2)|S1|
.
|S1||S2| n >
1
1
1
If |S1| = |S2| then |δ| ≥ 1 n(n−1 ) , otherwise |δ| ≥ |S1||S2| ≥ n(n−1 ) . Notice that combining the above two claims shows that the binary search terminates in at most ⌈4 log n⌉ queries . The following lemma is a structural lemma for the optimal s − t cut the network Hα .
Lemma 2 . Consider any minimum st cut ( S , T ) in the network Hα . Let A1 = S ∩ A , B1 = S ∩ B and A2 = T ∩ A , B2 = T ∩ B . The cost of the min cut is equal to
X v /∈A1 tv + 2t2(A1 ) + t1(A1 ) + 3α|A1| .
Proof . Case I : A1 = ∅ : In this case the proposition trivtv = 3t . It is worth ially holds , as the cost is equal to Pv∈A noticing that in this case B1 has to be also empty , otherwise we contradict the optimality of ( S , T ) . Hence S = {s} , T = A ∪ B ∪ {t} . Case II : A1 6= ∅ : Consider the cost of the arcs from A1∪B1 to A2 ∪ B2 . We consider three different subcases , one per each type of triangle with respect to set A1 . Type 3 : If there exist three vertices u , v , w ∈ A1 that form a triangle ∆(u , v , w ) , then the vertex r ∈ B corresponding to this specific triangle has to be in B1 . If not , then r ∈ B2 , and we could reduce the cost of the min cut by 3 , if we move the triangle to B1 . Therefore the cost we pay for triangles of type three is 0 .
Type 2 : Consider three vertices u , v , w such that they form a triangle ∆(u , v , w ) and u , v ∈ A1 , w ∈ A2 . Then , the vertex r ∈ B corresponding to this triangle can be either in B1 or B2 . In both cases we always pay 2 in the cut for each triangle of type two .
Type 1 : Finally , in the case u , v , w form a triangle , u ∈ A1 , v , w ∈ A2 the vertex r ∈ B corresponding to triangle ∆(u , v , w ) will be in B2 . If not , then it lies in B1 and we could decrease the cost of the cut by 3 if we move it in B2 . Hence , we pay 1 in the cut for each triangle of type one .
Therefore the cost due to the various types of triangles with respect to A1 is equal to 2t2(A1 ) + t1(A1 ) .
Furthermore , the cost of the arcs from source s to T is tv = Pv /∈A1 tv . The cost of the arcs from A1 equal to Pv∈A2 to T is equal to 3α|A1| . Summing up the individual cost terms , we obtain that the total cost is equal to Pv /∈A1 tv + 2t2(A1 ) + t1(A1 ) + 3α|A1| . The next lemma proves the correctness of the binary search in Algorithm 1 .
Lemma 3 . ( a ) If there exists a set W ⊆ V ( G ) such that t3(W ) > α|W| then any minimum st cut ( S,T ) in Hα satisfies S\{s} 6= ∅ . ( b ) Furthermore , if there does not exists a set W such that t3(W ) > α|W| then the cut ( {s} , A∪B∪{t} ) is a minimum st cut .
Proof . ( a ) Let W ⊆ V be such that t3(W ) > α|W| .
( 1 )
Suppose for the sake of contradiction that the minimum st cut is achieved by ( {s} , A ∪ B ∪ {t} ) . In this case the cost of the minimum st cut is Pv∈A tv = 3t . Now , consider the following ( S , T ) cut . Set S consists of the source vertex s , A1 = W and B1 be the set of triangles of type 3 and 2 induced by A1 . Let T be the rest of the vertices in H . The cost of this cut is cap(S , T ) = X v /∈A1 tv + 2t2(A1 ) + t1(A1 ) + 3α|A1| .
Therefore , by our assumption that the minimum st cut is achieved by ( {s} , A ∪ B ∪ {t} ) we obtain
3t ≤ X v /∈A1 tv + 2t2(A1 ) + t1(A1 ) + 3α|A1| .
( 2 )
Now , notice that by double counting tv = 3t3(A1 ) + 2t2(A1 ) + t1(A1 ) .
X v∈A1
Furthermore , we observe
X v∈A1 tv + X v /∈A1 tv = 3t .
By combining these two facts , and the fact that 3t is the capacity of the minimum cut , we obtain the following contradiction of Inequality ( 1 ) .
3t ≤ X v /∈A1 tv + 2t2(A1 ) + t1(A1 ) + 3α|A1| ⇔ t3(W ) ≤ α|W| .
( b ) By Lemma 2 , for any minimum st cut ( S , T ) the capacity of the cut is equal to Pv /∈A1 tv + 2t2(A1 ) + t1(A1 ) + 3α|A1| , where A1 = A∩ S , A2 = A∩ T . Suppose for the sake of contradiction that the cut ( {s} , A ∪ B ∪ {t} ) is not a minimum cut . Therefore , cap({s} , A∪B∪{t} ) = 3t > X v /∈A1 tv+2t2(A1)+t1(A1)+3α|A1| .
Using the same algebraic analysis as in ( a ) , the above statement implies the contradiction t3(W ) > α|W| , where W = A1 .
Now we can complete the proof of Lemma 1 .
Proof . The termination of Algorithm 1 follows directly from Claims 1 , 2 . The correctness follows from Lemmata 2 , 3 . The running time follows from Claims 1,2 which show that the number of binary search queries is O(log(n ) ) and each binary search query can be performed in O,nt + min ( n , t)3time using the algorithm due to Ahuja , Orlin , Stein and Tarjan [ 3]2 or Gusfield ’s algorithm [ 31 ] .
The proof of Theorem 1 follows from Lemma 1 and the fact that the parametric maximum flow algorithm of Ahuja , Orlin , Stein and Tarjan [ 3 ] , see also [ 25 ] , s(h)aves the logarithmic factor from the running time . 412 An O,(n5m1.4081 + n6 ) ) log(n) time exact soluIn this Section we provide a second exact algorithm for the TDS Problem . First , we provide the necessary theoretical background . tion
Definition 2
( Supermodular function ) . Let V be a finite set . The set function f : 2V → R is supermodular if and only if for all A , B ⊆ V f ( A ∪ B ) ≥ f ( A ) + f ( B ) − f ( A ∩ B ) .
A function f is supermodular if and only if −f is submodular .
Sub and supermodular functions constitute an important class of functions with various special properties . In this work , we are primarily interested in the fact that maximizing a supermodular function is solvable in strongly polynomial time [ 30 , 34 , 42 , 46 ] . For our purposes , we state the following result which we use as a subroutine in our proposed algorithm .
Theorem 2
( [43] ) . There exists an algorithm for maximizing an integer valued supermodular function f which runs in O,n5EO + n6) time , where n = |V | is the size of the ground set V and EO is the maximum amount of time to evaluate f ( S ) for a subset S ⊆ V .
We show in the following that when the ground set is the set of vertices V and fα : 2V → R is defined by fα(S ) = t(S ) − α|S| where α ∈ R+ , we can solve the TDS Problem in polynomial time .
Theorem 3 . Function f : V → R where f ( S ) = t(S ) −
α|S| is supermodular .
Proof . Let A , B ⊆ V . Let t : 2V → R be the function which for each set of vertices S returns the number of induced triangles t(S ) . By careful counting t(A∪B ) = t(A)+t(B)−t(A∩B)+t1(A : B\A)+t2(A : B\A ) , where t1(A : B\A ) , t2(A : B\A ) are the number of triangle with one , two vertices in A and two , one vertices in B\A respectively . Hence , for any A , B ⊆ V 2Notice that the network Hα has O(n + t ) arcs , therefore the running time of [ 3 ] is O(min ( n , t)(n + t ) + min ( n , t)3 ) = O(nt + min ( n , t)3 ) . t(A ∪ B ) + t(A ∩ B ) ≥ t(A ) + t(B ) and the function t is supermodular . Furthermore , for any α > 0 the function −α|S| is supermodular . Since the sum of two supermodular functions is supermodular , the result follows .
Theorem 3 naturally suggests Algorithm 3 . The algorithm will run in a logarithmic number of rounds . In each round we maximize function fα using Orlin Supermodular Opt which takes as input arguments the graph G and the parameter α > 0 [ 43 ] . We assume for simplicity that within the procedure Orlin Supermodular Opt function f is evaluated using an efficient exact triangle counting algorithm [ 4 ] . The algorithm of Alon , Yuster and Zwick [ 4 ] runs in O(m2ω/(ω+1 ) ) time where ω < 2.3729 [ 53 ] . This suggests the EO = O(m14081 ) The overall running time of Algorithm 3 is O,(n5m1.4081 + n6 ) log(n) and the space usage O(n + m ) rather than O(n + t ) .
Algorithm 3 triangle densest subgraph(G ) [ Supermodularity ]
, S∗ ← V
6 n(n−1 ) do
2
α ← l+u ( val , S ) ← Orlin Supermodular Opt(G , α ) if val < 0 then
1 : l ← 0 , u ← ( n−1)(n−2 ) 2 : while u ≥ l + 1 3 : 4 : 5 : 6 : 7 : 8 : 9 : 10 : 11 : 12 : end while u ← α l ← α S∗ ← S end if Return S∗ else
4.2 A 1
3 approximation algorithm
In this Section we provide an algorithm for the TDSProblem which provides a 1 3 approximation . Our algorithm follows the peeling paradigm , see [ 8 , 18 , 40 , 36 ] . Specifically , in each round it removes the vertex which participates in the smallest number of triangles and returns the subgraph that achieves the largest triangle density . The pseudocode is shown in Algorithm 4 .
Algorithm 4 Peel Triangles(G ) 1 : Count the number of triangles tv for each vertex v ∈ V 2 : Hn ← G 3 : for i ← n to 2 do 4 :
Let v be the vertex of Gi of minimum number of triangles
5 : Hi−1 ← Hi\v 6 : end for 7 : Return Hj that achieves maximum triangle density among His , i = 1 , . . . , n .
Theorem 4 . Algorithm 4 is a 1
3 approximation algorithm for the TDS Problem .
Proof . Let S∗ be an optimal set . Let v ∈ S∗,|S∗| = s∗ and tA(v ) be the number of induced triangles by A that v participates in . Then ,
τ ∗ G = t(S∗ ) s∗ ≥ t(S∗\{v} ) s∗ − 1 ⇔ tS∗ ( v ) ≥ τ ∗
G , since t(S∗\{v} ) = t(S∗ ) − tS∗ ( v ) . Consider the iteration before the algorithm removes the first vertex v that belongs in S∗ . Call the set of vertices W . Clearly , S∗ ⊆ W and for each vertex u ∈ W the following lower bound holds tW ( u ) ≥ tW ( v ) ≥ tS∗ ( v ) ≥ τ ∗ G due to the greediness of Algorithm 3 . This provides a lower bound on the total number of triangles induced by W t(W ) =
1 3 X u∈W tW ( u ) ≥
1 3|W|τ ∗
G ⇒ t(W )
|W| ≥
1 3
τ ∗ G .
To complete the proof , notice that the algorithm returns a subgraph S such that τ ( S ) ≥ τ ( W ) ≥ 1
3 τ ∗ G .
The key difference compared to the DS Problem peeling algorithm [ 18 ] is that when we remove a vertex , the counts of its neighbors may decrease more than 1 . Therefore , when vertex v is removed , we update the counts of its
2
time , by looking how many trian neighbors in O,deg(v ) gles each of its neighbors has after v is removed . Notice that O,Pv ,deg(v ) 4.3 MapReduce Implementation
= O(mn ) .
2
The MapReduce framework [ 20 ] has become the de facto standard for processing large scale datasets . In the following , we show how we can approximate efficiently the TDSProblem in MapReduce . Before we describe the algorithm , we show that Algorithm 5 for any ǫ > 0 terminates and provides a 3+3ǫ approximation . The idea behind this algorithm is to peel vertices in batches [ 10 , 29 ] rather than one by one .
1
Algorithm 5 Peel Triangles in Batches(G , ǫ > 0 ) 1 : Sout , S ← V 2 : while S 6= ∅ do 3 : A(S ) ← {i ∈ S : tS(i ) ≤ 3(1 + ǫ)τ ( S)} S ← S\A(S ) 4 : if τ ( S ) ≥ τ ( Sout ) then 5 : Sout ← S 6 : 7 : end if 8 : end while 9 : Return Sout .
Lemma 4 . For any ǫ > 0 , Algorithm 5 provides a
( 3+3ǫ ) approximation to the TDS Problem . Furthermore , it terminates in O(log1+ǫ(n ) ) passes .
1
Proof . Let S∗ be an optimal solution to the TDS Problem .
As we proved in Theorem 4 , for any v ∈ S∗ it is true that tS∗ ( v ) ≥ τ ∗ G . Furthermore , in each round at least one vertex is removed . To see why , assume for the sake of contradiction that A(S ) = ∅ for some S during the execution of the algorithm . Then , we obtain the contradiction that 3|S|τ ( S ) = Pv∈S tS(v ) ≥ ( 3 + 3ǫ)|S|τ ( S ) . Consider the round where the algorithm for the first time removes a vertex v ∈ S∗ . Let W be the corresponding set of vertices . Since v ∈ A(W ) is peeled off , we obtain an upper bound on its induced degree , namely v ∈ A(W ) ⇒ tW ( v ) ≤ ( 3 + 3ǫ)τ ( W ) . Since S∗ ⊆ W , we obtain
( 3 + 3ǫ)τ ( W ) ≥ tW ( v ) ≥ tS∗ ( v ) ≥ τ ( S∗ ) ,
( 3+3ǫ ) approximation to which proves that Algorithm 5 is a the TDS Problem . To see why the algorithm terminates in logarithmic number of rounds , notice that
1
3t(S ) > X v∈S\A(S ) tS(v ) ≥ ( 3 + 3ǫ),|S| − |A(S)| t(S )
|S| ⇔
ǫ
1 1 + ǫ|S| .
ǫ
rounds .
1 1+ǫ in each round , the algo
1 + ǫ|S| ⇔ |S\A(S)| ≤
|A(S)| ≥ Since S decreases by a factor of rithm terminates in O(log1+ǫ(n ) ) = O , log(n ) MapReduce Implementation : Now we are able to describe our algorithm in MapReduce . It uses any of the efficient algorithms of Suri and Vassilvitski [ 48 ] as a subroutine to count triangles per vertex in each round . The removal of the vertices which participate in less triangles than the threshold , is done in two rounds , as in [ 10 ] . For completeness , we describe the procedure here . The set of vertices S to be peeled off in each round are marked by adding a key value pair hv ; $i for each v ∈ S . Each edge ( u , v ) is mapped to hu ; vi . The reducer receives all endpoints of the edges incident with v and the symbol $ in case the vertex is marked for deletion . In case the vertex is marked , then the reduce task returns nothing , otherwise it copies its input . In the second round , we perform the same procedure with the only difference being that we map each edge ( u , v ) to hv ; ui . Therefore , the edges which remain have both endpoints unmarked . The algorithm runs in O(log(n)/ǫ ) , as it takes O(log(n)/ǫ ) peeling off rounds , and in each peeling round , constant number of rounds is needed to count triangles per vertex , mark vertices for deletion and remove the corresponding vertex set .
4.4 k clique Densest Subgraph
We outline that our proposed methods can be adapted to the following generalization of the DS Problem and the TDS Problem .
Definition 3
( k clique densest subgraph ) . Let G(V , E ) be an undirected graph . For any S ⊆ V we define its k clique density hk(S ) , k ≥ 2 as hk(S ) = ck(S ) , where ck(S ) is the number of k cliques induced by S and s = |S| . s
Problem 2 find a subset of vertices S∗ such that hk(S∗ ) = h∗ h∗ k = maxS⊆V hk(S ) .
( k Clique DS Problem ) . Given G(V , E ) , k where
As in the triangle densest subgraph problem , we create a network H parameterized by the value α on which we perform our binary search . The procedure is described in Algorithm 6 . The set C(G ) is the set of k cliques in G . We then invoke Algorithm 1 , with the upper bound u set to nk . Following the analysis of Theorem 1 , we see that the k CliqueDS Problem is solvable in polynomial time . For instance , using Gusfield ’s algorithm [ 31 ] or [ 3 ] in each binary search query we get an overall running time O,nk + ( n|C(G)| + n3 ) log(n) = O(nk+1 log(n) ) . Using the improved result due to Ahuja , Orlin , Stein and Tarjan for parametric max flows in unbalanced bipartite graphs [ 3 ] , we save the logarithmic factor in the running time .
Algorithm 6 Construct Network k ( G , α,C(G ) , k ) 1 : V ( H ) ← {s} ∪ V ( G ) ∪ C(G ) ∪ {t} . 2 : For each vertex v ∈ V ( G ) add an arc of capacity 1 to each k clique ci it participates in . 3 : For each k clique ( ui1 , . . . , uik ) ∈ C(G ) add arcs to 4 : Add directed arc ( s , v ) ∈ A(H ) of capacity cv for each 5 : Add weighted directed arc ( v , t ) ∈ A(H ) of capacity kα 6 : Return network H(V ( H ) , A(H ) , w ) , s , t ∈ V ( H ) . ui1 , . . . , uik of capacity k − 1 . v ∈ V ( G ) . for each v ∈ V ( G ) .
Furthermore , Algorithm 4 can also be modified , by removing in each round the vertex with the smallest number of kcliques , to obtain Corollary 2 . As the analogy of Theorem 4 .
Corollary 1 . The algorithm which peels off in each round the vertex with the minimum number of k cliques and returns the subgraph that achieves the largest k clique density , is a 1 k approximation algorithm for the k Clique DS Problem .
Similarly , Algorithm 5 and the MapReduce implementation can be modified to solve the k Clique DS Problem . We omit the details .
Corollary 2 . The algorithm which peels off in each round the set of vertices with less than k(1 + ǫ)h(S ) , where h(S ) is the k clique density in that round , terminates in O(log1+ǫ(n ) ) rounds and provides a k(1+ǫ ) approximation guarantee for the k Clique DS Problem . Furthermore , using [ 23 ] , we obtain an efficient MapReduce implementation .
1
We illustrate an example where choosing a larger k value yields benefits . Let G ∼ G(n , p ) be an Erd¨os R´enyi graph , where p = p(n ) . Assume that we plant a clique K of size nγ for some constant γ > 0 . We wish to show a non trivial range of p = p(n ) values such that the following conditions hold : h2(C ) = |E(K)| p(n 2 ) n = E [ h2(V ) ] , and for
( nγ 2 ) nγ < 2)(n k )
|K| = ( nγ k ) nγ > p(k n
= E [ hk(V ) ] . k ≥ 3 hk(C ) = By simple algebraic manipulation we see that p satisfies both ( 1−γ) 3 . Clearly , for conditions if O,n−(1−γ) < p < O,n− larger k values , we allow ourselves a larger range of p values for which we can find the hidden clique in expectation .
2 k
Our preliminary experimental results for k = 4 indicate that the 4 clique densest subgraph gets closer to a large nearclique compared to the triangle densest subgraph . However , the gain of moving from the densest subgraph to the triangle densest subgraph with respect to extracting large near cliques is larger than the gain of moving from the triangle densest subgraph to the 4 clique densest subgraph .
3 Notice that for this range of p , the graph is connected and the clique number is constant with high probability [ 15 ]
5 . EXPERIMENTAL EVALUATION
Before we present our findings in detail , we summarize them : ( i ) the TDS Problem and the proposed algorithms constitute new valuable graph mining primitives for finding large near cliques , ( ii ) the 1 3 approximation algorithm ( Algorithm 4 ) achieves significantly better approximations than the pessimistic 1 3 guarantee . Also it is significantly faster . ( iii ) Trying a small range of ǫ values for Algorithm 5 is in general a safer strategy compared to running experiments with fixed choice .
5.1 Experimental Setup
The datasets we use are shown in Table 1 . All graphs were made simple and undirected by ignoring the edge direction , when the graph is directed , and removing self loops and multiple edges , if any . The experiments were performed on a single machine , with Intel(R ) Core(TM ) i5 CPU at 2.40 GHz , with 3.86GB of main memory . We have implemented Algorithm 1 in Matlab R2011a using a maximum flow implementation due to Kolmogorov and Boykov [ 16 ] as our subroutine which runs in time O(t(n + t)3 ) . This implementation is prohibitively expensive even for small graphs which have a large number of triangles . We have coded the peeling algorithm in C++ using priority queues . As our triangle listing algorithm , we use the simple node iterator algorithm which checks for each vertex the number of edges among its neighbors . The code is publicly available at http://peopleseasharvardedu/~babis/codehtml We measure the quality of each extracted subgraph by two measures : the edge density of the extracted subgraph fe = e(S)/,|S| 2 and the output size |S| . Notice that when fe is close to 1 , the extracted subgraph is close to being a clique .
5.2 Main Findings
Table 2 shows the results obtained on several popular small and medium sized graphs . Each column corresponds to a dataset . The rows correspond to measurements for each method we use to extract a subgraph . Specifically , the first ( DS ) , second ( 1 2 DS ) , third ( TDS ) and fourth ( 1 3 TDS ) rows correspond to the subgraph extracted by Goldberg ’s exact algorithm [ 28 ] for the DS Problem , Charikar ’s 1 2 approximation algorithm [ 18 ] for the DS Problem , Algorithm 1 and Algorithm 4 for the TDS Problem respectively . For each optimal extracted subgraph S , we show its size as a fraction of the total number of vertices , the edge density fe(S ) , the average degree 2δ(S ) = 2e(S)/|S| and the average number of triangles per vertex 3τ ( S ) = 3t(S)/|S| . We observe that the triangle densest subgraph is closer to being a near clique compared to the densest subgraph . A pronounced example is the Football network where the optimal densest subgraph is the whole network with fe = 0.0094 , whereas the optimal triangle densest subgraph is a set of 18 vertices with edge density 048 Finally , we observe that the quality of Algorithm ’s 4 output is very close to the optimal solution and sometimes even better . The same observation holds for the case of Charikar ’s 1 2 approximation algorithm [ 18 ] .
We use the C++ implementation of Algorithm 4 and a C++ implementation of Charikar ’s 1 2 approximation algorithm on the rest of the datasets of Table 1 . The results are shown in Table 3 , up to two decimal digits of accuracy . The ca HepTh dataset is an exception , as the optimal solutions coincide . We also notice that the run times appear the same
Name Adjnoun AS 735 AS caida ca Astro ca GrQC ca HepTh Celegans DBLP Epinions Enron EuAll Football Karate Lesmis Political blogs Political books soc Slashdot0811 soc Slashdot0902 wb cs Stanford web Google web NotreDame Wiki vote
Nodes 112 6 475 26 475 17 903 4 158 11 204 297 53 442 75 877 33 696 224 832 115 34 77 1 490 105 77 360 82 168 8 929 855 802 325 729 7 066
Edges Description
425 Generated by processing text data
12 572 Autonomous Systems 53 381 Autonomous Systems
196 972 Co authorship 13 422 Co authorship 117 619 Co authorship
4 296 Neural network of C . Elegans
255 936 Co authorship 405 739 Social network 180 811 Email 339 925 Email
613 NCAA football game network
78
Social network
254 Generated by processing text data 16 715 Generated by processing sales data
441 Blog network
469 180 Person to Person 504 230 Person to Person
26 320 Web Graph 4 291 352 Web Graph 1 090 108 Web Graph
100 736 Wikipedia “ who votes whom ”
Table 1 : Datasets used in our experiments .
Method Measure Adjnoun Celegans
Football Karate
Lesmis Polblogs Polbooks
DS
|S| |V | ( % )
2δ fe 3τ
1 2 DS
|S| |V | ( % )
2δ fe 3τ
TDS
|S| |V | ( % )
2δ fe 3τ
1 3 TDS
|S| |V | ( % )
2δ fe 3τ
42.86 9.58 0.20 14 41.1 9.57 0.21 14.16 36.6 9.37 0.23 15 36.6 9.37 0.23 15
45.8 17.16 0.13 45.93 42.4 17.1 0.14 46.5 10.4 13.81 0.46 56.82
9.1
13.56 0.52 56.55
100 10.66 0.094 21.12 100 10.66 0.094 21.12 15.7 8.22 0.48 28 15.7 8.22 0.48 28
47.1 5.25 0.35 5.64 52.9 5.2 0.31 5.16 17.7 4.67 0.93 8.01 17.7 4.67 0.93 8.01
29.9 10.78 0.49 41.61 29.9 10.78 0.49 41.61 16.9 10.62 0.89 47.31 16.9 10.62 0.89 47.31
19.1 55.82 0.196 768.87
18.7 55.8 0.20 774.6
8.1
55.72 0.46
972.36
8.1
55.72 0.46
972.36
51.4 9.40 0.18 22.68 57.1 9.3 0.16 22.68 19.1 9.34 0.50 25.95 15.2 9.13 0.61 25.5
2 approximation algorithm ( 1
Table 2 : Comparison of the extracted subgraphs by the Goldberg ’s exact algorithm for the DS Problem ( DS ) , Charikar ’s 1 2 DS ) , our exact algorithm for the TDS Problem ( TDS ) and our 1 3 approximation algorithm ( 1 2 is the edge density of the extracted subgraph , 2δ(S ) = 2e(S)/|S| is the average degree and 3τ ( S ) = 3t(S)/|S| is the average number of triangles .
2 TDS ) . Here , fe(S ) = e(S)/,|S| for ca HepTh due to using two decimal digits of accuracy . On other datasets , we observe differences between the two solutions . For instance , for the collaboration network ca Astro the densest subgraph is a subgraph with 1 184 vertices and fe = 005 The triangle densest subgraph is a clique with 57 vertices . Overall , we verify the fact that the triangle densest subgraph is closer to being a near clique . Finally , the run times are shown . Notice that the run times reported for for Algorithm 4 include both the triangle counting and the peeling phase .
5.3 Exploring parameter ǫ in Algorithm 5
In this Section we present the results of Algorithm 5 on the DBLP graph . This is particularly interesting instance as it indicates that instead of trying to select a good ǫ value , it is worth trying out at least few values , assuming computational resources are available . We range ǫ from 0.1 to 1.8 with a step of 01 Figure 1(a ) plots the number of rounds Algorithm 5 takes to terminate as a function of ǫ . We observe that even for small ǫ values the number of rounds is 6 . The reader should compare this to the upper bound predicted by Lemma 4 which exceeds 100 . Figure 1(b ) plots the
6
4
2 s d n u o R
1
0.8
0.6
0.4
0.2
1
0.8
0.6
0.4
0.2
Rel . τ 1/(3+3ε )
Rel . f e
Rel . f t
0
0 0.2 0.4 0.6 0.8 1 1.2 1.4 1.6 1.8
ε ( a )
0 0 0.2 0.4 0.6 0.8 1 1.2 1.4 1.6 1.8
ε ( b )
0
0 0.2 0.4 0.6 0.8 1 1.2 1.4 1.6 1.8
ε ( c )
Figure 1 : Exploring the trade off between the number of rounds and accuracy as a function of the parameter ǫ for Algorithm 5 . Let S , S∗ be the extracted subgraphs by Algorithms 5 and 1 respectively . ( a ) Number of rounds , ( b ) relative average triangle density ratio τ ( S ) ( blue ∗ ) and the approximation guarantee 1/(3 + 3ǫ ) τ ∗ ( red ⋄ ) , and ( c ) relative ratios fe(S ) ft(S∗ ) as functions of ǫ . fe(S∗ ) , ft(S )
AS 735 AS caida ca Astro ca GrQC ca HepTh Epinions Enron EuAll soc Slashdot0811 soc Slashdot0902 wb cs Stanford web Google web NotreDame Wiki vote
1 2 DS fe 0.28 0.14 0.05 0.79
1
0.121 0.14 0.13 0.41 0.40 0.64 0.23 0.115 0.11
|S| 59 143 1 184
42 32 999 555 507 207 219 84 240 1 367 846
T
0.00 0.02 0.06 0.00 0.02 0.08 0.02 0.08 0.13 0.16 0.48 2.54 0.50 0.00
|S| 13 27 57 14 32 431 390 200 253 173 26 120 457 464
1 3 TDS fe 0.8 0.52
1
0.89
1
0.256 0.19 0.29 0.49 0.50 0.80 0.44 0.345 0.80
T
0.07 0.63 1.42 0.02 0.02 8.75 2.01 9.52 6.85 7.72 0.67 79.5 16.3 0.19
Table 3 : Comparison of the extracted subgraphs by the 1 2 approximation algorithm of Charikar and the 1 3 approximation algorithm , Algorithm 4 . The respective run times are shown in seconds . relative ratio Rel . τ = τ ( S ) rithm 5 . For convenience , the lower bound with red color .
τ ∗ where S is the output of Algo3+3ǫ is plotted
1
Besides the ratio fe(S ) ft(S∗ ) as a function of ǫ . Here ft(S ) = t(S ) ( |S| 3 ) fe(S∗ ) , figure 1(c ) plots also the relative . As we ratio ft(S ) observe , the quality of Algorithm 5 is close to the optimal solution except for ǫ = 0.7 and ǫ = 08 By inspecting why this happens we observe that the optimal triangle densest subgraph is a clique of 44 vertices . It turns out that for ǫ = 0.7 , 0.8 the optimal subgraph which is found in the last round of the execution of the algorithm ( the latter happens for all ǫ values ) consists of 98 and 74 vertices which contain as a subgraph the optimal K44 . For other values of ǫ , the subgraph in the last round is either the optimal K44 or close to it , with few more extra vertices . This example shows the potential danger of using a single value for ǫ , suggesting that trying out a small number of ǫ values can be significantly beneficial in terms of the approximation quality .
6 . APPLICATION : ORGANIZING COCKTAIL
PARTIES
A graph mining problem that comes up in various applications is the following : given a set of vertices Q ⊆ V , find a dense subgraph containing Q . We refer to this type of graph mining problems as cocktail problems , due to the following motivation , cf [ 47 ] . Suppose that a set of people Q wants to organize a cocktail party . How do they invite other people to the party so that the set of all the participants , including Q , are as similar as possible ? A variation of the TDS Problem which addresses this graph mining problem follows .
Problem 3
( Constrained TDS Problem ) . Given a graph G(V , E ) and Q ⊆ V , find the subset of vertices S∗ that maximizes the triangle density such that Q ⊆ S∗ ,
S∗ = arg max Q⊆S⊆V
τ ( S ) .
The Constrained TDS Problem can be solved by modifying our proposed algorithms accordingly . A useful corollary follows .
Corollary 3 . The Constrained TDS Problem is solvable in polynomial time by adding arcs from s to v ∈ A of large enough capacities , eg , capacities equal to n3 + 1 are sufficiently large . Furthermore , the peeling algorithm which avoids removing vertices from Q is a 1 3 approximation algorithm for the Constrained TDS Problem .
In the following we evaluate the 1
3 approximation algorithm on two datasets . The two experiments indicate two different types of performances that should be expected in real world applications . The first is a positive whereas the second is negative case . Both experiments here serve as sanity checks4 Political vote data . We obtain Senate data for the first session ( 2006 ) of the 109th congress which spanned the period from January 3 , 2005 to January 3 , 2007 , during the 4 For instance , by preprocessing the political vote data from a matrix form to a graph using a threshold for edge additions , results in information loss . fifth and sixth years of George W . Bush ’s presidency [ 1 ] . In this Congress , there were 55 , 45 and 1 Republican , Democratic and independent senators respectively . The dataset can be downloaded from the US Senate web page http://wwwsenategov We preprocess the dataset in the following way : we add an edge between two senators if among the bills for which they both casted a vote , they voted at least 80 % of the times in the same way . The resulting graph has 100 vertices and 2034 edges . We run the 1 3 approximation algorithm on this graph using as our set Q the first three republicans according to lexicographic order : Alexander ( R TN ) , Allard ( R CO ) and Allen ( R VA ) . We obtain at our output a subgraph consisting of 47 vertices . By inspecting their party , we find that 100 % of them are Republicans . This shows that our algorithm in this case succeeds in finding the large majority of the cluster of republicans . It is interesting that the 8 remaining Republicans do not enter the triangle densest subgraph . A careful inspection of the data , cf [ 2 ] , indicates that 6 republicans agree with the party vote on at most 79 % of the bills , and 8 of them on at most 85 % of the bills . DBLP graph . We input as a query set Q a set of scientists who have established themselves in theory and algorithm design : Richard Karp , Christos Papadimitriou , Mihalis Yannakakis and Santosh Vempala . The algorithm returns at its output the query set and a set S of 44 vertices corresponding to a clique of ( mostly ) Italian computer scientists . We list a subset of the 44 vertices here : M . Bencivenni , M . Canaparo , F . Capannini , L . Carota , M . Carpene , R . Veraldi , P . Veronesi , M . Vistoli , R . Zappi . The output graph induced by S ∪ Q is disconnected . Therefore , this can be easily explained because of the following ( folklore ) inequality , given that |Q| < |S| in our example .
Claim 1 . Let a , b , c , d be non negative . Then , max , a c
, b d ≥ a + b c + d ≥ min , a c
, b d
( 3 )
In our example , we get a = t(S ) , c = |S| , b = t(Q ) , d = |Q| . In such a scenario , where the output consists of the union of a dense subgraph and the query set Q , an algorithm which builds itself up from Q assuming Q is not an independent set to V by adding vertices which create as many triangles as possible and returning the maximum density subgraph , rather than peeling vertices from V down to Q should be preferred in practice , see also [ 49 ] .
7 . CONCLUSION
In this work we introduce the average triangle density as a novel objective for attacking the important problem of finding near cliques . We propose exact and approximation algorithms . Furthermore , our techniques can solve the more general problem of maximizing the k clique density . Experimentally we verify the value of the TDS Problem as a novel addition to the graph mining toolbox .
Our work leaves numerous problems open , including the following : ( a ) Can we obtain a faster exact algorithm by improving the space usage of the network construction ? ( b ) Can we use sparsification to obtain faster approximate solutions [ 44 ] ?
8 . REFERENCES [ 1 ] http://tinyurlcom/bwgpka 6
[ 2 ] http://tinyurlcom/zgdam 6 [ 3 ] R . K . Ahuja , J . B . Orlin , C . Stein , and R . E . Tarjan .
Improved algorithms for bipartite network flow . SIAM Journal on Computing , 23(5):906–933 , 1994 . 411 , 2 , 4.4
[ 4 ] N . Alon , R . Yuster , and U . Zwick . Finding and counting given length cycles . Algorithmica , 17(3):209–223 , 1997 . 2 , 412
[ 5 ] R . Andersen and K . Chellapilla . Finding dense subgraphs with size bounds . In WAW , 2009 . 2
[ 6 ] A . Angel , N . Sarkas , N . Koudas , and D . Srivastava . Dense subgraph maintenance under streaming edge weight updates for real time story identification . Proc . VLDB Endow . , 5(6):574–585 , Feb . 2012 . 1
[ 7 ] Y . Asahiro , R . Hassin , and K . Iwama . Complexity of finding dense subgraphs . Discr . Ap . Math . , 121(1 3 ) , 2002 . 2
[ 8 ] Y . Asahiro , K . Iwama , H . Tamaki , and T . Tokuyama .
Greedily finding a dense subgraph . J . Algorithms , 34(2 ) , 2000 . ( document ) , 2 , 4.2
[ 9 ] G . D . Bader and C . W . Hogue . An automated method for finding molecular complexes in large protein interaction networks . BMC bioinformatics , 4(1):2 , 2003 . 1
[ 10 ] B . Bahmani , R . Kumar , and S . Vassilvitskii . Densest subgraph in streaming and mapreduce . Proceedings of the VLDB Endowment , 5(5):454–465 , 2012 . ( document ) , 2 , 4.3 , 4.3
[ 11 ] V . Batagelj and M . Zaversnik . An O(m ) algorithm for cores decomposition of networks . Arxiv , arXiv.cs/0310049 , 2003 . 2
[ 12 ] A . Bhaskara , M . Charikar , E . Chlamtac , U . Feige , and
A . Vijayaraghavan . Detecting high log densities : an O(n1/4 ) approximation for densest k subgraph . In Proceedings of the 42nd ACM symposium on Theory of computing , pages 201–210 . ACM , 2010 . 2
[ 13 ] S . Bhattacharya , M . Henziger , D . Nanongkai , and
CE Tsourakakis . Space and time efficient algorithms for maintaining dense subgraphs on one pass dynamic streams . In Proceedings of the 47th ACM symposium on Theory of computing , 2015 2
[ 14 ] A . Bj¨orklund , R . Pagh , V . Williams Vassilevska , and
U . Zwick . Listing triangles . In Proceedings of 41st International Colloquium on Automata , Languages and Programming ( ICALP ) , 2014 . 2 , 411 , 411
[ 15 ] B . Bollob´as . Random graphs , volume 73 of Cambridge
Studies in Advanced Mathematics . Cambridge University Press , Cambridge , second edition , 2001 . 3
[ 16 ] Y . Boykov and V . Kolmogorov . An experimental comparison of min cut/max flow algorithms for energy minimization in vision . Pattern Analysis and Machine Intelligence , IEEE Transactions on , 26(9):1124–1137 , 2004 . 5.1
[ 17 ] G . Buehrer and K . Chellapilla . A scalable pattern mining approach to web graph compression with communities . In WSDM , pages 95–106 . ACM , 2008 . 1
[ 18 ] M . Charikar . Greedy approximation algorithms for finding dense components in a graph . In APPROX , 2000 . ( document ) , 1 , 2 , 4.1 , 4.2 , 4.2 , 5.2
[ 19 ] E . Cohen , E . Halperin , H . Kaplan , and U . Zwick .
Reachability and distance queries via 2 hop labels . In SODA , 2002 . 1
[ 20 ] J . Dean and S . Ghemawat . Mapreduce : simplified data processing on large clusters . Commun . ACM , 51(1):107–113 , Jan . 2008 . 4.3
[ 21 ] A . Epasto and S . Lattanzi and M . Sozio . Efficient
Densest Subgraph Computation in Evolving Graphs . WWW’15 ( to appear ) , 2015 . 2
[ 38 ] R . Kannan and V . Vinay . Analyzing the structure of large graphs , 1999 . 2
[ 39 ] H . Karloff , S . Suri , and S . Vassilvitskii . A model of computation for mapreduce . In SODA , pages 938–948 . Society for Industrial and Applied Mathematics , 2010 . 1
[ 40 ] S . Khuller and B . Saha . On finding dense subgraphs .
In ICALP , 2009 . 1 , 2 , 4.2
[ 22 ] U . Feige , G . Kortsarz , and D . Peleg . The dense
[ 41 ] M . N . Kolountzakis , G . L . Miller , R . Peng , and T . C . k subgraph problem . Algorithmica , 29(3 ) , 2001 . 2
[ 23 ] I . Finocchi , M . Finocchi , and E . G . Fusco . Counting small cliques in mapreduce . arXiv preprint arXiv:1403.0734 , 2014 . 2
[ 24 ] E . Fratkin , B . T . Naughton , D . L . Brutlag , and
S . Batzoglou . Motifcut : regulatory motifs finding with maximum density subgraphs . Bioinformatics , 22(14):e150–e157 , 2006 . 1
[ 25 ] G . Gallo , M . D . Grigoriadis , and R . E . Tarjan . A fast parametric maximum flow algorithm and applications . SIAM Journal on Computing , 18(1):30–55 , 1989 . 1 , 2 , 411
[ 26 ] D . Gibson , R . Kumar , and A . Tomkins . Discovering large dense subgraphs in massive graphs . In VLDB , 2005 . 1
[ 27 ] A . Gionis , F . Junqueira , V . Leroy , M . Serafini , and
I . Weber . Piggybacking on social networks . Proc . VLDB Endow . , 6(6):409–420 , Apr . 2013 . 1
[ 28 ] A . V . Goldberg . Finding a maximum density subgraph . Technical report , University of California at Berkeley , 1984 . 1 , 2 , 411 , 5.2
[ 29 ] M . T . Goodrich and P . Pszona . External memory network analysis algorithms for naturally sparse graphs . In Algorithms–ESA 2011 , pages 664–676 . Springer , 2011 . 4.3
[ 30 ] M . Gr¨otschel , L . Lov´asz , and A . Schrijver . Geometric algorithms and combinatorial optimization . Springer , Berlin , 1988 . 412
[ 31 ] D . Gusfield . Computing the strength of a graph . SIAM Journal on Computing , 20(4):639–654 , 1991 . 411 , 4.4 [ 32 ] J . Hastad . Clique is hard to approximate within n1−ǫ .
Acta Mathematica , 182(1 ) , 1999 . 1
[ 33 ] A . Itai and M . Rodeh . Finding a minimum circuit in a graph . SIAM Journal on Computing , 7(4):413–423 , 1978 . 2 , 411 , 411
[ 34 ] S . Iwata , L . Fleischer , and S . Fujishige . A combinatorial strongly polynomial algorithm for minimizing submodular functions . Journal of the ACM ( JACM ) , 48(4):761–777 , 2001 . 412
[ 35 ] M . Jha , C . Seshadhri , and A . Pinar . A space efficient streaming algorithm for triangle counting using the birthday paradox . In Proceedings of the 19th ACM SIGKDD international conference on Knowledge discovery and data mining , pages 589–597 . ACM , 2013 . 2
[ 36 ] J . Jiang , M . Mitzenmacher , and J . Thaler . Parallel peeling algorithms . arXiv preprint arXiv:1302.7014 , 2013 . 4.2
[ 37 ] R . Jin , Y . Xiang , N . Ruan , and D . Fuhry . 3 hop : a high compression indexing scheme for reachability query . In SIGMOD , 2009 . 1
E . Efficient triangle counting in large graphs via degree based vertex partitioning . Internet Mathematics , 8(1 2):161–185 , 2012 . 2
[ 42 ] L . Lov´asz . Submodular functions and convexity . In
Mathematical Programming The State of the Art , pages 235–257 . Springer , 1983 . 412
[ 43 ] J . B . Orlin . A faster strongly polynomial time algorithm for submodular function minimization . Mathematical Programming , 118(2):237–251 , 2009 . 2 , 412
[ 44 ] R . Pagh and CE Tsourakakis . Colorful triangle counting and a mapreduce implementation . Information Processing Letters , 112(7):277–281 , 2012 . 2 , 7
[ 45 ] A . D . Sarma , A . Lall , D . Nanongkai , and A . Trehan .
Dense subgraphs on dynamic networks . In Distributed Computing , pages 151–165 . Springer , 2012 . 2
[ 46 ] A . Schrijver . A combinatorial algorithm minimizing submodular functions in strongly polynomial time . Journal of Combinatorial Theory , Series B , 80(2):346–355 , 2000 . 412
[ 47 ] M . Sozio and A . Gionis . The community search problem and how to plan a successful cocktail party . In KDD , pages 939–948 . ACM , 2010 . 6
[ 48 ] S . Suri and S . Vassilvitskii . Counting triangles and the curse of the last reducer . In WWW , pages 607–614 . ACM , 2011 . 1 , 4.3
[ 49 ] CE Tsourakakis , F . Bonchi , A . Gionis , F . Gullo , and
M . ATsiarli Denser than the densest subgraph : extracting optimal quasi cliques with quality guarantees . In KDD , pages 104–112 . ACM , 2013 . 1 , 2 , 6
[ 50 ] C . E . Tsourakakis . A novel approach to finding near cliques : The triangle densest subgraph problem . arXiv preprint arXiv:1405.1477 , 2014 . 4.1
[ 51 ] C . E . Tsourakakis , M . N . Kolountzakis , and G . L .
Miller . Triangle sparsifiers . J . Graph Algorithms Appl . , 15(6):703–726 , 2011 . 2
[ 52 ] N . Wang , J . Zhang , K L Tan , and A . K . Tung . On triangulation based dense neighborhood graph discovery . Proceedings of the VLDB Endowment , 4(2):58–68 , 2010 . 2
[ 53 ] V . V . Williams . Multiplying matrices faster than coppersmith winograd . In STOC , pages 887–898 . ACM , 2012 . 2 , 411 , 412
[ 54 ] Y . Zhang and S . Parthasarathy . Extracting analyzing and visualizing triangle k core motifs within networks . In ICDE , pages 1049–1060 . IEEE , 2012 . 2
