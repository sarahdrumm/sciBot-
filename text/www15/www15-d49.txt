Towards Reconciling SPARQL and Certain Answers
Shqiponja Ahmetaj
TU Vienna ahmetaj@dbaituwienacat
Wolfgang Fischl
TU Vienna wfischl@dbaituwienacat
Reinhard Pichler
TU Vienna pichler@dbaituwienacat
Mantas Šimkus
TU Vienna simkus@dbaituwienacat
Sebastian Skritek
TU Vienna skritek@dbaituwienacat
ABSTRACT SPARQL entailment regimes are strongly influenced by the big body of works on ontology based query answering , notably in the area of Description Logics ( DLs ) . However , the semantics of query answering under SPARQL entailment regimes is defined in a more naive and much less expressive way than the certain answer semantics usually adopted in DLs . The goal of this work is to introduce an intuitive certain answer semantics also for SPARQL and to show the feasibility of this approach . For OWL 2 QL entailment , we present algorithms for the evaluation of an interesting fragment of SPARQL ( the so called well designed SPARQL ) . Moreover , we show that the complexity of the most fundamental query analysis tasks ( such as query containment and equivalence testing ) is not negatively affected by the presence of OWL 2 QL entailment under the proposed semantics .
Categories and Subject Descriptors H23 [ Database Management ] : Languages—Query Languages ; H25 [ Database Management ] : Heterogeneous Databases
General Terms Theory , Algorithms
Keywords SPARQL ; Certain Answers ; DL Lite ; Query Answering ; Query Rewriting ; Complexity
1 .
INTRODUCTION
In the recently released recommendation [ 12 ] , the W3C has defined various SPARQL entailment regimes to allow users to specify implicit knowledge about the vocabulary in an RDF graph ( see [ 10 ] for a tutorial ) . The theoretical underpinning to the systems for query answering under rich entailment regimes ( see eg[16 , 6 , 30 ] ) is provided by the big body of work on ontology based query answering , notably in the area of Description Logics ( DLs ) [ 3 ] . Superficially , query answering of basic graph patterns ( BGPs ) under an entailment regime looks exactly like answering conjunctive queries ( CQs )
Copyright is held by the International World Wide Web Conference Committee ( IW3C2 ) . IW3C2 reserves the right to provide a hyperlink to the author ’s site if the Material is used in electronic media . WWW 2015 , May 18–22 , 2015 , Florence , Italy . ACM 978 1 4503 3469 3/15/05 . http://dxdoiorg/101145/27362772741636 under the corresponding DL . However , there is a huge difference between the two in that SPARQL entailment regimes do not consider non distinguished variables :
Example 1 . Consider an RDF graph G containing a single triple ( b , a , Prof ) – stating that b is a professor – and an ontology O containing a single concept inclusion stating that every professor teaches somebody . In our notation introduced in Section 2 , this inclusion will be denoted as ( Prof , rdfs:sc,∃teaches ) . Now consider the following simple SPARQL query : SELECT ?x WHERE ( ?x , teaches , ?y).1 According to the SPARQL entailment regimes standard [ 12 ] , this query yields as result the empty set .
Clearly , the empty set as the result in the above example is rather unintuitive : by the inclusion ( Prof , rdfs:sc,∃teaches ) , we know for certain that b teaches somebody . However , the SPARQL entailment standard requires that all values assigned to any variable in the BGP must come from the RDF graph – thus treating distinguished variables ( which are ultimately output ) and non distinguished variables ( which are eventually projected out ) in the same way . In contrast , query answering in the DL world is based on the certain answer semantics . We thus consider the models of the database ( ie , the RDF graph ) and the ontology and we accept all those mappings as solutions that make the query true in every possible model . In the above example , every such model contains a triple ( b , teaches , u ) for some value u . Hence , even though there are distinct values u in different models , the projection onto the first component always yields the mapping µ = {?x → b} as an answer to the query .
Depending on the expressive power of a particular DL , query answering under the certain answer semantics may be computationally very expensive . Eg the problem is often 2EXPTIME complete for the so called very expressive DLs [ 21 , 11 ] . However , there exists a family of DLs with reasonable expressive power and very nice computational properties , namely the DL Lite family [ 7 ] . A member of this family is DL LiteR , which provides the theoretical underpinning of the OWL 2 QL entailment regime . Recall that – even without taking any DLs into account – answering CQs as well as basic query analysis tasks like testing containment or equivalence are NP complete [ 8 ] . Somehow surprisingly , this complexity does not increase if we consider CQ answering and CQ containment/equivalence under DL Lite [ 7 ] . In other words , the significant increase of expressive power has no serious effect on the complexity . The goal of this work is to introduce an intuitive certain answer semantics also for SPARQL under OWL 2 QL entailment with similarly favourable results as for CQ answering under DL Lite . 1Following [ 25 ] , we use a more algebraic style notation , denoting triples in parentheses with comma separated components rather than the blank separated turtle notation .
23 If we were contented with evaluating BGPs under OWL 2 QL according to the certain answer semantics , we could literally take over all results on CQ answering under DL Lite . But of course , there are more facets to SPARQL than just BGPs . A crucial extension of BGPs is given by the OPTIONAL operator ( henceforth referred to as OPT operator , for short ) . It allows one to express that a mapping should mandatorily bind some of the variables in the query and , if possible , it should be extended to further variables . If the extension is impossible , we simply keep the unextended mapping – but we do not dismiss it .
The OPT operator has an enormous impact on the complexity of query evaluation : indeed , even if SPARQL is restricted to the use of conjunction and the OPT operator , query evaluation is PSPACE complete [ 29 ] . In [ 25 ] , the authors therefore introduced well designed SPARQL as an interesting fragment where certain restrictions on the occurrence of variables are imposed . It is shown in [ 25 ] that for well designed SPARQL , the complexity of query evaluation drops from PSPACE completeness to coNP completeness . Moreover , as shown in [ 19 ] , well designed SPARQL queries have a very nice and intuitive representation by so called pattern trees , ie : rooted , unordered trees where the nodes are labelled with BGPs and the tree structure reflects the nesting of OPTs ( for details on well designed SPARQL and pattern trees , see Section 2 ) .
Recall that the natural definition of certain answers to a query is to collect all those mappings that are a solution in all possible models of the data and the ontology . As long as we restrict ourselves to answering conjunctive queries , this notion of certain answers is intuitive and constitutes the generally agreed semantics . In contrast , as soon as we extend CQs by the OPT operator , this approach turns out to be highly unsatisfactory , as the following example illustrates .
Example 2 . Consider the SPARQL query :
OPT ( ?y , knows , ?z )
SELECT ?x , ?z WHERE ( ?x , teaches , ?y ) over the graph G = {(b , teaches , c)} and empty ontology O . The query yields as only solution the mapping µ = {?x → b} . Clearly , also the graph G = G ∪ {(c , knows , d)} is a model of ( G,O ) . But in G , µ is no longer a solution since µ can be extended to solution µ = {?x → b , ?z → d} . Hence , there exists no mapping which is a solution in every possible model of ( G,O ) .
The reason for the unintuitive behaviour in the above example is the non monotonicity of the OPT operator . However , as observed in [ 2 ] , even if well designed SPARQL is non monotone , at least it is weakly monotone in the following sense : if a model M extends a model M by introducing additional facts , then every solution of a well designed SPARQL query Q in M can be extended to a solution of Q in M . Hence , the key idea for an appropriate definition of certain answers of well designed SPARQL under OWL 2 QL entailment will be to consider those mappings as certain which can be extended to a solution in all possible models of the RDF graph and the ontology . Actually , yet a further modification of the semantics definition will be required in order to arrive at a uniquely defined , intuitive semantics without resorting to bag semantics . The details are worked out in Section 3 .
The special behaviour of the OPT operator and the modification of the certain answer semantics require an adaptation and extension of the CQ answering algorithms for DL Lite . Moreover , also the complexity of query evaluation and of containment/equivalence testing for well designed SPARQL requires a new analysis in the presence of OWL 2 QL entailment . We shall show that , analogously to CQ answering under DL Lite , the additional expressive power due to OWL 2 QL entailment can be obtained without paying a price in terms of complexity .
Organization and main results . In Section 2 , we recall some basic notions and results . A conclusion and outlook to future work are given in Section 8 . Our main results are detailed in Sections 3 – 7 : • In Section 3 , we discuss the difficulties with a literal adoption of certain answer semantics in the presence of the non monotone OPT operator . To overcome these difficulties , we propose a modified definition of certain answers for well designed SPARQL queries . By relating the resulting semantics to SPARQL evaluation without entailment regimes we illustrate the naturalness of our definition . • Several adaptations and extensions of the rewriting based CQ evaluation under DL Lite [ 7 ] are needed in order to incorporate the OPT operator . In Sections 4 and 5 , we present two different approaches to answering well designed SPARQL queries under OWL 2 QL entailment : the first one proceeds in a modular way by rewriting each BGP individually . A new data structure – socalled guides – has to be introduced to ensure the consistency of local solutions for each BGP when combining them to a solution of the overall SPARQL query . Our second algorithm takes a holistic approach by rewriting the entire well designed SPARQL query at once . The CQ rewriting under DL Lite has to be significantly extended to take the peculiarities of the OPT operator into account . The two algorithms are discussed in Section 6 . • In Section 7 , we analyse the complexity of well designed SPARQL evaluation under OWL 2 QL entailment as well as the complexity of basic query analysis tasks such as query containment and query equivalence . We show that – analogously to CQs under DL Lite – the complexity remains essentially the same no matter whether we consider well designed SPARQL with or without OWL 2 QL entailment . Due to space limitations , we only give proof ideas of our results . All details will be provided in the full version of the paper .
2 . PRELIMINARIES RDF graphs and OWL 2 QL . We let U denote a countably infinite set of URIs . An RDF triple t is any tuple t ∈ U × U × U . An RDF graph G is any ( possibly infinite ) set G ⊆ U × U × U of triples . Note that we do not allow blank nodes , ie all RDF triples and graphs are ground . The active domain of an RDF graph G , denoted dom(G ) , is the set of all URIs that appear in G .
We next define membership and inclusion triples , which are special triples to enrich RDF graphs with OWL 2 QL or RDFS semantic information . Let C , A and R be countably infinite and mutually disjoint subsets of U that denote constants , atomic concepts ( aka classes ) and atomic roles ( aka properties ) , respectively . A basic role Q is either an atomic role from R or an expression R− , where R ∈ R . A basic concept B is either an atomic concept A ∈ A or an expression ∃Q , where Q is a basic role .
We further assume the dedicated URIs 2
“ a ” to assert membership of a constant in a concept ,
“ rdfs:sc ” to assert the inclusion relation between concepts ,
“ rdfs:sp ” to assert the inclusion relation between roles ,
“ owl:disjointWith ” to assert concept disjointness , and
“ owl:propertyDisjointWith ” to assert role disjointness .
2For the special RDF property rdf:type we use the common abbreviation “ a ” . For the RDFS properties rdfs:subClassOf and rdfs:subPropertyOf we use the abbreviations “ rdfs:sc ” and “ rdfs:sp ” , resp .
24 A membership assertion ( MA ) is any triple of the form ( c , a , B ) or ( c , Q , c ) , where c , c are constants from C , B is a basic concept and Q is a basic role . For a role R , we simplify ( R−)− to R . Given an RDF graph G , we write G |= ( c , Q , c ) if ( c , Q , c ) ∈ G or ( c , Q− , c ) ∈ G , G |= ( c , a , A ) if ( c , a , A ) ∈ G , and G |= ( c , a,∃Q ) if G |= ( c , Q , c ) for some c . inclusions .
We define the notion of
An RDFS inclusion is any triple having the form ( B , rdfs:sc , A ) or ( Q1 , rdfs:sp , Q2 ) , where B is a basic concept , A is an atomic concept , and Q1 , Q2 are basic roles . An OWL 2 QL inclusion is any RDFS inclusion or a triple of the form ( i ) ( B1 , rdfs:sc , B2 ) , ( ii ) ( B1 , owl:disjointWith , B2 ) or ( iii ) ( Q1 , owl:propertyDisjointWith , Q2 ) , where B1 , B2 are basic concepts and Q1 , Q2 are basic roles . Given an RDF graph G , we write G |= ( B1 , rdfs:sc , B2 ) if G |= ( a , a , B1 ) implies G |= ( a , a , B2 ) for any URI a , G |= ( Q1 , rdfs:sp , Q2 ) if G |= ( a , Q1 , b ) implies G |= ( a , Q2 , b ) for any pair a , b of URIs , G |= ( B1 , owl:disjointWith , B2 ) if G |= ( a , a , B1 ) implies G |= ( a , a , B2 ) for any URI a , and G |= ( Q1 , owl:propertyDisjointWith , Q2 ) if G |= ( a , Q1 , b ) implies G |= ( a , Q2 , b ) for any pair a , b of URIs . Concepts ∃Q in triples ( B , rdfs:sc,∃Q ) are to simplify presentation ; we can write ( ∃Q , rdfs:sc , A ) , ( ∃Q− , rdfs:sc , A ) instead of ( Q , rdfs:domain , A ) , ( Q , rdfs:range , A ) , respectively . The role R− is a convenient representation of the role r1 , where ( r1 , owl:inverseOf , R ) . Similar , triples of the form ( B , rdfs:sc,∃Q ) represent the following OWL 2 triples : ( B , rdfs:sc , c1 ) , ( c1 , a , owl:Restriction ) ,
( c1 , owl:onProperty , Q ) ,
( c1 , owl:someValuesFrom , owl:Thing ) .
An OWL 2 QL ontology ( resp . , RDFS ontology ) O is any set of OWL 2 QL ( resp . , RDFS ) inclusions . Wlog we assume 2 ) ∈ O for each ( Q1 , rdfs:sp , Q2 ) ∈ O . − − 1 , rdfs:sp , Q ( Q Given a graph G and an ontology O , we write G |= O if G |= σ for all σ ∈ O . A knowledge base ( KB ) is any pair G = ( G,O ) , where G is a graph and O is an ontology . Let G = ( G,O ) be a KB . Given a graph G , we say G is a model of G , denoted by G |= G if G ⊆ G and G |= O . We say G is consistent if there exists a model G , st G |= G . Finally , for an RDF triple t , we say G |= t if G |= t for every G |= G . Analogously , O |= t if G |= t for every G |= O . SPARQL . Let V be an infinite set of variables , st U∩ V = ∅ . We denote variables with a leading question mark , eg ?x . A SPARQL triple pattern t is a tuple in ( U ∪ V ) × ( U ∪ V ) × ( U ∪ V ) . Throughout this paper we will consider only triple patterns of the form ( ?x , a , B ) or ( ?x , Q , ?y ) , where B is a basic concept and Q a basic role.3
The set of SPARQL graph patterns is defined recursively as follows : ( 1 ) a triple pattern t is a graph pattern ; ( 2 ) if P1 and P2 are graph patterns , then ( P1 UNION P2 ) , ( P1 AND P2 ) , 3Constants in place of ?x and ?y can be simulated by using fresh variables and auxiliary triples in queries and input RDF graphs .
( P1 OPT P2 ) are graph patterns . Note that we follow the algebraic style notation from [ 25 ] , where an explicit AND operator is used . For a graph pattern P , we write vars(P ) , to denote the set of variables occurring in P .
In order to define the semantics of SPARQL graph patterns , we first introduce some additional terminology . A substitution is any partial function σ from V to U ∪ V . We use dom(σ ) and rng(σ ) to denote the domain and the range of σ , respectively . Given a triple pattern t and a substitution σ , we use σ(t ) to denote the triple obtained from t by replacing every variable ?x ∈ vars(t ) ∩ dom(σ ) by σ(?x ) . A ( SPARQL ) mapping is any partial function µ from V to U . Note that mappings are substitutions . Two mappings µ1 and µ2 are compatible ( written µ1 ∼ µ2 ) if µ1(?x ) = µ2(?x ) for all ?x ∈ dom(µ1 ) ∩ dom(µ2 ) . A mapping µ1 is subsumed by µ2 ( written µ1 µ2 ) if µ1 ∼ µ2 and dom(µ1 ) ⊆ dom(µ2 ) . We write µ1 < µ2 if µ1 µ2 and µ2 µ1 . For a mapping µ and sets M , M of mappings , we say µ M if µ µ for some µ ∈ M , and M M if µ M for every µ ∈ M . pattern t . mappings . For a graph pattern P , it is defined as follows [ 25 ] :
We formalize the evaluation of graph patterns over an RDF graph
G as a function(cid:74)·(cid:75)G that , given a graph pattern , returns a set of 1 . ( cid:74)t(cid:75)G = {µ | dom(µ ) = vars(t ) and µ(t ) ∈ G} for a triple 2 . ( cid:74)P1 AND P2(cid:75)G = {µ1 ∪ µ2 | µ1 ∈ ( cid:74)P1(cid:75)G , µ2 ∈ ( cid:74)P2(cid:75)G , and µ1 ∼ µ2} . 3 . ( cid:74)P1 OPT P2(cid:75)G =(cid:74)P1 AND P2(cid:75)G ∪ {µ1 ∈(cid:74)P1(cid:75)G | ∀µ2 ∈ ( cid:74)P2(cid:75)G : µ1 µ2} . 4 . ( cid:74)P1 UNION P2(cid:75)G =(cid:74)P1(cid:75)G ∪(cid:74)P2(cid:75)G . Hence , we have(cid:74)P(cid:75)G = {µ | dom(µ ) = vars(P ) , and µ(t ) ∈
A basic graph pattern ( BGP ) is a set of triple patterns P = {t1 , . . . , tn} – equivalently written as t1 AND . . . AND tn . G for all t ∈ P} . Note that , as in [ 25 ] and in the vast majority of works on query answering in DLs , we assume set semantics . In this paper we focus on well designed SPARQL graph patterns . A graph pattern P , built only from AND and OPT is well designed if there does not exist a subpattern P = ( P1 OPT P2 ) of P and a variable ?x ∈ vars(P2 ) that occurs in P outside of P , but not in P1 . A graph pattern P = P1 UNION . . . UNION Pn is well designed if each subpattern Pi is UNION free and well designed . Pattern trees . Another class of graph patterns defined in [ 25 ] are graph patterns in OPT normal form . A pattern containing only the operators AND and OPT is in OPT normal form if the OPT operator never occurs in the scope of an AND operator . It was shown that every well designed graph pattern can be transformed into OPT normal form in polynomial time . Moreover , such graph patterns allow for a natural tree representation , formalized by socalled pattern trees in [ 19 ] . A pattern tree ( PT ) T is a pair ( T,P ) , where T = ( V , E , r ) is a rooted , unordered , tree and P = {Pn | n ∈ V } is a labelling of the nodes in V , st Pn is a non empty set of triple patterns for every n ∈ V . Given T , we write V ( T ) to denote the set V of vertices . The next example illustrates this idea .
Example 3 . The following SPARQL graph pattern asks for all professors ?x and , if available , their email address ?w . Independently of the available information on the email address ?w , the pattern also tries to retrieve all professors ?y that ?x knows .
,(?x , a , Prof ) OPT ( ?x , email , ?w )
OPT,(?x , knows , ?y ) AND ( ?y , a , Prof )
The corresponding pattern tree looks as follows :
25 ( ?x , a , Prof )
( ?x , email , ?w )
( ?x , knows , ?y ) , ( ?y , a , Prof )
Let T = ( (V , E , r),P ) be a pattern tree . We call a PT T = ( (V , E , r),{Pn | n ∈ V ( T )} ) a subtree of T if ( V , E , r ) is a subtree of ( V , E , r ) . Throughout this article we only consider subtrees containing the root ( ie r = r ) , and will thus refer to them simply as “ subtrees ” , omitting the phrase “ containing the root ” . For a PT T = ( T,P ) , we denote with pat(T ) the set n∈V ( T ) Pn of triple patterns occurring in T . We write vars(T ) ( resp . vars(n ) for n ∈ V ( T ) ) as an abbreviation for vars(pat(T ) ) ( resp . vars(pat(n)) ) . A well designed pattern tree ( wdPT ) is a pattern tree T = ( T,P ) where for every variable ?x ∈ vars(T ) , the nodes {n ∈ V ( T ) | ?x ∈ vars(n)} induce a connected subgraph of T . Recall that wdPTs are a representation of well designed SPARQL graph patterns . Also , for every wdPT T , there exists a straight forward translation into a well designed graph pattern PT in OPT normal form . Moreover , all well designed graph patterns represented by T are equivalent to PT ( see [ 19 ] for details ) . For some
RDF graph G , we thus define(cid:74)T(cid:75)G =(cid:74)PT(cid:75)G .
Projection . Projection in SPARQL is realized via the SELECT result modifier on top of graph patterns ( or equivalently of pattern trees ) . For a mapping µ and a set X of variables , let µ|X denote the projection of µ to the variables in X , that is , the mapping µ defined as dom(µ ) := X ∩ dom(µ ) and µ(?x ) := µ(?x ) for all ?x ∈ dom(µ ) . We extend projection to a set M of mappings as M|X = {µ|X | µ ∈ M} . The result of projecting a graph pattern P to X is defined as(cid:74)(P,X )(cid:75)G = {µ|X | µ ∈(cid:74)P(cid:75)G} . Analogously , we define(cid:74)(T ,X )(cid:75)G = {µ|X | µ ∈ ( cid:74)T(cid:75)G} for a wdPT T . We refer to the pair ( T ,X ) as a projected wdPT ( pwdPT ) . 3 . CERTAIN ANSWER SEMANTICS
In this section , we propose an intuitive definition of certain answers for well designed SPARQL queries or , more precisely , for pwdPTs . Moreover , we shall establish the relationship of these certain answers with the canonical model – an important tool in the DL world . A natural first idea ( inspired by investigations in [ 2 ] on the relationship between the official SPARQL semantics and the open world assumption for RDF data ) was already mentioned in Section 1 , namely : rather than requesting that certain answers must be a solution in every possible model , at least one should be able to extend certain answers to a solution in every possible model . However , this idea alone still does not yield a satisfactory result as the following example shows .
Example 4 . Consider the following query
SELECT ?x , ?z WHERE ( ?x , teaches , ?y )
OPT ( ?y , knows , ?z )
= the graph G
{(a , teaches , b ) , ( b , knows , c ) , over ( a , teaches , d)} and empty ontology O . As possible models of ( G,O ) we have all supergraphs of G . Hence , µ = {?x → a , ?z → c} is a certain answer and so is µ = {?x → a} ( ?y is bound to d ) . Now let G = {(a , teaches , b ) , ( b , knows , c)} . If we take as certain answers all mappings that can be extended to some solution in every possible model , then µ is still a certain answer . The problem in the above example is that SPARQL queries with projection and/or the UNION operator may have “ subsumed ” solutions , ie , solutions such that also a proper extension is a solution .
But then – with set semantics – we cannot recognize the reason why some subsumed solution ( such as µ in the above example ) is possibly not a solution in some possible model : Note that in the above example , there are models for G in which µ is not a solution , eg , in the model G = G ∪ {(d , knows , c)} . In this model , µ is the only solution – with multiplicity 2 though .
In our first step towards reconciling SPARQL and certain answers , we decide to stick to set semantics in order to be able to build upon the broad DL literature . Indeed , apart from very few exceptions ( such as [ 18] ) , there hardly exist any works on query answering in DLs under bag semantics .
A key idea in our definition of certain answers is to only allow “ maximal ” solutions . For a mapping µ and some property A , we shall say that µ is maximal wrt A if µ satisfies A , and there is no µ such that µ < µ and µ satisfies A . mapping such that ( 1 ) µ ( cid:74)(T ,X )(cid:75)G for every model G of G ,
Definition 1 . Let G = ( G,O ) be a KB and ( T ,X ) a pwdPT . A mapping µ is a certain answer to ( T ,X ) over G if it is a maximal and ( 2 ) vars(T ) ∩ X = dom(µ ) for some subtree T of T . We denote by cert(T ,X ,G ) the set of all certain answers to ( T ,X ) over G .
Hence , in Example 2 , only µ is a certain answer over graph G , while the subsumed solution µ is dismissed .
The above definition ensures an important property of solutions to pwdPTs , namely : the domain of every solution must correspond to the free variables of some subtree in the pwdPT . However , for the design of algorithms to actually compute the certain answers for some entailment regime , it will turn out convenient if , in the first place , we do not need to check this condition . This leads to the following definition of certain pre answers for pwdPT . maximal mapping such that µ ( cid:74)(T ,X )(cid:75)G for every model G of
Definition 2 . Let G = ( G,O ) be a KB and ( T ,X ) a pwdPT . A mapping µ is a certain pre answer to ( T ,X ) over G if µ is a G . We denote by certp(T ,X ,G ) the set of all certain pre answers to ( T ,X ) over G .
We note that models of a KB G = ( G,O ) are invariant under renaming of URIs that do not occur in G . Hence , certain pre answers and certain answers have mappings only to constants in dom(G ) . The following example shows the difference between them . In Theorem 1 below , we shall then establish their precise relationship .
Example 5 . Consider the following query
OPT ( (?x , teaches , ?y ) AND ( ?x , knows , ?z ) )
SELECT ?x , ?y , ?z WHERE ( ?x , a , Prof ) and the following KB : G = {(a , a , Prof ) , ( a , knows , c)} and O = {(Prof , rdfs:sc,∃teaches)} . The mapping µ = {?x → a , ?z → c} is the certain pre answer , whereas µ = {?x → a} is the certain answer .
THEOREM 1 . Let G be a KB and ( T ,X ) a pwdPT . Then µ ∈ cert(T ,X ,G ) iff µ is a maximal mapping such that : ( 1 ) µ certp(T ,X ,G ) , and ( 2 ) vars(T ) ∩ X = dom(µ ) for some subtree T of T .
( cid:74)(T ,X )(cid:75)G for every graph G |= G , µ certp(T ,X ,G ) . The dition ( 1 ) : Since µ certp(T ,X ,G ) , µ ( cid:74)(T ,X )(cid:75)G for every
PROOF SKETCH . ‘⇒’ Let µ ∈ cert(T ,X ,G ) . Since , µ mapping µ is maximal trivially from Definition 1 . ‘⇐’ Let µ be maximal and satisfying ( 1 ) and ( 2 ) We prove Definition 1 conG |= G ; condition ( 2 ) : Follows from the maximality of µ wrt to ( 1 ) and ( 2 ) .
26 By the above theorem , the set of certain answers of some pwdPT can be easily computed from the set of certain pre answers by retaining only those mappings that bind all free variables of some subtree . Hence , in the rest of the paper , we shall focus on certain preanswers . The computation of the certain answers is then a simple post processing step .
As a further simplification in our algorithms , we shall also ignore for a while the distinction between distinguished and nondistinguished variables . Indeed , it is easy to see that to compute the certain pre answers of a pwdPT ( T ,X ) , it suffices to first compute the certain pre answers of T ( without projection , ie X = vars(T ) ) and then to project over X as shown in the following proposition . PROPOSITION 1 . Let G be a KB and ( T ,X ) a pwdPT . Then ( 1 ) µ
µ ∈ certp(T ,X ,G ) iff µ is a maximal mapping st certp(T ,G ) , and ( 2 ) dom(µ ) ⊆ X . Thus , from now on , we consider only certain pre answers for welldesigned pattern trees without projection .
In many Description Logics , the canonical model provides the basis for actually computing the certain answers for CQs or unions of CQs . Since our ontology is a variant of the DL DL LiteR , we will also employ canonical models , which we define similarly to [ 5 ] . The canonical model of a consistent KB G = ( G,O ) is a graph G that can be homomorphically mapped ( preserving the constants occurring G ) into any other model G of G . From now on , we assume G is consistent . In addition to the URIs in C , we introduce a new set of URIs AG ⊆ U with AG ∩ C = ∅ . The URIs in AG have the following form : aQ1Q2 . . . Qn , where n ≥ 1 , a ∈ dom(G ) and Q1 , . . . ,Qn are basic roles . The set AG consists of those URIs which satisfy ( 1 ) G |= ( a , a,∃Q1 ) ; ( 2 ) for every i ∈ {1 , . . . , n − 1} , O |= ( ∃Q = Qi+1 . We denote by tail(u ) the last role in a URI u ∈ AG , and define canO(G ) for basic roles Q , Q and a basic concept B : i , rdfs:sc,∃Qi+1 ) and Q −
− i
( 1 ) ( 2 ) ( 3 ) , rdfs:sc , B)} ∪ ( 4 )
−
( 5 )
G ∪
{(a , a , B ) | G |= ( a , a , B)} ∪ {(a , Q , b ) | G |= ( a , Q , b)} ∪ {(u , a , B ) | u ∈ AG,O |= ( ∃tail(u ) ,
{(u1 , Q , u2 ) | u2 ∈ AG , u2 = u1Q
O |= ( Q
, rdfs:sp , Q)} ∪
{(u2 , Q , u1 ) | u2 ∈ AG , u2 = u1Q
,
−
)}
O |= ( Q
, rdfs:sp , Q
( 6 ) We denote by compO(G ) the triples obtained from the union of Equations ( 1) (3 ) . Notice that compO(G ) = canORDFS ( G ) , where ORDFS is the set of all RDFS inclusions σ , st O |= σ ( for a similar result see [ 9 ] or [ 27] ) . We will write can(G ) ( resp . , comp(G ) ) instead of canO(G ) ( resp . , compO(G ) ) if O is clear from the context . Note that can(G ) can be infinite in size . The following well known result from databases and DLs can be shown for can(G ) ( see eg the proof of Theorem 2 in [ 24] ) . PROPOSITION 2 . Let G = ( G,O ) be a KB . Then ( a ) can(G ) |= G , and ( b ) for any G , st G |= G , there is a homomorphism h from can(G ) to G st for every a ∈ dom(G ) , h(a ) = a .
In Theorem 2 , we shall establish the relationship between certain pre answers to wdPTs and the canonical model . To this end , we first introduce the following useful definition .
Definition 3 . For a mapping µ , we let µ ↓= µ|{?x|µ(?x)∈C} , ie µ↓ is the restriction of µ to mappings into constants . Assume a set M of mappings . Then M ↓= {µ↓| µ ∈ M} . Moreover , MAX(M ) = {µ ∈ M | ( cid:64)µ ∈ M st µ < µ} , ie MAX(M ) is the set of maximal mappings in M . suffices
PROOF SKETCH . It
THEOREM 2 . Let G = ( G,O ) be a KB and T a wdPT . Then , certp(T ,G ) = MAX((cid:74)T(cid:75)can(G)↓ ) . ( cid:74)T(cid:75)can(G ) ↓ , and certp(T ,G ) ( cid:119 ) ( cid:74)T(cid:75)can(G ) ↓ . For ‘’ let µ µ↓ . For ‘(cid:119)’ let µ be a mapping in(cid:74)T(cid:75)can(G ) ↓ . By Proposition 2 , be a mapping in certp(T ,G ) . Then , µ is subsumed by an answer of T in every model . Hence , also by an answer µ in can(G ) . Since , µ only maps variables to constants in dom(G ) , µ is still subsumed by µ can be homomorphically mapped into every model of G , hence µ is part of a solution in every model , ie also maximal solutions . certp(T ,G ) to prove
4 . MODULAR QUERY REWRITING
In this section we provide our first method to compute certain answers to well designed pattern trees under OWL 2 QL entailment . In particular , we present a query rewriting procedure to compute certp(T ,G ) for a given wdPT T and a KB G = ( G,O ) . To this end , we extend the well known query reformulation algorithm of Calvanese et al . for answering conjunctive queries ( CQs ) over DL knowledge bases K = ( T , A ) , where T is a DL Lite TBox and A is an ABox [ 7 ] . The algorithm of Calvanese et al . transforms a CQ q and a TBox T into a union Q of CQs such that , given any ABox A , computing the certain answers to q over K = ( T , A ) is equivalent to evaluating Q over A , where A is seen as a plain relational database . In the presented approach , given a wdPT T and an ontology O we apply a rewriting at each node of T , obtaining a tree T of sets of BGPs . Roughly speaking , given any RDF graph G , computing certp(T ,G ) then corresponds to evaluating T in a bottom up fashion over G . Since nodes of T are rewritten in isolation but may share variables , the rewriting involves some bookkeeping , which we describe next . In particular , T will be expressed as an enriched query .
Definition 4 . Let Paths be the set of all words of the form ?xQ1 . . . Qn , where Q1 , . . . , Qn are basic roles with n ≥ 0 . Given a set of variables L ⊆ V , an L guide is a partial function γ from variables to words in Paths such that ( a ) dom(γ ) ∩ L = ∅ , and ( b ) for any ?x ∈ dom(γ ) with γ(?x ) =?zQ1 . . . Qn we have that ?z ∈ L . An enriched BGP is any tuple P , γ , where P is a BGP and γ is a vars(P ) guide . Expressions constructed from enriched BGPs by applying the AND , OPT and UNION connectives are called enriched queries . We use E , E1 , E2 , . . . to denote enriched queries .
We are ready to define the standard semantics of enriched queries . Intuitively , the answer to an enriched BGP P , γ over a graph G is obtained by first evaluating P using the standard semantics and then extending the obtained mappings with additional assignments prescribed by γ , potentially introducing assignments to elements from AG . The semantics is then generalized to full enriched queries using the standard operations on mappings .
Definition 5 . Assume a mapping µ and a dom(µ) guide γ . We let expand(µ , γ ) = µ ∪ {?x → µ(?y)Q1 . . . Qn | γ(?x ) = ?yQ1 . . . Qn} . Assume an RDF graph G . Then the evaluation of enriched queries is defined inductively as follows :
27 no r1 r2 r3 r4 r5
Triple t ( ?x , a , A ) ( ?x , a , A ) ( ?x , Q , ?y ) ( ?x , Q , ?y ) ( ?x , Q , ?y )
Inclusion α
( A1 , rdfs:sc , A ) ( ∃Q , rdfs:sc , A ) ( A , rdfs:sc , ∃Q ) ( ∃Q1 , rdfs:sc , ∃Q ) ( Q , rdfs:sp , Q ) gr(t , α ) ( ?x , a , A1 ) , ∅
( ?x , Q , ?x ) , ∅ff ( ?x , Q1 , ?x ) , ?y →?xQff ( ?x , Q , ?y ) , ∅ff
( ?x , a , A ) , ?y →?xQ
Table 1 : The result gr(t , α ) of applying an inclusion α to a triple t . Here ?x denotes a fresh variable . enriched BGP .
( cid:74)E(cid:75)G = {expand(µ , γ ) | µ ∈(cid:74)P(cid:75)G} in case E = ( P , γ ) is an ( cid:74)E1 AND E2(cid:75)G = {µ1 ∪ µ2 | µ1 ∈ ( cid:74)E1(cid:75)G , µ2 ∈ ( cid:74)E2(cid:75)G , and µ1 ∼ µ2} . ( cid:74)E1 OPT E2(cid:75)G =(cid:74)E1 AND E2(cid:75)G ∪ {µ1 ∈(cid:74)E1(cid:75)G | ∀µ2 ∈ ( cid:74)E2(cid:75)G : µ1 µ2} . ( cid:74)E1 UNION E2(cid:75)G =(cid:74)E1(cid:75)G ∪(cid:74)E2(cid:75)G .
Our rewriting procedure relies on the following “ lifting ” property of OWL 2 QL . For a guide γ , let ||γ|| denote the maximum |w| over all w ∈ rng(γ ) . Given a wdPT T and an ontology O , we let d(T ,O ) = 2k1 + k2 , where k1 is the number of atomic roles occurring in T and O , and k2 is the number of triples in T .
PROPOSITION 3 . Assume a wdPT T , a KB G = ( G,O ) , and a mapping µ ∈ ( cid:74)T(cid:75)can(G ) . Then there exists a mapping µ ∈ ( cid:74)T(cid:75)can(G ) such that ( a ) µ ↓= µ ↓ , and ( b ) |w| ≤ d(T ,O ) for every w ∈ rng(µ ) . Intuitively , the above says that any mapping µ for a wdPT T in the canonical model of G can be transformed into a mapping µ that is confined to the first d(T ,O ) levels of the canonical model yet agrees with µ on the assignments to constants . The property follows from the well known fact that in each branch of the canonical model of G one finds only a small number of types ( see eg [ 4] ) . We note that the above property does not hold in the presence of full OWL 2 . With the semantics and the desired properties of enriched queries established , we can describe the rewriting algorithm . The procedure exhaustively rewrites triples of an enriched BGP by applying inclusions “ backwards ” . Assume a BGP P . We say an inclusion α is applicable to a triple t wrt P if t and α have the following forms :
( i ) t = ( ?x , a , A ) and α = ( B , rdfs:sc , A ) ;
( ii ) t = ( ?x , Q , ?y ) , where ?y does not appear in any other triple of P , and α has ∃Q in the third position ;
( iii ) t = ( ?x , Q , ?y ) , ?x does not appear in any other triple of P , and α has ∃Q− in the third position ;
( iv ) t = ( ?x , Q , ?y ) and α = ( Q , rdfs:sp , Q ) . Let App(P ) denote the binary relation such that ( t , α ) ∈ App(P ) iff an inclusion α is applicable to a triple t wrt P .
In Algorithm 1 we present the rewriting routine RefBGP , which reformulates an input BGP P0 by taking into account the inclusions of O . It returns pr , which is a union of enriched BGPs . The procedure is parametrized by an integer k , which restricts the length of guide ranges and thus guarantees termination . As we shall see , Proposition 3 ensures that we do not lose completeness . The procedure employs the function gr ( t , α ) , which returns a tuple t , γ , where t is a triple and γ is a singleton guide , both obtained from t by applying α as described by Table 1 . P [ t/t ] denotes the BGP
:a BGP P0 , an inclusion set O , and an integer k
Algorithm 1 : RefBGP input output :a set pr of enriched BGPs 1 pr ← {P0,∅} 2 repeat 3 4 5 6 7 pr ← pr foreach P , γ ∈ pr st||γ|| ≤ k do foreach t∈ P and α ∈ O st ( t , α ) ∈ App(P ) do t , γ ← gr ( t , α ) pr ← pr ∪ {P [ t/t ] , expand(γ , γ)} foreach pair t1 , t2 in P with a MGU σ do pr ← pr ∪ {σ(P ) , expand(σ , γ)}
8 9 10 until pr = pr 11 return pr obtained from P by replacing the triple t with t . Given a BGP P and a substitution σ , we let σ(P ) = {σ(t ) | t ∈ P} . A unifier of a pair t1 , t2 of triples is a substitution σ such that σ(t1 ) = σ(t2 ) . We call σ a most general unifier ( MGU ) of t1 , t2 if for any unifier σ of t1 , t2 there exists a unifier σ of t1 , t2 such that σ = σ ◦ σ .
Using an adaptation of the proof in [ 7 ] , we can show that evaluating the output of RefBGP over a plain RDF graph corresponds to evaluating the original query over an initial segment of the canonical model . More formally :
PROPOSITION 4 . Let P be a BGP , G = ( G,O ) a KB , k an integer and pr the union of enriched BGPs returned by the restriction of can(G ) to URIs a ∈ U such that |a| ≤ k .
RefBGP(P,O , k ) . Then ( (cid:74)pr(cid:75)G)|vars(T ) = ( cid:74)P(cid:75)G , where G is
We can now generalize the rewriting from BGPs to full wdPTs . Given a wdPT T and an ontology O , we simply apply RefBGP to the BGP of every node in T .
Definition 6 . Let T be a wdPT and O an ontology . Let RefPT(T ,O ) denote the enriched query obtained by replacing in T every BGP P by RefBGP(P,O , d(T ,O) ) . certp(T , ( G,O ) ) = MAX(M↓ ) .
We arrive at the main technical result of this section . THEOREM 3 . Let T be a wdPT and G = ( G,O ) be a KB . Let
PROOF ( SKETCH ) . First note that by using Proposition 4 and where G is the restriction of can(G ) to URIs a ∈ U such that |a| ≤ d(T ,O ) .
M = ( (cid:74)RefPT(T ,O)(cid:75)G)|vars(T ) . Then induction on the structure of T , one can show ( (cid:63 ) ) M = ( cid:74)T(cid:75)G , show that ( (cid:74)T(cid:75)can(G))↓= M ↓ . Take an arbitrary mapping µ∗ ∈ ( (cid:74)T(cid:75)can(G))↓ . Then there exists a mapping µ ∈ ( (cid:74)T(cid:75)can(G ) ) such that µ↓= µ∗↓ . Moreover , due to such that µ ↓= µ∗ ↓ . Then due to ( (cid:63) ) , µ ∈(cid:74)T(cid:75)G . Thus trivially µ ∈(cid:74)T(cid:75)can(G ) and µ∗ ∈ ( (cid:74)T(cid:75)can(G))↓ .
Proposition 3 we can wlog assume that |w| ≤ d(T ,O ) for every w ∈ rng(µ ) . Then due to ( (cid:63) ) , µ ∈ M . Thus also µ∗ ∈ M ↓ . Take an arbitrary mapping µ∗ ∈ M ↓ . Then there exists µ ∈ M
Due to Theorem 2 , to prove the present theorem it suffices to
We put our algorithm to work in the following example .
28 Example 6 . Let O be the following set of inclusions :
( Person , rdfs:sc,∃knows ) , ( Prof , rdfs:sc,∃teaches ) ,
( 7 ) ( 8 ) which states that every Person object knows somebody and that every Prof object teaches somebody . Let G be an RDF graph containing the following triples : ( a , a , Person ) , ( b , a , Prof ) . We want to derive answers for the following query T over the above knowledge base :
( ?x , teaches , ?y ) OPT,(?z , teaches , ?y ) OPT ( ?u , knows , ?y )
This query asks for all ?x , ?z , ?u st ?x teaches some ?y and optionally all ?z , st ?z teach the same ?y as ?x and optionally all ?u that know ?y . We derive new queries by rewriting each node of the pattern tree corresponding to the above query separately .
1 . We start with the first BGP ( ?x , teaches , ?y ) : We use t = ( ?x , teaches , ?y ) . Equation 8 is applicable to t , hence in Line 6 t , γ = ( ?x , a , Prof ) , ?y →?x · teaches , which will be the enriched query that we add to pr in Line 7 . Since our BGP consists of a single triple pattern , we will not unify any pairs of triple patterns in Line 8 and 9 . No further application of inclusions leads to a new query . Hence , RefBGP((?x , teaches , ?y),O , d(T ,O ) ) outputs :
( ?x , teaches , ?y),∅
( ?x , a , Prof ) , ?y →?x · teaches
2 . Similar as above for the second BGP :
RefBGP((?z , teaches , ?y),O , d(T ,O ) ) outputs :
( ?z , teaches , ?y),∅
( ?z , a , Prof ) , ?y →?z · teaches
3 . And similar as above for the third BGP :
RefBGP((?u , knows , ?y),O , d(T ,O ) ) outputs :
( ?u , knows , ?y),∅
( ?u , a , Person ) , ?y →?u · knows
( 9 ) ( 10 )
( 11 ) ( 12 )
( 13 ) ( 14 )
Evaluating each of the enriched queries ( 9) (14 ) over G gives the following mappings : Query ( 10 ) evaluated over G outputs {?x → b , ?y → b · teaches} , Query ( 12 ) {?z → b , ?y → b · teaches} and Query ( 14 ) {?u → a , ?y → a · knows} . Combining the answers via Definition 5 gives the mapping : {?x → b , ?z → b} .
5 . HOLISTIC QUERY REWRITING
The modular approach from the previous section follows the general philosophy of SPARQL entailment regimes from [ 12 ] which also proceeds by first treating each BGP individually . However , a possible disadvantage of our modular approach is that we need to maintain additional data structures ( in particular , the “ guides ” ) to ensure consistency when combining the partial solutions from different nodes in the pattern tree to an overall solution . As a consequence , our whole algorithm has to be implemented from scratch because standard tools cannot handle these additional data structure . In this section , we therefore present a second approach to SPARQL evaluation under OWL 2 QL entailment . Its main goal is to make use of standard technology as far as possible . We thus aim at a transformation of OWL 2 QL entailment under our novel certain answer semantics into SPARQL evaluation with respect to RDFS Entailment . For the latter task , strong tools ( eg [ 13 , 22 ] ) are available . For the actual rewriting , we shall follow the rewriting from [ 9 ] ( see also [ 28 ] for a similar approach ) which incorporates several improvements compared with the original algorithm from [ 7 ] used in the previous section . The most important conceptual difference between our two algorithms , however , is that the algorithm presented below proceeds in a holistic way , ie , our query rewriting always takes the entire pattern tree into account . Further differences between our modular and holistic algorithm will be discussed in Section 6 .
As the modular rewriting , the holistic rewriting may unify and thus eliminate original variables ; this needs to be memorized in order to construct correct answers in the end . Thus the rewriting operates on pairs T , β , where T is a wdPT and β a partial function from variables to sets of variables . Intuitively , ?x ∈ β(?u ) says that ?x was substituted by the variable ?u during the rewriting . The evaluation of a pair T , β over an RDF graph is defined as follows :
( cid:74)T , β(cid:75)G = {expand(µ , β ) | µ ∈(cid:74)T(cid:75)G} , where expand(µ , β ) = {?z → µ(?u ) |?z ∈ β(?u ) , ?u ∈ dom(µ)}
The rewriting of T , β is obtained by applying exhaustively the following procedure .
Definition 7 . For a wdPT T together with a function β and an ontology O , we write T , β →O T , β if T and β can be obtained from T and β by the following steps : ( S1 ) non deterministically pick a variable ?x ∈ vars(T ) and a role
Q .
( S2 ) pick a concept BQ , st O |= ( BQ , rdfs:sc,∃Q ) and Q is a basic role . If no such concept BQ exists , continue with ( S1 ) .
( S3 ) Set T , β = T , β . Drop from T every subtree whose root has an triple of the form ( a ) ( ?z , Q1 , ?x ) such that O |= ( Q , rdfs:sp , Q1 ) , or ( b ) ( ?x , Q1 , ?z ) such that O |= ( Q , rdfs:sp , Q − 1 ) , or ( c ) ( ?x , a , A ) such that O |= ( ∃Q− , rdfs:sc , A ) . Note that ?z is an arbitrary variable . ( S4 ) Let neighboursT ( ?x ) = {?z
( ?x , P , ?z ) ∈ pat(T ) or ( ?z , P , ?x ) ∈ pat(T )} . Take a fresh variable ?u and replace in T all ?z ∈ neighboursT ( ?x ) with ?u . In other words , collapse all neighbours of ?x into ?u . Moreover ,
| let β(?u ) =
?z∈neighboursT ( ?x ) β(?z ) . ( S5 ) In all nodes n of T where ?x ∈ vars(n ) :
– if BQ is an atomic concept : add ( ?u , a , BQ ) . – if BQ is of the form ∃Q : add ( ?u , Q , ?y ) , where ?y is a new variable , ie not yet occurring in T .
( S6 ) In T , drop every triple t where ?x ∈ vars(t ) . We write T , β →∗ O T , β if T , β can be obtained from T , β by finitely many rewrite iterations . We let rewO ( T , β ) = O T , β} . {T , β | T , β →∗
Example 7 . Let us revisit the KB and the query of Example 6 . Let T denote the wdPT corresponding to this , and let βT be defined as in Theorem 4 . Then , the set rewO(T , βT ) is obtained as follows . We start with the query T , βT and proceed as in Definition 7 . The steps that change the PT are depicted in Figure 1 .
( S1 ) Let us pick variable ?y and the role teaches .
29 ( ?x , teaches , ?y )
( ?z , teaches , ?y )
( ?u , knows , ?y )
( S3 )
( ?x , teaches , ?y )
( ?u1 , teaches , ?y )
( S4 )
( ?z , teaches , ?y )
( ?u1 , teaches , ?y )
( S5 )
( ?u1 , a , Prof )
( ?u1 , teaches , ?y ) , ( ?u1 , a , Prof )
( ?u1 , a , Prof )
( S6 )
( ?u1 , teaches , ?y ) , ( ?u1 , a , Prof )
Figure 1 : Holistic rewriting given in Example 7 .
( S2 ) Since O |= ( Prof , rdfs:sc,∃teaches ) , we pick the con cept Prof .
( S3 ) T contains a node with ( ?u , knows , ?y ) , since O |= ( teaches , rdfs:sp , knows− ) , we drop from T the subtree rooted at the node containing ( ?u , knows , ?y ) .
( S4 ) Now , neighboursT ( ?y ) = {?x , ?z} . We introduce a fresh variable ?u1 and replace all occurrences of ?x and ?z in T with ?u1 . In addition , we set β(?u1 ) = β(?x ) ∪ β(?z ) = {?x , ?z} .
( S5 ) In all nodes of T with an occurrence of ?y we add
( ?u1 , a , Prof ) .
( S6 ) We now drop all triples where ?y occurs .
After this step , we will have the pattern tree depicted in the lower left of Figure 1 together with the function β , where β(?u1 ) = {?x , ?z} . Due to lack of space , we omit further rewriting steps . The evaluation of the query depicted in Figure 1 over the Graph G given in Example 6 outputs the mapping {?u1 → b} . Then , expand({?u1 → b} , β ) = {?x → b , ?z → b} , which is the answer also obtained in Example 6 . In order to compute the certain pre answers certp(T ,G ) , it just remains to eliminate all non maximal mappings :
THEOREM 4 . Let G = ( G,O ) be a KB and T a wdPT . Let βT be the function st for every ?x ∈ vars(T ) : βT ( ?x ) = {?x} . Let
M = ( (cid:74)rewO(T , βT )(cid:75)comp(G))|vars(T ) . Then , certp(T , ( G,O ) ) = MAX(M ) .
PROOF IDEA . For soundness , one shows the correctness of every rewriting step T , β →O T , β . For this , one shows st µ µ . For completeness , one shows for a mapping µ ∈ certp(T ,G ) that a sequence of rewriting steps to a query T , β , if µ ∈ ( cid:74)T , β(cid:75)can(G ) , then there is a µ ∈ ( cid:74)T , β(cid:75)can(G ) , st µ ∈(cid:74)T , β(cid:75)comp(G ) , can be found .
6 . DISCUSSION
In the previous sections , we have presented two algorithms for obtaining certain answers of well designed SPARQL queries over OWL 2 QL ontologies . The obvious difference between the two algorithms is that the first one proceeds by rewriting each node of the pattern tree individually while the second one targets the complete pattern tree at once . We now aim at a more detailed analysis of the characteristics of each of the two algorithms . In particular , we want to identify typical settings which favour one or the other . To this end , we look at a simple ontology consisting of a single inclusion triple : ( A , rdfs:sc,∃R ) .
First , consider the following pattern tree with 2 nodes :
( ?x , P , ?y1 ) , . . . , ( ?x , P , ?yn )
( ?z1 , R , ?y1 ) , . . . , ( ?zn , R , ?yn )
Modular rewriting gives a total number of queries whose order of magnitude is O(2n ) , since : a ) In the root node we cannot apply any inclusion triple to the
BGP . Hence , the algorithm just outputs one query . b ) In the child node we can immediately apply the inclusion ( A , rdfs:sc,∃R ) to any of the n triples . This can be done in any order , ie the total number of queries obtained is O(2n ) .
Holistic rewriting outputs only the original query . Whatever variable ?yi we pick in Step ( S1 ) , we will drop the complete query in Step ( S3 ) , since O |= ( R , rdfs:sp , P ) . Picking any other variable ?x or ?zi does not lead to further queries either .
For this query , the holistic approach by far outperforms the modular rewriting . Observe that all ?yi variables are shared by the two nodes in the wdPT . Hence , if some ?yi is mapped into the anonymous part of the canonical model , we would need to infer that the R edge is also a P edge , which is of course not true . Consequently , there exists no rewriting of the entire wdPT . However , in the modular approach , each node of the wdPT is processed individually . Hence , we do not detect that it is impossible to map the variable ?yi in the root node to the same anonymous element as ?yi in the child node .
Second , we consider the following wdPT with n nodes :
( ?x1 , P , ?z ) , ( ?x1 , R , ?y1 )
( ?xn , P , ?z ) , ( ?xn , R , ?yn )
Modular rewriting gives a total number of 2 ∗ n queries since , in each of the n nodes , we apply ( A , rdfs:sc,∃R ) independently . Holistic rewriting will do the same as the modular rewriting , but it copies with each rewriting also all other nodes , which then in turn must again be rewritten . Therefore , the holistic rewriting outputs a total number of queries whose order of magnitude is O(2n ) .
For the second query , clearly , the modular rewriting by far outperforms the holistic rewriting . We observe that now , the ?yi variables which have to be picked , only appear once in the tree . Hence , the nodes are independent of each other . This is in sharp contrast to the first query , where the two nodes shared all of the ?yi variables .
These two examples show that neither of the two algorithms is uniformly better than the other : depending on the setting , each of the two algorithms may produce exponentially fewer rewritings than the other . The way in which the same variables occur in multiple nodes looks like the key feature to distinguish situations where one or the other algorithm is preferable . The main strength of the holistic approach is to recognize incompatible occurrences of the same variable in different nodes , which allows the pruning of subtrees in the wdPT . The main strength of the modular approach is to avoid the same rewriting of subtrees in the wdPT for different rewritings in a parent node by treating each node individually . At any rate , it seems advantageous to have both algorithms in one ’s portfolio .
7 . COMPUTATIONAL COMPLEXITY
Having proposed two concrete algorithms for computing the certain answers to well designed SPARQL queries according to our
30 new semantics , we will next study the computational complexity of the evaluation problem . We show that the certain answer semantics does not increase its complexity compared to the setting without ontologies . Formally , we thus study the following problem .
OWL 2 QL EVALUATION
Input : pwdPT ( T ,X ) , KB G , mapping µ .
Question : µ ∈ cert(T ,X ,G ) ? For establishing several of the complexity results presented in this section , including the one on OWL 2 QL EVALUATION , it is convenient to first consider the following problem .
PARTIAL OWL 2 QL EVALUATION
Input : pwdPT ( T ,X ) , KB G , mapping µ .
Question : µ cert(T ,X ,G ) ?
THEOREM 5 . The problem PARTIAL OWL 2 QL EVALUATION is NP complete .
PROOF SKETCH . The membership can be shown using Theorem 4 : First , compute comp(G ) in polynomial time . Next , guess a subtree T , β of a rewriting T , β ∈ rewO(T , βT ) ( with dom(µ ) ⊆ vars(T , β ) ) and an extension λ of µ st λ(pat(T ) ) ⊆ comp(G ) .
Hardness follows immediately from the NP completeness of the query evaluation problem for CQs .
Deciding OWL 2 QL EVALUATION can now be reduced to several calls of PARTIAL OWL 2 QL EVALUATION .
THEOREM 6 . The problem OWL 2 QL EVALUATION is DP complete . Hardness holds even if the ontology is empty .
PROOF IDEA . For membership , note that OWL 2 QL
EVALUATION ( (T ,X ) , ( G,O ) , µ ) can be solved by deciding :
1 . µ cert(T ,X , ( G,O) ) , and 2 . for all µ : ¯X → dom(G ) with ¯X ⊆ X and µ < µ :
µ cert(T ,X , ( G,O) ) ?
Step ( 1 ) is in NP as shown in Theorem 5 . For step ( 2 ) , the coproblem is in NP : It can be solved by first guessing a mapping µ ( of polynomial size ) and then checking if µ cert(T ,X , ( G,O) ) . Guessing µ and the witness for µ cert(T ,X , ( G,O ) ) can be done in one step . Thus step ( 2 ) is in coNP . The hardness is shown in the full version .
We continue by studying typical query analysis tasks , ie , subsumption ( ) , containment ( ⊆ ) , and equivalence ( ≡ ) between pwdPTs . First of all , we have to adapt these notions to our setting including ontologies . That is , let ( T1,X1 ) and ( T2,X2 ) be pwdPTs , and O be an ontology . We say that ( T1,X1)◦(T2X2 ) ( for ◦ ∈ O,⊆O,≡O ) if cert(T1,X1 , ( G,O ) ) ◦ cert(T2,X2 , ( G,O ) ) ( for ◦ ∈ ,⊆ , = , respectively ) . This allows us to define the query analysis problems studied in this section .
OWL 2 QL SUBSUMPTION/OWL 2 QL CONTAINMENT/ OWL 2 QL EQUIVALENCE
Input : Question : pwdPTs ( T1,X1 ) , ( T2,X2 ) , ontology O . ( T1,X1 ) O / ⊆O / ≡O ( T2,X2 ) ?
These problems can be decided by using ( PARTIAL ) OWL 2 QLEVALUATION . For characterizing the relationships between these problems , we have to introduce some additional notation first . Let
( T ,X ) be a pwdPT . We use fvars(T ) = vars(T )∩X to denote the set of free variables in T . Moreover , let db( . ) be a bijective function that assigns to each variable ?x ∈ vars(T ) a unique , new URI db(?x ) , and that maps constants onto themselves . Then the frozen RDF graph G for T is the set of triples G = {db(t ) | t ∈ pat(T )} . Finally , for a subtree T of T , let µT be defined as dom(µT ) := fvars(T ) and µT ( ?x ) := db(?x ) for each ?x ∈ dom(µ ) .
This allows us to characterize the subsumption problem in terms of PARTIAL OWL 2 QL EVALUATION .
1 cert(T2,X2 , ( db(T
THEOREM 7 . Given pwdPTs ( T1,X1 ) , ( T2,X2 ) , and an ontol1 of ogy O , we have ( T1,X1 ) O ( T2,X2 ) iff for every subtree T T1 we have µT ∈ Intuitively , cert(T1,X1 , ( G,O) ) , an extension µ cert(T2,X2 , ( G,O ) ) can be obtained by a combination of µ and the mapping witnessing µT cert(T2,X2 , ( db(T that given some G and µ the idea is
1 ),O) ) .
1 ),O) ) .
The containment problem on the other hand can be characterized in terms of OWL 2 QL SUBSUMPTION and OWL 2 QLEVALUATION . In fact , the following result presents a characterization of ( cid:42)O , ie a characterization of the co problem , since we think it is more intuitive .
1
THEOREM 8 . Given pwdPTs ( T1,X1 ) , ( T2,X2 ) , and an ontol ogy O . Then ( T1,X1 ) ( cid:42)O ( T2,X2 ) iff
1 . X1 = X2 , or 2 . ( T1,X1 ) O ( T2,X2 ) , or 3 . there exist subtrees T
1
1
2 ) st µT fvars(T
1 ) ∪ db(T
1 of T1 and T
∈ cert(T1,X1 , ( db(T
2 of T2 with fvars(T 1 ) 2 ),O) ) . We briefly discuss the idea of this characterization : By properties 1 and 2 , containment cannot hold . Now assume ( T1,X1 ) O ( T2,X2 ) . Then clearly the only reason for some certain answer µ of T1 not being a certain answer of T2 is that some proper extension µ of µ is actually a certain answer of T2 . This situation is covered by the third property : T 2 represents µ . Finally 2 ),O ) ) ensures that while µ ∈ cert(T1,X1 , ( db(T µT can be extended to µ on T2 , this is not possible on T1 . The equivalence problem can of course be solved by checking mutual containment . Moreover , it is easy to see that ( T1,X1 ) ≡O ( T2,X2 ) iff ( T1,X1 ) O ( T2,X2 ) and ( T2,X2 ) O ( T1,X1 ) . Just consider the case that for some RDF graph G , assuming mutual subsumption , there is some µ ∈ cert(T1,X1 , ( G,O) ) , st µ /∈ cert(T2,X2 , ( G,O) ) . Then there must be µ ∈ cert(T2,X2 , ( G,O ) ) with µ < µ . Thus either µ or some extension of it must be contained in cert(T1,X1 , ( G,O) ) , which contradicts µ ∈ cert(T1,X1 , ( G,O) ) .
1 represents µ , T 1 ) ∪ db(T
Observe that Theorems 7 and 5 give an immediate ΠP
2 upper bound on the complexity of OWL 2 QL SUBSUMPTION . Also , this result combined with Theorem 6 provides a ΠP 2 upper bound for OWL 2 QL CONTAINMENT ( via a ΣP 2 bound for the co problem ) . Finally , these results imply the same upper bound for OWL 2 QLEQUIVALENCE . By proving matching lower bounds , we show that this is in fact the exact complexity of all three problems .
THEOREM 9 . The problems OWL 2 QL SUBSUMPTION , OWL 2 QL CONTAINMENT , and OWL 2 QL EQUIVALENCE are ΠP 2 complete . Hardness holds even for empty ontologies .
PROOF IDEA . Membership results follow from the above discussion . Hardness for OWL 2 QL SUBSUMPTION follows from the hardness of subsumption without ontologies [ 19 ] . The hardness for OWL 2 QL CONTAINMENT and OWL 2 QL EQUIVALENCE is shown in the full version .
31 ( T ,X ) and ontology O , the set(cid:74)(T ,X )(cid:75)G may contain subsumed
Of course , we cannot compare these results directly with the known results for well designed SPARQL queries in settings without ontologies . In fact , over plain RDF graphs , most of the problems have even a higher complexity : The evaluation problem is ΣP 2 complete [ 19 ] while the containment and equivalence problem are even undecidable [ 26 ] . Only the subsumption problem was shown to have the same complexity [ 26 ] . The reason for the higher complexity , or even undecidability , respectively , is the existence of subsumed mappings in query answers . Recall that , for any RDF graph G , pwdPT mappings . This is not the case for cert(T ,X , ( G,O) ) , due to the restriction to maximal mappings in our definition of certain answers . For the subsumption problem , this of course does not make a difference , since for two sets of mappings M , M we clearly have M M if and only if MAX(M ) MAX(M ) ( observe however , that in the presence of subsumed answers , pairwise subsumption does not guarantee equivalence [ 19] ) . However , for a reasonable comparison of the other problems under our new certain answer semantics with the settings without ontologies , we need to study suitable variants of these problems first . We thus investigate the following problem .
MAXEVALUATION
Input : pwdPT ( T ,X ) , RDF graph G , mapping µ .
Question : µ ∈ MAX((cid:74)(T ,X )(cid:75)G ) ? we have ( T1,X1 ) ◦ ( T2,X2 ) ( for ◦ ∈ ⊆MAX ,≡MAXff ) if MAX((cid:74)(T1,X1)(cid:75)G ) ◦ MAX((cid:74)(T2,X2)(cid:75)G ) ( for ◦ ∈ ⊆ , = , resp . )
For containment and equivalence , we consider the relations for pwdPTs ( T1,X1 ) , ( T2,X2 ) , ⊆MAX and ≡MAX where , for all RDF graphs G . This gives the following problems .
MAXCONTAINMENT/MAXEQUIVALENCE
Input : Question : pwdPTs ( T1,X1 ) , ( T2,X2 ) . ( T1,X1 ) ⊆MAX / ≡MAX ( T2,X2 ) ?
THEOREM 10 . The problem MAXEVALUATION is DPcomplete . The problems MAXCONTAINMENT and MAXEQUIVALENCE are ΠP
2 complete
PROOF IDEA . The corresponding problems in the presence of an ontology of course provide an upper bound . Hardness results are provided in the full version .
We have thus pinpointed the complexity of the most relevant reasoning problems related to query evaluation and query analysis : Starting from the problems respecting our new certain answer semantics , we also reconsidered the corresponding problems for settings without ontologies where we remove subsumed mappings from the query answers .
Our results show that for all the problems analysed in this section , applying the certain answer semantics does not increase their computational complexity compared to the case without ontologies .
8 . CONCLUSION AND FUTURE WORK Summary . In this work , we have provided an intuitive definition of certain answers for well designed SPARQL queries under entailment regimes . As a basis for the design of evaluation algorithms , we have established the relationship between certain answers and canonical models . It should be noted that this part of our work is completely generic in the sense that it applies to any entailment regime . We have then turned our attention to a concrete entailment regime – OWL 2 QL – for which we have presented novel evaluation algorithms together with a detailed complexity analysis . We have thus shown that – analogously to CQ answering under DL Lite [ 7 ] – one can extend SPARQL evaluation to OWL 2 QL entailment without significantly increasing the complexity . Related Work . Work related to our findings first and foremost includes the work our approaches are based upon [ 7 , 9 , 12 , 2 ] as discussed throughout this paper . There is a huge body of results on query answering under different Description Logics ( cf . [ 7 , 27 , 9 , 23] ) . However , the queries considered there are typically CQs . So far , query languages comparable to well designed SPARQL have not yet been studied in the context of Description Logics . The problem of answering SPARQL queries under OWL 2 QL via rewriting has been recently studied in [ 16 ] , where a translation of the problem into SQL is provided . Unlike our work , the authors do not modify the semantics defined by the entailment regime [ 12 ] . Investigating aggregate functions , similar to our observation in the presence of weak monotonicity , the authors of [ 18 ] notice that defining certain answers as the intersection over all possible worlds does not provide satisfactory answers . For the counting operator , they solve this problem by defining the certain answer to be the minimum over all possible worlds . In [ 1 ] , the authors describe a rewriting of SPARQL query answering under OWL 2 QL into Datalog± . A modification of this translation allows them to remove the restriction to map all variables to actual values from the RDF graph . However , this relaxation applies only to variables occurring in a single BGP , while we allow this for all non distinguished variables . Also , a discussion of the resulting semantics is missing . Libkin [ 20 ] also criticizes the standard notion of certain answers in case of non monotone queries . Similar to his suggestion to use the greatest lower bounds in terms of informativeness , our approach chooses the most informative solutions as certain answers . Future Work . Above all , we want to investigate further entailment regimes under our certain answer semantics . The implementation of the rewriting algorithms , the development of suitable benchmarks and alternative methods , eg employing materialization [ 15 ] , is a challenging task as well . It also remains to be seen whether the optimization in [ 14 ] can be adopted by the proposed semantics . Moreover , we want to study combinations of our semantics with other approaches : our definition of certain answers is a relaxation of the current semantics ; it allows to infer additional mappings that logically follow from the knowledge base . Recently , a stronger semantics was presented in [ 17 ] , which discards entire mappings whose possible extensions to optional subqueries would imply inconsistencies in the knowledge base . A semantics that would integrate both principles is also an exciting research problem . Another extension envisaged refers to the restrictions imposed on the fragment of SPARQL considered here : so far , we have only considered welldesigned SPARQL , which was further restricted to queries of the form ( ?x , a , B ) or ( ?x , Q , ?y ) . However , since SPARQL allows for variables in all positions , ie also ( ?x , ?y , ?z ) is a valid triple pattern , we will extend our work to allow these triple patterns as well . Even though we obtain nice complexity results , by investigating well designed SPARQL , for the certain answer semantics this restriction should not be of big importance . Hence , we want to further investigate the certain answer semantics in the presence of standard SPARQL queries over OWL 2 QL ontologies .
Acknowledgements This work was supported by the Vienna Science and Technology Fund ( WWTF ) , project ICT12 15 and by the Austrian Science Fund ( FWF ) : P25207 N23 and P25518 N23 .
32 9 . REFERENCES [ 1 ] M . Arenas , G . Gottlob , and A . Pieris . Expressive languages for querying the semantic web . In Proc . of PODS 2014 , pages 14–26 . ACM , 2014 .
[ 2 ] M . Arenas and J . Pérez . Querying semantic web data with SPARQL . In Proc . of PODS 2011 , pages 305–316 . ACM , 2011 .
[ 3 ] F . Baader , D . Calvanese , D . L . McGuinness , D . Nardi , and
P . F . Patel Schneider , editors . The Description Logic Handbook : Theory , Implementation , and Applications . Cambridge University Press , 2003 . [ 4 ] M . Bienvenu , T . Eiter , C . Lutz , M . Ortiz , and M . Šimkus . Query answering in the description logic S . In Proc . of DL 2010 . CEUR WS.org , 2010 .
[ 5 ] M . Bienvenu , M . Ortiz , M . Šimkus , and G . Xiao . Tractable queries for lightweight description logics . In Proc . of IJCAI 2013 . IJCAI/AAAI , 2013 .
[ 6 ] S . Bischof , M . Krötzsch , A . Polleres , and S . Rudolph .
Schema agnostic query rewriting in SPARQL 11 In Proc . of ISWC 2014 , pages 584–600 . Springer , 2014 .
[ 7 ] D . Calvanese , G . De Giacomo , D . Lembo , M . Lenzerini , and R . Rosati . Tractable reasoning and efficient query answering in description logics : The DL Lite family . J . Autom . Reasoning , 39(3):385–429 , 2007 .
[ 8 ] A . K . Chandra and P . M . Merlin . Optimal implementation of conjunctive queries in relational data bases . In Proc . of STOC 1977 , pages 77–90 . ACM , 1977 . rewriting for Horn SHIQ plus rules . In Proc . of AAAI 2012 . AAAI Press , 2012 .
[ 9 ] T . Eiter , M . Ortiz , M . Šimkus , T . Tran , and G . Xiao . Query
[ 10 ] B . Glimm . Using SPARQL with RDFS and OWL entailment .
In Reasoning Web 2011 , Tutorial Lectures , pages 137–201 . Springer , 2011 .
[ 11 ] B . Glimm , C . Lutz , I . Horrocks , and U . Sattler . Conjunctive query answering for the description logic SHIQ . J . Artif . Intell . Res . ( JAIR ) , 31:157–204 , 2008 .
[ 12 ] B . Glimm and C . Ogbuji . SPARQL 1.1 Entailment Regimes .
W3C Recommendation , W3C , Mar . 2013 . http://wwww3org/TR/sparql11 entailment
[ 13 ] F . Goasdoué , I . Manolescu , and A . Roatis . Efficient query answering against dynamic RDF databases . In In Proc . of EDBT 2013 , pages 299–310 . ACM , 2013 .
[ 14 ] I . Kollia and B . Glimm . Optimizing SPARQL query answering over OWL ontologies . J . Artif . Intell . Res . ( JAIR ) , 48:253–303 , 2013 .
[ 15 ] R . Kontchakov , C . Lutz , D . Toman , F . Wolter , and
M . Zakharyaschev . The combined approach to query answering in DL Lite . In Proc . of KR 2010 . AAAI Press , 2010 .
[ 16 ] R . Kontchakov , M . Rezk , M . Rodriguez Muro , G . Xiao , and
M . Zakharyaschev . Answering SPARQL queries over databases under OWL 2 QL entailment regime . In Proc . of ISWC 2014 , pages 552–567 . Springer , 2014 .
[ 17 ] E . V . Kostylev and B . C . Grau . On the semantics of SPARQL queries with optional matching under entailment regimes . In Proc . of ISWC 2014 , pages 374–389 . Springer , 2014 . [ 18 ] E . V . Kostylev and J . L . Reutter . Answering counting aggregate queries over ontologies of the DL Lite family . In Proc . of AAAI 2013 . AAAI Press , 2013 .
[ 19 ] A . Letelier , J . Pérez , R . Pichler , and S . Skritek . Static analysis and optimization of semantic web queries . ACM Trans . Database Syst . , 38(4):25 , 2013 .
[ 20 ] L . Libkin . Incomplete data : what went wrong , and how to fix it . In Proc . PODS 2014 , pages 1–13 . ACM , 2014 .
[ 21 ] C . Lutz . The complexity of conjunctive query answering in expressive description logics . In Proc . of IJCAR 2008 , pages 179–193 . Springer , 2008 .
[ 22 ] B . Motik , Y . Nenov , R . Piro , I . Horrocks , and D . Olteanu . Parallel materialisation of datalog programs in centralised , main memory RDF systems . In Proc . AAAI 2014 , pages 129–137 . AAAI Press , 2014 .
[ 23 ] M . Ortiz , D . Calvanese , and T . Eiter . Data complexity of query answering in expressive description logics via tableaux . Journal of Automated Reasoning , 41(1):61–98 , 2008 .
[ 24 ] M . Ortiz , S . Rudolph , and M . Šimkus . Query answering in the horn fragments of the description logics SHOIQ and SROIQ . In Proc . of IJCAI 2011 , pages 1039–1044 . IJCAI/AAAI , 2011 .
[ 25 ] J . Pérez , M . Arenas , and C . Gutierrez . Semantics and complexity of SPARQL . ACM Trans . Database Syst . , 34(3 ) , 2009 .
[ 26 ] R . Pichler and S . Skritek . Containment and equivalence of well designed SPARQL . In Proc . of PODS 2014 , pages 39–50 . ACM , 2014 .
[ 27 ] R . Rosati . On conjunctive query answering in EL . In Proc . DL
2007 . CEUR WS.org , 2007 .
[ 28 ] R . Rosati and A . Almatelli . Improving query answering over DL Lite ontologies . In Proc . of KR 2010 . AAAI Press , 2010 .
[ 29 ] M . Schmidt , M . Meier , and G . Lausen . Foundations of
SPARQL query optimization . In Proc . of ICDT 2010 , pages 4–33 . ACM , 2010 .
[ 30 ] J . F . Sequeda , M . Arenas , and D . P . Miranker . OBDA : query rewriting or materialization ? In practice , both! In Proc . of ISWC 2014 , pages 535–551 . Springer , 2014 .
33
