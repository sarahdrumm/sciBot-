Modeling High Level Behavior Patterns for Precise
Similarity Analysis of Software
Taeho Kwon
Zhendong Su
University of California , Davis
{kwon , su}@csucdavisedu
ABSTRACT The analysis of software similarity has many applications such as detecting code clones , software plagiarism , code theft , and polymorphic malware . Because often source code is unavailable and code obfuscation is used to avoid detection , there has been much research on developing effective models to capture runtime behavior to aid detection . Existing models focus on low level information such as dependency or purely occurrence of function calls , and suffer from poor precision , poor scalability , or both . To overcome limitations of existing models , this paper introduces a precise and succinct behavior representation that characterizes high level object accessing patterns as regular expressions . We first distill a set of high level patterns ( the alphabet Σ of the regular language ) based on two pieces of information : function call patterns to access objects and typestate information of the objects . Then we abstract a runtime trace of a program P into a regular expression e over the pattern alphabet Σ to produce P ’s behavior signature . We show that software instances derived from the same code exhibit similar behavior signatures and develop effective algorithms to cluster and match behavior signatures . To evaluate the effectiveness of our behavior model , we have applied it to the similarity analysis of polymorphic malware . Our results on a large malware collection demonstrate that our model is both precise and succinct for effective and scalable matching and detection of polymorphic malware .
1 .
INTRODUCTION
Detecting similar software is an important problem with many software engineering and security applications , ranging from detecting code clones , software defects , plagiarism and code theft , to the analysis of polymorphic malware . For many such applications , source code is often unavailable , and code obfuscation techniques are commonly used to avoid detection . For these reasons , techniques based on syntactic information are generally not effective , and ones based on runtime behavior have been extensively investigated [ 1–5 , 8 , 11 , 13–15 , 17 , 22 , 26 , 27 ] .
To detect similar software based on runtime behavior , the first and the most important step is to design precise models of execution behavior . Previously proposed models focus on low level function call and dependency information to approximate a runtime trace . Examples include the use of control and data dependencies among function calls [ 22 ] , call graphs [ 8 ] , and occurrence counts of call patterns [ 1 , 2 , 14 , 17 ] . Similarity analysis based on these models has either limited scalability or precision , or both : limited scalability because they capture detailed , low level dependencies and do not capture high level patterns ; limited precision because they do not model temporal dependency and repetition of function calls .
Recognizing the aforementioned limitations of existing work , we present a novel behavior model that is both precise and succinct : we characterize high level semantic aware behavior patterns to reduce model complexity ( for scalability ) and capture the patterns’ temporal dependency and repetition ( for precision ) . At the highlevel , we model the behavior signature of a program as a regular expression e : 1 ) the behavior patterns form the alphabet Σ ; and 2 ) the concatenation and Kleene star ( ∗ ) operators naturally and succinctly model temporal dependency and repetition of behavior patterns . Our model construction consists of a few main steps . First , from a dynamic trace , we extract sequences of semantically related object accessing function calls of each thread . We also model how the related calls modify the typestate of an object in the captured execution trace . A semantic aware behavior pattern corresponds to a call sequence , together with the associated typestate information of the accessed object , which we abstract into a letter in the alphabet Σ . We also use a special meta symbol ‘|’ in Σ to delimit thread boundaries . Next , we transform the runtime trace to a string s over Σ . As the final step , we find repeated substrings in the string s to detect repeated patterns and to produce a regular expression e as the program ’s behavior signature ( wrt the given dynamic trace ) . For example , the behavior signature of the malware Mytob.af is given as the regular expression |UH|VB*T|P*(|T)*|DT|B(|T)* ( we will explain the semantics of the letters in Section 2 ) .
Besides being precise and succinct , our proposed model has additional benefits for software similarity analysis . First , software derived from the same code is likely to have similar behavior signatures . For example , two polymorphic malware samples , Rbot.ox and Rbot.vr , in the same malware family , have very similar signatures : |BH|(DB)*D|BQ|DHPBT|(DB)*D and |BH|(DB)*D|B|DHPBT|(DB)*D|T . Second , our model reduces the problem of similarity analysis of program behavior to similarity analysis of regular strings , which is more amenable to effective algorithms . We present such an algorithm based on a string similarity metric utilizing prediction probabilitybased similarity [ 24 ] and the Jaccard index [ 9 ] . The algorithm can be used to cluster and match software exhibiting similar behavior . It can also be used to generate representative behavior signatures .
We have implemented our technique and evaluated its effectiveness in the context of similarity analysis of polymorphic malware . We have evaluated our model ’s abstraction capability and the effectiveness of our clustering algorithm for malware clustering and signature generation/matching . Results on analyzing a large malware collection are promising : 1 ) our model precisely characterizes malware behavior with small regular expressions ; and 2 ) our clustering algorithm produces precise clusters and behavior signatures .
To summarize , we make the following main contributions : • We introduce a precise and succinct software behavior model that extracts high level , semantic aware behavior patterns and represents their temporal and dependency relationship using concise regular expressions .
• We introduce an effective clustering algorithm based on our model and describe how it can be applied for generating
1 behavior signatures and matching similar software .
• We show empirically that our technique is effective for software similarity analysis by applying it to the analysis of behavior similarity of polymorphic malware .
The remainder of this paper is structured as follows . Section 2 presents our regular expression based behavior model and a running example . We present an algorithm for behavior based software clustering and its extension to behavior signature/matching of software in Section 3 . Section 4 describes our implementation and evaluation results on behavior similarity analysis of polymorphic malware . Finally , we survey related work ( Section 5 ) and conclude with a discussion of future work ( Section 6 . )
2 . MODEL FORMULATION
This section presents an overview of our regular expression based behavior model , describes how it is constructed , and uses an example to illustrate the construction . 2.1 Overview Extracting Behavior Patterns Dynamic techniques based on analyzing runtime traces have been well studied in modeling software behavior . We follow this general approach , but instead of working directly at the level of low level API calls , we extract API usage patterns to work at a higher level of abstraction . Because how objects are created , modified , and accessed are central to the understanding of runtime behavior , we focus on analyzing object accessing behavior . In particular , we analyze resource ownership patterns captured by the regular expression ( ab∗c? ) , where a , b , and c represent API calls for object acquisition , usage , and release . Extracting instances of such patterns provides a higher level understanding of program behavior . For example , the pattern “ ( CreateFile WriteFile* CloseFile ) ” where all APIs are invoked on a particular file object can be mapped to the higher level behavior file writing . The ( ab∗c ? ) pattern is quite flexible and can capture certain important patterns for imperfect ( ie , incomplete or buggy ) traces . For example , assume that a program writes a log file periodically without closing the file opened earlier . This behavior is described by the regular expression ab+ , which is captured by ( ab∗c? ) . After extracting the API usage patterns , we obtain a sequence of high level behavior patterns from the trace . Adding Typestate Information The same API usage pattern may operate on objects in different states at different points of program execution . Figure 1 displays a sample C code snippet to create a file newfile.txt and then read from it . We can extract from Lines 3–5 and 7–10 the patterns to create a file and to read from a file respectively . Because the file is created first and then read from , we know that the file read pattern reads from a file created by the program . If we comment out line 7 and uncomment line 8 , the file read pattern reads from an existing file . Although the two file read patterns are both about reading a file , the accessed objects have different states . Based on the above observation , we introduce semantic aware behavior to specify not only the behavior type , such as reading a file , but also additional semantic information of the associated object , such as reading a newly created or existing file . Dealing with Threads As many applications are multi threaded , it is important to consider threads ; otherwise , the extracted behavior information may be polluted by thread interleavings . In addition , parent/child dependencies among threads can provide useful behavior information . Due to these considerations , we separate the runtime trace into per thread sub traces . We also extract parent/child dependency among threads . In order to represent the complete trace
2
Figure 1 : Sample C code to read a created file . as a single regular expression , we force a total order on the threads such that a parent thread will be placed before its children , and a thread created by the same parent will be placed before all its siblings that are created at later times ( eg , a pre order traversal satisfies these requirements ) . Based on such a total ordering of the threads , we analyze semantic aware patterns ( ie , API usage patterns with object typestate information ) . Generating Behavior Signatures Once we have a sequence of semantic aware behavior patterns , we find repetitions in the sequence to reduce the size of the model and to characterize behavior repetition . For example , an application can create multiple threads that perform the same task . In this case , repeated thread creation is one high level behavior pattern . To search for behavior repetitions in the sequence , we transform the behavior sequence into a special string such that a letter in the string represents a semanticaware behavior , and a special character ‘|’ delimits the substrings corresponding to different threads’ semantic behavior . We then use string algorithms to find repeated substrings . We use Kleene star ( ∗ ) to represent such repetitions . This process transforms a sequence into a regular expression e , which denotes the program ’s behavior signature . This model effectively reduces various software behavior analyses to sequence mining problems . The following sections present more details on our construction . 2.2 Model Construction
Figure 2 shows the high level architecture to generate our regular expression based behavior signatures . Because our model is based on a thread level behavior analysis , we capture not only information regarding method invocations such as API names and parameters of interest , but also the corresponding process/thread identifiers during dynamic trace collection . The thread identifiers allow us to extract a sequence of method invocations per thread . This section describes details of each phase shown in Figure 2 .
221 Thread level Behavior Mining This phase extracts a sequence of behaviors of interest for each thread from a given dynamic trace . There are three main tasks : 1 ) specifying behavior patterns to be mined , 2 ) extracting the dynamic trace for each thread , and 3 ) mining the behavior sequence from the extracted dynamic trace .
To specify behaviors of interest , we take as input an API Alphabet Mapping , which describes how to map a letter in the alphabet in the regular expression ( ab∗c ? ) and the possible API names . Based on this mapping information , arbitrary object accessing behavior can be specified . Table 1 shows examples of the API alphabet mapping we use to specify the behavior of accessing file , registry key , mutex , and network device in Microsoft Windows .
The extraction of each thread ’s dynamic trace can be achieved as follows . We group method calls in the dynamic trace according to their process/thread identifiers and keep them in sorted order wrt runtime ordering of their process/thread execution .
For thread behavior mining , Algorithm 1 describes how to mine
1FILE*pFile;2charmystring[100];3pFile=fopen("newfiletxt","w");4fputs("createanewfile",pFile);5fclose(pFile);67pFile=fopen("newfiletxt","r");8//pFile=fopen("existingfiletxt","r");9fgets(mystring,100,pFile);10fclose(pFile ) ; Figure 2 : High level architecture .
Object
File
Mutex
Registry Key
Network Device a Type NtCreateFile , NtOpenFile NtDeleteFile NtCreateMutant NtCreateKey NtOpenKey NtCreateFile b Type NtReadFile NtWriteFile
NtSetValueKey NtDeleteValueKey NtDeviceIoControlFile c Type
NtClose
NtClose
NtClose
NtClose
Table 1 : Examples of API alphabet mapping . instances of the ( ab∗c ? ) pattern from a thread ’s dynamic trace . We assume that the given trace contains only methods specified in the API alphabet mapping . Briefly , the algorithm clusters the corresponding methods based on the pattern by matching objects each method accesses , and sorts groups of clustered methods by the occurrence of the type a methods . The sorted groups represent a sequence of behaviors observed for a single thread . 222 Thread Sorting We consider thread parent/child dependencies as an important class of behavior patterns because they determine orderings on thread execution . For example , if a thread A is the parent of a thread B , the thread A is executed before the thread B . This dependency provides detailed behavior information .
The dependency can be modeled with a tree structure where each node and edge represent a process/thread identifier and parent/child relationship between two threads . We call this tree thread dependency tree . To construct this tree , we search for a root node corresponding to an initial thread of the program ; this can be determined by selecting the first thread in a dynamic trace . From the root node , parent/child relationship between two nodes can be recursively mined by analyzing method invocations that belong to the same thread and create child threads . For example , if the methods in a thread A indicate that A creates new threads B , C , and D , then A is the parent of B , C , and D . By applying the same procedure to the children recursively , the complete thread dependency tree can be constructed .
Based on the thread dependency tree , we sort all created threads to determine a sequence of behaviors of interest performed by the target program . To this end , we traverse the thread dependency tree in pre order to generate sorted sequence of threads . The sorted thread order satisfies two conditions : 1 ) a parent thread is placed before its children , and 2 ) for threads with the same parent , the earlier the thread is created , the earlier it is placed .
Considering the threads in such a sorted order guarantees that we respect the ordering of object accesses across threads in multithreaded applications . For example , suppose thread A creates a new file and then thread B sets a registry key by using the newly created file . We need to place thread A before thread B . If instead we place thread B ahead of thread A , an unintended behavior sequence is generated : 1 ) setting a registry key using an existing file , and 2 ) creating a new file . Our method of sorting threads helps to determine the intended object accessing history . 223 Behavior Semantics Mining
Algorithm 1 MINEPATTERN : mine temporal patterns ( (ab∗c?)∗ ) from a sequence of invoked methods belonging to a single thread . Input : E ( a sequence of invoked methods ) ; Output : T ( mined temporal sequence ) Auxiliary functions :
Sa , Sb , Sc ( a set of methods of corresponding types )
GetRsc(e ) : returns resource accessed by e project(r , E ) : returns subsequence of E accessing resource r type(e ) : returns a if e ∈ Sa ; b if e ∈ Sb ; c if e ∈ Sc match(p , E ) : returns the longest matched subsequence of E against pattern p treating each e ∈ E as type(e ) 1 : T ← ∅ 2 : while E = ∅ do e ← head(E ) 3 : if type(e ) = a then 4 : r ← GetRsc(e ) 5 : Er ← project(r , E ) 6 : Tr ← match( “ ab∗c ? ” , Er ) 7 : T ← append(T , Tr ) 8 : E ← E \ Tr 9 : else 10 : E ← tail(E ) 11 : end if 12 : 13 : end while 14 : return T
As we mentioned in Section 2.1 , our model specifies each semanticaware behavior in the sequence by analyzing the object access history , which provides us with finer grained behavior types . To accomplish this , we record the access history of each object using a special finite automaton for each type of objects . Each state and each transition in such an automaton correspond to the object ’s typestate and its access type . The object ’s typestate is determined by its access history and describes specific state information of the object ( eg , created or existing file ) . Figure 3 shows the automata that we use for file , registry key , and mutex objects .
Based on the automaton for each object , we determine semanticaware behavior by combining the object access type and the current typestate in the corresponding automaton . In particular , when accessing a particular object , the current state of the automaton for the object is retrieved to obtain the current typestate of an accessed object , and the state of the automaton is changed based on the object access type . For the initial access to an object , the object ’s typestate is updated accordingly from its initial state wrt the given object access pattern .
To make this mining process clear , we show an example . Suppose that Figure 4 represents a sequence of behaviors observed for a program . The semantics of each behavior is mined as follows . When creating a file newfile.txt on line 1 , the current state is changed from Start to USERFILE according to Figure 3(a ) , because the program creates the file via a file writing operation and this is the first access to the file object . Second , the semantic aware behavior for line 2 is to set a user registry key using the created file . Setting a registry key makes the state of the automaton for the registry key object change from Start to USER_REG_KEY , and the current state
3
TracesThread Behavior MiningBehavior Semantics MiningString based Behavior ModelHigh Level Behavior Pattern MiningThread SortingAPI Alphabet MappingString Transform Information ( a ) File object .
( b ) Registry key object .
( c ) Mutex object .
Figure 3 : Example automata for analyzing object access history .
Figure 4 : An example behavior sequence . of the file object is USERFILE . Third , line 3 deletes the file with state USERFILE , and line 4 deletes the registry key of the USER_REG_KEY state . Based on such an analysis , the following sequence of semanticaware behaviors is generated : 1 ) creation of a user file ; 2 ) setting a user registry key based on the user file ; 3 ) deletion of the user file ; and 4 ) deletion of the user registry key . The above sequence provides more detailed information on each behavior pattern .
Table 2 shows semantic aware behaviors corresponding to objectaccessing behaviors specified by the API alphabet mapping in Table 1 . In addition to the typestates in Figure 3 , we consider two special typestates , SELF and CONST . The SELF state corresponds to the file object for the running program . For example , when a program reads its own binary executable , the semantic aware behavior is a combination of FILE_READ and SELF . The CONST state represents the constant value that is not related to access to system resource ( eg , a Boolean or constant value ) . Although our current setting only considers semantic aware behaviors in Table 2 , they can be extended by modifying the API alphabet mapping . 224 High Level Behavior Pattern Mining Behavior repetition is a key feature of high level behavior patterns . For example , Internet worms such as Sasser often create a large number of threads , trying to spread themselves to other remote hosts . Thus , they exhibit thread behavior repetitions . Also , many massmailing worms collect e mail addresses on an infected local host by repeatedly reading particular types of files such as .txt and doc In order to specify high level behavior abstractions that retain repetitive patterns , we transform a sequence of semantic aware behaviors into a special regular expression as our behavior signature . First , we construct a table to map each semantic aware behavior to a letter in an alphabet Σ . For example , Table 2 shows how we map a semantic aware behavior to a letter . Second , we transform a sequence of the semantic aware behaviors to a string over the letters in Σ . To separate substrings obtained from each thread behavior , we use a special meta symbol ‘|’ as a delimiter . Next , we concatenate the symbol ‘*’ to the repeated alphabet ( eg , AAAAA → A* ) . Finally , we find its repeated substrings and transform them to the form ( substring)* ( eg , ABABAB → ( AB)* ) .
To mine repeated substrings , we adopt an efficient suffix treebased technique that detects primitive tandem arrays in a string [ 19 ] . A primitive tandem is a string σ that cannot be expressed by its substrings , and a primitive tandem array is an array of the primitive tandems . For example , a string CABABABD has a primitive array of AB ( ie , ABABAB ) . More details on this algorithm can be found
Object Access Type
FILE_READ
FILE_WRITE
FILE_DEL
REG_SET
REG_DEL
Object Typestate SELF , SYSFILE MODIFIED_SYSFILE USERFILE SELF , SYSFILE MODIFIED_SYSFILE USERFILE SELF , SYSFILE MODIFIED_SYSFILE USERFILE SELF , SYSFILE MODIFIED_SYSFILE USERFILE , CONST SYS_REG_KEY USER_REG_KEY
NETWORK_ACCESS MUTEX_CREATE
USER , EXISTING_USER
Mapping Alphabet A , B C D E , F G H I , J K L M , N O P , Q R S T U , V
Table 2 : Examples of semantics aware behaviors and the corresponding mapping alphabet . in [ 19 ] . However , our regular expression based model is not suitable for directly applying this technique because this algorithm detects repeated characters , while we need to consider strings of the form character* ( eg , B* ) as a token . To address this problem , we transform each string token for behavior repetition into a character . In this paper , we use a letter ’s corresponding lowercase letter to represent the string token ( eg , B*→b ) . After detecting the tandem arrays in the transformed string , we rotate a tandem array left or right to find its proper starting location of the repetition . Compared to “ |D(BD)* ” , “ |(DB)*D ” represents left maximal behavior repetition for a thread and is more reasonable in terms of the starting location of behavior repetition . The string “ ( |bT|T)*b ” is more appropriate than “ |b(T|T|b)* ” , because the former has no interleaved behavior repetitions between two contiguous threads . Afterwards , we restore the transformed string by changing the lowercase letter into its corresponding string token . Combining these techniques , we can precisely mine behavior repetitions . Our behavior model retains high level behavior patterns of a program . For example , a string “ |PHB*|PH*(TH)*T(|T)* ” obtained from the dynamic trace characterizes the following behavior features : 1 ) there exist three types of threads performing different behaviors , and multiple threads of the third type perform the same behavior “ T ” ; 2 ) the first thread repeats the behavior “ B ” , which is represented by “ B* ” ; and 3 ) the “ TH ” behavior repeats in the second thread . 2.3 Example
We use a running example to illustrate the effectiveness of our model for characterizing high level behavior patterns of software . In particular , we extract the behavior of Mytob.af ( an instance of malicious software ) from its dynamic trace composed of 10,806
4
, fi ',ff()fffiff fi,fl,()fffiffifflfifi fififfifflfiff fifflfifi fififfifflfifi fi((ff,fl,()fffiff fififfifflfiff fifflfifi fi, fi ',ffff()ff,ff ,,ff()fffiffflff ff,ff ffififfflff ff, fi ',fffi( (ff),fffiflffi',fffi( (fi( (1Createafile"newfiletxt"2Createanewregistrykeybasedonthefile3Deletethefile4Deletetheregistrykey Figure 5 : Detailed behavior of Mytobaf
Process/Thread Id
( 328:340 )
( 328:1252 )
( 328:340 )
System calls NtCreateKey(448,f003f , \CurrentVersion\Run ) NtSetValueKey(448 , Windows Updater,w32NTupdt.exe ) NtClose(448 ) NtCreateKey(448,f003f , \CurrentVersion\RunServices ) NtSetValueKey(448 , Windows Updater,w32NTupdt.exe ) NtClose(448 ) NtCreateFile(a58,80100080 , \system32\w32NTupdtexe ) NtReadFile(a58 ) NtReadFile(a58 ) NtClose(a58 ) NtCreateFile(a88,c0100000,\Device\Afd\Endpoint ) NtDeviceIoControlFile(a88,BIND ) NtDeviceIoControlFile(a88,CONNECT ) NtCreateKey(448,f003f , \CurrentVersion\Run ) NtSetValueKey(448 , Windows Updater,w32NTupdt.exe ) NtClose(448 ) NtCreateKey(448,f003f , \CurrentVersion\RunServices ) NtSetValueKey(448 , Windows Updater,w32NTupdt.exe ) NtClose(448 )
Table 3 : Partial dynamic trace of Mytobaf invocations of the APIs shown in Table 1 . Detailed Malware Behavior Figure 5 shows a detailed analysis of user level behavior exhibited by Mytobf A thread is represented by a pair of process/thread identifiers ( eg , ( 108,316) ) : 1 ) a main thread ( 108:316 ) creates a mutex fnds7df6d5 , spawns a w32NTupdt.exe into the system directory , and creates a new thread ( 328:336 ) that tries to create the existing mutex , reads several system files , sends a packet to a remote host , and creates 7 threads ; 2 ) a thread ( 328,340 ) repeatedly installs the file w32NTupdt.exe , which is created by the malware , in the system by modifying startup registry keys ; 3 ) several threads try to connect to remote hosts and open particular ports ; 4 ) a thread ( 328:1252 ) reads the w32NTupdt.exe and sends network traffic ; 5 ) a thread ( 328:1308 ) reads an existing file ; and 6 ) a thread ( 328:1312 ) creates 200 threads , each of which tries to connect to a remote host . Thread Behavior Mining In this example , we focus on API usage patterns accessing four types of objects in Table 1 : file , registry key , network device , and mutex . Table 3 shows part
Process/Thread Id
( 108:316 )
( 328:336 )
( 328:340 )
( 328:364 ) ( 328:1288 ) ( 328:1304 )
( 328:1252 )
( 328:1308 ) ( 328:1224 ) . . . ( 328:2232 )
Semantic Aware Behavior MUTEX_CREATE(USER ) FILE_WRITE(USER_FILE ) MUTEX_CREATE(EXISTING_USER ) FILE_READ(SYS_FILE ) × 3 NETWORK_DEVICE_ACCESS REGISTRY_KEY_SET(USER_FILE ) REGISTRY_KEY_SET(USER_FILE ) . . .
NETWORK_DEVICE_ACCESS
FILE_READ(USER_FILE ) NETWORK_DEVICE_ACCESS FILE_READ(SYS_FILE )
NETWORK_DEVICE_ACCESS
Table 4 : Semantic aware behavior profile of Mytobaf of the dynamic trace obtained from Mytobaf Behavior mining is done as follows . Because the thread ( 328:340 ) is interleaved with the thread ( 328:1252 ) through thread level context switching , we first group API calls by their process/thread identifiers , and sort the groups according to the occurrence of type a API calls ( ie , ( 328:340 ) → ( 328:1252) ) . Then for each group of the traces , we mine the ( ab∗c?)∗ pattern . For the thread ( 328:340 ) , we observe a sequence of API calls that are related to the same registry key object and mine this as a registry key access behavior : the NtCreateKey opens the startup registry key object whose identifier is 448 , and NtSetValueKey modifies the registry key object to install the w32NTupdt.exe file on the system , which is followed by NtClose that releases the registry key . This is captured by the ( abc ) pattern . Similarly , we can mine two other patterns : reading the file ( (ab∗c ) ) and accessing network device object ( (ab) ) . Thread Sorting To locate process and thread creations in the traces , the corresponding APIs ( ie , NtCreateProcess , NtCreateProcessEx , and NtCreateThread ) are tracked . Identifiers of the created processes and threads are obtained by analyzing the parameters containing them . Figure 6 shows the thread dependency tree of Mytob.af in Figure 5 . We sort the created threads by traversing the tree in pre order . This leads to the following thread order : [ (108,316 ) , ( 328,336 ) , , ( 328,1312 ) , ( 328,1224 )
5
, fi'ff()fffi(flffi(ffifflfi'fififfffflffffiflffifflfi'fi*fifflff(cid:30)(cid:30 ) !"#$(cid:30)(cid:30)%fi&fifl(cid:30)(cid:30)’fifl!,(ff)fififfififfifflfi'fi, fi'fffiflfffififlffi, fi'fffiflfffififlffi(ffifflfi'fififfffflffffiflffi*fi'ff*fifflff(cid:30)(cid:30)'+fifi,) 'ffififfi*fi'ff*fifflff(cid:30)(cid:30))))(cid:30)(cid:30)'( +fi)( ffi/ffi*fi'ff*fifflff(cid:30)(cid:30)'+fifi,) 'ffiffi$fiff!fi’+,',flffifflfi'fi, fi'fffiflfffi/)ffiffifflfi'fi, fi'fffiflfffifl/ffiffifflfi'fi, fi'fffiflff(flffi0ffifflfi'fi, fi'fffiflff(fi)/ffi()ffifflfi'fi, fi'fffiflff(flflffi((ffifflfi'fi, fi'fffiflff(fi)ffi(flffifflfi'fi, fi'fffiflff(fi(flffi, fi'fffiflfffi/)ffi*fi(fi'1(ffi$fi*fi2%3fi%4'*fi536(cid:30)$#,7*8(cid:30),++(cid:30)ff+’(cid:30)fflfi4fi+(cid:30)*9ff+’:(ff'fi9’fifl!,(ff)fififfiffiflffi$fi*fi2%3fi%4'*fi536(cid:30)$#,7*8(cid:30),++(cid:30)ff+’(cid:30)fflfi4fi+(cid:30)*$fi;,fi9ff+’:(ff'fi9’fifl!,(ff)fififfiffi<, fi'fffiflfffifl/ffi(ffi,%+,+fi,+'fi&+fi +, fi'fffiflff(flffi(ffi,%+,+fi,+'fi&+fi +, fi'fffiflff(fi)/ffi(ffi#(fi=+, fi'fffiflff(flflffi(ffi*fi'ff*fifflff(cid:30)(cid:30 ) !"#$(cid:30)(cid:30)%fi&fifl(cid:30)(cid:30)’fifl!,(ff)fififfiflffi$fiff!fi’+,',, fi'fffiflff(fi)ffi(ffi*fi'ff*fifflff(cid:30)(cid:30)"+,&fi'ff$fi2(cid:30)(cid:30))))(cid:30)(cid:30) ff*+2)ffi, fi'fffiflff(fi(flffi(ffifflfi'fi, fi'fffiflff(flfl/ffiflffifflfi'fi, fi'fffiflff(fi/)ffi)))fl))ffifflfi'fi, fi'fffiflffflflfiflffi, fi'fffiflff(flfl/ffi(ffi,%+,+fi,+'fi&+fi +, fi'fffiflff(fi/)ffi(ffi,%+,+fi,+'fi&+fi +))), fi'fffiflffflflfiflffi(ffi,%+,+fi,+'fi&+fi + Figure 6 : Thread dependency tree of Mytobaf
, ( 328,2232) ] . Behavior Semantics Mining Table 4 describes a sequence of semantic aware behaviors of Mytobaf Such a sequence provides detailed semantic information of malware behavior patterns . For example , although the two treads ( 108:316 ) and ( 328,336 ) share the same behavior pattern of the mutex creation , their semanticaware behavior is different : the thread ( 108:316 ) creates a new mutex , and the thread ( 328,336 ) tries to create an existing mutex . Also , the thread ( 328:340 ) modifies a registry key based on a file created by the malware itself . High Level Behavior Pattern Mining The string based model is based on a sequence of the semantic aware behaviors . We construct the model as follows . First , we transform the sequence into a string based on a predefined mapping alphabet . For this example , we use the alphabet in Table 2 . The transformation generates a string |UH|VB*T|P*|T . . |T|DT|B|T . |T Afterwards , we replace all string tokens for behavior repetitions with their corresponding lowercase letters to get |UH|VbT|p|T . . |T|DT|B|T . |T We then perform the suffix tree based analysis to detect substring repetitions and generate the behavior string by restoring all lowercase letters in the transformed string to the corresponding string tokens to get |UH|VB*T|P*(|T)*|DT|B(|T)* , which is the string based behavior model of the malware . Table 5 shows the behavior semantics exhibited by each thread type represented by a substring of our model .
3 . SOFTWARE SIMILARITY ANALYSIS
So far , we have presented a model that specifies behavior patterns of software based on a special string . In addition to its modeling power , it has the important property for software behavior similarity analysis : programs with similar behavior patterns are modeled by similar strings . Based on this observation , we investigate effectiveness of our behavior model in analyzing software behavior similarity . To this end , we present a technique to analyze behavioral similarity of programs based on our behavior model . This section defines a similarity metric between a string and a cluster , and describes algorithms for clustering/signature generation based on the defined metric . Throughout this section , we use behavior string to refer to an instance of our regular expression based behavior model . 3.1 String Similarity Metric
To perform similarity analysis using our model , it is necessary to have a metric for string similarity . In this work , we utilize a novel sequence similarity metric proposed by Yang and Wang [ 24 ] . The metric is based on PS(σ ) and P r(σ ) :
• PS(σ ) , prediction probability of σ based on S , is the probability that a string σ is predicted under a conditional probability distribution modeling a cluster S . For a string σ = s1s2 . . . sl , PS(σ ) = PS(s1 ) × PS(s2|s1 ) × . . . PS(sl|s1s2 . . . sl−1 ) where PS(si|s1 . . . si−1 ) is the conditional probability that the symbol si is followed by the substring s1s2 . . . si−1 in the cluster S .
6
Substring |UH |VB*T
|P*
( |T)*
|DT |B ( |T)*
Behavior Semantics 1 . Create user mutex 2 . Create user file 1 . Create the existing user mutex 2 . Repeat to read system files 3 . Access network device 1 . Repeat to set a registry key based on user file
1 . Create multiple threads accessing network device
1 . Read the user file 2 . Access network device 1 . Read a system file 1 . Create multiple threads accessing network device
Thread
( 108:316 )
( 328:336 )
( 328:340 )
( 328:364,128,1304 )
( 328:1252 )
( 328:1308 )
( 328:1224,,2232 )
Table 5 : Behavior semantics of the obtained model . selection . For a string σ , Pr(σ ) =l
• P r(σ ) is the probability that a string σ is obtained by random i=1 p(si ) where p(si ) is the probability that symbol si is observed in a set of strings to be clustered .
PS(sj . . . si ) We define the similarity metric SIM S(σ ) = max P r(sj . . . si ) and it captures the maximum similarity between any substring of σ and the cluster S . A sequence clustering algorithm , CLUSEQ [ 24 ] , based on this metric has been effectively applied to various data sets such as protein sequences and document text .
1≤j≤i≤l
Although this metric is suitable for other sequence data , it is not appropriate in our setting . Comparing with other sequence data , the length of a behavior string is typically much shorter , which can cause potential noise to estimating prediction probability . To guarantee a high degree of noise resilience , CLUSEQ introduces the concept of a significant segment , a substring that appears at least a user defined number of times , and estimates the prediction probability using only significant segments . However , we cannot adopt this technique because our behavior strings are relatively short . Instead , we utilize two effective string similarity measures , Max similarity ratio and the Jaccard index [ 9 ] . Max similarity ratio is defined as |σ|2/(|σ| × |S| ) , where σ , σ and S represent an input string , a substring with the maximum similarity , and the seed behavior string of the cluster S . This metric represents how large portion of σ and S is matched with high similarity . The Jaccard index , J(A , B ) = |A ∩ B|/|A ∪ B| , is a metric for similarity between two sets [ 9 ] . We compute the Jaccard index considering a string as a multiset . Based on SIM S(σ ) and these two string similarity measures , we define the similarity metric we use : S(σ ) = SIM S(σ ) × Max similarity ratio(S.seed , σ ) × SIM Jaccard index(S.seed , σ ) , where S.seed is the initial string of S . This similarity metric not only retains advantages of the original SIM S(σ ) , but also reduces noise impact on the prediction probability estimation by considering other string similarity metrics with the seed of S . Although other similarity metrics combining these mea
, fi'ff ,ff(fi'ffff,ff(fi'ff),ff(fi'ff),ff(fi' (fifi,ff(fi' ff),ff(fi' ((,ff(fi' fffi,ff(fi' ff (,ff(fi' ((),ff(fi' ff)fffifffiff,ff(fi'((ff( Algorithm 2 CONSOLIDATECLUSTERS : Merge similar clusters . Input : C ( a set of initial clusters seed , members , CPD ) ; Output : M ( a set of merged clusters ) Auxiliary functions : t ( a threshold for merging clusters ) all σ ∈ X.member a substring of σ ∈ Σ , inducing max similarity to seed ∪Y.members , UpdateCPD(Y.CPD , X.members )
UpdateCPD(C , Σ = {σ1 , . . . , σn} ) : update C.CPD by adding ClusterMerge(X , Y ) : return a new cluster Y.seed , X.members ComputeSim(S , σ ) : return SIM MergeIndex(X , Y ) : return minimum of ComputeSim(Y , σ ) for 1 : M ← ∅ 2 : repeat 3 : 4 : pick the smallest cluster Ci ∈ C pick the largest cluster Cj ∈ C such that if Ci = Cj then else end if
MergeIndex(Ci , Cj ) ≥ t × ComputeSim(Cj , Cj.seed ) C ← ( C ∪ Merge(Ci , Cj))\Ci S ← M ∪ Ci
S(σ )
5 : 6 : 7 : 8 : 9 : 10 : until |C| = 1 11 : M ← M ∪ C
This index is used to select a pair of clusters to merge in our clustering algorithm .
Our algorithm is composed of two phases : Cluster Initial ization and Cluster Consolidation . Cluster Initialization In the initialization phase , we group identical strings in the string database , and initialize a cluster for each group . We assign a corresponding string to its seed , update its members using the group , and compute its CPD based on members . From the initialization phase , we can effectively reduce the number of input data to cluster in the consolidation phase , because software derived from the same source code tend to generate identical behavior strings , and the strings can be efficiently grouped with hashing . Cluster Consolidation Because our similarity metric is based on the CPD of members in the cluster , the similarity computed on larger cluster can be considered more reliably . Based on this intuition , we adopt a policy for merging the smallest cluster X into the largest cluster Y that satisfy MergeIndex(X , Y ) ≥ t × SIM Y ( Y.seed ) , where t is a given threshold and SIM Y ( Y.seed ) can be considered as the maximum similarity to the cluster Y . With this merging policy , we can improve the similarity computation during clustering and control the intra cluster similarity between its seed and members in terms of the threshold t . The cluster with the least reliable CPD is removed , and its members are merged into the similar cluster where the similarity is computed from the most reliable CPD in terms of the threshold . When we merge clusters , instead of using σ ∈ X.members , we update Y.CPD using the substring of the σ that induces the maximum similarity Y.seed to reduce outliers in YCPD Algorithm 2 gives details of cluster consolidation . 3.4 Signature Generation and Matching
Our cluster model , seed , members , CPD , can be extended to behavioral signatures that detect members in the cluster . Because a behavioral signature can detect multiple programs that perform similar behavior , this can reduce the number of signatures . Based on the cluster model , we define the behavior signature BehaviorSig(C ) of a cluster C as follows :
C.seed , C.CPD , min_sim = min
σ∈C.members
( SIM
C ( σ) ) .
To match the behavior signature for a given behavior string σ , we
7
Figure 7 : Probabilistic suffix tree of ABABCAB . sures are possible , our result in Section 4 indicates that SIM very effective in practice . 3.2 String Similarity Estimation
S(σ ) is
Because string similarity estimation is a key component of the clustering algorithm , it is necessary to maintain the conditional probability distribution ( CPD ) derived from the strings in the cluster . For this purpose , CLUSEQ uses a probabilistic suffix tree ( PST ) , a variant of normal suffix trees such that each node contains information on characters following the reverse of the path to the node . A PST is easy to construct and update . We can also retrieve the CPD efficiently by using a PST . For example , Figure 7 represents the PST of ABABCAB . To compute P ( C|AB ) , we first find a node whose path from the root is BA , the reverse of AB , and compute the probability based on subsequent character information on the node ( ie , 1/3 ) . Based on the PST , SIM S(σ ) can be computed efficiently via dynamic programming . However , because a PST is constructed from empirical data , it is required to compute the prediction probabilities of unknown strings . For this , we adopt adjusted probability estimation , which assigns minimum probability to unknown symbol sequences , and adjust the prediction probability of known ones . More details are available in the CLUSEQ paper [ 24 ] . 3.3 Behavior based Software Clustering
In CLUSEQ , although the linear regression based on the histogram of similarity between each unclustered sequence and all clusters adapts new threshold for the next iteration , the same threshold value for joining clusters is used to recluster unclustered strings in each iteration . This may lead to decreased clustering precision when the threshold is adapted to a small number . To address this problem , we present an agglomerative hierarchical clustering algorithm [ 10 ] for the behavior strings . Our algorithm is designed to show good performance when there exist many identical or similar sequences in the string database . This requirement is appropriate in our problem setting because the behavior strings of software derived from the same origin tend to be identical or similar . Our clustering algorithm models each cluster based on three items of seed , members , CPD , where seed is a seed string , members denotes member strings , and CPD is the conditional probability distribution obtained from members . Based on this model , we define a Merge Index that represents validity of merging a cluster X into a class Y in terms of our similarity measure :
Y ( σ) ) .
MergeIndex(X , Y ) = min
( SIM
σ∈X.member
, fi'fffffi(fiff)fffififffffffi(fifl,(fi'fffffffi(fifl,,fi'fffffififl ,ffifi'fffffififf)fffififl,fi'fiflfi,fi'fffffffififl ,fi'fffffffififl,fi'fiflfi,fi'fffffffififl,fi'fffffffififl,,fi'fffffffififl,fi'fffffffififl,,fi'fiflfi,fi'fffffffififl,,fi'fiflfi,fi'fffffififl,fi'fffffififl,,fi'fffffififl,fi'fffffififl,,fi'fiflfi,ffifi'fffffififf)fffififl,,fi'ff)fffififl,fi'fiflfi,fi'ff)fffififl,,fi'fiflfi ( a ) Distribution of string length .
( b ) Distribution of ratio of string length to trace size .
Figure 8 : Empirical evaluation on abstraction capability .
C ( σ ) ≥ evaluate the following signature matching condition : SIM BehaviorSig(C)min_sim If the condition holds , we consider the string σ is matched , because the similarity of σ to C.seed is higher than the least similar string in Cmembers Note that we can evaluate the condition from the BehaviorSig(C ) , because C.members is not necessary for computing SIM
C ( σ ) .
4 . EMPIRICAL EVALUATION
This section describes the implementation and evaluation of our behavior model and its effectiveness for software similarity analysis . 4.1
Implementation
We mainly implemented our idea using Python , except for collecting system calls : 1 ) we utilized a public SuffixTree package [ 20 ] for the string repetition analysis ; 2 ) we developed the PST data structure based on a dictionary representation of the Trie [ 21 ] ; 3 ) when we generate initial clusters , dictionaries in Python are utilized , which can easily collect data with the same label .
To collect dynamic traces , we developed a Windows Driver Model ( WDM ) driver that performs SSDT hooking [ 7 ] to track Win32 Native API calls . For file and registry key objects , a number of system calls are gathered , including benign operations . To address this issue , we focus on accesses to 1 ) files within the local filesystem and 2 ) security related registry keys.1 4.2 Evaluation Results
In our evaluation , we focus on polymorphic malware behavior and apply our technique to behavioral malware clustering and behavioral signature generation/matching , which are important problems in software similarity analysis . For the evaluation , we collected 5,419 malware samples from VX Heavens2 and Offensive Computing3 and transformed them into their malware behavior strings4 . We use the term a malware behavior string to refer to an instance of our string based behavior model obtained from a malware sample . To collect its dynamic trace , we monitored each malware instance on 1We define security related keys as those monitored by the Registry Guard component of Kaspersky Anti Virus 8.0 [ 12 ] . 2http://vxnetluxorg 3http://wwwoffensivecomputingnet 4Our malware sample set and their behavior strings are available at http://wwwcsifcsucdavisedu/~kwon/malware_ strtxt
Microsoft Windows XP SP2 running on QEMU [ 16 ] for 30 seconds . Based on our experience , traces collected during such a duration are sufficient for behavioral analysis of malware . For other applications , the time limit may need to be adjusted accordingly .
421 Abstraction Capability We first evaluate our model ’s abstraction power . In particular , we measure the amount of length reduction of malware behavior strings over the corresponding traces . This evaluation shows how effective our model is for abstracting the dynamic traces because our model characterizes important high level behavioral properties ( which are discussed in Section 2 ) .
Figure 8 depicts distributions of length of malware behavior strings and the reduction ratio for the collected malware samples . Length 37 in Figure 8(a ) corresponds to the number of malware samples whose string lengths are greater than 36 , and we rounded off the results to four decimal places to measure the reduction ratio in Figure 8(b ) . The results show that our model can represent malware behavior with relatively short strings even for long sequences of API invocations .
422 Cluster Quality and Quantity We now describe our evaluation of the proposed clustering technique in Section 3 . We evaluate the technique in terms of both cluster quality and quantitiy . Later we evaluate the precision of our technique by comparing our results to clusters obtained by a singlelinkage hierarchical clustering algorithm [ 10 ] using the Jaccard index [ 9 ] , which was shown effective for clustering malware behavior profiles [ 2 ] . Because the similarity metrics are different , we only compare the clusters obtained by applying the maximum similarity threshold , ie , MergeIndex(Ci , Cj ) = ComputeSim(Cj , Cj.seed and Jaccard index = 10 The Jaccard index based similarity metric can be considered as measuring similarity in terms of the frequency of each object accessing pattern , the number of threads a malware sample creates , and the number of behavior repetitions .
To construct the reference clusters , we first grouped all malware samples with identical behavior strings . For every pair of samples , we partitioned their behavior strings into thread level substrings . If all the corresponding thread level substrings are similar , which we define as having at least a 50 % common prefix . For example , we would assign |BUH|DVPHBT|P∗ and |BUH|DVPBRUT|P∗ to two different clusters because the maximal shared prefix DVP of DVPHBT
8
510152025303502004006008001000Mean : 9.367Std Dev : 6.757# of malwarelength of behavior string00000005001000150020002500300035020040060080010001200140016001800Mean : 0.0035 Std Dev : 0.0032# of malwarelength of behavior string / # of API invocations ( a ) Cluster quantity .
( b ) Cluster quality .
( c ) Signature error rates .
Figure 9 : Empirical evaluation on clustering and signature matching . and DVPBRUT is not long enough . From this extensive analysis , we obtained 1,302 reference clusters . Clustering Result We apply our clustering technique to malware clustering on a machine with an Intel Xeon 5160 CPU and 16GB RAM . Figure 9(a ) and Figure 9(b ) show quantity and the quality information ( ie , precision and recall ) of clusters wrt various threshold values . We observe that our algorithm significantly reduced the number of clusters compared to the number of original malware samples . The reduction rate was about from 70 % to 90 % for the thresholds . Our algorithm also produces optimal clusters in terms of precision/recall for threshold 0.2 and shows overall high precision/recall .
Our algorithm can effectively detect polymorphic or slightly modified malware . For example , 33 malware samples labeled as belonging to three malware families ( RBot , SDBot , and Agobot ) having the following malware behavior strings are clustered for threshold 0.2 : |HUH|VPBT , |HUH|VPBT|T , |HUH|VPBT(|T)∗ , |HUH|VPBT|P|T , |HUH|VPBT|P∗ . These malware samples commonly perform the following tasks represented by “ |HUH|VPBT" . They spawn a hack tool SVKP.sys , create a mutex , replicate itself to the system directory , create the previous mutex , install itself by modifying startup system registry key , read c : \autoexec.bat , and connect to the remote host . Despite the shared behavior pattern , their concrete instances for malware behavior are different . For example , Rbot.abw and Agobot.afb create different files ( pnpsrv.exe and nlsmon.exe ) and mutexes ( SKY2K4 and bkaaslc ) , respectively . However , in spite of these differences , our model can easily capture the invariant behavior sequence patterns . In addition , some added features can be easily identified using our model . For example , the “ P∗" represents the repetitive registry key modification for malware installation , and the “ ( |T)∗" specifies the repetitive thread creation that exploits remote code execution vulnerabilities for malware propagation . Comparison According to Figure 9(a ) and Figure 9(b ) , comparing to the Jaccard index based approach , our algorithm produces more clusters , but it is more precise when we consider the maximum similarity . This is because the Jaccard similarity considers no sequence information of behavior , which causes different behavior patterns to be misclassified into same clusters . For example , malware samples that have different string based behavior profiles ( eg , “ |H|PBT(|T)∗ ” , “ |HP|BT(|T)∗ ” , “ |BH|PT(|T)∗ ” , and “ |PH(|T ) ∗ |BT ” ) are merged into a single cluster , although we apply the maximum Jaccard similarity for clustering . However , this is not appropriate , because their behavior sequence patterns are different . From our evaluation , we believe that considering the temporal behavior sequence is necessary to specify detailed malware behavior models and precisely analyze malware behavior similarity .
Signature Matching Errors
423 As we mentioned in Section 3.4 , our cluster model can be used as behavioral signatures to detect malware . To evaluate the reliability of the generated signatures , we conducted the following analysis : 1 ) we collected 307 default programs of Microsoft Windows XP SP2 and 15 popular freeware out of the top 20 of download.com 5 ; 2 ) we generated their malware behavior strings as before and matched them with the cluster models , which are obtained from the evaluation .
Figure 9(c ) shows the results of matching the signatures with benign samples in terms of false positive and negative rates . These results indicate that the proposed cluster model can produce reliable behavioral malware signatures . First , even for small threshold value of 0.01 , our signature produces low false positive rates ( 9/322 ) . The main reason for having these false positives is that some benign behavior strings are matched with those clusters whose seeding strings are too short to represent meaningful malicious behavior . In particular , the following five seeding strings cause false positives : |BHU , |BUB , |H|U , |B|T , and |HUH . After a detailed analysis , we realized that such short strings are caused by crashes of malware executables or fixed time duration to collect the system call traces . We believe these problems can be solved straightforwardly by collecting correctly behavioring malware samples and increasing the duration . Second , we did not have any false negatives during our evaluation , and our signature model can precisely characterize all malware samples used in building the signatures .
424 Performance To evaluate the performance of our algorithm , we measured its execution time for clustering . Despite the pair wise comparisons for cluster consolidation , our algorithm shows good performance . Even for higher threshold values , the clusters can be collected in 4 minutes ( eg , it took 187.22 seconds to cluster 5,419 strings based on a threshold value 09 ) There are two reasons of this practical usability of our algorithm . First , we efficiently group same behavior strings into a cluster , which highly reduces the number of input data to cluster . This initial cluster generation practically shows promising in malware clustering , because polymorphic malware derived from the same source code tend to generate the same behavior strings . In our evaluation , 1,656 initial clusters were generated from 5,419 malware samples . Second , we only perform pairwise comparisons with a seeding string in each cluster to find the largest similar cluster . In comparison with standard agglomerative hierarchical algorithms , the number of comparisons in our algorithm is much smaller .
5http://wwwdownloadcom/3101 2001_4 0html?tag= contentBody;mostPopTwoColWrap .
9
00020406081040060080010001200140016001800# of clustersthreshold Sequence similarity based Jaccard index based0002040608100607080910cluster metricsthreshold precision ( Sequence similarity ) recall ( Sequence similarity ) precision ( Jaccard index ) recall ( Jaccard index)000204060810000%100%200%300%400%error ratesthreshold false positive false negative 5 . RELATED WORK
Our work is related to research on specifying software behavior and behavior based similarity analysis . Software Behavior Specification To specify software behavior , Christodorescu et al . [ 3 ] construct , from dynamic traces , a directed acyclic graph ( DAG ) where each node corresponds to a collected system call and an edge to a dependency among the system calls . Kolbitsch et al . [ 13 ] improve this DAG based behavior model by considering dataflow dependency determined by system call arguments . Schuler et al . [ 18 ] present dynamic birthmark , a set of short call sequences received by objects of the Java API , for characterizing program execution . Wang et al . [ 23 ] propose birthmarks of a program , which are based on system call sequences which are not commonly seen in executions of the program with respect to different inputs or executions exhibited by many other programs . Comparing to these approaches , our model specifies software behavior more abstractly and at a higher level . We represent each behavior based not on a single system call but a particular API usage pattern . Furthermore , our model specifies a sequence of software behaviors as a a special regular expression to capture high level behavior patterns of the target program . Software Behavior Similarity To detect similar behavior patterns , prior research [ 1 , 2 , 8 , 14 , 17 , 22 ] works by grouping similar behavior models obtained from captured behavior properties of software samples . Although following this general approach , our technique has several advantages . First , while previous research has focused on graph similarity [ 8 , 22 ] or numerical vector similarity [ 1 , 2 , 14 , 17 ] , our technique detects the sequence similarity , which provides precise similarity analysis of software behavior . Second , our model can effectively characterize high level abstraction of software behavior such as semantic aware and repetitive behaviors , while previous approaches do not model such high level properties of software execution . Ideally , we would have liked to empirically compare our technique with the existing work , but neither their implementations nor their evaluation subjects are made available , which precludes such a comparison . Nevertheless , the conceptual advantages of our model over existing ones are quite evident , and we have demonstrated empirically the effectiveness of our approach . Previous work on dynamic signature generation/matching has focused on generating malware signatures [ 4 , 5 , 13 , 26 ] . These approaches determine malware signatures as part of the executed instructions or control and data flow dependency information from dynamic traces . However , the precision of these signature models has not yet been demonstrated .
Other work is also related to the analysis of instruction level similarity between two program versions . Zhang and Gupta [ 27 ] present a technique to discover the mapping between instructions in two programs . Nagarajan et al . [ 15 ] analyze similarity in the control flow of programs . Jiang and Su [ 11 ] present a technique to mine code fragments with similar input/output behavior using random testing . These approaches aim at analyzing similarity of partial program fragments based on detailed low level execution information , while our purpose is to analyze high level similarity of complete programs .
6 . CONCLUSION AND FUTURE WORK
In this paper , we have proposed a novel behavior model that uses regular expressions to precisely and succinctly specify high level behavior patterns . Based on the model , we have developed an effective clustering algorithm and applied it to malware clustering and signature generation/matching . Evaluation results on a large malware collection show that our technique is effective : 1 ) it is concise , capable of representing long traces with short signatures ;
10 and 2 ) it can precisely cluster malware with similar behavior patterns and generate reliable behavior based malware signatures . We believe our model is general and is applicable to other applications involving similarity analysis of software .
For future work , we plan to consider various software similarity analyses based on sequence data mining , which has been widely studied in other research fields such as biological computation and bioinformatics . For example , analysis of software evolution can be conducted by adapting algorithms for analyzing DNA sequence evolution [ 6 , 25 ] . Our model opens the door for interesting crossfertilizations between the two areas .
7 . REFERENCES [ 1 ] M . Bailey , J . Oberheide , J . Andersen , Z . M . Mao , F . Jahanian , and
J . Nazario . Automated Classification and Analysis of Internet Malware . In Proc . RAID , 2007 .
[ 2 ] U . Bayer , P . M . Comparetti , C . Hlauscheck , C . Kruegel , and E . Kirda . Scalable , Behavior Based Malware Clustering . In Proc . NDSS , 2009 . [ 3 ] M . Christodorescu , S . Jha , and C . Kruegel . Mining specifications of malicious behavior . In Proc . ESEC/FSE , 2007 .
[ 4 ] M . Christodorescu , S . Seshia , S . Jha , D . Song , and R . E . Bryant .
Semantics aware malware detection . In Proc . S&P , 2005 .
[ 5 ] M . Feng and R . Gupta . Detecting virus mutations via dynamic matching . In Proc . ICSM , 2009 .
[ 6 ] N . Galtier and M . Gouy . Inferring pattern and process :
Maximum likelihood implementation of a nonhomogeneous model of dna sequence evolution for phylogenetic analysis . Molecular Biology and Evolution , 15(7):871–879 , 1998 .
[ 7 ] G . Hoglund and J . Butler . Rootkits : Subverting The Windows Kernel .
Addison Wesley , 2006 .
[ 8 ] X . Hu , T c Chiueh , and K . G . Shin . Large scale malware indexing using function call graphs . In Proc . CCS , 2009 .
[ 9 ] Jaccard index . http://enwikipediaorg/wiki/Jaccard_index
[ 10 ] A . K . Jain , M . N . Murty , and P . J . Flynn . Data clustering : a review .
ACM Comput . Surv . , 31(3):264–323 , 1999 .
[ 11 ] L . Jiang and Z . Su . Automatic mining of functionally equivalent code fragments via random testing . In Proc . ISSTA , 2009 .
[ 12 ] Kaspersky Anti Virus 80 http://usakasperskycom/ products_services/anti virusphp
[ 13 ] C . Kolbitsch , P . M . Comparetti , C . Kruegel , E . Kirda , X . Zhou , and
X . Wang . Effective and efficient malware detection at the end host . In Proc . 18th Usenix Security Symposium , 2009 .
[ 14 ] T . Lee and J . J . Mody . Behavioral Classification . In Proc . EICAR ,
2006 .
[ 15 ] V . Nagarajan , R . Gupta , M . Madou , X . Zhang , and B . D . Sutter .
Matching control flow of program versions . In Proc . ICSM , 2007 .
[ 16 ] QEMU : Open Source Processor Emulator . http://bellardorg/qemu/
[ 17 ] K . Rieck , T . Holz , C . Willems , P . Dussel , and P . Laskov . Learning and
Classification of Malware Behavior . In Proc . DIMVA , 2008 .
[ 18 ] D . Schuler , V . Dallmeier , and C . Lindig . A dynamic birthmark for java .
In Proc . ASE , 2007 .
[ 19 ] J . Stoye and D . Gusfield . Simple and flexible detection of contiguous repeats using a suffix tree . Theoretical Computer Science , 270(1 2):843–856 , 2002 .
[ 20 ] SuffixTree – python bindings for a suffix tree . http://wwwdaimiaudk/~mailund/suffix_treehtml
[ 21 ] Trie . http://enwikipediaorg/wiki/Trie [ 22 ] X . Wang , Y C Jhi , S . Zhu , and P . Liu . Behavior based software theft detection . In Proc . CCS , 2009 .
[ 23 ] X . Wang , Y C Jhi , S . Zhu , and P . Liu . Detecting software theft via system call based birthmarks . In Proc . ACSAC , 2009 .
[ 24 ] J . Yang and W . Wang . CLUSEQ : Efficient and Effective Sequence
Clustering . In Proc . ICDE , 2003 .
[ 25 ] Z . Yang . Paml 4 : Phylogenetic analysis by maximum likelihood . Mol
Biol Evol , May 2007 .
[ 26 ] Q . Zhang and D . S . Reeves . MetaAware : Identifying Metamorphic
Malware . In Proc . ACSAC , 2007 .
[ 27 ] X . Zhang and R . Gupta . Matching execution histories of program versions . In Proc . ESEC/FSE , 2005 .
