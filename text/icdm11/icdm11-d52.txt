2011 11th IEEE International Conference on Data Mining
Efficient Mining of a Concise and Lossless Representation of High Utility Itemsets
Cheng Wei Wu1 , Philippe Fournier Viger1 , Philip S . Yu2 , Vincent S . Tseng1
1Department of Computer Science and Information Engineering ,
National Cheng Kung University , Taiwan , ROC
2Department of Computer Science , University of Illinois at Chicago , Chicago , Illinois , USA
{silvemoonfox , philippefv}@gmailcom , psyu@csuicedu , tsengsm@mailnckuedutw
Abstract—Mining high utility itemsets from transactional databases is an important data mining task , which refers to the discovery of itemsets with high utilities ( eg high profits ) . Although several studies have been carried out , current methods may present too many high utility itemsets for users , which degrades the performance of the mining task in terms of execution and memory efficiency . To achieve high efficiency for the mining task and provide a concise mining result to users , we propose a novel framework in this paper for mining closed+ high utility itemsets , which serves as a compact and lossless representation of high utility itemsets . We present an efficient algorithm called CHUD ( Closed+ High Utility itemset Discovery ) for mining closed+ high utility itemsets . Further , a method called DAHU ( Derive All High Utility itemsets ) is proposed to recover all high utility itemsets from the set of closed+ high utility itemsets without accessing the original database . Results of experiments on real and synthetic datasets show that CHUD and DAHU are very efficient with a massive reduction ( up to 800 times in our experiments ) in the number of high utility itemsets . In addition , when all high utility itemsets are recovered by DAHU , the approach combining CHUD and DAHU also outperforms the state of the art algorithms in mining high utility itemsets .
Keywords utility mining ; frequent itemset ; closed+ high utility itemset ; lossless and concise representation
I .
INTRODUCTION in together by customers . However ,
Frequent itemset mining ( abbreviated as FIM ) [ 1 , 10 ] is a fundamental research topic in data mining . One of its popular applications is market basket analysis , which refers to the discovery of sets of items ( itemsets ) that are frequently purchased this application , the traditional model of FIM may discover a large amount of frequent itemsets with low profit and lose the information on valuable itemsets having low selling frequencies . These problems are caused by the facts that ( 1 ) FIM treats all items as having the same importance/unit profit/weight and ( 2 ) it assumes that every item in a transaction appears in a binary form , ie , an item can be either present or absent in a transaction , which doesn’t indicate its purchase quantity in the transaction . Hence , FIM cannot satisfy the requirement of users who desire to discover itemsets with high utilities such as high profits .
To address these issues , utility mining [ 2 , 5 , 6 , 7 , 8 , 11 , 13 , 15 , 19 , 20 , 24 , 26 ] emerges as an important topic in data mining . In utility mining , each item has a weight ( eg unit profit ) and can appear more than once in each transaction ( eg purchase quantity ) . The utility of an itemset represents
1550 4786/11 $26.00 © 2011 IEEE DOI 101109/ICDM201160
824 its importance , which can be measured in terms of weight , profit , cost , quantity or other information depending on the user preference . An itemset is called a high utility itemset ( abbreviated as HUI ) if its utility is no less than a userspecified minimum utility threshold . Utility mining has a wide range of applications such as website click stream analysis [ 2 , 5 , 19 , 24 ] , cross marketing analysis [ 6 , 20 , 26 ] and biomedical domains [ 7 ] .
However , HUIs mining is not an easy task since the downward closure property [ 1 , 10 ] in FIM does not hold in utility mining . The search space cannot be directly pruned to find HUIs as in FIM since a superset of a low utility itemset can be a high utility itemset . Many studies [ 2 , 13 , 15 , 20 , 21 ] were proposed for mining HUIs , but they often present a large number of high utility itemsets to users such that comprehension of the results becomes difficult . Meanwhile , the algorithms become inefficient in terms of time and memory requirement . In particular , the performance of the mining task decreases greatly under low minimum utility thresholds or dense databases .
Answering
To reduce the computational cost in FIM while presenting fewer and more important patterns to users , many studies developed concise representations , such as free sets [ 3 ] , nonderivable sets [ 4 ] , maximal itemsets [ 9 ] and closed itemsets [ 14 , 16 18 22 , 27 ] . These representations successfully reduce the set of itemsets found , but they were developed for frequent itemset mining instead of high utility itemset mining . Therefore , an important research question is “ Is it possible to conceive a compact and lossless representation of high utility itemsets inspired by these representations to address the aforementioned issues in HUI mining ? ” this question positively is not easy . Developing a concise and complete representation of HUIs poses several challenges : 1 . into HUI mining may produce a
Integrating concepts of concise representations from FIM lossy representation of all HUIs or a representation that is not meaningful to the users . 2 . The representation may not achieve a significant reduction in the number of extracted patterns to justify using the representation . 3 . Algorithms for extracting the representation may not be efficient . They may be slower than the best algorithms for mining all HUIs . It may be hard to develop an efficient method for recovering all HUIs from the representation .
4 .
In this paper , we address all of these challenges by proposing a condensed and meaningful representation of
HUIs named Closed+ High Utility Itemsets ( Closed+ HUIs ) , which integrates the concept of closed itemset into HUI mining . Our contributions are four fold in correspondence to resolving the four challenges mentioned previously : 1 . The proposed representation is lossless by using a new that allows structure named utility unit array recovering all HUIs and their utilities efficiently .
2 . The proposed representation is also compact . Experiments show that it reduces the number of itemsets by several orders of magnitude , especially for datasets containing long HUIs ( up to 800 times ) . 3 . We propose an efficient algorithm , named CHUD ( Closed+ High Utility itemset Discovery ) , to find this representation . It includes three novel strategies named REG , RML and DCM its performance . Results show that CHUD is much faster than current best methods for mining all HUIs [ 20 ] . 4 . We propose a top down method named DAHU ( Derive All High Utility itemsets ) for efficiently recovering all HUIs from the set of Closed+ HUIs . The combination of CHUD and DAHU provides a new way to obtain all HUIs and it outperforms UPGrowth [ 20 ] , the state ofthe art algorithm for mining HUIs . that greatly enhance
The remainder of this paper is organized as follows . In Section II , we introduce the background for compact representations and utility mining . Section III defines the representation of closed+ HUIs and presents our methods . Experiments are shown in Section IV and conclusions are given in Section V .
TABLE I .
AN EXAMPLE TRANSACTIONAL DATABASE
TID T1 T2 T3 T4 T5
Transaction
A(1 ) , B(1 ) , E(1 ) , W(1 ) A(1 ) , B(1 ) , E(3 ) A(1 ) , B(1 ) , F(2 ) E(2 ) , G(1 ) A(1 ) , B(1 ) , F(3 )
TU 5 8 8 5 11
TABLE II . Item
Unit Profit ( $ )
UNIT PROFITS FOR EVERY ITEM
B 1
E 2
F A 3 1 II . BACKGROUND
G W 1 1
In this section , we introduce the preliminaries associated with high utility itemset mining and compact representations .
A . High Utility itemset Mining
Let I ={a1 , a2 , … , aM} be a finite set of distinct items . A transactional database D = {T1 , T2,…,TN} is a set of transactions , where each transaction TRD ( 1  R  N ) is a subset of I and has an unique identifier R , called Tid . Each item aiI is associated with a positive real number p(ai , D ) , called its external utility . Every item ai in the transaction TR has a real number q(ai , TR ) , called its internal utility . An itemset X = {a1 , a2 , … , aK} is a set of K distinct items , where ai I , 1  i  K , and K is the length of X . A K itemset is an itemset of length K . An itemset X is said to be contained in a transaction TR if X  TR .
Definition 1 . The support count of an itemset X is defined as the number of transactions containing X in D and denoted as SC(X ) . The support of X is defined as the ratio of SC(X ) to |D| . The complete set of all the itemsets in D is denoted as L and L = {X | X  I , SC(X ) > 0} . Definition 2 . The utility of an item ai in a transaction TR is denoted as u(ai , TR ) and defined as p(ai , D ) × q(ai , TR ) . Definition 3 . The utility of an itemset X in a transaction TR is denoted as u(X , TR ) and defined as u(X , TR)= ( cid:751 ) . Definition 4 . The utility of an itemset X in D is denoted as u(X ) and defined as u(X ) = ( cid:751 )
( (cid:2928 ) i Xa
Tau , Ri
( DT
TXu , R
( cid:2928 ) ( cid:2936 ) ( cid:2930 )
TX
.
)
)
R
R
Definition 5 . An itemset X is called high utility itemset if u(X ) is no less than a user specified minimum utility threshold min_utility . Otherwise , X is a low utility itemset . Definition 6 . Let S be a set of itemsets and a function fH(S ) = {X | XS , u(X ) t min_utility} . The complete set of HUIs in D is denoted as H ( H ( cid:2930 ) L ) and defined as fH(L ) . The problem of mining HUIs is to find the set H in D . Example 1 . Let Table I be a database containing five transactions . Each row in Table I represents a transaction , in which each letter represents an item and has a purchase quantity ( internal utility ) . The unit profit of each item is shown in Table II ( external utility ) . In Table I , the utility of the item {F} in the transaction T3 is u({F} , T3 ) = p({F} , D ) × q({F} , T3 ) = 3 × 2 = 6 . The utility of {BF} in T3 is u({BF} , T3 ) = u({B} , T3 ) + u({F} , T3 ) = 1 + 6 = 7 . The utility of {BF} is u({BF} ) = u({BF} , T3 ) + u({BF} , T5 ) = 17 , since {BF} is contained in T3 and T5 . If the min_utility is set to 10 , the set of HUIs in Table I is H = {{E}:12 , {F}:15 , {AE}:10 , {AF}:17 , {BE}:10 , {BF}:17 , {ABE}:12 , {ABF}:19} , where the number beside each itemset is its utility . introduced task , Liu et al .
Note that the utility constraint is neither monotone nor anti monotone . In other words , a superset of a low utility itemset can be high utility and a subset of a high utility itemset can be low utility . Hence , we cannot directly use the anti monotone property ( also known as downward closure property ) to prune the search space . To facilitate the mining the concept of transaction weighted downward closure [ 13 ] , which is based on the following definitions . Definition 7 . The transaction utility of a transaction TR is denoted as TU(TR ) and defined as u(TR , TR ) . Definition 8 . The transaction weighted utilization of an itemset X is the sum of the transaction utilities of all the transactions containing X , which is denoted as TWU(X ) and defined as TWU(X ) = ( cid:751 ) Definition 9 . An itemset X is a high transaction weighted utilization itemset ( HTWUI ) if TWU(X ) t min_utility . Property 1 . The transaction weighted downward closure property states that for any itemset X that is not a HTWUI , all its supersets are low utility itemsets [ 2 , 13 , 15 , 20 ] .
D ( cid:2928 ) ( cid:2936 ) ( cid:2930 )
TU
TX
T R
.
)
(
T
R
R
825
For example , the transaction utilities of T1 and T3 are TU(T1 ) = u({ABE} , T1 ) = 5 and TU(T3 ) = 8 . When min_utility = 10 , {AB} is a HTWUI since TWU({AB} ) = TU(T1 ) + TU(T3 ) = 13 is no less than min_utility . In contrast , the itemset {W} is not a HTWUI , and therefore all the supersets of {W} are low utility itemsets .
Many studies have been proposed for mining HUIs , including Two Phase [ 13 ] , IHUP [ 2 ] , TWU Mining [ 21 ] , IIDS [ 15 ] and UPGrowth [ 20 ] . Two Phase , IHUP and TWUMining utilize transaction weighted downward closure property to find high utility itemsets . They consist of two phases . In phase I , they find all HTWUIs from the database . In phase II , high utility itemsets are identified from the set of HTWUIs by scanning the original database once . Although these methods capture the complete set of HUIs , they may generate too many candidates in phase I , ie HTWUIs , which degrades the performance of phase II and the overall performance ( in terms of time and space ) . To reduce the number of candidates in phase I , various methods have been proposed ( eg [ 15 , 20] ) . Recently , Tseng et al . proposed UPGrowth with four strategies DGU , DGN , DLU and DLN , for mining HUIs . Experiments in [ 20 ] show that the number of candidates generated by UPGrowth in phase I can be order of magnitudes smaller than that of HTWUIs . To the best of our knowledge , UPGrowth is the state of theart method for mining HUIs .
Although the above methods perform well in some case , their performance degrades quickly when there are many HUIs in the databases . A large number of HUIs and candidates cause these methods to suffer from long execution time and huge memory consumption . When the system resources are limited ( the memory , disk space or processing power ) , it is often impractical to generate the entire set of HUIs . Besides , a large amount of HUIs is hard to be comprehended or analyzed by users . In FIM , to reduce the number of patterns , many studies were conducted to develop compact representations of frequent itemsets that eliminate redundancy , such as free sets [ 3 ] , non derivable sets [ 4 ] , maximal itemsets [ 9 ] and closed itemsets [ 16 18 ] . Although representations achieve a significant reduction in the number of extracted frequent itemsets , some of them lead to loss of information ( eg [ 9] ) . To provide not only compact but also complete information about frequent itemsets to users , many studies were conducted on closed itemset mining . B . Closed Itemset Mining these
In this subsection , we introduce definitions and properties related to closed itemsets and mention relevant methods . For more details about closed itemsets , readers can refer to [ 14 , 16 18 , 22 , 27 ] . Definition 10 . The Tidset of an itemset X is denoted as g(X ) and defined as the set of Tids of transactions containing X . The support count of an itemset X is expressed in terms of g(X ) as SC(X ) = |g(X)| . Property 2 . For itemsets X , Y(cid:2928)L , SC(X Y ) = |g(X ) g(Y)| .
( ( cid:2928 )
TXgR R )
Definition 11 . The closure of an itemset X(cid:2928 ) L , denoted as C(X ) , is the largest set Y(cid:2928 ) L such that X(cid:2930)Y and SC(X ) = SC(Y ) . Alternatively , it is defined as C(X ) = . Property 3 . ( cid:3455)X(cid:2928)L , SC(X ) = SC(C(X ) ) ( cid:3454 ) g(X ) = g(C(X) ) . Definition 12 . An itemset X(cid:2928)L is a closed itemset if there exists no itemset Y(cid:2928)L such that ( 1 ) X  Y and ( 2 ) SC(X ) = SC(Y ) . Otherwise X is a non closed itemset . An equivalent definition is that X is closed if C(X ) = X . For example , {B} is non closed since C({B} ) = T1 T2 T3 T5 = {AB} . Definition 13 . Let S be a set of itemsets and a function fC(S ) ={X| XS , ( cid:3456)¬ YS such that X(cid:2932)Y and SC(X ) = SC(Y)}.The complete set of closed itemsets in D is denoted as C ( C(cid:2930)L ) and defined as fC(L ) . For example , the set of closed itemsets in Table I is C = {{E}:3 , {EG}:1 , {AB}:4 , {ABE}:2 , {ABF}:2 , {ABEW}:1} , in which the number beside each itemset is its support count . Property 4 . ( cid:3455)X ( cid:2928 ) L , SC(X ) = max{SC(Y ) | Y ( cid:2928 ) fC(L ) ( cid:2936 ) X ( cid:2930)Y} . For example , the supersets of {B} in fC(L ) are {AB}:4 , {ABE}:2 , {ABF}:2 and {ABEW}:1 . Thus , SC({B} ) is the maximum of these support counts , ie 4 .
Mining frequent closed itemset refers to the discovery of all the closed itemsets whose supports are no less than a user specified threshold . It is widely recognized that the number of frequent closed itemsets can be much smaller than the set of frequent itemsets for real life databases and that mining frequent closed itemsets can also be much faster and memory efficient than mining frequent itemsets [ 14 , 22 , 27 ] . The set of closed itemsets is lossless since all frequent itemsets and their supports can be easily derived from it by property 4 without scanning the original database [ 16 18 ] . Many efficient methods were proposed for mining frequent closed itemsets , such as A Close [ 16 18 ] , CLOSET+ [ 22 ] , CHARM [ 27 ] and DCI Closed [ 14 ] . However , these methods do not consider the utility of itemsets . Therefore , they may present lots of closed itemsets with low utilities to users and omit several high utility itemsets . C . Compact Representations of High Utility Itemsets
To present representative HUIs to users , some concise representations of HUIs were proposed . Chan et al . introduced the concept of utility frequent closed patterns [ 7 ] . However , it is based on a definition of high utility itemset that is different from [ 2 , 13 , 15 , 20 ] and our work . Shie et al . proposed a compact representation of high utility itemsets , called maximal high utility itemset and the GUIDE algorithm for mining it [ 19 ] . A HUI is said to be maximal if it is not a subset of any other HUI . For example , when min_utility = 10 , the set of maximal HUIs is {{ABE} , {ABF}} . Although this representation reduces the number of extracted HUIs , it is not lossless . The reason is that the utilities of the subsets of a maximal HUI cannot be known without scanning the database . Besides , recovering all HUIs from maximal HUIs can be very inefficient because many subsets of a maximal HUI can be low utility.(cid:691 ) Another problem is that the GUIDE algorithm cannot capture the complete set of maximal HUIs .
826
III . CLOSED+ HIGH UTILITY ITEMSET MINING
In this section , we incorporate the concept of closed itemset with high utility itemset mining to develop a representation named closed+ high utility itemset . We theoretically prove that this new representation is meaningful , lossless and not larger than the set of all HUIs . A . Pushing Closed Property into HUI Mining
The first point that we should discuss is how to incorporate the closed constraint into high utility itemset mining . There are several possibilities . First , we can define the closure on the utility of itemsets . In this case , a high utility itemset is said to be closed if it has no proper superset having the same utility . However , this definition is unlikely to achieve a high reduction of the number of extracted itemsets since not many itemsets have exactly the same utility as their supersets in real datasets . For example , there are seven HUIs in Example 1 and only one itemset {E} is non closed , since {E}(cid:2930){ABE} and u({E} ) = u({ABE} ) = 12 . A second possibility is to define the closure on the supports of itemsets . In this case , there are two possible definitions depending on the join order between the closed constraint and the utility constraint : x Mine all the high utility itemsets first and then apply closed constraint . We formally define this set as H’ = fC(fH(L) ) . It follows that H’(cid:2930)H . x Mine all the closed itemsets first and then apply the utility constraint . We formally define this set as C’ = fH(fC(L) ) . It follows that C’(cid:2930)C .
As indicated in [ 23 ] , the join order between two constraints often lead to different results . Therefore , our next step is to analyze the result sets defined based on the above two join orders . We show that they produce the same result set by the following lemmas . Lemma 1 . H’(cid:2930)C’ . Proof . We prove that H’ ( cid:2930)C’ by proving that ( cid:3455)X ( cid:2928)H’֜ X(cid:2928)C’ . Since X(cid:2928 ) H’ , X(cid:2928 ) H and u(X ) ( cid:763 ) min_utility . Then , we prove that ( cid:3456)¬ Y(cid:2928)H such that X(cid:2932)Y and SC(X ) = SC(Y ) yields X ( cid:2928)C by showing that X C contradicts Y ( cid:2928)H . If XC , there must exists an itemset Y(cid:2928)L such that X(cid:2932)Y and SC(X ) = SC(Y ) . By Definition 4 , u(Y ) > u(X ) ( cid:763 ) min_utility , and therefore Y(cid:2928)H , which is a contradiction . Lemma 2 . C’(cid:2930)H’ Proof . We prove that C’(cid:2930)H’ by proving that(cid:3455)X(cid:2928)C’֜ X(cid:2928 ) H’ . Since X ( cid:2928)C’ and u(X ) ( cid:763 ) min_utility , we have X ( cid:2928)H . Then , we prove that X(cid:2928)C yields ( cid:3456)¬ Y(cid:2928)H such that X(cid:2932)Y and SC(X ) = SC(Y ) by showing that ( cid:3456)Y ( cid:2928)H contradicts XC . If YH , then Y(cid:2928)L . Because X(cid:2932)Y , Y(cid:2928)L and SC(X ) = SC(Y ) , it follows that XC . Theorem 1 . H’= C’ . Proof . This directly follows from Lemma 1 and Lemma 2 . Because the two join orders produce the same result , we remove the join order to obtain a general definition .
827
Definition 14 . We define the set of closed high utility itemsets as HC = {X | X(cid:2928 ) L , X = C(X ) , u(X ) ( cid:763 ) min_utility} , HC = H’ = C’ . An itemset X is called a non closed high utility itemset if X(cid:2928 ) H and X C . For example , the set of closed HUIs in Table I is HC = {{E} , {ABE} , {ABF}} .
Definition 14 gives an alternative solution to incorporate the closed constraint with high utility itemset mining . The advantage of using this definition is that the two constraints can be applied in any order during the mining process . We say that the representation HC is concise because its size is guaranteed to be no larger than the set of all HUIs ( because HC(cid:2930)H).We next show that this representation is meaningful . Property 5 . For any non closed high utility itemset X , ( cid:3456)Y(cid:2928 ) HC such that Y= C(X ) and u(Y ) > u(X ) . Proof . ( cid:3455)X ( cid:2928 ) L , ( cid:3456)Y ( cid:2928 ) C such that Y= C(X ) and SC(X ) = SC(Y ) . Since X(cid:2928 ) H and XC , u(X ) ( cid:763 ) min_utility and X(cid:2932)Y . SC(X ) = SC(Y ) and X(cid:2932)Y yields u(Y ) > u(X ) ( cid:763 ) min_utility by Property 3 and Definition 4 .
We claim that HC is a meaningful representation of all HUIs by Property 5 . For any non closed high utility itemset X , X does not appear in a transaction without its closure Y . Moreover , the utility ( eg profit/user preference ) of Y is guaranteed to be higher than the utility of X . For these reasons , users are more interested in finding Y than X . Moreover , closed itemsets having high utilities are useful in many applications . For example , in market basket analysis , Y is the closure of X means that no customer purchase X without its closure Y . Thus , when a customer purchase X , the retailer can recommend Y X to the customer , to maximize profit .
.
)
T ( cid:2928 ) ( cid:2936 ) ) R a i
XgR ( ( cid:2928 )
Tau , ( Ri
Although HC is based on the concise representation of closed itemsets , the set of closed HUIs is not lossless . If an itemset is not included in this representation , there is no way to infer its utility and to know whether it is high utility or not . To tackle this problem , we attach to each closed HUI a special structure named utility unit array , which is defined as follows . Definition 15 . ( cid:3455)X = {a1 , a2,…,aK}(cid:2928 ) L , the utility unit array of X is denoted as V(X ) = [ v1 , v2,… , vK ] and contains K utility values . The i th utility value vi in V(X ) is denoted as V(X , ai ) and defined as ( cid:751 ) For example , consider the itemset {ABE} appearing in T1 and T2 . The first utility value in V({ABE} ) is V({ABE} , {A} ) = u({A} , T1 ) + u({A} , T2 ) = 2 . The utility unit array of {ABE} is V({ABE} ) = [ 2 , 2 , 8 ] . Property 6 . ( cid:3455)X = {a1 , a2,…,aK}(cid:2928 ) L , u(X ) = ( cid:751 ) 1= K i Proof . The utility of X is the sum of the utilities of items a1 , a2,…,aK in transactions containing X . For an item ai , the value V(X , ai ) represents the sum of the utilities of ai in transactions containing X . Therefore u(X ) can be expressed as V(X , a1 ) + V(X , a2 ) + … + V(X , aK ) . For example , u({ABE} ) = V({ABE} , {A} ) + V({ABE} , {B} ) + V({ABE} , {E} ) = 2 + 2 + 8 = 12 . Property 7 . ( cid:3455)X(cid:2928 ) L , X is low utility if C(X)HC . aXV ,
(
. i )
(
(
) i i Xa ( cid:2928 )
Proof . If C(X)HC , u(C(X ) ) < min_utility . Since SC(X ) = SC(C(X ) ) and X ( cid:2930)C(X ) , by Definition 4 we have u(X ) ( cid:762 ) u(C(X ) ) < min_utility . Property 8 . ( cid:3455)X = {a1 , a2,… , aK}(cid:2928 ) L , the utility of X can be calculated as u(X ) = ( cid:751 ) by using the utility unit aXCV ) , array of its closure if C(X)(cid:2928 ) HC . Proof . Because X(cid:2930)C(X ) , there exists an entry V(C(X ) , ai ) in V(C(X ) ) for each ai(cid:2928)X . Besides , g(X ) = g(C(X ) ) since SC(X ) = SC(C(X ) ) and X(cid:2930)C(X ) ( Property 3 ) . Therefore , V(X , ai ) = V(C(X ) , ai ) , by Definition 15 . According to Property 6 , u(X ) . By replacing V(X , ai ) with V(C(X ) , ai ) , we = ( cid:751 ) K ( 1= i obtain Property 8 . Definition 16 . An itemset X is called a closed+ high utility itemset ( abbreviated as CHUI ) if X(cid:2928 ) HC and X is annotated with V(X ) . The set of closed+ HUIs lossless representation of all HUIs . For any itemset X(cid:2928)H , its exact utility can be inferred from the utility unit array of its closure by Property 8 without scanning the original database . is a aXV ,
) i
Although the set of closed+ HUIs is meaningful , concise and lossless , mining closed+ HUIs is not an easy task . There are two naive methods . The first one is to find all HUIs and then to remove non closed itemsets . The main drawbacks of this method are that it cannot be more efficient than mining all HUIs and that in the worst case removing all non closed itemset requires comparing all HUIs with each other . The second approach is to first mine all closed itemsets and then to remove those that are low utility itemsets . The drawback of this method is that it needs to generate all closed itemsets and this set can be very large since no threshold can be used . B . Efficient Discovery of Closed+ High Utility Itemsets
In this subsection , we present an efficient algorithm named CHUD ( Closed+ High Utility itemset Discovery ) for mining closed+ HUIs . CHUD is an extension of DCI Closed [ 14 ] , one of the current best methods for mining closed itemsets , and it also integrates the TWU model and effective strategies to prune low utility itemsets . CHUD consists of two phases . In phase I , CHUD discovers candidates for closed+ HUIs . In phase II , the closed+ HUIs are identified from the set of candidates found in phase I and their utility unit arrays are computed by scanning the database once .
Similar to the DCI Closed algorithm , CHUD adopts an IT Tree ( Itemset Tidset pair Tree ) [ 14 , 27 ] to find closed+ HUIs . In an IT Tree , each node N(X ) consists of an itemset X , its Tidset g(X ) , and two ordered sets of items named PREVSET(X ) and POST SET(X ) . The IT Tree is recursively explored by the CHUD algorithm until all closed itemsets that are HTWUIs are generated . Different from the DCIClosed algorithm , each node N(X ) of the IT Tree is attached with an estimated utility value EstU(X ) .
A data structure called TU Table ( Transaction Utility Table ) [ 13 ] is adopted for storing the transaction utilities of transactions . It is a list of pairs <R , TU(TR)> where the first value is a TID R and the second value is the transaction utility of TR . Given a TID R , the value TU(TR ) can be efficiently retrieved from the TU Table . Given a node N(X ) with its Tidset g(X ) and a TU Table TU , the estimated utility of the itemset X can be efficiently calculated by the procedure shown in Figure 1 .
The main procedure of CHUD is named Main and is shown in Figure 2 . It takes as parameter a database D and the min_utility threshold . CHUD first scans D once to convert D into a vertical database . At the same time , CHUD computes the transaction utility for each transaction TR and calculates TWU of items . When a transaction is retrieved , its Tid and transaction utility are loaded into a global TUTable named GTU . An item is called a promising item if its estimated utility ( eg its TWU ) is no less than min_utility . After the first scan of database , promising items are collected into an ordered list O = <a1 , a2,…,an> , sorted according to a fixed order % such as increasing order of support . Only promising items are kept in O since supersets of unpromising items are low utility itemsets . According to [ 22 ] , the utilities of unpromising items can be removed from the GTU table . This step is performed at line 2 of the Main procedure . Then , CHUD generates candidates in a recursive manner , starting from candidates containing a single promising item and recursively joining items to them to form larger candidates . To do so , CHUD takes advantage of the fact that by using the total order % , the complete set of itemsets can be divided into n non overlapping subspaces , where the k th subspace is the set of itemsets containing the  O , CHUD item ak but no item ai % ak [ 14 ] . For each item ak creates a node N({ak} ) and puts items a1 to ak 1 into PREVSET({ak} ) and items ak+1 to an into POST SET({ak} ) . Then CHUD calls the CHUDPhase I procedure for each node N({ak} ) to produce all the candidates containing the item ak but no item ai % ak . Finally , the Main procedure performs phase II on these candidates to obtain all closed+ HUIs . CalculateEstUtility(g(X ) , TU ) 01 . 02 . 03 . 04 .
EstU := 0 ; for each TID R(cid:2928)g(X ) do { return EstU
EstU := EstU + TU.get(R ) }
Figure 1 . CalculateEstUtility
Main(D , min_utility ) 01 . 02 . 03 . 04 . 05 . 06 . 07 .
InitialDatabaseScan(D ) RemoveUtilityUnpromisingItems(O , GTU ) . for each item ak(cid:2928)O do
PerformPhase II(D )
Create node N({ak} ) CHUDPhase I(N({ak} ) , GTU , min_utility ) //Apply Strategy 3(REG )
Figure 2 . Main
CHUDPhase I ( NX , TU , min_utility ) 01 . 02 . 03 . 04 . 05 . Explore(N(XC ) , TU , min_utility ) } } if ( SubsumeCheck(N(X ) , PREV SET(X ) ) == false ) then { XC := ComputeClosure(N(X ) , POST SET(X ) ) if ( EstU(XC ) ( cid:763 ) min_utility ) then //Apply Strategy 5(DCM ) { Output XC with EstU(XC )
Figure 3 . CHUDPhase I
SubsumeCheck ( N(X ) , PREV SET(X ) ) 01 . 02 . 03 . for each item a(cid:2928 ) PREV SET(X ) do { return false if ( g(X)(cid:2930 ) g(a ) ) then return true }
Figure 4 . SubsumeCheck
828
XC := X for each item a ( cid:2928 ) POST SET(X ) do { if ( g(X)(cid:2930)g(a ) ) then
ComputeClosure ( N(X ) , POST SET(X ) ) 01 . 02 . 03 . 04 . { POST SET(X ) := POST_SETX /{a} XC := XC(cid:1046){a} } } 05 . return XC 06 .
Figure 5 . ComputeClosure
Explore ( N(X ) , TUX , min_utility ) 01 . 02 . 03 . 04 . 05 . 06 . 07 . 08 . 09 . 10 . 11 . for each item ak(cid:2928 ) POST SET(X ) do {
POST SET(X ) := POST SET(X ) /{ak} Create a node N(Y ) , where Y := X ( cid:1046){ak} g(Y ) := g(X ) ( cid:1045 ) g(ak ) POST SET(Y ) := POST SET(X ) PREV SET(Y ) := PREV SET(X ) EstU(Y ) := CalculateEstUtility(g(Y ) , TUX ) if ( EstU(Y ) , EstU(X )  min_utility ) then { CHUDPhase I ( N(Y ) , TUX , min_utility ) PREV SET(X ) := PREV SET(X)(cid:1046){ak} } // Apply Strategy 4(RML ) }
Figure 6 . Explore threshold . The procedure
The CHUDPhase I procedure shown in Figure 3 takes as parameter a node N(X ) , a TU Table TU and the min_utility first performs SubsumeCheck on X as presented in Figure 4 . This check verifies if there exists an item a from PREV SET(X ) such that g(X)(cid:2930)g(a ) . If there exists such an item , it means that X is included in a closed itemset that has already been found and supersets of X do not need to be explored ( see [ 14 ] for a complete justification ) . Otherwise , the next step is to compute the closure XC = C(X ) of X . This is performed by the procedure ComputeClosure(N(X ) , POST SET(X ) ) shown in Figure 5 [ 14 ] . Then the estimated utility of XC is calculated . If it is no less than min_utility , XC is considered as a candidate for Phase II and it is outputted with its estimated utility value EstU(XC ) . Note that CHUD does not maintain any discovered candidate in memory . Instead , when a candidate itemset is found , it is outputted to disk . After this , a node N(XC ) is created and the procedure Explore is called for finding candidates that are supersets of XC .
The Explore procedure is shown in Figure 6 . It takes as parameter a node N(X ) , a TU Table and the min_utility threshold . The Explore procedure explores the search space of closed candidates that are superset of X by appending items from POST SET(X ) to X . We here briefly explain this process . For a proof that this method is a correct way of exploring closed candidates , the reader can consult the paper describing DCI Closed [ 14 ] . For each item ak of POSTSET(X ) , the procedure first removes ak from POST SET(X ) to create a node N(Y ) with Y = X(cid:1046){ak} . The Tidset of Y is then calculated as g(Y ) = g(X ) ( cid:1045)g(ak ) by Property 2 . The set POST SET(Y ) and PREV SET(Y ) are respectively set to POST SET(X ) and PREV SET(X ) . Then , the estimated utility of Y is calculated by calling the CalculateEstUtility procedure with g(Y ) and TU . If EstU(Y ) and EstU(X ) are no less than min_utility , the procedure CHUDPhase I is recursively called with N(Y ) to consider the search space of Y and ak is added to PREV SET(X ) . If EstU(Y ) is lower than min_utility , the search space of Y is pruned since Y and its supersets are low utility itemsets ( Property 1 ) .
After recursions of the Explore and CHUDPhase I procedures are completed , closed candidates that have been outputted are processed by phase II . Phase II consists of taking each candidate X and to calculate its exact utility and utility unit array . Each candidate that is a low utility itemset is discarded . Calculating the exact utility of a candidate X is performed by doing the summation of u(X , TR ) for each R(cid:2928)g(X ) . This is done very efficiently thanks to the vertical representation of the database ( only transactions containing X are considered to calculate its utility ) .
We now prove that this basic version of the CHUD algorithm generates the complete set of closed+ HUIs . We consider the two phases of CHUD to prove the correctness . The first phase produces a set of candidates P(cid:2930 ) C , since it is based on the DCI Closed algorithm that generates all closed itemsets C ( see [ 14 ] for the proof that DCI Closed generates C ) . The second phase consists of discarding candidates that are low utilities from P to obtain C’ . The algorithm is therefore correct if and only if C’(cid:2930 ) P ( the set of candidates P produced in Phase I contains all closed+ HUIs C’ ) . To prove this , we need to show that the modifications that have been made to DCI Closed will not discard any closed+ high utility itemset X ( cid:2930 ) C’ . We discuss the correctness of these modifications thereafter . Strategy 1 . Considering only promising items . The first strategy that we have incorporated in CHUD is to only consider promising items for generating candidates and to remove the utilities of unpromising items from the GTU table . It is applied in line 2 and 3 of the Main procedure . Rationale . It was shown in [ 14 ] that unpromising items cannot be part of a HUI and that the utility of unpromising items can be ignored in the calculation of the estimated utility of itemsets when searching for high utility itemsets . Strategy 2 . Discarding itemsets having an estimated utility lower than min_utility . The second strategy in CHUD is to discard the itemset XC such that EstU(XC ) ( cid:763 ) min_utility . This strategy is integrated in line 3 of the CHUDPhase I procedure . Rationale . It was demonstrated in Section 2 that an itemset that is not a HWTUI is not a high utility itemset as well as all of its supersets ( see Property 1 and Definition 4 , 8 and 9 ) . Because DCI Closed discovers candidates recursively by considering supersets of candidates , discarding an itemset such that EstU(XC ) < min_utility will not discard any itemset from P that is in C’ .
To enhance the performance of CHUD , we integrate three additional strategies , which have never been used in vertical mining of HUIs . They are described as follows . Strategy 3 . Removing the Exact utilities of items from the Global TU Table ( REG ) . Strategy 3 is called REG , which is applied after line 5 of the procedure Main . Each time that an item ak ( cid:2928)O has been processed , u(ak ) is removed from the transaction utility of each transaction containing ak in the global TU Table .
829
Rationale . CHUD explores the search space of patterns by dividing it into non overlapping subspaces such that each item ai that has been processed is excluded from the subspace of item aj ai . Therefore , u(ai ) can be removed from the transaction utility of each transaction containing aj in the global TU Table . The pseudo code for this strategy is shown as follows . 06 . for each Tid R(cid:2928 ) g(ak ) do 07 . { remove u(ak ) from <R , GTU(TR)> }
Definition 17 . The minimum item utility of an item a is denoted as miu(a ) and defined as the value u(a , Tr ) for which ( cid:3456)¬ Ts ( cid:2928 ) D such that u(a , Ts ) < u(a , Tr ) . Definition 18 . Let N(X ) be a node for the itemset X and a be an item in POST SET(X ) . The local TU Table for the node Y = X(cid:1046){a} is denoted as TUY and is initialized with the entries from TUX corresponding to transactions from g(Y ) . The local TU Table for the root node of the IT Tree is GTU . Strategy 4 . Removing the Mius of items from Local TUTables ( RML ) . Strategy 4 is called RML , which is applied after line 11 of the procedure Explore . This strategy consists of using a local TU Table TUX for each node N(X ) in the IT Tree . Let Y = X {ak} and NY be the child node of NX . Each time that an item ak from POST SET(X ) is processed , miu(ak ) is removed from the transaction utility of each transaction containing ak in TUX . The updated local TUTable TUX is used for all child nodes of N(X ) . This process reduces the estimated utility of N(X ) and that of its children nodes . Besides , miu(ak ) × SC(Y ) is removed from EstU(X ) . If the updated EstU(X ) is less than min_utility , the algorithm will not process X {ak} for each item ak(cid:2928 ) POST SET(X ) . Rationale . Each item ai that is processed for a node N(X ) will not be considered for any child node N(Y ) , where Y = X {aj} and aj ai . Therefore , miu(ai ) × SC(Y ) and miu(ai ) can be removed from EstU(X ) and the transaction utility of each transaction containing aj from TUX . The pseudo code for this strategy is shown as follows . 11 . for each Tid R(cid:2928 ) g(Y ) do 12 . { remove miu(ak ) from <R,TUX(Tc)> } 13 . remove miu(ak ) × SC(Y ) from EstU(X )
Definition 19 . The maximum item utility of an item a is denoted as mau(a ) and defined as the value u(a , Tr ) for which ( cid:3456)¬ Ts ( cid:2928 ) D such that u(a , Ts ) > u(a , Tr ) . Definition 20 . The maximum utility of an itemset X={a1 , a2,… , aK} is defined as MAU(X ) = ( cid:751 ) K i 1= Lemma 4 . ( cid:3455)X , X is low utility if MAU(X ) < min_utility . Proof . The utility of an itemset X is the sum of the utility of its items in transactions containing X . MAU(X ) is the sum of the maximum item utility of each item multiplied by the number of transactions containing X . Since the maximum item utility of each item represents the highest utility that an item can have , MAU(X ) is higher or equals to the utility of X .
× SC(X ) . amau (
) i
830
Strategy 5 . Discarding Candidates with a MAU that is less than the minimum utility threshold ( DCM ) . The last strategy is called DCM and is applied to line 3 of the CHUDPhase I procedure . A candidate XC can be discarded from phase II if its estimated utility EstU(XC ) or MAU(XC ) is less than min_utility . Rationale . Lemma 4 guarantees that an itemset X is not a closed+ HUI if MAU(X ) < min_utility . The pseudo code for the strategy 5 is shown below . 03 . if ( min{EstU(XC ) , MAU(XC)} ( cid:763 ) min_utility ) then
C . Efficient Recovery of High Utility Itemsets
In this subsection , we present a top down method named DAHU ( Derive All High Utility itemsets ) for efficiently recovering all the HUIs . The pseudo code of DAHU is shown in Figure 7 . It takes as input a min_utility threshold , a set of closed+ HUIs HC and Kmax the maximum length of itemsets in HC . DAHU outputs the complete set of high utility itemsets H = K i 1= HK respecting min_utility , where HK denotes the set of HUIs of length K . To derive all HUIs , DAHU proceeds as follows . First , the set HKmax is initialized to HCKmax , where the notation HCK represents the set of Kitemsets in HC . During step 2 to step 14 in Figure 7 , each set HK is constructed from K = ( Kmax – 1 ) to K = 1 . In each iteration , H(K–1 ) is recovered by using HCK . For each itemset X = {a1 , a2,…,aK} in HCK , if the utility of X is no less than min_utility , the algorithm outputs the high utility itemset X with its exact utility and then generates all ( K–1) subsets of X . The latter are obtained by removing each item ai ( cid:2928 ) X from X one at a time to obtain subsets of the form Y = X – {ai} . If Y is not present in HK or Y is present in HK with SC(X ) > SC(Y ) , Y is added to H(K–1 ) , its support count is set to the support count of X ( Property 4 ) , ie , SC(Y ) = SC(X ) , and the utility of Y is set to the utility of X minus the i th value in V(X ) , ie , u(Y ) = u(X ) – V(X , ai ) ( Property 6 8 ) . In addition , the utility unit array of V(Y ) is set to V(X ) with the value V(X , ai ) removed ( Property 8 ) . This process is repeated until H has been completely recovered .
DAHU(HC , min_utility , Kmax ) 01 . HKmax := HCKmax 02 . 03 . { for each K itemset X = {a1 , a2,…,aK} in CHK do 04 . { if ( u(X ) < min_utility ) then delete X from CHK else add X and its exact utility u(X ) to H . 05 . { 06 . 07 .
08 . 09 . 10 . 11 . 12 . 13 . 14 . if Y(cid:2928)CH(K 1 ) and SC(X ) > SC(Y ) then { SC(Y ) := SC(X ) } else if ( YHC(K 1 ) ) then { put Y into HC(K 1 ) SC(Y ) := SC(X ) }}}}}} u(Y ) := u(X ) – V(X , ai ) if(u(Y ) ( cid:763)min_utility ) then { for each item ai(cid:2928)X do { Y : = X – {ai} for ( K := Kmax – 1 ; K > 0 ; K– – ) do
Figure 7 . DAHU
TABLE III .
PARAMETER FOR SYNTHETIC DATASETS
Parameter Descriptions Total number of transactions Average transaction length Number of distinct items
D : T : N : I : Average size of maximal potential frequent itemsets
Default 200K 12 1,000
8
TABLE IV . Dataset Mushroom Foodmart
BMSWebView1 T10I8D200K
CHARACTERISTICS OF DATASETS
N 119 1,559 497 1,000
T 23 4.4 2.51 10
D
8,124 4,141 59,601 200K
TABLE V .
NUMBER OF EXTRACTED PATTERNS FOR MUSHROOM
CHUD CHUD
Phase I Phase I
Minimum Minimum
Utility Utility
Threshold ( % ) # Candidates For Threshold ( % ) # Candidates For
10 10 6 6 2 2 1 1
CHUIs CHUIs 889 889 3,311 3,311 19,362 19,362 39,522 39,522 i
) . c e s ( e m T n o i t u c e x E
10000
1000
100
10
1
UPGrowth CHUD i
) . c e s ( e m T n o i t u c e x E
4
2
0 ( a ) Time for Phase I
Minimum Utility Threshold ( % )
8
10
6
Phase II Phase II
# CHUIs # CHUIs
157 157 634 634 4,911 4,911 25,611 25,611
UPGrowth UPGrowth
Reduction Reduction
Phase I Phase I
# Candidates # Candidates
For HUIs For HUIs 84,392 84,392 692,470 692,470 15,687,252 15,687,252 68,634,458 68,634,458
Phase II Phase II
#HUIs #HUIs
6,655 6,655 72,810 72,810 3,381,719 3,381,719 20,392,064 20,392,064
Ratio Ratio #HUI #HUI #CHUI #CHUI 42.39 42.39 56.04 56.04 197.65 197.65 796.22 796.22
UPGrowth CHUD+ DAHU CHUD
1000000
100000
10000
1000
100
10
4
2
10 Minimum Utility Threshold ( % )
0 ( b ) Time for Phase II
6
8
Figure 8 . Execution time on Mushroom
IV . EXPERIMENTS
In this section , we compare the performance of CHUD and DAHU with UPGrowth [ 20 ] , which is to our best knowledge , the state of the art method for high utility itemset mining . Although CHUD and UPGrowth produce different results , both of them consist of two phases . In Phase I , CHUD and UPGrowth respectively generate candidates for CHUIs and HUIs . In Phase II , CHUD and UPGrowth respectively identify CHUIs and HUIs from candidates produced in their Phase I . The combination of CHUD and DAHU is denoted as CHUD+DAHU , which first applies CHUD to find all closed+ high utility itemsets and then uses DAHU to derive all high utility itemsets from the set of closed+ high utility itemsets generated by CHUD . The process of CHUD+DAHU in phase I is the same as that of CHUD . In Phase II , CHUD+DAHU first identifies CHUIs from the set of candidates and then uses CHUIs to derive all HUIs . Experiments were performed on a desktop computer with an Intel® Core 2 Quad Processor @ 2.66 GHz running Windows XP and 2 GB of RAM . CHUD and DAHU were implemented in Java . The implementation of UPGrowth was obtained from Tseng et al . [ 20 ] , which is also implemented in Java . All memory measurements were done by using the Java API . Both synthetic and real datasets were used to evaluate the performance of the algorithms . A synthetic dataset T12I8D200K was generated by the IBM
831 data generator [ 1 ] . The parameters of the data generator are described in Table III . Real datasets Mushroom and BMSWebView1 were obtained from FIMI Repository [ 32 ] . Foodmart is a real dataset obtained from the Microsoft foodmart 2000 database . Except the Foodmart dataset , the external and internal utility of each item are generated with the settings used in [ 20 ] . Foodmart already contains unit profits and purchase quantities of items . The total utility of Foodmart is 120,16084 Table IV shows the characteristics of the above datasets . Mushroom is a real life dense dataset , each transaction containing 23 items . Foodmart is a real life sparse dataset from a retail store , with real utility values . BMSWebView1 is a real life sparse dataset of click stream data with a mix of short and long transactions ( up to 267 items ) . T10I8D200K is a large sparse dataset with an average transaction length of 10 . A . Experiments on Mushroom Dataset for both phases , and
The first experiment consisted of running UPGrowth , CHUD , and DAHU on the Mushroom dataset , while varying min_utility from 10 % to 1 % . The execution time of UPGrowth , CHUD , and CHUD+DAHU is shown in Figure 8 for Phase I and Phase II . Results show that CHUD outperforms UPGrowth the performance gap increased as min_utility was set lower . For example , when min_utility = 1 % , CHUD is 50 times faster than UPGrowth for Phase 1 and 63 times faster for Phase II . Moreover , when CHUD is combined with DAHU to discover all high utility itemsets , the combination largely outperforms UPGrowth and was only slightly slower than CHUD . Table V shows the number of candidates and the number of results generated by UPGrowth , CHUD , and CHUD+DAHU . CHUD generates a much smaller number of candidates and results than UPGrowth . The smaller number of candidates generated by CHUD in Phase I is what makes CHUD perform better than UPGrowth in Phase II and for the total execution time ( because Phase II is more costly than Phase I [ 20] ) . Lastly , we measured the reduction achieved by the representation of closed+ high utility itemsets generated by CHUD compared to the set of all high utility itemsets generated by UPGrowth . As shown in Table V , a huge reduction is obtained ( up to 796 times ) . Moreover , by running DAHU , it is possible to recover all high utility itemsets . B . Experiments on Foodmart Dataset
The second experiment consists of running UPGrowth , CHUD and DAHU on the Foodmart dataset , while varying min_utility from 0.10 % to 0.005 % of the total utility in the database . Execution times for Phase I and Phase II are shown in Figure 9 . The total execution time of UPGrowth is less than CHUD , initially . But as the min_utility threshold became smaller , CHUD becomes faster ( up to two times faster than UPGrowth ) . The reason why the performance gap between CHUD and UPGrowth is smaller for Foodmart than for Mushroom is due to the fact that Foodmart is a sparse dataset . As a consequence the reduction achieved by mining closed+ high utility itemsets is less ( still up to 34.6 times , as shown in Table VI ) .
TABLE VI .
NUMBER OF EXTRACTED PATTERNS FOR FOODMART
CHUD CHUD
Phase I Phase I
Minimum Minimum
Utility Utility
Threshold ( % ) # Candidates For Threshold ( % ) # Candidates For
CHUIs CHUIs 581 581 1,444 1,444 6,332 6,332 6,657 6,657
Phase II Phase II
# CHUIs # CHUIs
258 258 1,076 1,076 6,293 6,293 6,656 6,656
UPGrowth CHUD i
) . c e s ( e m T n o i t u c e x E
UPGrowth UPGrowth
Phase I Phase I
# Candidates # Candidates
For HUIs For HUIs 1,585 1,585 37,158 37,158 230,165 230,165 233,032 233,032
Phase II Phase II
#HUIs #HUIs
258 258 6,266 6,266 209,387 209,387 230,617 230,617
Reduction Reduction
Ratio Ratio #HUI #HUI #CHUI #CHUI
1 1 5.8 5.8
33.273 33.273 34.647 34.647
200
150
100
50
0
0
UPGrowth CHUD+DAHU CHUD
0.06
0.02
0.04
0.08 Minimum Utility Threshold ( % ) ( b ) Time for Phase II
0.10
0.02
0.04
0.06 0 ( a ) Time for Phase I
Minimum Utility Threshold ( % )
0.08
0.10
Figure 9 . Execution time on Foodmart
TABLE VII . NUMBER OF EXTRACTED PATTERNS FOR BMSWEBVIEW1
CHUD CHUD
Phase I Phase I
Minimum Minimum
Utility Utility
Threshold ( % ) # Candidates For Threshold ( % ) # Candidates For
CHUIs CHUIs
UPGrowth UPGrowth
Phase I Phase I
# Candidates # Candidates
For HUIs For HUIs
Phase II Phase II
#HUIs #HUIs
Reduction Reduction
Ratio Ratio #HUI #HUI #CHUI #CHUI
6 6 13 13 23 23 32 32
Phase II Phase II
# CHUIs # CHUIs
2 2 4 4 5 5 7 7
UPGrowth CHUD
165 165 198 198 536 536 * *
100000 10000 1000 100 10 1 0.1 0.01 i
) . c e s ( e m T n o i t u c e x E 10
2 2 4 4 5 5 * *
1 1 1 1 1 1 1 1
UPGrowth CHUD+DAHU CHUD
10
0.1 0.1 0.05 0.05 0.01 0.01 0.005 0.005
15
10
5
0 i
) . c e s ( e m T n o i t u c e x E
3 3 2.6 2.6 2.2 2.2 2 2 100000
10000
1000
100
10
1
0.1 i
) . c e s ( e m T n o i t u c e x E
4
2 Minimum Utility Threshold ( % )
6
8
( a ) Time for Phase I
4
2 Minimum Utility Threshold ( % )
8
6
( b ) Time for Phase II
Figure 10 . Execution time on BMSWebView1
TABLE VIII . NUMBER OF EXTRACTED PATTERNS FOR T12I8D200K
CHUD CHUD
Phase I Phase I
Minimum Minimum
Utility Utility
Threshold ( % ) # Candidates For Threshold ( % ) # Candidates For
CHUIs CHUIs
UPGrowth UPGrowth
Phase I Phase I
# Candidates # Candidates
For HUIs For HUIs
Phase II Phase II
#HUIs #HUIs
Reduction Reduction
Ratio Ratio #HUI #HUI #CHUI #CHUI
28 28 165 165 1,093 1,093 4,776 4,776
0.1 0.1 0.05 0.05 0.03 0.03 0.02 0.02
400
300
200
100 i
) . c e s ( e m T n o i t u c e x E
Phase II Phase II
# CHUIs # CHUIs
8 8 47 47 169 169 782 782
UPGrowth CHUD i
) . c e s ( e m T n o i t u c e x E
1000
800
600
400
200
0
0
488 488 1,297 1,297 4,811 4,811 16,444 16,444
8 8 47 47 169 169 782 782
1 1 1 1 1 1 1 1
UPGrowth CHUD+DHUI CHUD
0
0.02
0.04
0.06 0 ( a ) Time for Phase I
Minimum Utility Threshold ( % )
0.08
0.10
0.02
0.04
Minimum Utility Threshold ( % )
0.08 ( b ) Time for Phase II
0.06
0.10
Figure 11 . Execution time on T12I8D200K
Note that achieving a smaller reduction for sparse datasets is a well known phenomenon in frequent closed itemset mining . A similar phenomenon occurs in closed+ HUI mining . Besides , when DAHU was combined with
832
CHUD , the execution time of CHUD+DAHU was up to two times faster than UPGrowth for low minimum utility thresholds and slightly slower than CHUD . C . Experiments on BMSWebView1 Dataset
The third experiment consists of running UPGrowth , CHUD and CHUD+DAHU on BMSWebView1 while varying min_utility from 10 % to 1 % of the total utility of the database . Results are presented in Figure 10 and Table VII . UPGrowth runs faster than CHUD and CHUD+DAHU for min_utility  3 % . However , for min_utility < 3 % , the performance of UPGrowth decreases sharply . For min_utility = 2 % , UPGrowth cannot terminate within the time limit of 100,000 seconds and it generates more than 1,000,000 candidates in Phase I , whereas CHUD terminates in 80 seconds and produces only seven closed+ HUIs from 32 candidates . The reason why CHUD performs so well is that it achieves a massive reduction in the number of candidates by only generating a few itemsets containing up to 149 items , while UPGrowth has to consider a huge amount of redundant subsets ( for a closed itemset of 149 items , there can be up to 2149 2 non empty proper subsets that are redundant ) . DAHU also suffers from the fact that there are too many HUIs . It runs out of memory for min_utility < 2 % when trying to recover all HUIs because it has to generate too many subsets . D . Experiments on Sythetic Dataset long
The fourth experiment is to run the algorithms on T12I8D200K with min_utility varying from 0.1 % to 0.02 % of the database total utility . Results are presented in Figure 11 and Table VIII . For this dataset , CHUD is faster than UPGrowth for the total execution time . Although the reduction on this synthetic dataset is not as good ( since it produced the same result as UPGrowth ) , CHUD is faster because it generates about three times less candidates in Phase I . CHUD takes more times to generate candidates in Phase I . But the total execution time of CHUD is less than UPGrowth because Phase II is more costly than Phase I . CHUD+DAHU also outperforms UPGrowth , since DAHU only spend one second to derive all HUIs . E . Memory Usage
During the previous experiments , we also measure the maximum memory usage of UPGrowth and CHUD . Results for Mushroom and Foodmart are presented in Figure 12 and are similar for the other datasets . In general , CHUD uses as much or slightly more memory than UPGrowth because the latter uses a compact tries based data structure for representing the database that is more memory efficient than a vertical database . However , when the databases contain very long HUIs such as BMSWebView1 , the number of candidates can be very large . In this case , the memory consumption of UPGrowth rises dramatically because it needs to create a number of conditional UPTrees that is proportional to the number of candidates .
[ 8 ] A . Erwin , R . P . Gopalan , and N . R . Achuthan . Efficient Mining of High utility Itemsets from Large Datasets . In Int’l Conf . on PAKDD , pp . 554561 , 2008 .
[ 9 ] K . Gouda and M . J . Zaki . Efficiently mining maximal frequent itemsets . In
Proc . of IEEE Int'l Conf . on Data Mining , pp . 163 170 , 2001 .
[ 10 ] J . Han , J . Pei , and Y . Yin . Mining frequent patterns without candidate generation . In Proc . of the ACM SIGMOD Int'l Conf . on Management of Data , pp . 1 12 , 2000 .
[ 11 ] H F Li , H Y Huang , Y C Chen , Y J Liu and S Y Lee . Fast and Memory Efficient Mining of High Utility Itemsets in Data Streams . In Proc . of IEEE Int'l Conf . on Data Mining , pp . 881 886 , 2008 .
[ 12 ] B . Le , H . Nguyen , T . A . Cao , and B . Vo . A Novel Algorithm for Mining High utility Itemsets . In Proc . of First Asian Conference on Intelligent Information and Database Systems , pp.13 17 , 2009 .
[ 13 ] Y . Liu , W . Liao , and A . Choudhary . A fast high utility itemsets mining algorithm . In Proc . of the Utility Based Data Mining Workshop , pp . 90 99 , 2005 .
[ 14 ] C . Lucchese , S . Orlando and R . Perego , “ Fast and Memory Efficient Mining of Frequent Closed Itemsets , ” In IEEE Transactions on Knowledge and Data Engineering , Vol . 18 , Issue 1 , pp . 21 36 , 2006 .
[ 15 ] Y C Li , J S Yeh , and C C Chang . Isolated Items Discarding Strategy for Discovering High utility Itemsets . In Data & Knowledge Engineering , Vol . 64 , Issue 1 , pp . 198 217 , 2008 .
[ 16 ] N . Pasquier , Y . Bastide , R . Taouil , and L . Lakhal . Efficient mining of association rules using closed itemset lattice , ” In Journal of Information Systems , Vol 24 , Issue 1 , pp . 25–46 , 1999 .
[ 17 ] N . Pasquier , T . Bastide , R . Taouil , and L . Lakhal . Discovering Frequent Closed Itemsets for Association Rules . In Proc . of Int'l Conf . on Database Theory , pp . 398–416 , Israel , 1999 .
[ 18 ] N . Pasquier , Y . Bastide , R . Taouil , and L . Lakhal . Generating a Condensed representation for Association Rules , In Journal of Intelligent Information Systems , Vol 24 , Issue 1 , pp . 29–60 , 2005 .
[ 19 ] B E Shie , V . S . Tseng , and P . S . Yu . Online Mining of Temporal Maximal Utility Itemsets from Data Streams . In Proc . of Annual ACM Symposium on Applied Computing , pp . 1622 1626 , 2010 .
[ 20 ] V . S . Tseng , C W Wu , B E Shie , and P . S . Yu . UP Growth : an efficient algorithm for high utility itemset mining . In Proc . of Int'l Conf . on ACM SIGKDD , pp . 253–262 , 2010 .
[ 21 ] B . Vo , H . Nguyen , T . B . Ho , and B . Le . Parallel Method for Mining High utility Itemsets from Vertically Partitioned Distributed Databases . In Proc . of Int’l Conf . on Knowledge based and Intelligent Information and Enginnering Systems , pp . 251 260 , 2009 .
[ 22 ] J . Wang , J . Han , and J . Pei . Closet+ : Searching for the Best Strategies for Mining Frequent Closed Itemsets . In Proc . of Int'l Conf . on ACM SIGKDD , pp . 236–245 , 2003 .
[ 23 ] U . Yun . Mining lossless closed frequent patterns with weight constraints .
In Knowledge Based Systems , Vol . 20 , pp . 86–97 , 2007 .
[ 24 ] J S Yeh , C Y Chang , and Y T Wang . Efficient Algorithms for Incremental Utility Mining . In Proc . of the 2nd Int'l Conf . on Ubiquitous information management and communication , pp . 212 217 , 2008 .
[ 25 ] H . Yao , H . J . Hamilton , L . Geng , A unified framework for utility based measures for mining itemsets . In Proc . of ACM SIGKDD 2nd Workshop on Utility Based Data Mining , pp . 28 37 , 2006 .
[ 26 ] S J Yen and Y S Lee . Mining High utility Quantitative Association Rules . In Proc . of Int'l Conf . on Data Warehousing and Knowledge Discovery , pp . 283 292 , 2007 .
[ 27 ] M . J . Zaki and C . J . Hsiao . Efficient Algorithms for Mining Closed Itemsets and Their Lattice Structure . In IEEE Transactions on Knowledge and Data Engineering , Vol . 17 , Issue 4 , pp . 462–478 , 2005 . implementations
[ 28 ] Frequent repository , itemset mining http://fimicshelsinkifi/
) .
B M
( e g a s U y r o m e M
20
15
10
5
0
0
UPGrowth CHUD
) .
B M
( e g a s U y r o m e M
2
4
6
8
10
6
4
2
0
0
UPGrowth CHUD
0.02
0.04
0.06
0.08
0.10
Minimum Utility Threshold ( % )
Minimum Utility Threshold ( % )
( a ) Mushroom Figure 12 . Memory usages for the algorithms in phase I
( b ) Foodmart
V . CONCLUSION
In this paper , we addressed the problem of redundancy in high utility itemset mining by proposing a compact representation of all high utility itemsets named closed+ high utility itemsets . To our knowledge , this is the first study on compact and lossless representation of high utility itemsets . To mine this new style of itemsets , we proposed an efficient algorithm named CHUD . Three effective strategies named REG , RML and DCM were further proposed to enhance the performance of CHUD . To efficiently recover all high utility itemsets from this representation , we proposed a top down method named DAHU . Real and synthetic datasets with varied characteristics were used to perform a thorough performance evaluation . Results show that the proposed representation achieves a massive reduction in the number of high utility itemsets ( eg a reduction of up to 800 times for Mushroom and 32 times for Foodmart outperforms UPGrowth , the current best algorithm by several orders of magnitude under low minimum utility thresholds ( eg CHUD terminates in 80 seconds on BMSWebView1 for min_utility = 2 % , while UPGrowth cannot terminate within 24 hours ) . The combination of CHUD and DAHU is also faster than UPGrowth when DAHU could be applied . datasets ) . Besides , CHUD
ACKNOWLEDGEMENT
This research was supported by National Science Council , Taiwan , ROC under grant no . NSC100 2631 H 006 002 and NSC100 2218 E 006 001 .
REFERENCES
[ 1 ] R . Agrawal and R . Srikant . Fast algorithms for mining association rules . In Proc . of the 20th Int'l Conf . on Very Large Data Bases , pp . 487 499 , 1994 .
[ 2 ] C . F . Ahmed , S . K . Tanbeer , B S Jeong , and Y K Lee . Efficient Tree Structures for High utility Pattern Mining in Incremental Databases . In IEEE Transactions on Knowledge and Data Engineering , Vol . 21 , Issue 12 , pp . 1708 1721 , 2009 . J . F . Boulicaut , A . Bykowski , and C . Rigotti . Free sets : a condensed representation of boolean data for the approximation of frequency queries . In Data Mining and Knowledge Discovery , Vol . 7 , Issue 1 , pp . 5–22 .
[ 3 ]
[ 4 ] T . Calders and B . Goethals . Mining all non derivable frequent itemsets . In Proc . of the Int’l Conf . on European Conference on Principles of Data Mining and Knowledge Discovery , pp . 74 85 , 2002 .
[ 5 ] C J Chu , V . S . Tseng , T and Liang . An efficient algorithm for mining temporal high utility itemsets from data streams . In Journal of Systems and Software Vol . 81 , Issure 7 , pp . 1105 1117 , 2008 .
[ 6 ] C J Chu , V . S . Tseng , and T . Liang . An Efficient Algorithm for Mining High utility Itemsets with Negative Values in Large Databases . In Applied Mathematics and Computation , Vol . 215 , Issue . 2 , pp . 767 778 , 2009 .
[ 7 ] R . Chan , Q . Yang , and Y . Shen . Mining high utility itemsets . In Proc . of
IEEE Int'l Conf . on Data Mining , pp . 19 26 , 2003 .
833
