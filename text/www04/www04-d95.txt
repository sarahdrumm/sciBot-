CT R S : A Logic for Specifying Contracts in Semantic Web Services
Hasan Davulcu Department of CSE
Arizona State University
Box 875406 ,
Tempe , AZ 85287 5406 hdavulcu@asu.edu
Michael Kifer
Department of Computer
Science
Stony Brook University Stony Brook , NY 11794
IV Ramakrishnan Department of Computer
Science
Stony Brook University Stony Brook , NY 11794 kifer@csstonybrookedu ram@csstonybrookedu
ABSTRACT A requirements analysis in the emerging field of Semantic Web Services ( SWS ) ( see http://daml.org/services/swsl/requirements/ ) has identified four major areas of research : intelligent service discovery , automated contracting of services , process modeling , and service enactment . This paper deals with the intersection of two of these areas : process modeling as it pertains to automated contracting . Specifically , we propose a logic , called CT R S , which captures the dynamic aspects of contracting for services . Since CT R S is an extension of the classical first order logic , it is wellsuited to model the static aspects of contracting as well . A distinctive feature of contracting is that it involves two or more parties in a potentially adversarial situation . CT R S is designed to model this adversarial situation through its novel model theory , which incorporates certain game theoretic concepts . In addition to the model theory , we develop a proof theory for CT R S and demonstrate the use of the logic for modeling and reasoning about Web service contracts .
Categories and Subject Descriptors H4m [ Information Systems ] : Miscellaneous ; I13 [ Computing Methodologies ] : Symbolic and algebraic manipulation—Languages and Systems
General Terms Web Services , Semantic Web
Keywords Web Services , Services Composition , Contracts
1 .
INTRODUCTION
A Web service is a process that interacts with the client and other services to achieve a certain goal . A requirements analysis in the emerging field of Semantic Web Services ( SWS)1 has identified three major areas of research : intelligent service discovery , automated contracting of services , process modeling , and service enactment . It is generally agreed that Semantic Web Services should be based on a formalism with a well defined model theoretic semantics , ie , on some sort of a logic . In this paper we propose a
1See http://daml.org/services/swsl/requirements/ Copyright is held by the author/owner(s ) . WWW2004 , May 17–22 , 2004 , New York , NY USA . ACM xxxxxx logic , called CT R S , which captures the dynamics of contracting for services and thus is in the intersection of the areas of contracting and process modeling . Since CT R S is an extension of the classical first order logic , it is well suited for modeling of the static aspects of contracting as well . If object oriented representation is desired , F logic [ 14 ] ( and an adaptation of CT R S ) can be used instead .
The idea of using a logic to model processes is not new [ 8 , 2 , 12 , 23 , 21 ] . These methodologies are commonly based on the classical first order logic , temporal logic [ 9 ] , and Concurrent Transaction Logic [ 5 ] . A distinctive aspect of contracting in Web services , which is not captured by these formalisms , is that contracting involves multi party processes , which can be adversarial in nature . One approach to deal with this situation could be to try and extend a multi modal logic of knowledge [ 10 ] . However , we found it more expedient to extend Concurrent Transaction Logic [ 5 ] ( or CT R ) , which has been proven a valuable tool for modeling and reasoning about processes [ 8 , 4 , 17 ] . The extension is called CT R S and is designed to model the adversarial situation that arises in service contracting . This is achieved by extending the model theory of CT R with certain concepts borrowed from the Game Theory [ 18 , 13 , 19 ] . In this paper we also develop a proof theory for CT R S and illustrate the use of this logic for modeling and reasoning about Web service contracts .
A typical situation in contracting where different parties may sometimes have conflicting goals is when a buyer interacts with a seller and a delivery service . The buyer needs to be assured that the goods will either be delivered ( using a delivery service ) or money will be returned . The seller might need assurance that if the buyer breaks the contract then part of the down payment can be kept as compensation . We thus see that services can be adversarial to an extent . Reasoning about such services is an unexplored research area and is the topic of this paper .
Overview and summary of results . We introduce the game theoretic aspects into CT R using a new connective , the opponent ’s conjunction . This connective represents the choice of action that can be made by a party other than the reasoner . The reasoner here can be the client of a Web service who needs to verify that her goals are met or a service that needs to make sure that its business rules are satisfied no matter what the other parties do . We then develop a model theory for CT R S and show how this new logic can be used to specify executions of services that may be non cooperating and have potentially conflicting goals . We also discuss reasoning about a fairly large class of temporal and causality constraints . In CT R S , a contract is modeled as a workflow that represents the various possibilities for the reasoner and the outside actors . The
CT R S model theory characterizes all possible outcomes of a formula W that represents such a workflow . A constraint Φ characterizes executions of the contract with certain desirable properties ( for instance , that either the good is delivered or payment refunded ) . The formula W ∧ Φ characterizes those executions that satisfy the constraint Φ . If W ∧Φ is satisfiable , ie , there is at least one execution O in its model , then we say that the constraint Φ is enforcible in workflow formula W . We describe a synthesis algorithm that converts declarative specifications , such as W ∧ Φ , into equivalent CT R S formulas that can be executed more efficiently and without backtracking . The transformation also detects unsatisfiable specifications , which are contracts that the reasoner cannot force to execute with desirable outcomes . In game theoretic terms , the result of such a transformation can be thought of as a concise representation of all winning strategies , ie , all the ways for the reasoner to achieve the desired outcome , regardless of what the rest of the system does , if all the parties obey the terms of the contract . Finally , since CT R S is a natural generalization of CT R , a pleasing aspect of this work is that our earlier results in [ 8 ] become special cases of the new results . The rest of the paper is organized as follows . In Section 2 , we introduce CT R S and discuss its use for modeling workflows and contracts . In Section 3 , we introduce the model theory of CT R S . The proof theory of CT R S is not discussed here due to lack of space , but it is available in the following report.2 Section 4 introduces causal and temporal workflow constraints that can be used to specify contracts . In Section 5 , we present the coordinator synthesis algorithm and discuss its complexity . Section 6 concludes with a discussion of related formalisms .
VICE CONTRACTS
2 . CT R S AND THE DYNAMICS OF SERFamiliarity with CT R [ 5 ] can help understanding of CT R S and its relationship to workflows and contracts . However , this paper is self contained and includes all the necessary definitions . We first describe the syntax of CT R S and then supply intuition to help the reader make sense out of the formal definitions . The model theory of CT R S , which is a rather radical extension of that of CT R , is described in Section 3 . 2.1 Syntax
The atomic f ormulas of CT R S are the same as in classical logic , ie they are expressions of the form p(t1 , , tn ) , where p is a predicate symbol and ti are terms . Complex formulas are built with the help of connectives and quantifiers : if φ and ψ are CT R S formulas , then so are φ ∧ ψ , φ ⊗ ψ , φ | ψ , ¬φ , φ fi ψ , and ( ∀X)φ , where X is a variable . Intuitively , the formula φ ⊗ ψ means : execute φ and then execute ψ . The connective ⊗ is called serial conjunction . The formula φ | ψ denotes an interleaved execution of two games φ and ψ . The connective | is called concurrent conjunction . The formula φ fi ψ means that the opponent chooses whether to execute φ or ψ , and therefore fi is called opponent s conjunction . The meaning of φ ∨ ψ is similar , except the reasoner makes the decision . In CT R this connective is called classical disjunction but because of its interpretation as reasoner ’s choice we will also refer s disjunction . Finally , the formula φ ∧ ψ to it as reasoner denotes execution of φ constrained by ψ ( or vice versa ) . It is called classical conjunction.3 2http://wwwpublicasuedu/∼hdavulcu/gamectrtechpdf 3The aforesaid meaning of ∧ is all but classical . However , its
As in classical logic , we introduce convenient abbreviations for complex formulas : φ←ψ stands for φ ∨ ¬ψ and is called a rule ; φ ∨ ψ denotes ¬(¬φ ∧ ¬ψ ) ; and ∃ φ is an abbreviation for ¬∀¬φ . The opponent ’s conjunction also has a dual connective , ) , but we will not discuss its properties in this paper .
As mentioned in the introduction , we model the dynamics of service contracts using the abstraction of a 2 party workflow , where the first party is the reasoner and the other represents the rest of the players involved in the contract . In general , if several parties need to be able to reason about the same contract , the contract can be represented as several 2 party workflows , each representing the contract from the point of view of a different reasoner .
Definition 1 . ( Workflows ) A CT R S goal is either an atomic formula or an expression of the form φ ⊗ ψ , φ | ψ , φ ∨ ψ , or φ fi ψ , where φ and ψ are CT R S goals . A rule is of the form head←body , where head is an atomic formula and body a CT R S goal . A workf low control specif ication consists of a CT R S goal and a ( possibly empty ) set of rules .
In this paper we will restrict workflows to be non recursive , so having rules is just a matter of convenience , which does not affect the expressive power . Note also that some connectives , like ∧ , are not allowed in workflow control specifications , but are used to specify constraints .
2.2 Modeling Contract Dynamics in CT R S
Example 1 . ( Procurement Contract ) Consider a procurement application that consists of a buyer interacting with three services , seller , f inancing and delivery . We assume that the buyer is the reasoner for the rest of this example .
Services are modeled in terms of their significant events . Thus , the buyer service begins when the significant event pay escrow occurs . Then concurrent execution of seller , and f inancing services proceeds .
Thus , at a high level , this buyer workflow can be represented as : pay escrow ⊗ ( f inancing | seller )
The connective ⊗ represents succession of events or actions : when the above expression “ executes , ” the underlying database state changes first to one where the workflow has started ( which would typically be expressed by insertion of a literal pay escrow into the log and execution of an escrow payment transaction ) , then to one where the execution of the rest of the formula proceeds . The connective | represents concurrent , interleaved execution of the two sequences of actions . Intuitively , this means that a legal execution of ( f inancing | seller ) is a sequence of database states where the initial subsequence corresponds , say , to a partial execution of the subformula f inancing ; the next subsequence of states corresponds to the execution of the seller ; the following subsequence is a continuation of the execution of the f inancing ; and so on . The overall execution sequence of ( f inancing | seller ) is a merge of an execution sequence for the left subformula and an execution sequence for the right subformula . Execution has precise meaning in the model and proof theory of CT R . Truth of CT R formulas is established not over database states , as in classical logic , but over sequences of states . Truth of a formula over such a sequence is interpreted as an execution of that formula in which the initial database state of the sequence is successively changed to the second , third , etc . , state . The database semantic definition looks very much like that of a conjunction in predicate calculus . This similarity is the main reason for the name . ends up in the final state of the sequence when the execution terminates.4 Workflow formulas can be modularized with the help of the rules . The intuitive meaning of a rule , head←body , where head is an atomic formula and body is a CT R S goal , is that head is an invocation interface to body , which is viewed as a subroutine . This is because according to the semantics described in Section 3 , such a rule is true if every legal execution of body must also be a legal execution of head . Combined with the minimal model semantics this gives the desired effect [ 6 ] . With this in mind , we can now express the above procurement workflow as follows : buyer ← pay escrow ⊗ ( seller | f inancing )
Next , buyer searches for matching services for seller using a services directory to discover the following match . seller ← reserve item ⊗ ( delivery ∨ collect escrow ) delivery ← insured ∨ uninsured The definition of seller involves the use of the ∨ connective . The connective ∨ here represents alternative executions for the reasoner . For instance , a legal execution of insured ∨ uninsured is either a legal execution of insured or of uninsured . Similarly , a legal execution of seller involves the execution of reserve item and then , the alternative execution of either delivery or recv escrow .
The above definition of seller also requires compliance to the following contract requirements between the buyer and the seller :
− if buyer cancels , then seller keeps the escrow − if buyer pays , then seller must deliver
Thus , ∨ connective represents a choice . The question is , however , whose choice it is : the reasoner ’s or that of the rest of the actors ? In an environment where workflow activities might not always cooperate , we need a way to distinguish these two kinds of choices . For instance , the contract may say that the outcome of the actions of the delivery agent the goods might be delivered or lost . This alternative is clearly not under the control of the reasoner . On the other hand , the choice of whether to use an insured or of uninsured delivery is made by the reasoner . With this understanding , the insured and uninsured services are defined as follows : insured ← ( delivered ⊗ conf irm ) fi ( lost ⊗ conf irm ) uninsured ← ( delivered ⊗ conf irm ) fi lost The above connective fi represents the service environment ’s choice . If the buyer uses insured delivery then he is guaranteed a confirmation whether the item is delivered or lost . If the buyer uses uninsured delivery then he can get a confirmation only if the item is delivered . Whether the item is delivered or lost depends on the service environment ’s choice .
Next , the buyer identifies the following matching service for f inancing : f inancing ← ( approve ⊗ ( make payment ∨ cancel ) ) fi ( reject ⊗ cancel )
Note that the approval or rejection of the financing request is the servicing agent ’s choice . However , if the financing is approved the decision of whether to proceed and make payment or to cancel 4Space limitation does not permit us to compare CT R to other logics that on the surface might appear to address the same issues ( eg , temporal logics , process and dynamic logics , the situation calculus , etc ) We refer the reader to the extensive comparisons provided in [ 5 , 6 ] . the procurement still depends on the choice of the reasoner , the buyer agent . In addition , the f inancing agent might require the following clause in the contract :
− if financing is approved and buyer does not cancel then delivery should confirm
The details of how to express the above contract in CT R S will be explained in Section 4 . Also in Section 5 we will show that regardless of the service environment ’s behavior , a suitable workflow coordinator for enforcing the above contract can be synthesized automatically .
We shall see that a large class of temporal and causality constraints ( including those in our example ) can be represented as CT R S formulas . If Φ represents such a formula for the above example , then finding a strategy to win the above game ( ie , enforce the constraints ) is tantamount to checking whether buyer ∧ Φ is satisfiable in CT R S .
Before going on , we should clear up one possible doubt : why is there only one opponent ? The answer is that this is sufficient for a vast majority of practical cases , especially those that arise in Web services . Indeed , even when multiple independent actors are involved , we can view each one of them ( or any group that decides to cooperate ) as the reasoner and all the rest as the opponent . Any such actor or a group can then use CT R S to verify that its goals ( specified as a condition Φ ) are indeed enforcible .
3 . MODEL THEORY
In this section we define a model theory for our logic . The importance of a model theory is that it provides the exact semantics for the behavioral aspects of service contracts and thus serves as a yardstick of correctness for the algorithms in Section 5 . 3.1 Sets of Multipaths
A path is a sequence of database states , d1dn Informally , a database state can be a collection of facts or even more complex formulas , but for this paper we can think of them as simply symbolic identifiers for various collections of facts . In CT R [ 5 ] , which allows concurrent , interleaved execution , the semantics is based on sequences of paths , π = p1 , , pmff , where each pi is a path . Such a sequence is called a multipath , or an m path [ 5 ] . For example , d1d2 , d3d4d5ff is an m path that consists of two paths : one having two database states and the other three ( note that a comma separates paths , not states in a path ) . As explained in Example 1 , multipaths capture the idea of an execution of a transaction that interleaves with executions of other transactions . Thus , an m path can be viewed as an execution that is broken into segments , such that other transactions could execute in between the segments . CT R S further extends this idea by recognizing that in the presence of other parties , the reasoner cannot be certain which execution ( or “ play ” ) will actually take place , due to the lack of information actual opponent ’s moves . However , the reasoner can have a strategy to ensure that regardless of what the opponent does the resulting execution will be contained within a certain set of plays . Such a set is called an outcome of the game . Thus , while truth values of formulas in Transaction Logic are determined on paths and of CT R formulas on m paths , CT R S formulas get their truth values on sets of m paths . Each such set , S , is interpreted as an outcome of the game in the above sense , and saying that a CT R S formula , φ , is true on S is tantamount to saying that S is an outcome of φ . In particular , two games are equivalent if and only if they have the same sets of outcomes .
3.2 Satisfaction on Sets of Multipaths
The following definitions make the above discussion precise .
Definition 2 . ( m Path Structures ) An m path structure [ 5 ] is a triple of the form U , IF , Ipathff , where U is the domain , IF is an interpretation function for constants and function symbols ( exactly like in classical logic ) , and Ipath is a mapping such that if π is an m path , then Ipath(π ) is a first order semantic structure ( as commonly used in classical predicate logic ) .
For a CT R formula , φ , and an m path , π , the truth of φ on π with respect to an m path structure is determined by the truth values of the components of φ on the appropriate sub m paths πi on π . In a well defined sense , establishing the truth of a formula , φ , over an m path , π = p1 , , pnff , corresponds to the possibility of executing φ along π where the gaps between p1 , , pn are filled with the executions of other formulas [ 5 ] . The present paper extends this notion to CT R S by defining truth of a formula φ over sets of m paths , where each such set represents a possible outcome of the game represented by φ . The new definition reduces to CT R ’s for formulas that have no fi ’s .
Definition 3 . ( Satisfaction ) Let I = U , IF , Ipathff be an mpath structure , π be an arbitrary m path , S , T , S1 , S2 , etc . , be non empty sets of m path , and let ν be a variable assignment ( ie , it assigns an element of U to each variable ) . We define the notion of satisf action of a formula , φ , in I on S by structural induction on φ :
1 . Base Case :
ν
I , {π} |=ν p(t1 , . . . , tn ) if and only if Ipath(π ) |=classic p(t1 , . . . , tn ) , for any atomic formula p(t1 , . . . , tn ) , where |=classic is the usual first order entailment . ( Recall that Ipath(π ) is a usual first order semantic structure , so |=classic is defined for it . ) Typically , p(t1 , , tn ) is either defined via rules ( as in Example 1 ) or is a “ built in , ” such as insert(q(a , b) ) , with a fixed meaning . For instance , in case of insert(q(a , b ) ) the meaning would be that I,{π} |=ν insert(q(a , b ) ) iff π is an m path of the form d1 d2ff ( ie , it consists of a single path ) , where d2 = d1 ∪{q(a , b)}.5 These built ins are called elementary updates and constitute the basic building blocks from which more complex actions , such as those at the end of Example 1 , are constructed .
2 . Negation : I , S |=ν ¬φ if and only if it is not the case that
I , S |=ν φ .
I , S |=ν φ ∨ ψ if and only if 3 . Reasoner ’s Disjunction : I , S |=ν φ or I , S |=ν ψ . The dual connective , φ∧ ψ , is a shorthand for , ¬(¬φ ∨¬ψ ) . I , S |=ν φ fi ψ if and only if S = S1 ∪ S2 , for some pair of m path sets , such that I , S1 |=ν φ , and I , S2 |=ν ψ . The dual connective , ) , also exists , but is not used in this paper .
4 . Opponent ’s Conjunction :
5 . Serial Conjunction :
I , S |=ν φ ⊗ ψ if and only if there is a set R of m paths , such that S can be represented as π∈R π◦Tπ , where each Tπ is a set of m paths , I , R |=ν φ , and for each Tπ , I , Tπ |=ν ψ . Here π◦T = {π ◦ δ | δ ∈ T} , where π ◦ δ is an m path obtained by appending the m path δ to the end of the m path π . 5Formally , the semantics of such built ins is defined using the notion of the transition oracle [ 6 ] .
( For instance , if π = d1d2 , d3d4ff and δ = d5d6 , d7d8d9ff then π ◦ δ = d1d2 , d3d4 , d5d6 , d7d8d9ff . ) In other words , R is a set of prefixes of the m paths in S .
6 . Concurrent Conjunction :
I , S |=ν φ | ψ if and only if there is a set R of m paths , such that S can be represented π∈R πfflTπ , where each Tπ is a set of m paths , and as either
• I , R |=ν φ and for all Tπ , I , Tπ |=ν ψ ; or • I , R |=ν ψ and for all Tπ , I , Tπ |=ν φ
Here πfflTπ denotes the set of all m paths that are interleavings of π with an m path in Tπ . For instance , if π = d1d2 , d3d4ff and d5d6 , d7d8d9ff ∈ Tπ then one of the interleavings is d1d2 , d5d6 , d3d4 , d7d8d9ff .
7 . Universal Quantification :
I , π |=ν ∀X.φ if and only if I , π |=µ φ for every variable assignment µ that agrees with ν everywhere except on X . Existential quantification , ∃X.φ , is a shorthand for ¬∀X¬φ .
Example 2 . ( Database Transactions ) Consider the following formula
φ = insert(st ) ⊗ ( insert(ab ) fi insert(cm ) )
⊗ ( insert(cp ) ∨ insert(no ) )
Then the possible outcomes for φ can be computed from the outcomes of its components as follows :
1 . By ( 1 ) in Definition 3 : {d d ∪ {st}ff} |= insert(st ) , {d d ∪ {cm}ff} |=
{d d ∪ {ab}ff} |= insert(ab ) , insert(cm ) , {d d ∪ {cp}ff} |= insert(cp ) , and {d d ∪ {no}ff} |= insert(no )
2 . By ( 3 ) in Definition 3 : {d d ∪ {cp}ff} |= ( insert(cp ) ∨ and {d d ∪ {no}ff} |= ( insert(cp ) ∨ insert(no) ) , insert(no ) )
3 . By ( 5 ) in Definition 3 : {d d ∪ {ab}ff , d d ∪ {cm}ff} |=
( insert(ab ) fi insert(cm ) ) in {∅ {st} {st , ab}ff , ∅ {st} {st , cm}ff} |= insert(st ) ⊗ ( insert(ab ) fi insert(cm ) )
Definition
4 . By
( 6 )
3 :
5 . By ( 6 ) in Definition 3 :
{ ∅ {st} {st , ab} {st , ab , cp}fi , ∅ {st} {st , cm} {st , cm , cp}fi} |= φ , and { ∅ {st} {st , ab} {st , ab , cp}fi , ∅ {st} {st , cm} {st , cm , no}fi} |= φ , and { ∅ {st} {st , ab} {st , ab , no}fi , ∅ {st} {st , cm} {st , cm , cp}fi} |= φ , and { ∅ {st} {st , ab} {st , ab , no}fi , ∅ {st} {st , cm} {st , cm , no}fi} |= φ
The following is the CT R S analogue of the proposition true of classical logic , which we denote Playset and define as φ ∨ ¬φ .
4 . CONSTRAINTS ON CONTRACT EXE
CUTION
In [ 8 ] , we have shown how a large class of constraints on workflow execution can be expressed in CT R . In CT R S we are interested in finding a similar class of constraints . In this context , verification of a constraint against a contract means that the reasoner has a way of executing the contract so that the constraint will hold no matter what the other parties do ( for instance , that the goods are delivered or payment refunded regardless ) . Our verification algorithm requires that behavioral specification of contracts have no loops in them , which is captured by the unique event property defined below.6 We assume that there is a subset of propositions , E VENT , which represents the “ interesting ” events in the course of workflow execution . These events are the building blocks both for workflows and constraints . In terms of Definition 3 , these propositions constitute the built in elementary updates .
Definition 4 . ( Unique event property ) A CT R S workflow W has the unique event property if and only if every proposition in E VENT can execute at most once in any execution of W . Formally , this can be defined both model theoretically and syntactically . The syntactic definition is that for every e ∈ E VENT : If W is W1 ⊗ W2 or W1 | W2 and e occurs in W1 then it cannot occur in W2 , and vice versa .
For workflows with no loops , we can always rename different occurrences of the same type of event to satisfy the above property . We shall call such workflows unique event workf lows .
Definition 5 . ( Constraints ) Let φ be a fi free formula . Then ∗φ denotes a formula that is true on a set of m paths , S , if and only if φ is true on every m path in S . The operator ∗ can be expressed using the basic machinery of CT R S . Our constraints on workflow execution , defined below , will all be of the form ∗φ , because intuitively this is the most common thing that a reasoner would want to know about the possible executions of a contract . Rules 1–3 define primitive constraints , denoted PRIMIT IVE . Rule 4 defines the set CONST R of all constraints . 1 . Elementary primitive constraints : If e ∈ E VENT is an event , then ∗e and ∗(¬e ) are primitive constraints . The constraint ∗e is true on a set of m paths , S , in an m path structure I = ( U , IF , Ipath ) iff e occurs on every m path in S . Similarly , ∗(¬e ) is true on S iff e does not occur on any m path in S . Formally , the former constraint says that every execution of the contract , ie , every m path p1 , , pi , , pnff ∈ S , has a component path , pi of the form d1dkdk+1dm , such that for some pair of adjacent states , dk and dk+1 , the event e occurs at dk and causes state transition to dk+1 , ie , Ipath(dkdk+1ff ) |=classic e ( see Definition 3 ) . The latter constraint , ∗(¬e ) , means that e does not occur on any m path in S .
2 . Disjunctive and Conjunctive Primitive constraints : Any ∨ or ∧ combination of propositions from E VENT is allowed under the scope of ∗ .
3 . Serial primitive constraints : If e1 , , en ∈ E VENT then ∗(e1 ⊗ ⊗ en ) is a primitive constraint . It is true on a set of m paths S iff e1 occurs before e2 before before en on every path in S .
4 . Complex constraints : The set of all constraints , CONST R , consists of all Boolean combinations of primitive constraints using the connectives ∨ and ∧ .
6This assumption has good practical reasons . It is made by virtually all formal approaches to workflow modeling ( eg , [ 2 , 22 ] ) and even such specification languages as WSFL — IBM ’s proposal for Web service specification language that was one of the inputs to BPEL4WS [ 15 ] .
It can be shown that under the unique event assumption any serial primitive constraint can be decomposed into a conjunction of binary serial constraints . For instance , ∗(e1 ⊗ e2 ⊗ e3 ) is equivalent to ∗(e1 ⊗ e2 ) ∧ ∗(e2 ⊗ e3 ) . Here are some typical constraints in CONST R and their real world interpretation : ∗e − event e should always eventually happen ; ∗e ∧ ∗f − events e and f must always both occur ( in some order ) ; ∗(e ∨ f ) − always either event e or event f or both must occur ; ∗e ∨ ∗f − either always event e must occur or always event f must occur ; ∗(¬e ∨ ¬f ) − it is not possible for e and f to happen together ; ∗(e → f ) − if event e occurs , then f must also occur . Example 3 . ( Procurement Contract ) The contract among these actors of the procurement workflow from Example 1 can be expressed as the following constraints : if financing is approved buyer should confirm
∗(approve ∧ ¬cancel → conf irm ) ∗(cancel → recv escrow ) ∗(make payment → delivery ) if buyer cancels , then seller keeps the escrow if buyer pays , then seller must deliver
5 . SYNTHESIZING A COORDINATOR BY
SOLVING WORKFLOW GAMES
5.1 Algorithm for Generating Strategies As explained , given a CT R S workflow W and a winning condition Φ , our goal is to compute a ∧ free workflow WΦ that is equivalent to W ∧ Φ . Because WΦ is ∧ free , it is directly executable by the CT R S proof theory7 and thus can be thought of as a set of executable strategies that the workflow coordinator can follow to enforce Φ . Enforcing complex constraints . Let ∗C1,∗C2 ∈ CONST R , W be a CT R S workflow , then
( ∗C1 ∨ ∗C2 ) ∧ W ≡ ( ∗C1 ∧ W ) ∨ ( ∗C2 ∧ W ) ( ∗C1 ∧ ∗C2 ) ∧ W ≡ ( ∗C1 ∧ ( ∗C2 ∧ W ) )
Enforcing elementary constraints . The following transformation takes an elementary primitive constraint of the form ∗α or ∗¬α and a control flow graph ( expressed as a CT R S unique event workflow ) and returns a CT R S workflow all of whose outcomes satisfy the constraint . Let α , β ∈ E VENT and W1,W2 be CT R S workflows . Then : ∗α ∧ α = α ∗α ∧ β = ¬Playset
∗¬α ∧ α = ¬Playset ∗¬α ∧ β = β if α = β
∗α ∧ ( W1 ⊗ W2 ) = ( ∗α ∧ W1 ) ⊗ W2 ∨ ∗¬α ∧ ( W1 ⊗ W2 ) = ( ∗¬α ∧ W1 ) ⊗ ( ∗¬α ∧ W2 )
W1 ⊗ ( ∗α ∧ W2 )
∗α ∧ ( W1 | W2 ) = ( ∗α ∧ W1 ) | W2 ∨ ∗¬α ∧ ( W1 | W2 ) = ( ∗¬α ∧ W1 ) | ( ∗¬α ∧ W2 )
W1 | ( ∗α ∧ W2 )
The above transformations are identical to those used for workflows of cooperating tasks in [ 8 ] . The first transformation below is specific to CT R S . Here we use σ to denote ∗α or ∗¬α : σ ∧ ( W1 fi W2 ) = ( σ ∧ W1 ) fi ( σ ∧ W2 ) σ ∧ ( W1 ∨ W2 ) = ( σ ∧ W1 ) ∨ ( σ ∧ W2 )
7Not presented here due to space constraints . The proof theory can be found in http://wwwcssunysbedu/∼davulcu/gamectrtechps
For example , if W ≡ abort fi prep⊗ ( abort∨ commit ) , then :
∗abort ∧ W = abort fi ( prep ⊗ abort ) ∗¬abort ∧ W = ¬Playset
Enforcing serial constraints . Next we extend our solver to work with constraints of the form ∗(α ⊗ β ) .
Let α , β ∈ E VENT and let W be a CT R S workflow . Then : ∗(α ⊗ β ) ∧ W = sync(α < β , ( ∗α ∧ ( ∗β ∧ W) ) ) and receive as can be defined
The transformation sync here is intended to synchronize events in the right order . It uses elementary updates send(ξ ) and receive(ξ ) , where W . and is defined as follows : sync(α < β , W ) = W . is like W , except that every occurrence of event α is replaced with α⊗send(ξ ) and every occurrence of β with receive(ξ)⊗β , where ξ is a new constant . The primitives send insert(channel(ξ ) ) and delete(channel(ξ) ) , respectively , where ξ is a new symbol . The point here is that these two primitives can be used to provide synchronization : receive(ξ ) can become true if and only if send(ξ ) has been executed previously . In this way , β cannot start before α is done . The following examples illustrate this transformation : ∗ ( α ⊗ β ) ∧ γ ∨ ( β ⊗ α ) = receive(ξ ) ⊗ β ⊗ α ⊗ send(ξ ) ∗ ( α ⊗ β ) ∧ ( α | β | ρ1 | | ρn ) =
( α ⊗ send(ξ ) ) | ( receive(ξ ) ⊗ β ) | ρ1 | | ρn ) Proposition 1 . ( Enforcing Elementary and Serial Constraints ) The above transformations for elementary and serial primitive constraints are correct , ie , they compute a CT R S workflow that is equivalent to W ∧ σ , where σ is an elementary or serial constraint .
Enforcing conjunctive primitive constraints . To enforce a primitive constraint of the form ∗(σ1 ∧ ∧ σm ) , where all σi are elementary , we utilize the logical equivalence ∗(σ1 ∧ ∧ σm ) ≡ ∗ σ1 ∧ ∧ ∗σm ( and the earlier equivalences for enforcing complex constraints ) . Enforcing disjunctive primitive constraints . These constraints have the form ∗(σ1 ∨ ∨ σn ) where all σi are elementary constraints . To enforce such constraints we rely on the following lemma .
Lemma 1 . ( Disjunctive Primitive Constraints ) Let σi be elementary constraints . Then ∗(σ1 ∨ ∨ σn ) ≡ ( ∗¬σ2 ∧ ∧ ∗¬σn → ∗σ1 ) fi fi ( ∗¬σ1 ∧ ∧ ∗¬σi−1 ∧ ∗¬σi+1 ∧ ∧ ∗¬σn → ∗σi ) fi fi ( ∗¬σ1 ∧ ∧ ∗¬σn−1 → ∗σn ) The above equivalence allows us to decompose the set of all plays in an outcome into subsets that satisfy the different implications shown in the lemma . Unfortunately , enforcing such implications is still not easy . Unlike the other constraints that we have dealt with in this section , enforcement of the implicational constraints cannot be described by a series of simple logical equivalences . Instead , we have to resort to equivalence transformations defined with the help of parse trees of workflows ( expressed as CT R S formulas ) . These transformations are correct only for workflows that satisfy the unique event property .
Definition 6 . ( Maximal guarantee for an event ) Let ∗σ be an elementary constraint ( ie , σ is e or ¬e ) , W be a workflow , and ϕ be a subformula of W . Then ϕ is said to be a maximal guarantee for ∗σ iff
1 . ( W ∧ ( ϕ | Playset ) ) → ∗σ 2 . ϕ is a maximal subformula of W that satisfies ( 1 )
The set of all maximal guarantees for an elementary event ∗σ is denoted by GS∗σ(W ) . Intuitively , formulas in GS∗e(W ) are such that the event e is guaranteed to occur during every execution of such a formula . Likewise , the formulas in GS∗¬e(W ) are such that the event e does not occur in any execution of such a formula .
Definition 7 . ( Co executing sub games of a subformula ) Let W be a workflow and ψ , ϕ be a pair of subformulas of W . Then ψ and ϕ coexecute in W , denoted ψ ∈ coExec(W , ϕ ) iff
1 . ( W ∧ ( ϕ | Playset ) ) → ( ψ | Playset ) , 2 . φ and ψ are disjoint subformulas in W , and 3 . ψ is a maximal subformula in W satisfying ( 1 ) and ( 2 )
Intuitively members of coExec(W , ϕ ) correspond to maximal sub games of W that must execute whenever ϕ executes as part of the workflow W . following procedures compute GS∗σ(W )
Proposition 2 . ( Computing GS∗σ(W ) and coExec(W , ϕ ) ) The and coExec(W , ϕ ) . They operate on the parse tree of W , which is defined as usual : the inner nodes correspond to composite subformulas and the leaves to atomic subformulas . Thus , the leaves are labeled with their corresponding atomic subformulas , while the inner nodes are labeled with the main connective of the corresponding composite subformula . GS∗e(W ) : The set of subformulas that correspond to the nodes in the parse tree of W that are closest to the root of the tree and can be reached by the following marking procedure : ( i ) mark all the leaves labeled with e ; ( ii ) mark any node labeled with a subformula of W of the form ( ϕ ⊗ ψ ) or ( ϕ | ψ ) if either the node for ϕ or that for ψ is marked ; ( iii ) mark any node labeled with a subformula of the form ( ϕ ∨ ψ ) or ( ϕ fi ψ ) if both the node for ϕ and the node for ψ are marked . coExec(W , ϕ ) : Find all subformulas of W of the form ψ1 | ψ2 or ψ1 ⊗ ψ2 that contain ϕ as a subformula . Then , ψ1 ∈ coExec(W , ϕ ) if ϕ is a subformula of ψ2 and ψ1 is a maximal subformula of W with this property . Likewise ψ2 ∈ coExec(W , ϕ ) if ϕ is a subformula of ψ1 and ψ2 is maximal .
GS∗¬e(W ) : Let T be the set of nodes in the parse tree of W that belong to any of the subformulas ϕ ∈ GS∗e(W ) or ψ ∈ coExec(W , ϕ ) . Then , η ∈ GS∗¬e(W ) iff it is a subformula of W such that its subtree contains no nodes in T and η is a maximal subformula with such a property .
Example 4 . ( Computation of maximal guarantees and coexecution ) The workflow parse tree for Example 3 is shown in Figure 1 . For the event approve , the set GS∗approve(W ) is {approve ⊗ ( makepay ∨ cancel)} . It contains a single maximal guarantee subformula for approve , which corresponds to the node labeled n1 in the figure . The set of co executing subformulas for n1 , coExec(W , n1 ) , consists of two formulas that correspond to the nodes n3 and n4 in the figure . The only maximal guarantee for ¬approve is the subformula rej ⊗ cancel , which corresponds to node n2 . buyer n3 pay_escrow finance n1 n2 n6 approve n5 makepay reserve rej cancel cancel n10 n11 insured seller n4 n7 deliver lost confirm confirm n8 recv_escrow non_insured n9 lost deliver confirm for each i such that W |= ∗ σi do for each f ∈ GS∗¬σi(W ) do
Figure 1 : Workflow parse tree and workflow graph for Example 3 procedure solve((∗σ1 ∧ ∧ ∗σn → ∗σ ) , W ) if ∀ i , W |= ∗σi then compute W ∧ ∗σ 1 . else Guard(g ) := ∅ for all g ∈ subf ormulas(W ) 2 . 3 . 4 . 5 . 6 . 7 . 8 . 9 . 10 . 11 . 12 . then rewrite f to send(ξ ) ⊗ f and set Guard(g ) := Guard(g ) ∪ {recv(ξ)} , else solve((∗σ1 ∧ ∧ ∗σn → ∗σ ) , sibling(f ) ) for each g ∈ subf ormulas(W ) do if Guard(g ) = ∅ then if ∃h ∈ coExec(W , f ) and ( h ∧ ∗σ ) is satisfiable
∀g ∈ GS∗¬σ(h ) rewrite g to (
. recv(ξ)∈Guard(g ) recv(ξ ) ) ⊗ g
Figure 2 : Enforcement of ( (∗σ1 ∧ ∧ ∗σn → ∗σ ) ∧ W )
The algorithm in Figure 2 computes a workflow that is equivalent to ( ∗σ1 ∧ ∧∗σn → ∗σ ) ∧ W ( and thus enforces the constraint on W ) , where ∗σi,∗σ are all elementary constraints . If the precondition of the constraint is true whenever the game is played then ( in line 1 ) ∗σ is enforced on W . Otherwise , for every ∗σi that is not true everywhere , we identify the subgames f ∈ GS∗¬σi ( lines 2 3 ) . Note that , whenever subgames in GS∗¬σi are executed the constraint ∗σ1 ∧ ∧∗σn → ∗σ is vacuously true . In lines 4 6 , we identify the subformulas h of W that co execute with the formulas f ∈ GS∗¬σi . If ∗σ is enforcible in any of these subformulas h , ie , h ∧ ∗σ is satisfied ( there can be at most one such subformula h per f , due to the unique event property , Definition 4 ) , then we enforce the above constraint by delaying executions of those subgames in h that violate ∗σ ( these are exactly the g ’s in line 7 ) until it is guaranteed that the game moves into f ∈ GS∗¬σi , because once f is executed our constraint becomes satisfied . This delay is achieved by synchronizing the executions of f to occur before the executions of g by rewriting f into send(ξ ) ⊗ f and by adding recv(ξ ) to the guard of g ( in line 6 ) . Otherwise , if no such h exists , in line 9 , we explicitly enforce the constraint on the sibling nodes ( in the parse tree of W ) of the formulas f ∈ GS∗¬σi ( because an outcome that satisfies ∗σi might exist in a sibling ) . Finally , in lines 10 12 , we make sure that the execution of every g that has a non empty guard is conditioned on receiving of a message from at least one f with which g is synchronized .
Example 5 . ( Procurement Workflow – contd . ) The algorithm in Figure 2 creates the following workflow by applying the constraints in Example 3 to the procurement workflow in Example 1 . The parse tree for that workflow is depicted in Figure 1 .
• To enforce ( ∗cancel → ∗recv escrow ) we first compute GS∗¬cancel(buyer ) = {n5} , and coExec(buyer , n5 ) = {n3 , n4 , n6} . Of these , n4 ( substituted for h ) satisfies the conditions of line 5 of the algorithm in Figure 2 . Since GS∗¬recv escrow(n4 ) = {n7} , we insert a synchronization from node n5 to n7 shown in Figure 1 as a dotted line . This ensures that if the buyer cancels the procurement workflow , the seller collects the escrow .
• To enforce ( ∗approve ∧ ∗ ¬cancel → ∗conf irm ) , we compute GS∗¬approve(buyer ) = {n2} and notice that n4 ∈ coExec(buyer , n2)} satisfies the conditions in line 5 of the algorithm in Figure 2 . Since GS∗¬conf irm(n4 ) = {n8 , n9} , we insert a synchronization from node n2 to n8 and n9 which yields the dotted edges in Figure 1 . We also compute GS∗cancel(buyer ) = {n10 , n2} and notice that n4 ∈ coExec(buyer , n2)} , n4 ∈ coExec(buyer , n10)} , and n4 satisfies the conditions in line 5 of the algorithm . Since GS∗¬conf irm(n4 ) = {n8 , n9} , we insert a synchronization from the nodes n10 and n2 to n8 and n9 , which yields the dotted edges in Figure 1 . This synchronization ensures that if buyer ’s financing is approved and he chooses to make the payment and buy the item then delivery must use the insured method . Also , once the constraint ( ∗make payment → ∗delivery ) is enforced too , the seller can no longer pocket the escrow . The resulting strategy is : buyer ← pay escrow ⊗ ( f inancing | seller ) f inancing ← ( approve ⊗ ( (send(ξ1 ) ⊗ make payment ) ∨ ( (send(ξ3 ) ⊗ cancel) ) ) fi ( send(ξ2 ) ⊗ ( reject ⊗ cancel ) ) seller ← reserve item ⊗ ( (recv(ξ1 ) ⊗ delivery ) ∨ ( (recv(ξ2 ) ∨ recv(ξ3 ) ) ⊗ collect escrow ) ) delivery ← insured ∨ ( (recv(ξ2 ) ∨ recv(ξ3 ) ) ⊗ non insured ) insured ← ( delivered ⊗ conf irm ) fi ( lost ⊗ conf irm ) non insured ← ( delivered ⊗ conf irm ) fi lost
Proposition 3 . ( Enforcing disjunctive primitive constraints ) The above algorithm for enforcing disjunctive primitive constraints is correct , ie , it computes a CT R S workflow that is equivalent to W ∧ ∗(σ1 ∨ ∨ σn ) where σi are elementary constraints .
THEOREM 1
( COMPLEXITY OF ENFORCING DPC ) . Let W be a control flow graph and ∗Φ ∈ PRIMIT IVE be a disjunctive primitive constraint(DPC ) . Let |W| denote the size of W , and d be the number of elementary disjuncts in ∗Φ . Then the worst case size of ∗Φ ∧ W is O(d × |W| ) , and the time complexity is O(d × |W|2 )
THEOREM 2
( COMPLEXITY OF SOLVING GAMES ) . Let W be a control flow graph W and Φ ⊂ CONST R be a set of global ( ∨jP rim ) where constraints in the conjunctive normal form P rim ∈ PRIMIT IVE . Let |W| denote the size of W , N be the number of constraints in Φ , and d be the largest number of disjuncts in a primitive constraint in Φ . Then the worst case size .= Φ ∧ W is O(dN × |W| ) , and the time of solve(Φ , W ) complexity is O(dN × |W|2 ) . fi
N
Cycle detection and removal . After compiling the constraints Φ into the workflow W , several things still need to be done . The problem is that even though WΦ is an executable workflow specification , WΦ may have sub formulas where the send/receive primitives cause a cyclic wait , which we call cyclic blocks . Fortunately , we can show that a variant of depth first search on the control flow graph of W can identify all executable cyclic blocks and remove all blocks from W in time O(|W|3 ) .
Example 6 . ( Cyclic Block Removal ) Let W ← ( a∨b)⊗(cfid ) and C be ( ∗c → ∗a ) . Our algorithm will compile W ∧ C into ( a ∨ recv(ξ ) ⊗ b ) ⊗ ( c fi ( send(ξ ) ⊗ d) ) . Now , if reasoner moves into b , a deadlock occurs . However , we can rewrite this workflow into a ⊗ ( c fi d ) to avoid the problem .
6 . CONCLUSION AND RELATED WORK We presented a novel formalism , CT R S , for modeling the dynamics of service contracts . CT R S is a logic in which service contracts are represented as formulas that specify the various choices that are allowed for the parties to the contracts . The logic permits the reasoner to state the desired outcomes of the contract execution and verify that a desired outcome can be achived no matter what the other parties do as long as they obey the rules of the contract .
There is a body of preliminary work trying to formalize the representation of Web service contracts [ 20 , 11 ] , but none deals with the dynamics of such contracts , which is the main subject of this paper . Technically , the works closest to ours come from the fields of model checking and game logics .
Process algebras and alternating temporal logic [ 7 , 1 ] have been used for modeling open systems with game semantics . Model checking is a standard mechanism for verifying temporal properties of such systems and deriving automata for scheduling . In [ 16 ] , the complexity and size of computing the winning strategies for infinite games played on finite graphs are explored . A result analogous to ours is obtained for infinite games : assuming the size of the graph is Q and the size of the winning condition is W the complexity of computing winning strategies is exponential in the size of W and polynomial in the size of the set Q . The use of CT R S has enabled us to find a more efficient verification algorithm than what one would get using model checking . Indeed , standard model checking techniques [ 7 , 1 ] are worst case exponential in the size of the entire control flow graph and the corresponding scheduling automata are also exponential . This is often referred to as the state explosion problem . In contrast , the size of our solver is linear in the size of the original workflow graph and exponential only in the size of the constraint set ( Theorem 2 ) , which is a much smaller object . In a sense , our solver can be viewed as a specialized and more efficient model checker/scheduler for the problem at hand . It accepts high level specifications of workflows and yields strategies and schedulers in the same high level language . Logic games have been proposed before in other contexts [ 13 , 19 ] . As in CT R S , validity of a statement in such a logic means that the reasoner has a winning strategy against the opponent . In CT R S however , games , winning conditions , and strategies are themselves logical formulas ( rather than modal operators ) . Logical equivalence in CT R S is a basis for constructive algorithms for solving games and synthesizing strategies , which are in turn executable by the proof theory of CT R S . Related game logic formalisms , such as [ 13 , 19 ] , only deal with assertions about games and their winning strategies . In these logics , games are modalities rather than executable specifications , so they can only be used for reasoning about Web service contracts , but not for modeling and executing them .
Related work in planning , where planning goals are expressed as temporal formulas includes [ 3 ] . In [ 3 ] , plans are generated using a forward chaining engine that generates finite linear sequences of actions . As these linear sequences are generated , the paths are incrementally checked against the temporal goals . This approach is sound and complete . However , in the worst case it performs an exhaustive search of the model similar to the model checking approaches .
For the future work , we are planning to extend our results to allow contracts that include iterative behaviour . Such contracts can already be specified in CT R S . However , iteration requires new verification algorithms to enable reasoning about the desired outcomes of such contracts .
7 . REFERENCES [ 1 ] Rajeev Alur , Thomas A . Henzinger , and Orna Kupferman .
Alternating time temporal logic . In Intl . Conference on Foundations of Computer Science , pages 100–109 , 1997 .
[ 2 ] PC Attie , MP Singh , EA Emerson , AP Sheth , and M . Rusinkiewicz . Scheduling workflows by enforcing intertask dependencies . Distributed Systems Engineering Journal , 3(4):222–238 , December 1996 .
[ 3 ] Fahiem Bacchus and Froduald Kabanza . Planning for temporally extended goals . In Proceedings of the Thirteenth National Conference on Artificial Intelligence ( AAAI 96 ) , pages 1215–1222 , Portland , Oregon , USA , 1996 . AAAI Press / The MIT Press .
[ 4 ] AJ Bonner . Workflow , transactions , and datalog . In ACM
Symposium on Principles of Database Systems , Philadelphia , PA , May/June 1999 .
[ 5 ] AJ Bonner and M . Kifer . Concurrency and communication in transaction logic . In Joint Intl . Conference and Symposium on Logic Programming , pages 142–156 , Bonn , Germany , September 1996 . MIT Press .
[ 6 ] AJ Bonner and M . Kifer . A logic for programming database transactions . In J . Chomicki and G . Saake , editors , Logics for Databases and Information Systems , chapter 5 , pages 117–166 . Kluwer Academic Publishers , March 1998 .
[ 7 ] Edmund M . Clarke , E . Allen Emerson , and A . Prasad Sistla .
Automatic verification of finite state concurrent systems using temporal logic specifications . In ACM Transactions on Programming Languages and Systems ( TOPLAS ) , pages 244–263 , 1986 .
[ 8 ] H . Davulcu , M . Kifer , CR Ramakrishnan , and IV
Ramakrishnan . Logic based modeling and analysis of workflows . In ACM Symposium on Principles of Database Systems , pages 25–33 , Seattle , Washington , June 1998 .
[ 9 ] EA Emerson . Temporal and modal logic . In Handbook of Theoretical Computer Science , pages 997–1072 . Elsevier and MIT Press , 1990 .
[ 10 ] R . Fagin , J . Y . Halpern , Y . Moses , and Moshe Y . Vardi .
Reasoning About Knowledge . MIT Press , 1994 .
[ 11 ] BN Grosof and TC Poon . Sweetdeal : representing agent contracts with exceptions using xml rules , ontologies , and process descriptions . In Proceedings of the twelfth international conference on World Wide Web , pages 340–349 , May 2003 .
[ 12 ] R . Gunthor . Extended transaction processing based on dependency rules . In Proceedings of the RIDE IMS Workshop , 1993 .
[ 13 ] J . Hintikka . Logic , Language Games , and Information .
Oxford Univ . Press , Clarendon , Oxford , 1973 .
[ 14 ] M . Kifer , G . Lausen , and J . Wu . Logical foundations of object oriented and frame based languages . Journal of ACM , pages 741–843 , July 1995 .
[ 15 ] F . Leymann . Web services flow language ( wsfl 10 )
Technical report , IBM , 2001 . http://www4ibmcom/software/solutions/webservices/pdf/WSFLpdf
[ 16 ] R . McNaughton . Infinite games played on finite graphs .
Annals of Pure and Applied Logic , 65:149–184 , 1993 .
[ 17 ] S . Mukherjee , H . Davulcu , M . Kifer , G . Yang , and P . Senkul . Survey of logic based approaches to workflow modeling . In J . Chomicki , R . van der Meyden , and G . Saake Springer , editors , Logics for Emerging Applications of Databases , LNCS . Springer Verlag , October 2004 .
[ 18 ] M . Osborne and A . Rubinstein . A Course in Game Theory .
The MIT Press , 1998 .
[ 19 ] Rohit Parikh . Logic of games and its applications . In Annals of Discrete Mathematics , volume 24 , pages 111–140 . Elsevier Science Publishers , March 1985 .
[ 20 ] DM Reeves , MP Wellman , and BN Grosof . Automated negotiation from declarative contract descriptions . In JP M¨uller , E . Andre , S . Sen , and C . Frasson , editors , Proceedings of the Fifth International Conference on Autonomous Agents , pages 51–58 , Montreal , Canada , 2001 . ACM Press .
[ 21 ] C . Schlenoff , M . Gruninger , M . Ciocoiu , and J . Lee . The essence of the process specification language . Transactions of the Society for Computer Simulation International , 16(4):204–216 , 2000 .
[ 22 ] MP Singh . Semantical considerations on workflows : An algebra for intertask dependencies . In Proceedings of the International Workshop on Database Programming Languages , Gubbio , Umbria , Italy , September 6–8 1995 .
[ 23 ] MP Singh . Synthesizing distributed constrained events from transactional workflow specifications . In Proceedings of 12 th IEEE Intl . Conference on Data Engineering , pages 616–623 , New Orleans , LA , February 1996 .
