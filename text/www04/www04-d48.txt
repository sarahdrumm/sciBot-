TCOZ Approach to Semantic Web Services Design
Jin Song Dong Yuan Fang Li Hai Wang
1
Abstract—Complex Semantic Web ( SW ) services may have intricate data state , autonomous process behavior and concurrent interactions . The design of such SW services systems requires precise and powerful modelling techniques to capture not only the ontology domain properties but also the services’ process behavior and functionalities . Timed Communicating Object Z ( TCOZ ) is an integrated formal design language which builds on the strengths of Object Z in modelling complex data state and strength of Timed CSP in modelling concurrent interaction . In this paper , we illustrate how TCOZ can be used as high level design language to design SW services . Furthermore , the paper presents the development of the systematic translation rules and tools which can automatically extract the SW ontology and services semantic markup from the formal TCOZ design model . The online talk discovery system is used as a demonstrating case study .
Index Terms—Semantic Web , Formal Methods , TCOZ ,
DAML+OIL , DAML S .
I . INTRODUCTION
As the next generation of Web , the Semantic Web ( SW ) [ 1 ] provides computer interpretable markup of the Web ’s content and capability , thus enabling automation of many tasks currently performed by humans . Among the most important Web resources are those that provide services . The Web services , as the key application of SW , are Web accessible programs and devices that will proliferate the Web . Some SW services have been developed recently , eg ITTALKS [ 5 ] . SW is highly distributed , and different parties may have different understandings for the same concept . One important concept in SW services is ontology . Ontology is the basis for constructing common understand through explicitly defined relations . The most typical kind of ontology for the Web has taxonomy and a set of constraints . RDFS and DAML+OIL languages can be used to define the ontology . Another important concept in SW services is the semantic markup of services . Semantic markup of the content and capability of Web services – what a service does , how to use it , what its effect will be – will enable easy automation of a variety of reasoning tasks , currently performed manually by human beings , or through arduous hand coding that enables subsequent automation . DAML S [ 4 ] is such a semantic markup language for Web services . SW services may have intricate data state , complex process behavior and concurrent interactions . The design of such SW service systems requires precise and powerful modelling techniques to capture not only the ontology domain properties J . S . Dong is with the School of Computing , National University of Y . F . Li is with School of Computing , the National University of Singapore . H . Wang is with the Medical Informatics Group , Department of Computer
Singapore . E mail : dongjs@compnusedusg E mail : liyf@compnusedusg Science , University of Manchester . E mail : hwang@csmanacuk but also the services’ process behavior and functionalities . It is desired to have a powerful formal notation to precisely design the Web system . Timed Communicating Object Z ( TCOZ ) [ 14 ] is a Formal Specification language which builds on the strengths of Object Z [ 8 ] , [ 22 ] in modelling complex data and state with strength of Timed CSP [ 21 ] in modelling real time concurrency . We believe that TCOZ as a high level design technique can contribute to the semantic web based system development in many ways . In support of this claim , we conduct a SW service case study , ie , the online talk discovery system , and apply TCOZ to the design stage to demonstrate how TCOZ can be used as high level design language to specify SW services . The following characteristics of many Web services make TCOZ a good candidate to design such a system . • A complex Web service system often has both intricate data state and process control aspects . An integrated formal modelling language , like TCOZ , has the strength to model such systems . • A Web service agent often provides several kinds of different services concurrently . TCOZ has the multithreaded capabilities to capture that . • A complex Web service system is often composed from sub services . The sub services may be provided by other agents , which have their own thread of control . It can be modelled by the active objects feature in TCOZ . • A Web service includes highly distributed components with various synchronous and asynchronous communications . It can be specified with various TCOZ communication interfaces – channels , sensors and actuators . • A Web service like an online hospital or online bank may have critical timing requirements . TCOZ can capture the real time requirement well . language like TCOZ it can provide a unambiguous requirement for the SW services system and the series of related supporting tools [ ? ] , [ ? ] , [ 23 ] can ensure the high quality of the design model . Besides these general advantages of using formal language to design a system , the paper also presents the development of the systematic translation rules and tools to automatically extract the Web ontology and semantic markup for the SW services from the formal TCOZ design model . It is a desired add on value . This online talk discovery system is a simplified version of the ITTALKS system [ 5 ] which is a real life SW service case study . The remainder of the paper is organized as follows . Section 2 briefly introduces TCOZ and SW . Section 3 formally specifies the functionalities of the SW service example ( talk discovery system ) . Section 4 presents the tool which extracts the ontology used by the SW services from the TCOZ design
By using a nexpressive formal model automatically . Section 5 presents the tool which extracts the semantic markup for SW services from the TCOZ design model automatically . Section 6 concludes the paper .
II . TCOZ AND SW SERVICES OVERVIEW
A . TCOZ overview
Timed Communicating Object Z ( TCOZ ) [ 14 ] is essentially a blending of Object Z with Timed CSP [ 21 ] , for the most part preserving them as proper sub languages of the blended notation . The essence of this blending is the identification of Object Z operation specification schemas with terminating CSP processes . Thus operation schemas and CSP processes occupy the same syntactic and semantic category , operation schema expressions may appear wherever processes may appear in CSP and CSP process definitions may appear wherever operation definitions may appear in Object Z . The primary specification structuring device in TCOZ is the Object Z class mechanism . In this section we briefly consider various aspects of TCOZ . A detailed introduction to TCOZ and its Timed CSP and Object Z features may be found elsewhere [ 14 ] . The formal semantics of TCOZ is also documented [ 15 ] . 1 ) Interface – channels , sensors and actuators : CSP channels are given an independent , first class role in TCOZ . In order to support the role of CSP channels , the state schema convention is extended to allow the declaration of communication channels . If c is to be used as a communication channel by any of the operations of a class , then it must be declared in the state schema to be of type chan . Channels are type heterogeneous and may carry communications of any type . Contrary to the conventions adopted for internal state attributes , channels are viewed as shared ( global ) rather than as encapsulated entities . This is an essential consequence of their role as communications interfaces between objects . The introduction of channels to TCOZ reduces the need to reference other classes in class definitions , thereby enhancing the modularity of system specifications . Complementary to the synchronizing CSP channel mechanism , TCOZ also adopts a non synchronizing shared variable mechanism . A declaration of the form s : X sensor provides a channel like interface for using the shared variable s as an input . A declaration of the form s : X actuator provides a local variable like interface for using the shared variable s as an output . Sensors and actuators may appear either at the system boundary ( usually describing how global analog quantities are sampled from , or generated by the digital subsystem ) or else within the system ( providing a convenient mechanism for describing local communications which do not require synchronization ) . The shift from closed to open systems necessitates close attention to issues of control , an area where both Z and CSP are weak [ 27 ] . We believe that TCOZ with the actuator and sensor can be a good candidate for specifying open control systems . Mahony and Dong [ 13 ] presented detailed discussion on TCOZ sensor and actuators . 2 ) Active objects : Active objects have their own threads of control , while passive objects are controlled by other objects in a system . In TCOZ , an identifier MAIN ( non terminating
2 process ) is used to determine the behavior of active objects of a given class [ 6 ] . The MAIN operation is optional in a class definition . It only appears in a class definition when the objects of that class are active objects . Classes for defining passive objects will not have the MAIN definition , but may contain CSP process constructors . If ob1 and ob2 are active objects of the class C , then the independent parallel composition behavior of the two objects can be represented as ob1 ||| ob2 , which means ob1.MAIN ||| ob2.MAIN 3 ) Semantics of TCOZ : A separate paper details the blended state/event process model which forms the basis for the TCOZ semantics [ 15 ] . In brief , the semantic approach is to identify the notions of operation and process by providing a process interpretation of the Z operation schema construct . TCOZ differs from many other approaches to blending ObjectZ with a process algebra in that it does not identify operations with events . Instead an unspecified , fine grained , collection of state update events is hypothesized . Operation schemas are modelled by the collection of those sequences of update events that achieve the state change described by the schema . This means that there is no semantic difference between a Z operation schema and a CSP process . It therefore makes sense to also identify their syntactic classes . The process model used by TCOZ consists of sets of tuples consisting of : an initial state ; a trace ( a sequence of time stamped events , including update events ) , a refusal ( a record what and when events are refused by the process ) , and a divergence ( a record of if and when the process diverged ) . The trace/refusal pair is called a failure and the overall model the state/failures/divergences model . The state of the process at any given time is the initial state updated by all of the updates that have occurred up to that time . If an event trace terminates ( that is if a X event occurs ) , then the state at the time of termination is called the final state . The process model of an operation schema consists of all initial states and update traces ( terminated with a X ) such that the initial state and the final state satisfy the relation described by the schema . If no legal final state exists for a given initial state , the operation diverges immediately . An advantage of this semantics is that it allows CSP process refinement to agree with Z operation refinement .
B . Semantic Web overview
As a huge information space , the Web should be useful not only for human human communication , but also allows machines to participate and help . However , nowadays most information on the Web is designed for human consumption and the structure of the data is not evident for a robot browsing the Web . There are two distinct approaches to enable the machine to automatically manipulate the information in the Web . One approach which comes from artificial intelligence is machine learning . The machine is trained to behave like a person . However this approach is domain dependent and requires a huge training process . The Semantic Web [ 1 ] approach instead develops language for expressing information in a machine processable form . The W3C gives the following definition for the Semantic Web :
The Semantic Web is an extension of the current Web in which information is given a well defined meaning , better enabling computers and people to work in cooperation .
SW is a collaborative effort led by W3C with participation from a large number of researchers and industrial partners . A series of technologies has been proposed to realize the vision of the Semantic Web as the next generation Web . It extends the current Web by giving the Web content a well defined meaning and representing the information in a machine understandable form . HTML , the current Web data standard , is aimed at delivering information to the end user for human consumption ( eg display this document ) . XML is aimed at delivering data to systems that can understand and interpret the information . XML is focused on the syntax ( defined by the XML schema or DTD ) of a document and it provides essentially a mechanism to declare and use simple data structures . However there is no way for a program to actually understand the knowledge contained in the XML documents . Resource Description Framework ( RDF ) [ 11 ] is a foundation for processing metadata ; it provides interoperability between applications that exchange machine understandable information on the Web . RDF uses XML to exchange descriptions of Web resources and emphasizes facilities to enable automated processing . The RDF descriptions provide a simple ontology system to support the exchange of knowledge and semantic information on the Web . RDF Schema [ 2 ] provides the basic vocabulary to describe RDF documents . RDF Schema can be used to define properties and types of the Web resources . In a similar fashion to XML Schema which gives specific constraints on the structure of an XML document , RDF Schema provides information about the interpretation of the RDF statements . The DARPA Agent Markup Language ( DAML ) [ 25 ] is an AI inspired description logic based language for describing taxonomic information . DAML currently combines Ontology Inference Layer ( OIL ) [ 3 ] and features from other ontology systems . It is now called DAML+OIL and contains richer modelling primitives than RDF schema . The DAML+OIL language builds on top of XML and RDF(S ) to provide a language with both a well defined semantics and a set of language constructs including classes , subclasses and properties with domains and ranges , for describing a Web domain . DAML+OIL can further express restrictions on membership in classes and restrictions on certain domains and ranges values . Semantic Web is highly distributed , and different parties may have different understandings of the same concept . Ideally , the program must have a way to discover the common meanings from the different understandings . It is central to one important concept in Semantic Web system – ontology . The ontology for a Semantic Web system is a document or a file that formally defines the relations among terms . The most typical kind of ontology for the Web has taxonomy and a set of inference rules . Ontology can enhance the functioning of the Web in many ways . RDFS and DAML+OIL supply the language to define the ontology . For example , the following DAML+OIL code specifies a concept ‘talk’ which
3
DAML+OIL constructs Description DAML class DAML property DAML subclass[C ] DAML subproperty[P ] instanceof [ C ] classes properties subclasses of C subproperties of P instances of the DAML+OIL class C
TABLE I
DAML+OIL CONSTRUCTS ( PARTIAL ) hold in a certain place . A ‘talk’ ( a DAML+OIL class ) has a property ‘talk place’ , having only one value ‘place’ ( also a DAML+OIL class ) . <daml:class rdf:ID="talk">
<rdfs:label>Talk</rdfs:label>
</daml:class> <daml:class rdf:ID="place">
<rdfs:label>Place</rdfs:label>
</daml:class> <daml:ObjectProperty rdf:ID="talk_place">
<rdf:type rdf:resource=
"http://wwwdamlorg/2001/03/ daml+oil#UniqueProperty"/> <rdf:domain rdf:resource="#talk"/> <rdf:range rdf:resource="#place"/>
</daml:ObjectProperty> We summarize some essential DAML+OIL constructs in Table I . A fundamental component of the Semantic Web will be the markup of Web Services to make them computer interpretable , use apparent , and agent ready .
C . DAML S
DAML S is a DAML+OIL ontology for Web services developed by a coalition1 . DAML S was expected to enable the following tasks . • automatic Web service discovery , • automatic Web service invocation , • automatic Web service composition and interoperation , • automatic Web service execution monitoring . DAML S consists of three main parts : the process model and the grounding . The DAML S profile describes what the service does . Thus , the class SERVICE presents a SERVICEPROFILE . The service profile is the primary construct by which a service is advertised , discovered and selected . The DAML S process model tells how the service works . Thus , the class SERVICE is describedBy a SERVICEMODEL . It includes information about the service inputs , outputs , preconditions and effects . It also shows the 1DAML Service Coalition : A . Ankolekar , M . Burstein , J . Hobbs , O . Lassila , D . Martin , D . McDermott , S . McIlraith , S . Narayanan , M . Paolucci , T . Payne , K . Sycara , H . Zeng . the profile , component processes for a complex process and how the control flows between the components . The DAML S grounding tells how the service is used . It specifies how an agent can access a service . In this paper , we focus on the connection between the TCOZ model and the DAML S process model .
D . DAML S process
The DAML S process model is intended to provide a basis for specifying the behavior of a wide array of services . It is influenced by the work in AI on standardizations of planning languages [ 9 ] , work in programming languages and distributed systems [ 17 ] , [ 18 ] , emerging standards in process modelling and workflow technology such as the NIST ’s Process Specification Language ( PSL ) [ 20 ] and the Workflow Management Coalition effort ( http://wwwaiimorg/wfmc ) , work on modelling verb semantics and event structure [ 19 ] , work in AI on modelling complex actions [ 12 ] , and work in agent communication languages [ 10 ] , [ 16 ] . There are two chief components of a DAML S process model – the process , and process control model . The process describes a Web Service in terms of its input , output , precondition , effects and , where appropriate , its component subprocess . The process model enables planning , composition and agent/service inter operation . The process control model – which describes the control flow of a composite process and shows which of various inputs of the composite process are accepted by which of its subprocesses – allows agents to monitor the execution of a service request . The constructs to specify the control flow within a process model includes Sequence , Split , Split+Join , If Then Else , Repeat While and Repeat Until . We will use the following table ( Table II ) to summarize some of the constructs available in DAML S process :
III . THE TALK DISCOVERY SYSTEM
In this section , an online talk discovery system is used as an example to demonstrate how TCOZ notation can be applied to the Semantic Web service development .
A . System scenario
The talk discovery system is a Web portal offering access to information about talks and seminars . This Web portal can provide not only the talk ’s information corresponding to the user ’s profile in terms of his interest and location constraints , but also can further filter the IT related talks based on information about the user ’s personal schedule , etc . In the course of operation , the talk discovery system discovers that there is an upcoming talk that may interest a registered user based on information in the user ’s preferences , which have been obtained from his online , DAML encoded profile . Upon receiving this information , the user ’s User Agent needs to know more ; it consults with its Calendar agent to determine the user ’s availability , and with the MapQuest agent to find the distance from the user ’s office to the talk ’s venue . We assume that a user only wants to attend the talks located within five miles from his office . Finally , after evaluating the
4
DAML S Constructs damls Process damls input damls output damls precondition damls effect damls AtomicProcess
Description Describes service which includes atomic , composite and simple process Specifies one of the inputs of the service . Specifies one of the outputs of the service . Specifies one of the preconditions of the service . Specifies one of the effects of the service . Process which is directly invocable , have no subprocess and execute in a single step . Process which is composed damls CompositeProcess from other process . Process which is used as damls SimpleProcess elements of abstraction . damls Sequence[P1 , P2 , ] Executes a list of processes in order Execute a bag of processes damls Split[P1 , P2 , ] concurrently
TABLE II
A PARTIAL SUMMARY OF THE DAML S CONSTRUCTS information and making the decision , the User Agent will send a notification back to the talk discovery agent indicating that the user will ( or will not ) plan to attend . The completed functionality of the ITTALKS system can be found at http : //wwwittalksorg/jsp/Controllerjsp
B . Formal model of the talk discovery system
The system involves four different intelligent agents which communicate interactively . They are the user ’s Calendar agent , MapQuest agent , user ’s personal agent and the talk discovery agent . 1 ) Calendar agent : Firstly , the DATE and TIME set are defined by the Z given type definitions . As this paper focuses only on demonstrating the approach , we try to make the model simple . Z given type is chosen to define TIME , DATE and some other concepts . These concepts can be subdivided into detailed components , eg , the TIME comprises hour , minute , and second . The more detailed the model is , the more detailed ontology will be derived automatically from our tool . This tool will be further discussed in the later section . The DateTime is defined as a schema with two attributes date and time .
[ TIME , DATE ]
DateTime date : DATE time : TIME
The Calendar agent maintains a schedule for each eligible user and supplies some related services . Each eligible user must have a personal ID [ PID ] registered . This id is used to validate the identity of users when the system receives requests . The Calendar agent has an ID manager which provides functions for identity certifying . It may use Web security techniques like digital signatures to ensure the service is only available to the valid users .
The following specifies the ID manager :
Firstly , the PLACE is defined as a Z given type . The MapQuest agent contains a set of places in its domain and a database storing the distance between any two places .
5
INIT ids = ?
RemovePID ∆(ids ) id ? : PID ids0 = ids °{ id?}
PIDManager ids : P PID add , remove : chan check : chan AddPID ∆(ids ) id ? : PID ids0 = ids [ { id?} New b= [ id : PID | id 62 ids ] • add?id ! AddPID Delete b= [ id : PID | id 2 ids ] • remove?id ! RemovePID Validate b= [ id : PID ] • check?id ! ( [id 2 ids ] • check!true ! Skip 2 [ id 62 ids ] • check!false ! Skip ) MAIN b= µ N • ( New 2 Delete 2 Validate ) ; N Status ::= FREE | BUSY
The Status defined by the Z free type definition indicates if a person is free or busy .
Calendar timetable : ( PID £ DateTime ) ! Status upd , checktm : chan check : chan
Upd ∆(timetable ) id ? : PID ; t ? : DateTime ; s ? : Status timetable0 = timetable ©{ ( id ? , t ? , s?)} Update b= [ id : PID ; t : DateTime ; s : Status ] • upd?(id , t , s ) ! check!id ! ( check?false ! SKIP 2 check?true ! Upd ) Check Status b= [ id : PID ; t : DateTime ] • checktm?(id , t ) ! check!id ! ( check?false ! SKIP 2 check?true ! checktm!timetable(id , t ) ! Skip ) MAIN b= µ N • ( Update 2 Check Status ) ; N
Update is used to update the timetable . The operation Check Status is used to check whether a person is available or not for a particular time slot . 2 ) MapQuest agent : MapQuest agent is a third party agent supplying the service for calculating the distance between two places .
[ PLACE ]
MapQuest places : P PLACE distance : places £ places ! R+ dist : chan Get dis b= [ p1 , p2 : places ] • dist?(p1 , p2 ) ! dist!distance(p1 , p2 ) ! Skip MAIN b= µ N • Get dis ; N
3 ) Personal agent : The personal agent keeps the user ’s profile including user ’s name , office location , interests , etc .
[ NAME , SUBJECT ]
Person id : PID name : NAME office : PLACE interests : P SUBJECT upd , talkch , dist , checktm : chan
Check b= [ tk : Talk ] • talkch?(id , tk ) ! ( (checktm!(id , tk.dt ) ! [ tresult : Status ] • checktm?tresult ! Skip)k ( dist!(office , tk.place ) ! [ dresult : R+ ] • dist?dresult ! Skip) ) ; [ tresult = FREE ^ dresult < 5 ] • talkch!(id , GO ) ! upd!(id , tk.dt , BUSY ) ! Skip
2 [ tresult = BUSY _ dresult > 5 ] • talkch!(id , NO ) ! Skip
MAIN b= µ N • Check ; N
After receiving an interested talk information from the talk discovery agent ( defined later ) , the personal agent uses operation Check to communicate with his calendar agent to check whether the user is free or not and with the MapQuest agent to ensure the talk will be held nearby . In our system we assume that a user only wants to attend the talks located within five miles from his office . If the user could attend the talk , the personal agent will inform the discovery agent and connect the calendar agent to update the user ’s timetable . 4 ) Talk discovery agent : Schema Talk is defined for a general talk type . The interested subjects records the interested subjects for the users .
Talk place : PLACE dt : DateTime subject : P SUBJECT notify ::= GO | NO interested subjects : Person $ SUBJECT Discovery
A . Given type translation
The given types in the TCOZ model are directly translated into DAML+OIL classes . This rule is applicable to the given types defined in both inside and outside of a class definition . The translation can be expressed as the following rule :
6 users : P1 Person talkch : chan monitor : Talk sensor 8 u1 , u2 : users • u1 6= u2 ) u1.id 6= u2.id MAIN b= µ M • [ t : TALK ] • monitor?t !||| [ u : users ] • ( [interested subjects(| {u} | ) \ t.subject 6= ? ] • 2 [ interested subjects(| {u} | ) \ t.subject = ? ] talkch!(u.id , t ) ! [ response : notify ] • talkch?(u.id , response ) ! Skip
• Skip ) ; M
The talk discovery system senses market updates , finding new talks information . Once a new talk is found , it sends a notification to all the users who may be interested .
A number of instances can be created also . National University Singapore : Place atalk : Talk atalk.place = National University Singapore
IV . EXTRACTING WEB ONTOLOGY FROM THE TCOZ
MODEL
It is important to have a thoroughly designed ontology since it will be shared by different agents and it forms the foundation of all agents’ services . However designing a clear and consistent ontology is not a trivial job . It is useful to have some tool support in designing the ontology . In this section , we will demonstrate the development of an XSL [ 26 ] program to automatically extract the ontology related domain properties from the static aspects of TCOZ formal models ( encoded in ZML format [ 24] ) . The ontology for the system can be resolved readily from the static parts of TCOZ design documents . In the next section , we will demonstrate tools to automatically extract the semantic markup for service from dynamic aspects of TCOZ formal models . ZML is an XML environment for Z family notations ( Z/Object Z/TCOZ ) . It encodes the Z family documents in XML format so that the formal model can be easily browsed by the Web browser ( eg Internet Explorer ) . The eXtensible Stylesheet Language ( XSL ) [ 26 ] is a stylesheet language to describe rules for matching and translating XML documents . In our case we translate the ZML to DAML+OIL and DAMLS . The main process and techniques for the translation are depicted by Figure 1 . A set of translation rules translating from TCOZ model ( in ZML ) to DAML+OIL ontology is developed in the following presentation .
[ T ] T 2 daml class
For example , the given type TIME can be translated into a class in DAML+OIL with time as ID . <daml:Class rdf:ID="time">
<rdfs:label>TIME</rdfs:label>
</daml:Class> B . Axiomatic ( Function and Relation ) definition translation The translation from functions and relations in TCOZ to
DAML+OIL ontology requires several cases . B , C 2 daml class
R : B $ ( ! , 7!)C
R 2 daml objectproperty[B $ ( ! , 7!)C ]
The relation R will be translated into a DAML+OIL property with B as the domain class and C as the range class . For total functions we restrict the daml : cardinality property to be one and for partial functions we restrict the daml : maxCardinality property to be one . In relation talk translated into DAML+OIL interested subjects as : <daml:ObjectProperty discovery can be example , our the rdf:ID="interested_subjects"> <rdfs:domain rdf:resource="#person"/> <rdfs:range rdf:resource="#subject"/>
1 ) Subset :
</daml:ObjectProperty> C . Z Axiomatic ( Subset and Constant ) definition translation to a situation , then M will be translated into a DAML+OIL class , to a DAML+OIL subclass of N . DAML+OIL property , then M will be translated into a DAML+OIL subproperty of N . The translation rules for the subset are : if N corresponds If N corresponds
In this
M : N
M 2 daml subclass[N ] M : N
N 2 daml class
N 2 daml objectproperty
M 2 daml subproperty[N ]
7
XML Schema
TCOZ XML Document
XT Parsed XML
DOM/SAX Parser XSLT Processor
Parsed XSL Commands
DAML extraction XSL Stylesheet
DAML S extraction XSL Stylesheet
Fig 1 . TCOZ DAML+OIL/DAML S projection
DAML+OIL Document
DAML S Document
2 ) Constant : In this situation , X will be translated into an instance of Y . The following is the translation rule :
Y 2 daml class x : Y
x 2 instantceof [ Y ]
For example , the National University Singapore and atalk defined in a previous section can be translated to <place rdf:ID=
"National_University_Singapore"/>
<talk rdf:ID="atalk">
<rdfs:label>atalk</rdfs:label> <talk_place rdf:resource=
"#National_University_Singapore"/> </talk>
D . Z state schema translation A Z state schema can be translated into a DAML+OIL class . Its attributes are translated into DAML+OIL properties with the schema name as domain DAML+OIL class and the Z type declaration as range DAML+OIL class . In order to resolve the name conflict between same attribute names used in different schemas , we use the schema name appended with attribute name as the ID for the DAML+OIL property .
S x : T1 ; y : T2
T1 , T2 2 daml class
S 2 daml class , S x 2 daml objectproperty[S ! T1 ] , S y 2 daml objectproperty[S $ T2 ]
For example the Talk schema defined in a previous section can be translated to DAML+OIL as : <daml:Class rdf:ID="talk">
<rdfs:label>Talk</rdfs:label>
</daml:Class>
<daml:ObjectProperty rdf:ID="talk_place"> <rdf:type rdf:resource=" http://wwwdamlorg/2001/03/ daml+oil#UniqueProperty"/>
<rdf:domain rdf:resource="#talk"/> <rdf:range rdf:resource="#place"/>
</daml:ObjectProperty> <daml:ObjectProperty
rdf:ID="talk_subject"> <rdf:domain rdf:resource="#talk"/> <rdf:range rdf:resource="#subject"/>
</daml:ObjectProperty>
E . Class translation An Object Z class can be translated into a DAML+OIL class . Its attributes defined in state schema are translated into DAML+OIL properties with the class name as domain DAML+OIL class and the type declaration as range DAML+OIL class . Other translation details are similar to the Z state schema translation defined above .
T1 , T2 2 daml class
C x : T1 ; y : T2
C 2 daml class , C x 2 daml objectproperty[C ! T1 ] , C y 2 daml objectproperty[C $ T2 ]
For example the Person class defined in a previous section can be translated to DAML+OIL as : <daml:Class rdf:ID="person">
<rdfs:label>Person</rdfs:label>
</daml:Class> <daml:ObjectProperty rdf:ID="person_id">
<rdf:type rdf:resource=" http://wwwdamlorg/2001/03/ daml+oil#UniqueProperty"/>
<rdf:domain rdf:resource="#person"/> <rdf:range rdf:resource="#PID"/>
</daml:ObjectProperty> Other translation rules are omitted as the aim of this paper is to demonstrate the approach rather than providing the complete XSL program design . V . EXTRACTING DAML S ONTOLOGY FROM THE TCOZ
MODEL
In the previous two sections we demonstrated how TCOZ can be used to capture the requirement of Semantic Web applications and how to project TCOZ models to DAML+OIL ontology automatically . DAML+OIL ontology is used to define the common understanding for certain concepts . The dynamic aspects of Semantic Web services , which define what is the service done and how it behaves is also crucial . Recently , DAML S [ 4 ] emerges to define such information for SW services . Extracting the semantic markup information ( ie DAML S ) for a Semantic Web service from the formal requirement model is another important research work . In this section , we will demonstrate the development of another XSL program to automatically extract DAML S information from TCOZ formal models . The semantic markup for the system can be resolved from the TCOZ design documents also .
A . Translation rules
A set of translation rules translating from TCOZ model to DAML S semantic markup for Semantic Web services are developed in the following : 1 ) Basic rule 1 ( R1) : : Each operation in TCOZ is modelled as a process ( AtomicProcess or CompositeProcess ) in DAMLS . In TCOZ , operations are discrete processes which specify the computation behavior and interaction behaviors . From a dynamic view , the state of an object is subject to change from time to time according to its interaction behavior , which is defined by operation definitions . At the same time the service process allows one to effect some action or change in the world . The connection between operations in TCOZ and service process in Semantic Web services is obvious . In order to resolve the name conflict between the same operation names used in different classes we use the class name appended with operation name as the ID for the process .
2 ) Basic rule 2 ( R2) : :
C O pre(O ) ; post(O )
[ pre(O ) is a precondition of the operation O . post(O ) is a postcondition of the operation O . ]
C O 2 damls AtomicProcess C O pre(O ) 2 damls precondition C O post(O ) 2 damls effect
In the case that an operation invokes no other operations , the operation is translated as an AtomicProcess . A precondition
8 appearing in a TCOZ operation schema definition is modelled as precondition in the respective service process . A postcondition appearing in a TCOZ operation schema definition is modelled as effect in the respective service process .
3 ) Basic rule 3 ( R3) : :
C O i ? : T o! : T
C O i 2 damls input C O o 2 damls output
An input appearing in a TCOZ operation schema definition is modelled as input in the respective service process . An output appearing in a TCOZ operation schema definition is modelled as output in the respective service process .
4 ) Basic rule 4 ( R4) : :
C
Ob=
C O 2 damls CompositeProcess operation is translated as a composite process .
In the case that an operation calls other operations , the 5 ) Basic rule 5 ( R5) : :
C
Ob= Ch?i !
C O Ch 2 damls AtomicProcess C O Ch i 2 damls input C
Ob= Ch!o !
C O Ch 2 damls AtomicProcess C O Ch o 2 damls output
Communication in TCOZ is modelled as an atomic process with input or output . In DAML S , atomic processes , in addition to specifying the basic actions from which larger processes are composed , can also be thought of as the communication primitives of an ( abstract ) process specification . 6 ) Basic rule 6 ( R6) : : Each TCOZ process primitive will be translated into the proper DAML S composite process . For example , the following two rules show how the translation is done for the sequential and parallel processes in TCOZ . Other translation rules for process primitive are omitted due to the limited space .
C
Ob= P1 ; P2
C O 2 damls Sequence[P1 , P2 ]
[ P1 and P2 are process components ]
Process:AtomicProcess rdfs:subClassof
Process:effect rdfs:subPropertyOf
9
Rdfs:domain
Rdfs:domain
PIDManager_AddPID input effect
PIDManager_AddPID_EF
FECT
Rdfs:range ……
Process:input rdfs:subPropertyOf
PIDManager_AddPID_id
Rdfs:range
PID
Fig 2 . The DAML S process ontology for AddID service
Process:input
Process:AtomicProcess rdfs:range rdfs:domain
PIDManager_new
_add_id_in precondition
Sequence process collection rdfs:subPropertyOf add_id input
PID
IDnotInIDS
… rdfs:subPropertyOf
Process:condition rdfs:subClassOf rdfs:subClassOf
PIDManager_AddPID
…
PIDManager_new rdfs:subClassOf
Process:CompositeProcess
Fig 3 . The DAML S process ontology for New service
[ P1 and P2 are process components ]
C
Ob= P1 k P2
C O 2 damls Split[P1 , P2 ]
7 ) Basic rule 7 ( R7) : :
C
Ob= [ G ]
C O G 2 damls precondition
The guards in TCOZ model are used to control the input of an operation . The guards are modelled as preconditions . Other translation rules are omitted as the aim of this paper is to demonstrate the approach rather than providing the complete XSL program design .
B . Case study
The PIDManager class defined for the Calendar agent will be used to demonstrate the translation . The PIDManager class has five operations , AddPID , RemovePID , New , Delete and Validate . Each of them will be translated into a process .
The operation AddPID is an operation invokes no other operations , so it will be translated as an AtomicProcess ( R2 ) . Some standard header information is generated first . <! Header Information > <?xml version=’1.0’ encoding=’ISO 8859 1’?> <rdf:RDF xmlns:rdf = "&rdf;#" > <daml:Ontology rdf:about="">
<daml:imports rdf:resource="&daml;"/> <daml:imports rdf:resource="&service;"/> <daml:imports rdf:resource="&process;"/>
</daml:Ontology> <! PIDmanager AddPId process > <daml:Class rdf:ID="PIDManager_AddPID"> <rdfs:subClassOf rdf:resource ="&process;#AtomicProcess"/>
<rdfs:subClassOf>
<daml:Restriction daml:cardinality="1">
<daml:onProperty rdf:resource="#AddPID_id"/>
</daml:Restriction>
</rdfs:subClassOf> </daml:Class>
It will be into type PID .
Figure 2 shows the semantic markup for service AddID in the graphical format . The DAML S code in RDF format can be found in Appendix . id ? declared The operation AddPID has one input to be translated input ( PIDManager AddPID id ) in DAML S ( R3 ) . The operation AddPID has one predicate ids0 = ids[{ id?} which is a postcondition . It will be translated into effect ( PIDManager AddPID EFFECT ) in DAML S ( R2 ) . The operation RemovePID can be translated similarly . The operation New calls the other operation AddPID , so it is translated as a composite process ( R4 ) . It performs two subprocesses PIDManager AddPID add id in and PIDManager AddPID in sequence . The PIDManager AddPID add id in process represents the communication on channel add ( R5 ) . The guard of the operation is translated as the precondition ( IDnotInIDS)(R7 ) . Figure 3 shows the semantic markup DAML S for the operation New . The operation Delete and Valide can be similarly translated .
VI . CONCLUSION
In this paper , we demonstrate that TCOZ can be used a high level design language for modeling the SW services ontology and functionalities . Another major contribution of this paper is that it develops systematic transformation rules and tools which can automatically project TCOZ models to DAML+OIL ontology and DAML S semantic markup . From a completely different direction , we also recently investigated how RDF and DAML+OIL can be used to build a Semantic Web environment for supporting , extending and integrating various formal specification languages [ 7 ] . One additional benefit is that RDF query techniques can facilitate formal specification comprehension . In summary , there is a clear synergy between Semantic Web and Formal Methods . The investigation between these two paradigms will lead great benefits for both areas . We hope this paper has showed one strong link between the two .
ACKNOWLEDGEMENTS
We would like to thank Hugh Anderson for many helpful comments . This work is supported by the Defence Innovative Research grant Formal Design Methods and DAML from Defence Science & Technology Agency ( DSTA ) Singapore .
REFERENCES
[ 1 ] T . Berners Lee , J . Hendler , and O . Lassila . The semantic web . Scientific American , May 2001 . [ 2 ] D . Brickley and R . G . ( editors ) . Resource description framework ( rdf ) schema specification 10 http://wwww3org/TR/2000/ CR rdf schema 20000327/ , March , 2000 . [ 3 ] J . Broekstra , M . Klein , S . Decker , D . Fensel , and I . Horrocks . Adding formal semantics to the web : building on top of rdf schema . In ECDL Workshop on the Semantic Web : Models , Architectures and Management , 2000 . [ 4 ] D . S . Coalition . Daml s – version 09 http://wwwdamlorg/ services/daml s/ , 2003 . [ 5 ] R . Cost , T . Finin , A . Joshi , and etc . Ittalks : A case study in the semantic web and daml . In proceedings of the International Semantic Web Working Symposium , July 2002 .
10
[ 6 ] J . S . Dong and B . Mahony . Active Objects in TCOZ .
[ 13 ] B . Mahony and J . S . Dong . Sensors and Actuators in TCOZ .
In J . Staples , M . Hinchey , and S . Liu , editors , the 2nd IEEE International Conference on Formal Engineering Methods ( ICFEM’98 ) , pages 16–25 . IEEE Press , Dec . 1998 . [ 7 ] J . S . Dong , J . Sun , and H . Wang . Semantic Web for Extending and Linking Formalisms . In L H Eriksson and P . A . Lindsay , editors , Proceedings of Formal Methods Europe : FME’02 , Copenhagen , Denmark , July 2002 . Springer Verlag . [ 8 ] R . Duke and G . Rose . Formal Object Oriented Specification Using Object Z . Cornerstones of Computing . Macmillan , March 2000 . [ 9 ] M . G . et . al . PDDL The Planning Domain Definition Language V . 2 . Technical Report TR 98 003/DCS TR 1165 , Yale Center for Computational Vision and Control , 1998 . [ 10 ] T . Finin , R . Fritzson , D . McKay , and R . McEntire . KQML as an Agent Communication Language . In N . Adam , B . Bhargava , and Y . Yesha , editors , Proceedings of the 3rd International Conference on Information and Knowledge Management ( CIKM’94 ) , pages 456–463 , Gaithersburg , MD , USA , 1994 . ACM Press . [ 11 ] O . Lassila and R . R . S . ( editors ) . Resource description framework ( rdf ) model and syntax specification . http://wwww3org/TR/1999/ REC rdf syntax 19990222/ , Feb , 1999 . [ 12 ] H . J . Levesque , R . Reiter , Y . Lesperance , F . Lin , and R . B . Scherl . GOLOG : A logic programming language for dynamic domains . Journal of Logic Programming , 31(1 3):59–83 , 1997 . In J . Wing , J . Woodcock , and J . Davies , editors , FM’99 : World Congress on Formal Methods , Lect . Notes in Comput . Sci . , pages 1166–1185 , Toulouse , France , Sept . 1999 . Springer Verlag . [ 14 ] B . Mahony and J . S . Dong . Timed Communicating Object Z . IEEE Transactions on Software Engineering , 26(2):150–177 , Feb . 2000 . [ 15 ] B . Mahony and J . S . Dong . Deep Semantic Links of TCSP and Object Z : TCOZ Approach . Formal Aspects of Computing , 13:142–160 , 2002 . [ 16 ] D . Martin , A . Cheyer , and D . Moran . The Open Agent Architecture : a framework for building distributed software systems . Applied Artificial Intelligence , 13(1/2):91–128 , 1999 . [ 17 ] J . Meseguer . Conditional rewriting logic as a unified model of concurrency . Theoretical Computer Science , 96(1):73–155 , 1992 . [ 18 ] R . Milner . Communicating with Mobile Agents : The pi Calculus . Cambridge University Press , 1999 . [ 19 ] S . Narayanan . Reasoning about actions in narrative understanding . In International Joint Conference on Artificial Intelligence ( IJCAI’1999 ) , pages 350–357 . Morgan Kaufmann Press , 1999 . [ 20 ] C . Schlenoff and etc . The Process Specification Language ( PSL ) : Overview and Version 1.0 Specification . Technical Report NISTIR 6459 , National Institute of Standards and Technology , Gaithersburg , MD , 2000 . [ 21 ] S . Schneider and J . Davies . A brief history of Timed CSP . Theoretical Computer Science , 138 , 1995 . [ 22 ] G . Smith . The Object Z Specification Language . Advances in Formal Methods . Kluwer Academic Publishers , 2000 . [ 23 ] J . Sun , J . S . Dong , J . Liu , and H . Wang . A XML/XSL Approach to Visualize and Animate TCOZ . In J . He , Y . Li , and G . Lowe , editors , The 8th Asia Pacific Software Engineering Conference ( APSEC’01 ) , pages 453–460 . IEEE Press , 2001 . [ 24 ] J . Sun , J . S . Dong , J . Liu , and H . Wang . Object Z Web Environment and Projections to UML . In WWW 10 : 10th International World Wide Web Conference , pages 725–734 . ACM Press , May 2001 . [ 25 ] F . van Harmelen , P . F . Patel Schneider , and I . H . ( editors ) . Reference description of the daml+oil ontology markup language . Contributors : T . Berners Lee , D . Brickley , D . Connolly , M . Dean , S . Decker , P . Hayes , J . Heflin , J . Hendler , O . Lassila , D . McGuinness , L . A . Stein , , March , 2001 . [ 26 ] W . W . W . C . ( W3C ) . Extensible stylesheet language ( xsl ) . http : //wwww3org/Style/XSL [ 27 ] P . Zave and M . Jackson . Four dark corners of requirements engineering . ACM Trans . Software Engineering and Methodology , 6(1):1–30 , Jan . 1997 .
APPENDIX
The PIDManager class defined for the Calendar agent will be used to demonstrate the translation from TCOZ model to DAMLS document . The PIDManager class has five operations , AddPID , RemovePID , New , Delete and Validate . Each of them will be translated into a process .
The operation AddPID is an operation invokes no other operations , so it will be translated as an AtomicProcess ( R2 ) . Some standard header information is generated firstly . <! Header Information > <?xml version=’1.0’ encoding=’ISO 8859 1’?> <! PIDmanager AddPId process > <daml:Class rdf:ID="PIDManager_AddPID"> <rdfs:subClassOf rdf:resource <rdfs:subClassOf>
="&process;#AtomicProcess"/> <daml:Restriction daml:cardinality="1">
<daml:onProperty </daml:Restriction> rdf:resource="#AddPID_id"/>
</rdfs:subClassOf> </daml:Class> The operation AddPID has one input id ? declared to be type PID .
It will be translated into input in DAML S ( R4 ) . <! input > <rdf:Property rdf:ID="PIDManager_AddPID_id"> <rdfs:subPropertyOf <rdfs:domain <rdfs:range rdf:resource="#PID"/> rdf:resource="&process;#input"/> rdf:resource="#PIDManager_AddPID"/>
</rdf:Property> The operation AddPID has one predicate ids0 = ids[{id?} which involve post states . It will be translated into effect ( PIDManager AddPID EFFECT ) in DAML S ( R2 ) . <! UnConditionalEffect parameter > <daml:Property <rdfs:subPropertyOf <rdfs:domain <rdfs:range> <daml:Class> rdf:ID="PIDManager_AddPID_EFFECT"> rdf:resource="&process;#effect"/> rdf:resource="#PIDManager_AddPID"/>
<rdfs:subClassOf rdf:resource ="&process;#UnConditionalEffect"/> <rdfs:subClassOf> <daml:Restriction> <daml:onProperty <daml:toClass rdf:resource="&process;#ceEffect"/> rdf:resource=
"#PIDManager_AddPIDEffect"/>
</daml:Restriction> </rdfs:subClassOf> </daml:Class></rdfs:range>
</daml:Property> <daml:Class rdf:ID="#PIDManager_AddPIDEffect"> <rdfs:subClassOf rdf:resource="&daml;#Thing"/> </daml:Class> The operation RemovePID can be translated similarly . The operation New calls other operation AddPID , so it was translated as a composite process ( R4 ) . It perform two subprocess PIDManager AddPID add id in and PIDManager AddPID in sequence . The PIDManager AddPID add id in process represents the communication on channel add ( R5 ) . The guard of the operation was translated as the precondition ( IDnotInIDS)(R7 ) .
11 atomic process R5 >
< "New" process > < Communication translated as <daml:Class rdf:ID="PIDManager_New_add_id_in"> <rdfs:subClassOf rdf:resource= "&process;#AtomicProcess"/> <rdfs:subClassOf> <daml:Restriction daml:cardinality="1"> <daml:onProperty rdf:resource=
"#PIDManager_New_add_id"/>
</daml:Restriction>
</rdfs:subClassOf> <rdfs:subClassOf>
<daml:Restriction>
<daml:onProperty rdf:resource= "&process;#precondition"/> <daml:toClass rdf:resource ="#IDnotInIDS"/> </daml:Restriction>
</rdfs:subClassOf> as input for process !>
</daml:Class> < input from channel translated <rdf:Property rdf:ID="PIDManager_New_add_id"> <rdfs:subPropertyOf rdf:resource="&process;#input"/> <rdfs:domain rdf:resource= "#PIDManager_New_add_id_in"/> <rdfs:range rdf:resource="#PID"/> </rdf:Property> < Guard !> <daml:Class rdf:ID="IDnotInIDS"> <rdfs:subClassOf <rdfs:subClassOf> <daml:Restriction> <daml:onProperty <daml:hasValue rdf:resource="&process;#Condition"/> rdf:resource="&process;#Value"/> rdf:resource="&process;#True"/>
</daml:Restriction>
</rdfs:subClassOf> </daml:Class> < "New" translated as compositeprocess !> <daml:Class rdf:ID="PIDManager_New"> <rdfs:subClassOf <rdfs:subClassOf> rdf:resource="&process;#CompositeProcess"/> <daml:Restriction> <daml:onProperty rdf:resource= "&process;#composedOf"/> <daml:toClass> <daml:Class> <daml:intersectionOf rdf:parseType="daml:collection"> <daml:Class rdf:about ="&process;#Sequence"/> <daml:Restriction> <daml:onProperty rdf:resource= "&process;#components"/> <daml:toClass><daml:Class> <process:listOfInstancesOf rdf:parseType="daml:collection"> <daml:Class rdf:about=
12
"#PIDManager_New_add_id_in"/> <daml:Class rdf:about="#PIDManager_AddPID"/> </process:listOfInstancesOf> </daml:Class></daml:toClass>
</daml:Restriction> </daml:intersectionOf>
</daml:Class> </rdfs:subClassOf>
</daml:toClass></daml:Restriction>
<! some atomic derived IOEP was omitted here > </daml:Class>
The operation Delete and Valide can be similarly translated .
