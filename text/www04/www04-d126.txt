Composite Events for XML
Martin Bernauer Institute for Software
Technology and Interactive Systems , Vienna University of Technology , Austria
Gerti Kappel
Institute for Software
Technology and Interactive Systems , Vienna University of Technology , Austria
Gerhard Kramler Institute for Software
Technology and Interactive Systems , Vienna University of Technology , Austria bernauer@bigtuwienacat gerti@bigtuwienacat kramler@bigtuwienacat
ABSTRACT Recently , active behavior has received attention in the XML field to automatically react to occurred events . Aside from proprietary approaches for enriching XML with active behavior , the W3C standardized the Document Object Model ( DOM ) Event Module for the detection of events in XML documents . When using any of these approaches , however , it is often impossible to decide which event to react upon because not a single event but a combination of multiple events , ie , a composite event determines a situation to react upon . The paper presents the first approach for detecting composite events in XML documents by addressing the peculiarities of XML events which are caused by their hierarchical order in addition to their temporal order . It also provides for the detection of satisfied multiplicity constraints defined by XML schemas . Thereby the approach enables applications operating on XML documents to react to composite events which have richer semantics .
Categories and Subject Descriptors E.1 [ Data ] : Data Structures ; H23 [ Database Management ] : Languages ; H24 [ Database Management ] : Systems—Rulebased databases
General Terms Languages
Keywords XML , Composite Event , Event Algebra , Active Behavior , EventCondition Action Rule
1 .
INTRODUCTION
Recently , active behavior has received attention in the XML field after being widely used in other fields such as database systems [ 15 ] and workflow management [ 14 ] . Various proprietary approaches for active XML [ 2 , 3 , 4 , 5 , 6 , 16 ] show how event condition action ( ECA ) rules can be used to automatically react to an occurred event by executing an action if a condition applies . Events that can be reacted on are modifications of XML data , such as the insertion of an element with a certain name , and invocations of operations against XML data in [ 16 ] .
In parallel to these efforts , the W3C standardized the Document Object Model ( DOM ) Event Module [ 20 ] . It provides for detection of events in DOM documents so that application programs can react accordingly . Defined events comprise among others mutation Copyright is held by the author/owner(s ) . WWW2004 , May 17–22 , 2004 , New York , New York , USA . ACM 1 58113 844 X/04/0005 . events , which are events that represent modifications of XML data . The Event Module may thus be used to provide the proprietary approaches mentioned before and custom applications with mutation events .
When using any of the approaches [ 2 , 3 , 4 , 5 , 6 , 20 ] it is sometimes impossible to decide upon which event to react . The reason is that often not a single event but a combination of multiple events determines a situation where some action has to be executed . A potential work around in such a situation is to use the event that always occurs at last of multiple events or to use another event that usually occurs after multiple events . Using such a work around , however , makes rules dependent on applications which define the order of event occurrences .
Obviously , a technique is needed to detect occurrences of combinations of multiple events , ie , to detect so called composite events . This has long been studied in the active database literature where event algebras have been proposed for the description of composite events ( eg , cf . [ 8 , 11 , 13 , 22 , 23 ] ) and several techniques for realizing detection of composite events have been proposed , namely event graphs [ 7 ] , state automata [ 13 ] , and petri nets [ 12 ] .
Events in XML , however , differ from the concept of events in literature as follows :
( 1 ) XML events are not only ordered by time but also by hierarchical structure . It is mostly undesired to use hierarchically unrelated events to form composite events as previous approaches do .
( 2 ) An XML schema may constrain the number of element and attribute occurrences in documents . Existing approaches do not support the detection of when such constraints are satisfied .
( 3 ) Event types , which are descriptions of events at the schema level , are hierarchically related as their events are . This allows for more expressive and more reusable event type definitions than in previous approaches .
Due to the above peculiarities of XML events , existing approaches for detecting composite events , such as [ 8 , 11 , 13 , 22 , 23 ] , cannot be reasonably employed for XML events because one encounters the following problems : ( i ) depending on the order of multiple modifications that all result in the same XML data different composite events are detected , ( ii ) most of the detected composite events are meaningless since they are not hierarchically related , they have to be filtered out by application code , ( iii ) it cannot be detected when multiplicity constraints defined by an XML schema are satisfied , and ( iv ) event types are unrelated and their extents are disjunct , limiting expressiveness and reusability of composite event type definitions . For a motivating example that shows problems i and ii when using a refined existing approach see Section 23
The contribution of the paper is to present an approach to detect composite events in XML that takes the above peculiarities of XML events into account . It refines an event algebra known from literature by defining the employed abstract model for XML data , XML events , and XML event types . Thereby it provides for more expressive and reusable event type definitions ( addressing peculiarity 3 ) . Moreover , it extends the semantics of the refined event algebra by introducing the hierarchical context to combine events according to hierarchy ( addressing peculiarity 1 ) , by introducing the multiplicity operator to detect when multiplicity constraints are satisfied ( addressing peculiarity 2 ) , and by introducing operator modifiers to provide for more expressive event type definitions .
In particular , the presented approach refines and extends the event algebra Snoop [ 7 , 8 ] , because it is both extensible and well suited for XML . Snoop is extensible because it uses contexts to define the semantics of an event expression , thus by defining a new context semantics can be extended . Snoop is well suited for XML because event trees are used to realize event expressions and demonstrate event detection . Event trees fit well for processing XML events because they are hierarchically ordered as well . Moreover , Snoop is used in the Sentinel active DBMS , is prominent among [ 11 , 13 , 22 , 23 ] according to CiteSeer1 , and is still subject to active research [ 1 ] .
The paper is structured as follows . The refinement of the event algebra and a motivating example is shown in Section 2 , the algebra ’s extension in Section 3 . Section 4 briefly discusses the implementation of a proof of concept prototype , and finally Section 5 concludes the paper .
2 . REFINED EVENT ALGEBRA
This section shows how the event algebra Snoop is refined so that it can be used with XML events . First it presents the employed abstract model for XML data , a syntax for referrers to portions of XML data at the schema and instance level , and operators on referrers in Section 21 Second , an abstract model for events and event types is introduced in Section 22 Finally , Section 2.3 briefly introduces Snoop and shows an example that uses the refined event algebra with contexts from Snoop . 2.1 Path Types and Path Instances
An XML document is represented by a tree of nodes where an XML document ’s elements , attributes and text is represented by the tree using element , attribute , and text nodes respectively . As such it is a subset of the XML Infoset [ 18 ] . Each node has an identifier . A path type identifies a node of a tree by using type information , ie , independently of concrete documents . A path type accords to a restricted XPath expression [ 17 ] that refers to either element , attribute , or text nodes in each of its steps via respective axis and node tests . A path type is absolute or relative with respect to the root of the tree , eg , /order/item/price denotes an absolute path type while item/price denotes a relative path type to element price . Path type pt is a tuple comprising a kind ∈ {absolute , relative} and an ordered set of steps , thus pt = kind , steps or pt = null . Two single steps are equal if they equal in their respective axis ( child or attribute ) and node test ( test for an XML QName or text() ) .
A path instance identifies a node of a tree representing a concrete document . For node price1 its path instance comprises an ordered set of identifiers that starts with the identifier of the tree ’s root node and ends with price1 ’s identifier and is thus always absolute . A path
1http://citeseernjneccom instance is denoted similar to a path type by using “ / ” to separate nodes , eg , /order1/item1/price1 denotes a path instance to node price1 . Path instance pi is a tuple comprising its absolute path type and an ordered set of node identifiers , thus pi = pt , ids or pi = null . To compare and operate on path types , operators for testing for equality ( = ) , containment ( ⊂ ) , ending ( ⊂e ) , and intersection ( ∩lb , ∩ab ) are defined . The operators complement the ones defined by XPath which operate on path instances only , such as = [ 17 ] and intersection [ 21 ] . The result of applying operators on path types are defined as follows ( where m = |pt1.steps| and n = |pt2.steps| ) : • pt1 = pt2
Path type pt1 equals pt2 iff pt1.kind = pt2.kind ∧ m = n ∧ ∀1 ≤ i ≤ m : pt1.steps[i ] = pt2steps[i ] Example 1 . item/price = item/price , /order = /order , order = /order .
• pt1 ⊂ pt2
Path type pt2 uniquely contains path type pt1 iff ∀1 ≤ i ≤ m : pt1.steps[i ] = pt2.steps[c + i ] where c is a constant offset and m + c ≤ n . No c = c may exist for which the expression above applies as well . Additionally , if pt1 and pt2 are both absolute c = 0 ∧ m < n must apply , if both are relative only m < n must apply . A relative path type cannot contain an absolute one . Example 2 . item/price ⊂ /order/item/price , order/item ⊂ /order/item/price , /order ⊂ order/item .
• pt1 ⊂e pt2
Relative path type pt1 ends path type pt2 if the end of pt2.steps contains pt1.steps and pt2 is more special than pt1 , ie , pt1 ⊂e pt2 iff pt1.kind = relative ∧ ( m < n ∨ ( pt2.kind = absolute ∧ m = n ) ) ∧ ∀1 ≤ i ≤ m : pt1.steps[i ] = pt2.steps[n − m + i ] . Example 3 . item/price ⊂e /order/item/price , price ⊂e item/price , order/item ⊂e /order/item/price .
• r := pt1 ∩lb pt2
The left bound intersection operator is commutative and determines for path types pt1 and pt2 equal steps at the beginning of pt1.steps and pt2steps If pt1.kind = pt2.kind , r.kind := pt1.kind , otherwise it is absolute . Resulting r.steps := {pt1steps[i]|pt1steps[i ] = pt2.steps[i]} where 1 ≤ i ≤ j where j is either the largest index for which pt1.steps[j ] = pt2.steps[j ] applies or the minimum out of m and n . The result is null if pt1 = null ∨ pt2 = null ∨ pt1.steps[1 ] = pt2steps[1 ] Example 4 . order/item ∩lb /order/billTo = /order , item/@partnum ∩lb item = item , order ∩lb item = null .
• r := pt1 ∩ab pt2
The absolute path intersection is not commutative and makes path type pt1 absolute according to absolute path type pt2 . If pt1 ⊂ pt2 ∨ pt1 = pt2 , r is defined by r.kind := absolute and r.steps := {pt2.steps[i]|1 ≤ i ≤ j} where j is the last index where pt2 contains pt1 . The result is null if pt1 = null ∨ pt2 = null ∨ ( pt1 ⊂ pt2 ∧ pt1 = pt2 ) .
Example 5 . item ∩ab /order/item/price = /order/item , item ∩ab /order = null .
To compare and operate on path instances , operators for testing for equality ( = ) and projection ( π ) are defined . The result of applying operators on path instances are defined as follows :
• pi1 = pi2
Two path instances pi1 and pi2 equal iff pi1.pt = pi2.pt ∧ ∀1 ≤ i ≤ |pi1.ids| : pi1.ids[i ] = pi2ids[i ] Example 6 . /order1/item1 = /order1/item1 .
• r := πpt(pi )
A projection of path instance pi on path type pt is a path instance if pt ⊂ pi.pt ∨ pt = pipt Then r.pt := pt and r.ids := {pi.ids[i]|j ≤ i ≤ k} where j and k are the indexes between which piptsteps contains ptsteps The result is null if pi = null ∨ pt = null ∨ ( pt ⊂ pi.pt ∧ pt = pipt ) Example 7 . πitem(/order1/item1/price1 ) = item1 ,
π/order(/order1/item1 ) = /order1 , πitem(/order1 ) = null .
2.2 Event Types and Events
The DOM Event Module defines among others event types for mutation events , which reflect modifications of DOM documents’ data . They basically comprise one event type for the insertion of nodes , one for the deletion of nodes , one for manipulation of attributes , and one for manipulations of text nodes .
While the DOM event types are sufficient for a procedural handling of occurred events , they are too coarse grained for a declarative handling by an event algebra . Hence , for every path type pt the presented approach distinguishes three primitive event types , denoted as ins(pt ) , upd(pt ) , and del(pt ) . Like in the DOM Event Module , ins and del events reflect insertions and deletions of element , attribute , and text nodes , while upd events reflect modifications of text nodes and attribute nodes . Moreover , instead of an operation wildcard “ ∗ ” can be used . The path type defines where events of that type occur . It can be relative or absolute . Primitive event type et is a tuple comprising an operation , which is one of {ins , upd , del,∗} , and a path type , thus et = op , pt .
A primitive event occurs whenever a node is manipulated . Primitive event e is represented by a tuple comprising its identifier id , timestamp ts , event type et , and path instance pi which identifies the manipulated node , thus e = id , ts , et , pi . The event type ’s operation does not equal wildcard “ ∗ ” , its path type is absolute , and the path instance ’s path type pi.pt equals etpt
A composite event type , ie , the event type of a composite event , is a tuple that comprises a unique name and a path type , thus et = name , pt . Wildcard “ ∗ ” can be used instead of a name , referring to any composite event type having the path type . A composite event type is denoted as name(pt ) analogously to a primitive one . The path type of a composite event type defines , like the path type of a primitive event type , where events of that type occur . It can be relative or absolute .
A composite event is formed by combining primitive and other composite events , which are referred to as constituent events . Composite event ec is represented by a tuple comprising its identifier id , composite event type et , path instance pi , which identifies where the event occurred , and a set of constituent events cevts , thus ec = id , et , pi , cevts . The composite event type ’s name does not equal wildcard “ ∗ ” , its path type is absolute , and the path instance ’s path type ecpipt equals ecetpt
The clock for measuring the timestamps of primitive events is a logical one , ie , a counter . Primitive events occur at distinct points in time and for simplicity it is assumed that the detection of composite events takes no time . Therefore one primitive and multiple composite events may be detected at a single point in time .
Primitive as well as composite event types are hierarchically related via their path type and lead to more expressive composite event type definitions than in Snoop . Most important this allows to constrain the combination of event types by an operator to related event types . For the constraints on operator nodes see Section 31 An event can be an instance of more than one event type , providing for more reusable composite event type definitions than in Snoop . Event e is a direct instance of its type e.et and an indirect instance of event types eti = e.et to which the event ’s type is compatible to , denoted by e.et ( cid:186 ) eti ( not commutative ) . Primitive event type et1 is compatible to primitive event type et2 , ie , et1 ( cid:186 ) et2 iff ( (et1.op = et2.op ) ∨ ( et2.op = “ ∗ ” ) ) ∧ ( (et2.pt ⊂e et1.pt ) ∨ ( et2.pt = et1pt ) ) Analogously , for two compos2.name ) ∨ ite event types etc ( etc 1pt ) ) For more details on reuse see Section 3.1 , especially Examples 13 and 14 .
1 ( cid:186 ) etc 2.name = “ ∗ ” ) ) ∧ ( (etc
1.name = etc 1.pt ) ∨ ( etc
2 iff ( (etc 2.pt ⊂e etc
2.pt = etc
Example 8 . Primitive event ep1 reflecting an insertion in path type ep1 etpt = /order/item/price is an instance of event types such as E1 = ins(/order/item/price ) and E2 = ∗(price ) since ep1 .et ( cid:186 ) E1 and ep1 .et ( cid:186 ) E2 . Analogously , composite event ec h1 with path type ec h1 etpt = /order/item and name Nm is an instance of composite event types such as Ec 1 = Nm(/order/item ) h1 .et ( cid:186 ) Ec and Ec 1 and ec 2 .
2 = ∗(item ) since ec h1 .et ( cid:186 ) Ec
Like in Snoop , composite event types are defined by event expressions according to an event algebra . An expression combines events by the algebra ’s operators . The presented approach uses operators , , and ; from Snoop to form conjunction , disjunction , and sequence of events . An expression is realized by an event tree , eg , Figure 1 depicts the event tree that realizes the expression described in Section 23 An event tree comprises event type nodes and operator nodes . An event type node is a tuple et , evts which stores a set of events evts . All events in evts are a direct or indirect instance of event type et . An operator node combines events from child nodes nds to events of composite event type et according to operator opr and stores them in a set of composite events evts , and is thus a tuple opr , nds , et , evts . Leaf nodes in an event tree are event type nodes while inner nodes are operator nodes .
In the presented approach the event type of an event tree node can be compared to the static type of a variable in strongly typed objectoriented programming languages ( eg , Java ) , while the event type of an event can be compared to the dynamic type of an expression , eg , an object . An occurred event is stored in all leaf nodes that have a compatible event type . By using the ending operator in the definition of type compatibility a leaf node only stores events that occur directly in the node ’s path type and not in descendants .
Example 9 . Continuing Example 8 , when primitive event ep1 with ( dynamic ) event type ep1 .et occurs , it is stored in event type nodes that have compatible ( static ) event types such as E1 and E2 . Analogously , when composite event ec h1 is raised , it is stored in event type nodes that have event types such as Ec
1 and Ec 2 .
2.3 Example
This section exemplifies the need for composite events in XML and demonstrates the application of the refined event algebra . Consider an XML document that represents a purchase order ( document element order ) comprising items to be ordered ( element t1 t2 t3 t4 t5 t6
Table 1 : Raised composite events when using contexts from Snoop
Cumulative Context ei2 ep2 eq1 ,{ei1 ei2 ep1 eq1}c eq2 ,{ei1 ei2 ep1 eq2}c ep2 eq1 ,{ei1 ei2 ep1 ep2 eq1}c ep2 ep2
Chronicle Context ei2 ep2 eq1 ,{ei1 ep1 eq1}c eq2 ,{ei1 ep1 eq2}c ep2 eq1 ,{ei1 ep1 eq1}c ep2 ep2
Recent Context
S1 S2 S3 S4
S1 S2 S3 S4
S1 S2 S3 S4 ei1 ei1 ei1 ei1 ei1 ei1 ei1 ei1 ei1 ei1 ei1 ei1 ep1 ei2 ei2 ei2 ep1 ei2 ei2 ei2 ep1 ei2 ei2 ei2 eq1 ,{ei1 ep1 eq1}c ep1 ep1 ep1 eq1 ,{ei1 ep1 eq1}c ep1 ep1 ep1 eq1 ,{ei1 ep1 eq1}c ep1 ep1 ep1 eq2 eq2 ,{ei2 ep2 eq2}c eq2 , ( {ep2 eq2}c ) eq1 , ( {ep2 eq1}c ) eq2 ,{ei2 ep2 eq2}c eq2 ,{ei2 ep2 eq2}c eq2 ,{ei2 ep2 eq2}c eq1 ,{ei2 ep2 eq1}c eq2 ,{ei2 ep2 eq2}c eq2 ,{ei2 ep2 eq2}c eq2 ,{ei2 ep2 eq2}c eq1 ,{ei2 ep2 eq1}c eq2 , ( {ep2 eq2}c ) eq2 , ( {ep2 eq2}c ) eq1 , ( {ep2 eq1}c ) eq2 ei2 ep2 eq1 ,{ei2 ep1 eq1}c eq2 ,{ei2 ep1 eq2}c
Continuous Context ep2 ,{ei2 ep2 eq1}c eq1 ,{ei2 ep2 eq1}c ep2 ,{ei2 ep2 eq1}c ep2 ,{ei2 ep2 eq2}c ep2 ,{ei2 ep2 eq1}c ep2 , ( {ep2 eq1}c ) ep2 , ( {ep2 eq2}c ) eq1 ,†1 eq1 ,{ei1 ep1 eq1}c ei1 ei1 ei1 ei1
S1 S2 S3 S4 †1 : {ei1 ep1 eq1}c,{ei1 ep2 eq1}c,{ei2 ep1 eq1}c,{ei2 ep2 eq1}c †2 : {ei1 ep1 eq1}c,{ei2 ep1 eq1}c †3 : {ei1 ep1 eq2}c,{ei2 ep1 eq2}c ei2 ep2 eq1 ,†2 eq2 ,†3 ep1 ei2 ei2 ei2 ep1 ep1 ep1 item ) , each in turn described by a price ( element price ) and a quantity ( element quantity ) . When defining a rule that reacts on the insertion of an item and re calculates the overall order value by multiplying price by quantity of each item and summing it up , one encounters the problem to decide which event to react on . Upon the insertion of element item it does not comprise any of the necessary child elements , and upon the insertion of element price the quantity element may not be available and vice versa .
The problem can be overcome by using composite events . A composite event is raised according to its definition after certain events have occurred . In the example , a composite event should occur after the occurrence of events reflecting insertions of an item , a price , and a quantity element ( where the latter two are children of the first ) so that a rule can be defined on it . This can be achieved by event expression “ Ei ; ( Ep Eq ) ” , where Ei := ins(item ) , Ep := ins(item/price ) , and Eq := ins(item/quantity ) .
The event tree realizing the example ’s expression is depicted in Figure 1 . The event tree ’s behavior when using contexts from Snoop , ie , its processing of four sequences of primitive events S1S4 is shown in Table 1 . The sequences reflect the insertions of item ( abbreviated as in ) , price ( pn ) , and quantity ( qn ) elements . Numerical index n of an element represents its hierarchical position , meaning that elements with the same numerical index are hierarchically related , eg , p1 is a child of i1 . In case two numerical indices are separated by a dot , the first number represents the element ’s hierarchical position and the second one the time of its insertion , eg , the insertion of q1.1 occurs before the insertion of q12
Briefly and informally introducing the contexts from Snoop , a composite event is raised by a conjunction operator node as soon as a child node ’s set of stored events is modified , ie , an event is added ( the so called “ terminator ” ) and every child node contains at least one event . Note that only the conjunction operator is described here , however , sequence and disjoint operator are defined analogously . A raised composite event ’s constituent events are defined as follows :
• in cumulative context they comprise all events from every child node wherefrom they are removed .
• in chronicle context they comprise the oldest event from every child node wherefrom they are removed , ie , all constituent events are consumed in chronological order of occurrence .
• in recent context they comprise the most recent event from each child node . All events that cannot be the earliest constituent event of subsequently raised composite events ( ie , that cannot be an “ initiator ” ) are removed from child nodes . • in continuous context its constituent events comprise the terminator and the most recent event from every child node except the one of the terminator . Subsequently all constituent events are removed from child nodes except the terminator . The procedure is repeated until there are no events left to be combined with the terminator . Finally the terminator is removed if it cannot be an initiator of subsequently raised composite events .
The rationale of Table 1 is to introduce the unfamiliar reader to Snoop ’s contexts and to exemplify that incorrect composite events are raised when any of Snoop ’s contexts is used ( for which one falsifying event sequence would suffice ) . Incorrect events are raised because events are selected only by their occurrence time and not their hierarchical position . Where under a correct composite event it is referred to a composite event whose constituent events are hierarchically related . Composite events raised by the root of the tree are shown by their constituent events , eg , {ei1 ep1 eq1}c . Unconsumed composite events that remain in the tree after t6 are shown at the time they are raised , but in brackets , eg , ( {ep2 eq2}c ) . The table does not show the unrestricted context which basically forms the cartesian product of all events . Naturally , it raises even more incorrect composite events .
Summarized , the refined event algebra as presented in this section is still not applicable to detect composite events in XML when used with contexts from Snoop . The reason is that the requirements on applications using such an event algebra are inadequate , which would have to use the unrestricted context and filter out huge amounts of incorrect events or manipulate XML data in a defined temporal order so that some context only detects correct events . And still , the satisfaction of multiplicity constraints cannot be detected using the refined algebra .
3 . EXTENDED EVENT ALGEBRA
This section presents an extension to the refined event algebra . The extension comprises the hierarchical context presented in Section 3.1 , the multiplicity operator in Section 3.2 , and operator modifiers in Section 33 Event trees which are generated from event expressions are used for presentational purposes throughout the section . 3.1 Hierarchical Context
The hierarchical context is introduced since it is necessary to combine events according to their hierarchical position , which is not supported by existing contexts . It raises only correct composite events , ie , composite events whose constituent events are hierarchically related .
To combine events according to their hierarchical position an event tree maintains data concerning hierarchy . Therefore , as mentioned earlier , every node n in an event tree has an assigned path type netpt Naturally , an event type node specifies a path type , however , the path type of an operator node , if not specified by the event expression , has to be derived from its child nodes c1 , c2 , , cn by evaluating c1etpt ∩lb c2etpt ∩lb ∩lb cnetpt ( left bound intersection is used for simplicity ) . The derivation of path types for all operator nodes is done bottom up . For an event tree to be valid , every node n must have a non null path type whose steps are not empty and do not violate the constraints on child nodes ( cf . later in this section ) .
Example 10 .
Figure 1 shows an exemplary event tree on the := Ei ; ( Ep Eq ) for left defining composite event type Ec i the insertion of item elements and the derivation of path types for operator nodes on the right . The derivation is done bottom up , step 1 determines the path type of operator node by evaluating item/price ∩lb item/quantity = item . Subsequently , step 2 determines the path type of operator node ; by evaluating item ∩lb item = item .
Figure 1 : Derivation of operator nodes’ path types
An operator node raises a composite event by selecting events from its child nodes that satisfy certain conditions . Basically , ( a ) at least one child node of a disjunction operator node must hold an event , ( b ) all child nodes of a conjunction operator node must hold an event , and ( c ) all child nodes of a sequence operator node must hold an event and they must have occurred in the specified order . If operator node o combines multiple events from child nodes they must all have the same ancestor node , ie , ∀1 ≤ i ≤ m − 1 :
πoetpt(eipi ) = πoetpt(ei+1pi ) where m is the number of events in o ’s child nodes that are to be combined . Events for which the projection evaluates to null are not combined . Raised composite event ec ’s path instance , which must be absolute , is derived from constituent events by πoetpt∩abe1pipt(e1pi ) Event e1 is the first constituent event , however , any other constituent event ei could be used instead because if all constituent events ei equal in πoetpt(eipi ) they equal in πoetpt∩abeipipt(eipi ) as well .
Example 11 . How the event tree in Figure 1 forms composite events in hierarchical context is shown in Figure 2 . Its status after the occurrence of the event sequence ei1 , ei2 , ep1 , ep2 , eq1 is shown on the left . In path instances and event indices , o abbreviates order , i abbreviates item , p abbreviates price , q abbreviates quantity , and the numerical index indicates the hierarchical position , eg , p1 is a child of i1 . Events ep1 and eq1 are combined by operator to form composite event ec h1 , since πitem(ep1 .pi ) = πitem(eq1 .pi ) ( = i1 ) . With the creation of ec h1 the two primitive events are consumed ( step 1 ) . Subsequently , ei1 and ec h1 are combined by operator ; since πitem(ei1 .pi ) = πitem(ec h1 .pi ) ( = i1 ) ( step 2 ) . Upon the occurrence of eq2 later on the same combination process starts over again .
Figure 2 : Event selection and event consumption in hierarchical context
Constraints on operator node o ’s path type are enforced so that the projection of an event ’s path instance on o ’s path type is likely to return a non null value , ie , so that for child event ej expression πoetpt(ejpi ) = null applies . The constraints seek a compromise between the operator ’s expressiveness for the reuse of event trees ( cf . later in this section ) and restrictions on child nodes and do thus not guarantee a non null value . They are as follows ( where Ej refers to a child node ’s event type ) : ( a ) if both oetpt and Ej.pt are absolute , oetpt∩lb Ej.pt = null must apply , ( b ) if only Ej.pt is absolute , oetpt ⊂ Ej.pt must apply . If Ej.pt is relative no constraints must apply so that it may contain only a single step that is not contained in oetpt In such cases one must rely that an event ’s ( dynamic ) event type is compatible to the operator ’s ( static ) event type so that the event ’s path instance can be projected on the operator ’s path type . This can be compared to a type cast in strongly typed object oriented programming languages where an object ’s dynamic type must be compatible to the static casted type which can only be determined at runtime . For examples see Example 13 and 14 .
Operators combine events with interval based semantics not detection based semantics , since composite events detected with the latter are not always exactly as , presumably , intended ( cf . [ 1 , 10] ) . Basically , this means that operators do not combine events according to their detection time but take the intervals during which the events occurred into account . A primitive event detected at td occurs in interval [ td , td ] , and a composite event starts at the beginning of the smallest interval and ends at the end of the latest one . Comparing intervals , [ t b . Interval b ] iff t a < t a , t a ] < [ t b , t ins(item)ins(item/price);ins(item/quantity)itemitem/price;item/quantityitemitem(1)(2)EpEiEqEicevent type nodeoperator nodee =ins(/o1/i1/p1)e =ins(/o1/i2/p2);e =ins(/o1/i1)e =ins(/o1/i2)e =ins(/o1/i1/q1)e =e;ee =(1)(2)h1h1eh1i1i1i2e =ins(/o1/i1)e =ins(/o1/i2)i1i2p1p2p1q1eq1ep1eq1e i1e i1;(ep1eq1)cccce =ins(/o1/i2/p2)p2 based semantics only affect the sequence operator , so that expression Ei;Ej combines two hierarchically matching events ei and ej only if the occurrence interval of the former is smaller than the other .
The hierarchical context is orthogonal to existing contexts from Snoop , because selection by XML hierarchy is orthogonal to selection by time . Thus it can be combined with any existing context , acting like a filter . For operator node o , first the hierarchical context groups all events from child nodes according to o ’s path type , and second o selects and consumes events within each group according to its context from Snoop . Example 12 . To detect when both price and quantity information of an order item are modified , event expression ∗(item/quantity ) upd(item/price ) can be used . Table 2 shows raised composite events , represented by their constituent events for the above expression in the hierarchical variants of Snoop ’s contexts . Events that remain in the event graph after t5 are shown in the rightmost column for completeness .
A composite event type definition can reuse other , existing event type definitions , ie , and event tree can reuse other event trees . All event trees together form the event graph . A composite event ec i of type Ec i raised by an event tree is reused in another tree by an i .et ( cid:186 ) Ec event type node with a compatible event type , ie , if ec j , presuming that Ec j name It may be the case that the node ’s parent operator node o ’s path type oetpt cannot be derived from its child nodes , because the left bound intersection of Ec j .pt with the path types of o ’s other child nodes is null , eg , if their path types are of different kind or Ec j .pt contains only a single step . In either case o ’s path type must be specified explicitly . i .name = Ec b and Ec s Ec
Example 13 . The order element has aside from item elements a billTo and a shipTo child element . When two composite event types Ec s for complete insertions of the latter two elements are defined in addition to Ec i ( from Example 10 ) , a fourth composite event type can use the three to define a composite event that occurs after both addresses and at least one item have been inserted by i Ec b.pt = item ∩lb Ec shipTo∩lb billTo = null , the conjunction operator ’s path type must be specified explicitly , eg , as order . Because the ( dynamic ) event types of occurred events have absolute path types , the projection of their path instances on order is not null . b . Since , eg , Ec i .pt ∩lb Ec s.pt ∩lb Ec
Reuse of event type definitions is facilitated by using type compatibility instead of type equality for storing occurred events in event type nodes , as mentioned before and in Section 22 The reason is that the more leaf nodes with “ general ” event types an event tree has ( ie , nodes with event types that have relative path types and/or wildcard “ ∗ ” as operator or name ) , the more events will be stored in it because an event ’s “ special ” event type ( ie , one with absolute path type and given operation ) may be compatible to a general one but not to another special one . The more events are stored , the more composite events are raised , and the more the tree , ie , the event definition is reusable .
Example 14 . The order ’s shipTo and billTo elements both have an address child element that comprises other elements such as street and city . By defining composite event type Ec a for the insertions of address elements and using only relative path types that start with address , the according event tree in Figure 3 raises composite events for complete insertions of address elements as childs of both shipTo and billTo . Thus Ec b and Ec a can be reused by both Ec s from Example 13 .
3.2 Multiplicity Operator
Because an XML schema can define multiplicity constraints on XML elements and attributes it is desirable to be able to detect
Figure 3 : Reuse of event trees when multiplicity constraints are satisfied by observing occurred events . A multiplicity constraint is defined by lower bound l and upper bound u ( l ≤ u ) , meaning that between l and u child elements or attributes with the same name may occur as child of a parent element . After l events reflecting insertions the multiplicity constraint is satisfied ( if the parent element did not contain any such child elements before ) . The operator from Snoop that closest resembles the required functionality is the ANY operator . It detects a fixed number > 0 of events of distinct event types , however , in XML the required number is ≥ 0 , since 0 events reflect optional elements , and the events are of the same event type . To detect when multiplicity constraints are satisfied unary multiplicity operator “ × ” is introduced , denoted as ×[l , u]Ei . It raises a composite event as soon as l events of Ei occurred , thereby indicating the constraint ’s satisfaction . The consumption of the composite event , however , may take place after other events of Ei occurred . To provide composite events with most extensive sets of constituent events , the multiplicity operator has integrative semantics .
Event integration starts after composite event ec
1 is raised upon the occurrence of the lth event of Ei . A subsequently occurring event gives rise to the new composite event ec 2 which integrates ec 1 ’s constituent events . Event ec 1 is waived because it has been integrated and is thus assumed not to be of interest any longer . If u is reached or the integrating composite event is consumed , integration is suspended and starts over after the lth occurrence of Ei .
When employed in a hierarchical context , the multiplicity operator shows the above behavior for every distinct path instance of its path type . If not specified explicitly , a multiplicity operator ’s path type is set to the child node ’s path type omitting the last step . The same constraints on a multiplicity operator ’s path type must apply as on other operator ’s path types ( cf . Section 31 ) Multiplicity operator o raises a composite event ec 1 as soon as there exist l child events that equal in πoetpt(eij .pi ) for 1 ≤ j ≤ l . Thereafter it raises new composite event ec 2 upon the occurrence of child event eik where πoetpt(eik .pi ) = πoetpt(ec 1 has not been consumed yet , where ec 1.cevts and eik .
2.cevts is defined by the union of ec
1.pi ) if ec
Example 15 . The event tree depicted in Figure 4 allows multiple insertions of quantity elements as childs of element item . For two insertions of quantity elements eq1.1 and eq1.2 the multiplicity operator first raises composite event ec q1 upon the occurrence of eq11 If ec q1 has not been consumed upon the occurrence of eq1.2 new q2 .cevts = {eq1.1 , eq1.2} , composite event ec and ec q1 has been consumed new composite ec q2 .cevts = {eq12} q2 is raised as well , however , with ec q1 is waived . Otherwise , ie , if ec q2 is raised , where ec
A multiplicity operator in hierarchical context with a lower bound of zero raises a composite event without the occurrence of a child event . Instead , composite event ec 1 is raised with the event representing the creation of ( absolute ) path instance pi that satis
;Ea(address)cins(address)ins(address/street)ins(address/city);Es(shipTo)cins(shipTo);Eb(billTo)cins(billTo)Ea(shipTo/address)cEa(billTo/address)ceventsevents Table 2 : Combination of the hierarchical context with contexts from Snoop t1 t2 t3 t4 t5 unconsumed events
S5 eq1.1 eq2 eq1.2
S5 eq1.1 eq2 eq1.2
S5 eq1.1 eq2 eq1.2
S5 eq1.1 eq2 eq1.2 ep2 ,{ep2 eq2}c ep2 ,{ep2 eq2}c ep2 ,{ep2 eq2}c ep2 ,{ep2 eq2}c
Hierarchical Cumulative Context ep1 ,{ep1 eq1.1 eq1.2}c
Hierarchical Chronicle Context
Hierarchical Recent Context ep1 ,{ep1 eq1.1}c ep1 ,{ep1 eq1.2}c
Hierarchical Continuous Context ep1 ,{ep1 eq1.1}c,{ep1 eq1.2}c
– eq1.2 ep1 , eq1.2 , ep2 , eq2 ep1 , ep2 p . If it is non local , ec is raised relative to the detection of a potential event . If the termination mode is earliest , composite event ec i is raised with the detection of potential composite event ec i is raised after the detection of ec p and the first occurrence of event ej , p.pi ) = πoetpt(ejpi ) This means that operator where πoetpt(ec node o waits until an event occurs that reflects a manipulation in another subtree of the document , ie , it assumes that the manipulation of a document is done hierarchically . If the termination mode is custom , composite events are raised upon flushing or closing the event tree ( cf . later in this section ) .
Example 17 . For the event tree depicted in Figure 4 and four exemplary event sequences S6S9 Table 3 shows when composite events are raised depending on the termination mode of ( i ) the conjunction operator node and ( ii ) the multiplicity operator node of the quantity element . The other two operator nodes have termination mode earliest . To clearly point out the consequences of termination modes the table shows composite events raised by any operator node . A composite event is denoted by ec with an alphabetical index indicating its event type and a numerical index indicating its hierarchical position . Note that due to the order of occurred events in S6S9 the same composite events are raised irrespective of the context from Snoop that is combined with the hierarchical context . Second , the termination condition must be fulfilled for a comIt is a condition on the subtree of the posite event to be raised . XML document with root node ec p.pi in the form of an arbitrary XPath expression that evaluates to boolean . The termination condition differs from operators and termination modes in that it is used to test the document and not events , eg , to test if text nodes contain any or certain text . for
Example 18 . the insertion of tree depicted in Figure 4 ,
Instead of adding event test type nodes and operator nodes that text nodes to the event termination condition “ item/price ≥ 0 ∧ item/quantity > 0 ” can be defined on the root node so that a composite event is only raised when both price and quantity element contain a value that is a number . This has also the advantage that text nodes can be arbitrarily inserted , updated , and deleted because its their value that matters , not the operations that lead to it .
An event tree can be opened , flushed , and closed by an application . After opening it stores occurring primitive and composite events . If it is flushed , remaining composite events are raised by operator nodes with non local or custom termination mode . Closing an event tree first flushes it and afterwards takes it out of order , eg , when an XML document is closed after manipulation .
4 .
IMPLEMENTATION
The implemented proof of concept prototype extends the DOM event module of Apache ’s Xerces [ 9 ] and thus provides Java applications with composite events . This section briefly describes the
Figure 4 : Event tree using a multiplicity operator fies the constraint of multiplicity operator o by having oetpt ⊂e pi.pt∨ oetpt = pipt It does not comprise any constituent event , its path type is set to pi.pt , and its path instance to pi . When event ei with πoetpt(eipi ) = πoetpt(ec 1.pi ) subsequently occurs in o ’s child node before ec 2 which integrates ec 2 is consumed later on and ec 3 is raised since o ’s constraints are still satisfied .
2.pi still exists , new composite event ec
1 is consumed , new composite event ec
1 is raised . If composite event ec
Example 16 . The event tree depicted in Figure 4 allows optional element comment as child of element item . With the insertion of item element i1 composite event ec c1 etpt = /order/item and ec c1 .pi = /o1/i1 . Thereafter , the conjunction operator raises composite event ec h1 as soon as matching events are stored in its other child nodes , ie , as soon as p1 and q1 are inserted as childs of i1 . If matching comment element c1 is inserted before both elements p1 and q1 are inserted , event ec c1 is raised which becomes a part of ec c1 occurs with ec c2 integrating ec h1 later on .
3.3 Operator Modifiers
To enrich the expressiveness of event type definitions , operator nodes are parameterized by two modifiers to exactly define the points in time when composite events are raised . When an operator node detects events in child nodes that satisfy the operator ’s semantics , a “ potential composite event ” , which is not stored in the tree , is detected . A composite event , which is stored in the tree , is raised with the detection of the potential event or is deferred to a later date . This is of importance , eg , when a multiplicity operator or the hierarchical cumulative context is used , because the later a composite event is raised the more constituent events it will possibly have . Thus applications can react to deferred composite events comprising a rich set of constituent events and can determine the net effect [ 15 ] , ie , overall effect of multiple events more easily .
First , the termination mode determines when a composite event ins(item/comment)x[0,1]ins(item)ins(item/price);ins(item/quantity)x[1 , ](1 ) tm:earliest(2 ) tm:non local(a ) tm:earliest ( b ) tm:non localEqEcEhEiccccootm:earliesttm:earliesttm termination mode Table 3 : Raised composite events in hierarchical context when different termination modes are used t3
( 1a ) : earliest,×[1,∞ ] : earliest t4 eq1 , ec eq1.1 , ec q1 , ec ec1 , ec h1 , ec i1 c1.2 h1 , ec q1.1 , ec i1 ei2 , ec c2 ( 1b ) : earliest,×[1,∞ ] : non local ei2 , ec c2 h1 , ec q1 , ec i1 ec1 , ec c1.2 ep2 eq1 , ec ei2 , ec c2 eq1.2 , ec q1 , ec eq1 , ec q1.2 h1 , ec i1 c1.2 eq1 ec1 , ec eq1.1 ei2 , ec c2 eq1 , ec q1 ec1 , ec eq1.1 , ec ei2 , ec c2 c1.2 q1.1 ei2 , ec h1 , ec i1 c2 , ec q1 , ec eq1 ec1 , ec ep2 c1.2 ei2 , ec h1 , ec c2 , ec i1 eq1 , ec q1 ec1 , ec ep2 c1.2
( 2a ) : non local,×[1,∞ ] : earliest
S6 S7 S8 S9
S6 S7 S8 S9
S6 S7 S8 S9
S6 S7 S8 S9 t1 ei1 , ec c1 ei1 , ec ei1 , ec ei1 , ec c1 c1.1 c1.1 ei1 , ec c1 ei1 , ec ei1 , ec ei1 , ec c1 c1.1 c1.1 ei1 , ec c1 ei1 , ec ei1 , ec ei1 , ec c1 c1.1 c1.1 ei1 , ec c1 ei1 , ec ei1 , ec ei1 , ec c1 c1.1 c1.1 t2 ep1 ep1 ep1 ep1 ep1 ep1 ep1 ep1 ep1 ep1 ep1 ep1 ep1 ep1 ep1 ep1 t5
– eq1.2 eq1
–
– c2 , ec q1 , ec ei2 , ec h1 , ec i1 ei2 , ec h1 , ec i1 q1.2 c2 , ec eq1.2 , ec eq1 , ec q1 t6
– – ei2 , ec c2 h2 , ec q2 , ec i2 eq2 , ec
– – c2 , ec q1 , ec ei2 , ec eq2 , ec q1 , ec h1 , ec i1 h1 , ec i1
– – ei2 , ec c2 , ec h1 , ec i1 h1 , ec i1 eq2 , ec
( 2b ) : non local,×[1,∞ ] : non local c1.2 eq1 ec1 , ec eq1.1 ei2 , ec c2 ei2 , ec h1 , ec i1 c2 , ec q1 , ec eq1 ec1 , ec ep2 c1.2
– c2 , ec q1 , ec ei2 , ec h1 , ec i1 eq1.2 eq1
– – q1 , ec c2 , ec ei2 , ec eq2 , ec q1 , ec h1 , ec i1 h1 , ec i1 prototype ’s execution model .
Every occurred primitive event is inserted into the event graph , which is processed to detect composite events . To determine the order in which the event trees of the graph are processed , which remains the same as long as neither the graph nor the trees are modified , the notion of event tree dependency is introduced . Event tree tb directly depends on event tree ta , denoted as ta → tb , iff tb uses composite event type etb to which event type eta defined by ta is compatible to , ie , if eta ( cid:186 ) etb . An event tree may not depend directly or indirectly on itself .
Algorithm processGraph for processing event graph G upon the occurrence of primitive event e is shown below . It processes every event tree of the graph exactly once . Line #1 determines the ordered set of event trees that do not directly depend on any other event tree and assigns it to T . Subsequently , the set of occurred and raised events E is initialized to e ( line #2 ) . While there are event trees left that need to be processed ( line #3 ) , every event tree ti ∈ T is processed ( line #4–#5 , see later in this section ) , where ti denotes the ith element of T . Subsequently , all event trees that directly depend on any t ∈ T and thus need to be processed are determined and assigned to T ( line #6 ) . Finally , T is purged ( line #7 , see later in this section ) . processGraph(e ) #1 T := {t ∈ G| ∃u ∈ G : u → t} #2 E := {e} #3 while T = ∅ do #4 #5 #6 #7 for i = 1 to |T| do T := {t ∈ G|∃t ∈ T : t → t} purge(T )
E := processTree(ti , E )
Algorithm processTree(t,E ) processes event tree t with the set of events E as follows . The tree is traversed in postorder ( a form of depth first traversal ) during which ( a ) every visited event type node n is tested for type compatibility with the event type of every event e ∈ E and if they are compatible , ie , e.et ( cid:186 ) n.et , e is stored in n.evts ( but not taken out of E ) , and ( b ) every visited operator node o is evaluated if ( i ) an event was stored in a ( direct ) child node , ( ii ) if o specifies a termination condition and for the primitive event e ∈ E it applies that oetpt ⊂ e.pt ∨ oetpt = e.pt , ( iii ) if o has non local termination mode , or ( iv ) if o is a multiplicity operator node with l = 0 and for the primitive event e ∈ E it applies that oetpt ⊂e e.pt ∨ oetpt = ept Finally , composite events that are raised in the root node of event tree t are added to E to be processed by dependent event trees later on . Algorithm purge(T ) removes every event tree tk ∈ T from T if it is contained in the closure of another event tree tj ∈ T , where the closure of a tree refers to the set of trees that directly and indirectly depend on it . This guarantees that an event tree is processed exactly once at the latest time possible .
5 . CONCLUSIONS
We have presented the first approach to detect composite events in XML , which refines and extends the event algebra Snoop to take the peculiarities of events in XML into account and provide for the detection of satisfied multiplicity constraints . Moreover , the introduced concept of compatibility of event types makes event expressions more expressive and reusable . The prototype including additional examples is available on the Web at http://wwwbigtuwienacat/research/ prototypes/composite events . Naturally our approach is independent of an implementation and can be used by any application in need of composite events in XML , presumably , such as [ 2 ] and [ 6 ] .
The presented approach is fully compatible with Snoop and thus provides for combined expressiveness . First , the hierarchical context presented herein is orthogonal to Snoop ’s contexts and can thus be arbitrarily combined with the latter , providing for simultaneous event combination by hierarchical position and time . Second , composite XML event types can be combined by operators from Snoop , providing for subsequent event detection based on time ( eg , NOT detects non occurrences of events in intervals ) .
Our ongoing research concentrates on the automatic derivation of event expressions from XML schemas ( ie , schemas expressed in XML Schema [ 19 ] ) to provide a set of composite event type definitions an application engineer can start working with . We assume that if schemas use XML schema concepts such as type definitions , type hierarchies and model groups in a meaningful way , derived composite event type definitions will be meaningful as well .
6 . ACKNOWLEDGMENTS
We want to thank Jan Wenger for implementing the prototype and giving valuable feedback and Elke Michlmayr for carefully reading the paper and giving helpful comments .
7 . REFERENCES [ 1 ] R . Adaikkalavan and S . Chakravarthy . Event Operators :
Formalization , Algorithms , and Implementation . Technical Report CSE 2002 3 , Department of Computer Science and Engineering , University of Texas at Arlington , 2002 .
[ 2 ] J . Bailey , A . Poulovassilis , and P . T . Wood . An
Event Condition Action Language for XML . In Proceedings of the 11th International Conference on World Wide Web ( WWW11 ) , Honolulu , USA , pages 486–495 . ACM Press , 2002 .
[ 3 ] J . Bailey , A . Poulovassilis , and P . T . Wood . Analysis and Optimisation of Event Condition Action Rules on XML . Computer Networks , 39(3):239–259 , 2002 .
[ 4 ] A . Bonifati , D . Braga , A . Campi , and S . Ceri . Active
XQuery . In Proceedings of the 18th International Conference on Data Engineering ( ICDE ) , San Jose , USA , 2002 .
[ 5 ] A . Bonifati , S . Ceri , and S . Paraboschi . Active Rules for
XML : A New Paradigm for E Services . The VLDB Journal , 10(1):39–47 , 2001 .
[ 6 ] A . Bonifati , S . Ceri , and S . Paraboschi . Pushing Reactive
Services to XML Repositories using Active Rules . In Proceedings of the 10th International World Wide Web Conference ( WWW10 ) , Hong Kong , China , pages 633–641 . ACM Press , 2001 .
[ 7 ] S . Chakravarthy , V . Krishnaprasad , E . Anwar , and S K
Kim . Composite Events for Active Databases : Semantics , Contexts and Detection . In Proceedings of the 20th International Conference on Very Large Data Bases ( VLDB ) , Santiago de Chile , Chile , pages 606–617 . Morgan Kaufmann , 1994 .
[ 8 ] S . Chakravarthya and D . Mishra . Snoop : An Expressive
Event Specification Language for Active Databases . Data & Knowledge Engineering , 14(1):1–26 , Nov . 1994 .
[ 9 ] A . S . Foundation . Xerces Java . http://xmlapacheorg/xerces2 j/ , 2003 . [ 10 ] A . Galton and J . C . Augusto . Two Approaches to Event
Definition . In Proceedings of the 13th International Conference on Database and Expert Systems Applications ( DEXA ) , Aix en Provence , France , number 2453 in LNCS , pages 547–556 . Springer , 2002 .
[ 11 ] S . Gatziu and K . R . Dittrich . Events in an Active
Object Oriented Database System . In Proceedings of the 1st Intl . Workshop on Rules in Database Systems ( RIDS ) , Edinburgh , Scotland , pages 23 – 29 . Springer , 1993 .
[ 12 ] S . Gatziu and K . R . Dittrich . Detecting Composite Events in Active Database Systems Using Petri Nets . In Proceedings of the 4th Intl . Workshop on Research Issues in Data Engineering ( RIDE ) : Active Database Systems , Houston , Texas , 1994 .
[ 13 ] N . H . Gehani , H . V . Jagadish , and O . Shmueli . Composite
Event Specification in Active Databases : Model & Implementation . In Proceedings of the 18th International Conference on Very Large Databases ( VLDB ) , 1992 .
[ 14 ] G . Kappel , S . Rausch Schott , and W . Retschitzegger . A
Framework for Workflow Management Systems Based on Objects , Rules and Roles . ACM Computing Surveys Electronic Symposium on Object Oriented Application Frameworks , 32(1 ) , Mar . 2000 .
[ 15 ] N . Paton and O . Diaz . Active Database Systems . ACM
Computing Surveys , 31(1):63–103 , Mar . 1999 .
[ 16 ] M . Schrefl and M . Bernauer . Active XML Schemas . In Proceedings of the Workshop on Conceptual Modeling Approaches for e Business ( eCOMO ) at the International Conference on Conceptual Modeling ( ER ) , Yokohama , Japan , volume 2465 of LNCS . Springer , 2001 .
[ 17 ] W3C . XML Path Language ( XPath ) , W3C Recommendation . http://wwww3org/TR/xpath , Nov . 1999 .
[ 18 ] W3C . XML Information Set , W3C Recommendation . http://wwww3org/TR/xml infoset , Oct . 2001 .
[ 19 ] W3C . XML Schema Part 1 : Structures , W3C
Recommendation . http://wwww3org/TR/xmlschema 1 , May 2001 .
[ 20 ] W3C . Document Object Model ( DOM ) Level 3 Events
Specification . http://wwww3org/TR/DOM Level 3 Events/ , Mar . 2003 .
[ 21 ] W3C . XQuery 1.0 and XPath 2.0 Functions and Operators ,
W3C Working Draft . http://wwww3org/TR/xpath functions , May 2003 .
[ 22 ] R . J . Zhang and E . A . Unger . Event Specification and Detection . Technical Report CS 96 8 , Department of Computing and Information Sciences , Kansas State University , 1996 .
[ 23 ] D . Zimmer and R . Unland . On the Semantics of Complex
Events in Active Database Management Systems . In Proceedings of the 15th International Conference on Data Engineering ( ICDE ) , Sydney , Australia , pages 392–399 . IEEE Computer Society Press , 1999 .
