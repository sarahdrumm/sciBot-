Repetition Aware Content Placement in Navigational
Networks
Dóra Erdös Boston University
Boston , MA edori@bu.edu
Vatche Ishakian
∗
Raytheon BBN Technologies
Cambridge , MA vishakia@bbn.com
Azer Bestavros Evimaria Terzi Boston University Boston University
Boston , MA best@bu.edu
Boston , MA evimari@bu.edu
ABSTRACT Arguably , the most effective technique to ensure wide adoption of a concept ( or product ) is by repeatedly exposing individuals to messages that reinforce the concept ( or promote the product ) . Recognizing the role of repeated exposure to a message , in this paper we propose a novel framework for the effective placement of content : Given the navigational patterns of users in a network , eg , web graph , hyperlinked corpus , or road network , and given a model of the relationship between content adoption and frequency of exposition , we define the repetition aware content placement ( RACP ) problem as that of identifying the set of B nodes on which content should be placed so that the expected number of users adopting that content is maximized . The key contribution of our work is the introduction of memory into the navigation process , by making user conversion dependent on the number of her exposures to that content . This dependency is captured using a conversion model that is general enough to capture arbitrary dependencies . Our solution to this general problem builds upon the notion of absorbing random walks , which we extend appropriately in order to address the technicalities of our definitions . Although we show the RACP problem to be NP hard , we propose a general and efficient algorithmic solution . Our experimental results demonstrate the efficacy and the efficiency of our methods in multiple real world datasets obtained from different application domains .
Categories and Subject Descriptors H28 [ Database Management ] : Database Applications— data mining
Keywords Optimization , Markov chains , Navigational networks
∗This work was completed while the author was a PhD student at Boston University
INTRODUCTION
1 . Motivation : There is ample evidence in the literature that the probability of internalizing a concept or buying a product ( user conversion ) is dependent on the number of times that an individual user is exposed to information or advertisement related to that concept or product . As Artistotle put it “ it is frequent repetition that produces a natural tendency ” . In education , repetition is recognized as an effective pedagogical tool ; repetition deepens and hastens students’ engagement and understanding processes [ 5 , 22 ] . In marketing , repeated exposure to a product is key to the success of marketing campaigns [ 17 ] . In politics , repeating specific messages in stump speeches or in mass media advertisements is effective in influencing public opinion , and thus critical to the success of political campaigns [ 1 , 21 ] . The effects of repetition are not always positive : while repeated exposure to a message increases one ’s ability to internalize a concept in an educational setting , it may yield undesirable outcomes in a different setting – for example , the probability of purchasing a product decreases dramatically with repeated exposure ( more than twice ) of the product to a customer 1 . Problem : Motivated by the role that repeated exposure to content plays in these various settings , in this paper we define and study the repetition aware content placement ( RACP ) problem in navigational networks , ie , networks in which the ( directed ) edges represent the potential of users to transition from one node to another as they navigate through the network . Broadly speaking , given the navigational patterns of users in such a network , and given the relationship between the level of user exposure to content and the probability of user conversion , the RACP problem is that of identifying the set of k nodes on which content should be placed so that the expected number of users adopting the content ( ie , the conversion rate ) is maximized . Applications : Instances of RACP occur in multiple domains . For example , consider the problem of superimposing content on the navigational network defined by the hyperlink structure of the web . Here , the challenge is the identification of the set of k web pages ( nodes of the navigational graph ) on which content should be placed in order to maximize the impact of an advertisement campaign , eg , placement of slogans that raise awareness about a social issue , or placement of advertisement about a product or a political party . As another example , consider the problem of providing recommendations for additional content to readers of on line
1http://wwwmediabizbloggerscom/bill harvey/ 50150992.html corpora . Here , the reader ( a student ) navigates a body of knowledge ( an on line textbook ) – not necessarily serially – by following links that underscore dependencies between units of the corpus ( eg , sections and chapters ) , and the challenge is to identify the best set of units where additional content ( further readings , references , exercises ) could be linked or recommended so as to maximize the probability of access to such additional content . The RACP problem is applicable to offline physical navigational networks as well – the canonical example being road networks . Here users navigate a set of interconnected locations , and the challenge is the placement of billboard advertisements at the right locations , so as to maximize the impact on travelers/commuters .
Model : The main components of our setting are the user ’s navigational and conversion models . The navigational model assumes that user ’s navigation through the nodes of the network is modeled by a Markov chain , ie , a random walk over the navigational graph . The conversion model specifies the probability of a user adopting content as a function of the number of times that content is shown to the user within a single walk over the navigational network . Our incorporation of a conversion model fundamentally changes the nature of content placement by making user conversion dependent on the number of times that content is shown to the user . Said differently , the novelty of our work is the introduction of memory into the navigation process . In our work , rather than focusing on a particular type of relationship between number of views and probability of content adoption , we consider generic conversion models that handle arbitrary dependencies between the number of views and the probability of content adoption .
Contributions : Problems of picking important ( or target ) nodes in networks have been studied extensively in the past , both in information flow ( or social ) networks [ 7 , 9 , 11 , 16 ] , in transportation [ 2 , 3 , 13 , 14 , 20 ] and in navigational networks [ 6 , 8 ] . A thorough examination of this related work is presented in Section 2 . The key difference between that prior work and ours is that the former assumes memoryless navigation or information flow processes , and as a result has an implicit conversion model that presumes the independence of number of views and conversion probability . The explicit modeling of this dependence and the flexibility of our model to capture arbitrary forms of this dependency makes our work more general in the sense that prior work represents a subset of the scenarios that are possible to consider using our approach . Another salient feature of our work is that our formulation and algorithmic treatment of the RACP problem are general in the sense that they apply to any conversion model as long as the conversion probability can be expressed as a function of the number of times content is presented to the user in a single random walk over the navigation graph . The incorporation of an arbitrary conversion model ( memory ) into a navigation ( random walk ) process raises new modeling as well as computational challenges , which comprise the main technical contributions of our paper . We address this new class of problems by building upon the notion of random walks with absorbing states . More specifically , we propose solutions to our RACP problem based on analysis using absorbing random walks , and we demonstrate that our techniques are scalable and thus useful for real world data analysis tasks . To the best of our knowledge we are the first to leverage such techniques not only in the context of content placement in navigational networks , but also in the context of node selection in general .
2 . RELATED WORK
Although , to the best of our knowledge , we are the first to propose and solve the RACP problem , which encompasses both a navigational and a general conversion model , our work is related to a large body of existing work on information , transportation and online navigational networks .
Information networks : Recently , there has been a lot of work in the computer science literature on identifying a set of nodes of a social network to advertise a product or to immunize so that the spread of the product or the spread of an epidemic in the network is maximized or minimized . Different assumptions about how information items propagate in the network has led to a rich literature of node selection methods [ 7 , 9 , 11 , 16 , 18 , 19 ] . The key difference between our work and all these methods is that the latter assume that the underlying network is an information network on which items ( rather than users ) propagate . As a result , the models adopted in such existing work are information propagation models and thus , cannot be used to model the navigation of users in a navigational network . Hence , despite the fact that at a high level we also need to pick a subset of the nodes of our network , our objective – ie , the maximization of users’ conversion rate – does not have an analogue in the social network literature . More specifically , the models we propose here are specific to navigational networks and lead to problem definitions that require the development of new machinery in order to be solved .
Transportation networks : Related to ours is the work on the flow capturing location allocation problem ( FCLA ) in transportation networks . This problem has originally been introduced in 1990 by Hodgson [ 13 ] . In the FCLA problem , the input consists of a network as well as the customer traversals in the form of flows between source and destination pairs . The objective is to locate facilities in a set of k nodes so as to maximize the number of customers who encounter at least one facility in their flow through the network . In his original paper , Hodgson proves that this version of the location allocation problem is NP hard , but empirically shows that a greedy algorithm can be quite efficient in solving it . The problem we study here is different from this original version of the FCLA problem in three ways : First , while in FCLA the repetition of interceptions ( ie , multiple encounters of customers with facilities ) is ignored , our work focuses on optimizing the interception of the users’ navigation given the impact that repetitions have on the users’ tendency to convert . Second , Hodgson assumes that the interception of a flow is a deterministic process , ie , a flow is either intercepted or not , hence set cover type of reasoning works for his approach . In our case the paths of users is only intercepted in a probabilistic sense . Third , in our work we assume the navigation model is Markovian , while in FCLA the navigation paths of users from sources to destinations are a priori known and deterministically defined . As a result , both our model as well as the computational challenges we need to resolve are different from those that arise in the FCLA problem .
Even in the domain of transportation networks , the assumption that all source destination flows are known a priori proved impractical . As a result , there exists work on variants of the original FCLA problem where partial flow information is assumed [ 2 , 3 ] . In these cases , the available navigation information specifies the fraction of flows that pass through every node and its neighbors . Despite the fact that this navigation model resembles ours , existing work still ignores the effect of repetitive interceptions on users . As a result , the underlying combinatorial problems that appear in existing work [ 2 , 3 ] are different from ours . After all , the algorithms used for solving these existing variants of FCLA are based on non linear integer programming and total reward Markov decision processes , while our solution is based on deploying Markov chains with absorbing states .
Navigational networks : More recent work on node selection in online navigational networks includes the work of Chierichetti et al . [ 8 ] and Charikar et al . [ 6 ] . In their work Charikar et al . [ 6 ] assume a similar propagation model and objective to ours , in that users traverse a Markov chain and the ultimate goal is to assign content to certain states in this chain . Despite the similar objective function , the underlying problem they solve is completely different from ours ; in their setup users can either be in a targeted or non targeted population and the goal is to intercept the largest possible fraction of the targeted population . In their setting , interception of users’ is deterministic and repetition does not play any role . As opposed to this , in our work users are only intercepted with some probability in chosen states and this probability may change with the number of times an interception happens .
Chierichetti et al . [ 8 ] assume a user navigation model similar to ours and their goal is to find an optimal placement of online advertisements . In their setting , ads are placed to the nodes of the navigation network and there is a utility assigned to a user seeing an ad , that depends both on the state and the specific ad that is shown . When an ad is shown the user may stop with some probability ( go to an exit state of the chain ) or continue traversing . While the is similar to user propagation model of Chierichetti et al . ours , their conversion model is different . In special , they do not distinguish between the first and subsequent views of the same ad . They propose a very elegant LP solution for their problem . However , the method they derive is inadequate to solve the RACP problem . Due to the fact that in our setting the conversion probabilities are affected by repeated traversal through the same state , the size of the corresponding LP program in their solution would blow up .
3 . PROBLEM DEFINITION
The input to our problem consists of the navigational and the conversion model . The navigational model is a network ; the nodes of this network correspond to entities ; the user navigates through the entities by following the links of the underlying graph ( directed or undirected ) based on probabilities associated with the links . The conversion model quantifies the relationship between the number of times a user views a particular content and the probability of her adopting the content ( or converting to the content ) . The objective of our work is to place content in the network at locations so as to maximize the probability of conversion .
Throughout the paper , we assume as input a navigational graph G = ( S , E ) , which is a directed or undirected graph with nodes S , edges E and |S| = n . Navigational model : We assume that the users’ traversal of the network follows the traditional Markov model ; users navigate between a set of states in a randomized way , transitioning between states with given probabilities , such that the transition probabilities define a Markov chain on this set of states . Let M = S , P denote this Markov chain , set S contains n states S = {s1 , s2 , . . . , sn} and P contains the transition probabilities P(i , j ) of a user moving from state si to state sj . We think of P as an n× n matrix , that is the transition matrix of M . Note that the state space S of the Markov chain is simply the set of nodes of the navigational graph G = ( S , E ) . For the rest of the discussion , we will assume that M is irreducible and aperiodic , and thus has a stationary distribution π2 . Finally , in order to make our model more realistic , we assume that there is an upper bound on the maximum number of hops the user is taking , ie , this bound encodes that the user quits his navigational session in finite time . We denote this bound by Mmax . Conversion model : This model depicts the user ’s behavior upon being exposed to some content in one of the states . Upon viewing content c the user has two possible actions : either convert ( ie , click on the link , adopt some view or buy the advertised product ) and quit the traversal of the network or continue without taking any action . The conversion model provides the probability with which the user chooses in any given situation between these two options . Note , that a user may only quit the navigation by either converting or by exceeding the maximum number of hops .
In this paper , we focus on memory full conversion models , ie , conversion models for which the probability of a user converting to the content c depends on the number of times she has been exposed to this content before – while it does not depend on the specific path that the user has followed . To describe this model in more detail we introduce the notion of levels .
Definition 1 . We say that a user is in level if she has been exposed to content c exactly times .
A result of the above definition is that the user is in level 0 when she has not seen the content yet . That is , every user starts her traversal of the network in level 0 . When a user , who is at level is exposed to the content but decides not to convert , she moves to level ( + 1 ) .
The probability that a user converts to content c , when presented with it in state s , depends on the state itself as well as on the user ’s level , but not on the user ’s path during her navigation . We denote this probability by C( , s ) . Naturally , the probability that a user continues the traversal – without converting – is ( 1 − C( , s) ) . We call C( , s ) the conversion probability in state s at level .
Note that the probability C( , s ) can be any arbitrary function of s and . For example , if the number of repetitions of the content ’s viewings increases ( resp . decreases ) the probability of adoption , then we will assume that C( , s ) is monotonically increasing ( resp . decreasing ) with . However , such monotonic relationship is not necessary for our framework . Our intuition is that the probability of the user ’s conversion increases for the first couple of exposures to the content and then it decreases . 2In fact , our method only makes use of the irreducibility property of Markov chains . In our experiments we compute the PageRank with a dampening factor [ 4 ] of states instead of the stationary distribution .
The only assumption we make with respect to the dependency of C( , s ) on is that there is a sufficiently large number K , such that if the user did not convert after level K , then the probability of conversion becomes infinitesimal small . That is , C( , s ) → 0 for ≥ K and for any s . This assumption also ensures that the number of different conversion probabilities per state is at most K .
The dependency of C( , s ) on the state s may also be arbitrary . In some cases , the conversion probability C( , s ) may depend on the relevance of the content c , which we are placing to the node s , and the content of the node s itself . For example , an ad ’s placement on a webpage depends on the topic of the page . In other cases , the conversion probability C( , s ) may only depend on factors irrelevant to the content or the node . Expected conversion rate : The objective in the RACP problem is to maximize the expected probability of a user converting to content c , given the navigational and conversion models . We are now ready to give the formal definition of this objective function . For this , let MS , P be the user ’s navigational model . Moreover , if L = {1 , 2 , . . . , K} is the set of all possible levels of a user then let C : L× S → [ 0 , 1 ] denote the input conversion model . Finally , let R( , s ) denote the probability that the user is encountering content c for the th time when she is visiting state s . Note that since the user has not yet quit the navigation she has neither converted to c , nor has she reached the maximum number of steps Mmax . Although the definition of R( , s ) is conceptually easy , computing the value of R( , s ) is computationally challenging . In order to maintain the smoothness of the flow of the paper , we assume for now that R( , s ) can be computed and we give the details of this computation in Section 42 If copies of content c are placed on a subset of states A ⊆ S , then the expected conversion rate of content placement A is given by the formula :
CR(A ) =
R( , s)C( , s ) .
( 1 )
X
KX s∈A
=0
Note that Equation ( 1 ) is the probability that a user reaches a state s ∈ A and converts to content c , after having encountered content c for times in the past , where ∈ L .
Since our goal is to actually find the content placement A for which Equation ( 1 ) is maximized , we define the RACP problem as an optimization problem as follows :
Problem 1
( RACP ) . Given the navigational model M = S , P , the conversion model C( , s ) for every ∈ L and s ∈ S , and a budget B , assign content to at most B states A ⊆ S so that the expected conversion rate CR(A ) is maximized .
Theorem 1 . The RACP problem is NP hard .
Proof . We prove the theorem by reducing the decision version of the Vertex Cover problem [ 12 ] to the decision version of the RACP problem . The decision version of the Vertex Cover problem takes as input a graph G = ( V , E ) and asks whether there exists a set of vertices U ⊆ V of size at most k such that every edge in E is incident to at least one of the vertices in U .
We transform the above instance of Vertex Cover to an instance of the decision version of our problem as follows .
We assume that our navigation graph G = ( S , E ) has the same nodes as G ( ie , S = V ) and the same set of edges as E ( the undirected edges in E become bidirectional edges in E ) . Our navigational model is a simple Markov chain defined on G . Further , we define our conversion model as follows : for any state s ∈ S , the user converts to content c the first time she encounters c . That is , for every s ∈ S we have that C(0 , s ) = 1 . We can now show that there exists a vertex cover of size k in G iff in the above instance of the RACP problem there exists a set of k nodes A ⊆ S such that for Mmax = 1 the expected conversion rate for A is equal to 1 , ie , CR(A ) = 1 .
4 . SOLVING THE RACP PROBLEM
In this section , we give a greedy algorithm for solving the RACP problem . We also identify the connection of our problem to random walks with absorbing states and demonstrate how this connection is exploited within the implementation of our algorithm . 4.1 The Greedy algorithm
Our greedy algorithm , which we call Greedy , forms solution A iteratively ; at each iteration it adds the node that causes ( locally ) the most increase in the objective function . More specifically , Greedy starts from an empty set A = ∅ . At iteration i , a new state s is added to A , such that CR(A∪ {s} ) is maximized . The algorithm terminates when either the budget B of states for content placement is exceeded , or there is no state that increases the expected conversion rate . In many applications , not all states are available for content placement . For this reason , we keep a set of candidate states S ⊆ S and only consider states in S to add to A . The pseudocode of the Greedy algorithm is given in Algorithm 1 .
Algorithm 1 The Greedy alorithm for the RACP problem . Input : Markov chain MS , P , budget B , candidate list S and conversion rates C( , s ) for every ∈ {0 , . . . , K} and every s ∈ S . Output : set of states A and CR(A ) . A ← 0 CR(A ) ← 0 for i = 1 . . . B do s = argmaxs∈S CR(A ∪ {s} )
A = A ∪ {s} S = S \ {s}
In terms of running time , the most computationally expensive step of Greedy is the computations done inside the for loop , ie , computing CR(A∪{s} ) ( line 4 of Algorithm 1 ) . If the time required for computing function CR( ) is T , then the running time of Greedy is O(B|S|T ) , which in the worst case ( ie , when S = S ) is O(BnT ) .
Note that at each iteration of the for loop in line 4 all candidates need to be evaluated in order to choose the one with the largest marginal benefit . Although this can be time consuming , we observe that the evaluation of each candidate can be done independently of the rest . Therefore , we have implemented a parallel version of Greedy , which we call Par Greedy , and which evaluates each candidate separately . Thus Par Greedy is O(n/q ) times faster than the serial version of Greedy shown in Algorithm 1 , where q depends on the number of cores of the underlying hardware .
The details of how we evaluate CR(A ) for any A ⊆ S are given in the next paragraph . 4.2 Computing the expected conversion rate The computation of CR(A ) for any A requires the evaluation of Equation ( 1 ) . Since C( , s ) for any level and any state s is provided as part of the input ( ie , the conversion model ) , the main challenge in the evaluation of Equation ( 1 ) stems from computing the values of R( , s ) for every ∈ {0 , . . . , K} and every s ∈ S . Next , we show how these computations can be done using the notion of absorbing Markov chains [ 10 , 15 ] .
Absorbing Markov chains : Given an underlying graph H = ( X , Q ) , consisting of nodes X and edges Q , an absorbing Markov chain C = X , Q defines an absorbing random walk on H . The statespace of this walk is X ( ie , the nodes of H ) and there are two types of states in X : absorbing and transient . A state x ∈ X is absorbing if the random walk transitions into this node , but not out of it ( and thus , the random walk is absorved in state x ) . Let B ⊆ X denote the set of absorbing states . The remaining states U = X \ B define the set of non absorbing or transient states .
Given this partition of the states , the transition matrix of this random walk can be written as follows :
„QUB QUU
«
.
I
0
Q =
( 2 ) If |X| = N , then in the above equation , I is an ( N − |U| ) × ( N −|U| ) identity matrix and 0 a matrix with all its entries equal to 0 ; QUU is the |U| × |U| sub matrix of Q with the transition probabilities between transient states ; and QUB is the |U| × |B| sub matrix of Q with the transition probabilities from transient to absorbing states .
An important quantity of an absorbing random walk is the expected number of visits to a transient state y when starting from a transient state x , before being absorbed . The probability of transitioning from x to y in exactly steps is the ( x , y ) entry of the matrix Q UU . Finally , the matrix
QUB = Q
UUQUB
( 3 ) is an |U|×|B| matrix , with QUB(x , y ) being the probability that a random walk which starts at a transient state x ends up being absorbed at state y ∈ B . Absorbing Markov chains and the RACP problem : In order to illustrate how absorbing random walks can be leveraged by our problem , let us consider the navigational graph G = ( S , E ) and the corresponding navigational model M = S , P and conversion model C( , s ) for ∈ {0 , . . . , K} and s ∈ S . Further assume that a subset of states A ⊆ S have been selected for placing content c . graph bG = ( bS , bE ) as follows : for every node s ∈ S \ A there exist a node s ∈bS , and for every node s ∈ A we create two copies of it in bS – one denoted by st and the other denoted all absorbing copies appearing in bS due to states s ∈ A . Clearly , |At| = |Ab| and |bS| = |S| + |A| . The edges among the nodes in S \ A are the same both in G and bG . Finally , by sb . We call st the transient copy of s and sb the absorbing copy of s . For the rest of the discussion , we will use At and Ab to denote the set of all transient copies and the set of
Given the above we will define the extended navigational the transient copy st of s ∈ A maintains all the outgoing
In this Markov chain , the nodes Ab are absorb follows : the transition probability from a transient state s edges of node s , while the absorbing copy sb of s maintains all the incoming edges of s .
Given bG , we also define the absorbing Markov chain cM = bS,bP . ing and all other nodes in bS are transient . The transition matrix bP of such an absorbing random walk is defined as to an arbitrary state s ∈ bS is identical to that in M , thus bP(s , s ) = P(s , s ) . For absorbing state s ∈ Ab the probability of transitioning to any other state s ∈ bS is zero and thus , bP(s , s ) = 0 . To make bP a proper transition matrix ( ie , ensure that all its rows sum up to 1 ) we set bP(s , s ) = 1 for all absorbing states s ∈ Ab . Note that matrix bP has the the absorbing Markov chain cM is shown in Figures 1 and 2 .
A transformation from the original Markov chain M to same structure as matrix Q described in Equation ( 2 ) .
The former figure shows the original Markov chain which corresponds to the navigational graph G = ( S , E ) . The highlighted nodes in the figure correspond to the set A on which content c is placed . The highlighted graph of Figure 2 shows the absorbing Markov chain cM = bS,bP , which corresponds to graph bG = ( bS , bE ) . The highlighted nodes here Note that the extended graph bG and the corresponding absorbing Markov chain cM capture the navigational journey are the absorbing states of the chain .
In order to capture the journey of the user across levels of a user at a single level , eg , level . At this level , the user navigates according to her navigational model and once it encounters content c placed in one of the level ’s absorbing nodes , the random walk of the user gets absorbed . holistically , we need to create one copy of cM at every level = {0 , . . . , K} ; we denote such copies by cM . Now , when random walk cM ) , she directly enters random walk cM(+1 ) ; cM to cM(+1 ) is shown in Figure 2 and is captured by the the starting point of this random walk is node st . We call this set of connected absorbing Markov chains a sequence of absorbing Markov chains . The transition of the user from the user gets absorbed at sb at level ( ie , while she was at dotted arrows that connect nodes from different levels .
In practice , we never actually construct this sequence of absorbing Markov chains , neither do we need to do any computation on the sequence itself . However , the above description provides a nice intuition and a conceptual understanding of the computations that follow . s s
Figure 1 : Markov chain M = S , P , with A = {s , s} picked as states on which content c is placed .
Computing CR : In this paragraph we compute CR(A ) as given in Equation ( 1 ) . Observe , that as C( , s ) is part of the states where content is placed t s s b
Level − 1
Level st sb transient state statesbS of M . Each column of F has one non zero element : Observe now that bP · F is of the same size as F , and for sb ∈ At we set F ( st , sb ) = 1 . That is , there is an 1 in a cell of F if the row and the column of the cell correspond to the transient and the absorbing copies of the same state . contains at cell ( s , sb ) the probability that a random walk starting in state s will be absorbed in one step in state sb . Moreover , if we set F0 = F and apply the recursion
Fi = PA · Fi−1
( 5 ) we get that Fi(s , sb ) is the same as Pi A(s , a ) ; ie , stores the probability that a random walk that starts at s gets absorb at sb . From the theory of random walks with absorbing states , we can observe that matrix F and Recursion ( 5 ) allows us to compute the analogue of matrix QUB ( described
Despite the fact that Equation ( 5 ) still involves a matrix multiplication , it is much more efficient to compute in practice , when compared to Equation ( 4 ) . This is not only be in Equation ( 3 ) ) for the absorbing Markov chain cM . cause F is of much smaller size than bP , but also because the sparsity of bP is maintained and thus the running time of the of bP ( ie , the number of edges |E| of the input navigational computation only depends on the number of non zero entries
Level + 1
Figure 2 : A sequence of absorbing Markov chains cM = bS,bP . For each state s ∈ A of Markov chain M shown in Figure 1 two states are created : sb ( absorbing ) and st ( transient ) . The transient and the absorbing copies of the same state are drawn as superstates . input , we only need to compute R( , s ) where s is one of the states in A . copy of s , ie , node sb , in cM . Since the user only enters cM
Given the above discussion though , R( , s ) is identical to the probability of the user being absorbed in the absorbing from transient states t ∈ At then R( , s ) can be computed as the sum over all states in t ∈ At of probabilistic paths of length at most Mmax ending in sb and starting at all possible entry points t ∈ At .
The probability of a path of length of exactly i between any two states s1 and s2 can be computed as the appropriate cell in the i th power of the transition matrix as Pri(s1 , s2 ) = Mmax from any state t ∈ At to state sb is bPi(s1 , s2 ) . Hence , the probability of a path of length at most
Pr(t , sb ) =
( 4 ) i=0 need to know the absorption probabilities of the states in
Speedup : The computation of Equation ( 4 ) can be computationally demanding . After all , it requires evaluating the
Mmax th power of the matrix bP . However , since we only Ab ⊆ bS , we can obtain a significant speedup as follows : first we define an auxiliary matrix F of size |bS| × |Ab| . The Ab of chain cM while the rows of the matrix correspond to all columns of this matrix correspond to the absorbing states
MmaxX bPi(t , sb ) .
MmaxX i=0 graph ) . Thus , for an absorbing state sb and transient state t we can compute the probability of a user being absorbed in that state after at most Mmax steps by
Pr(t , sb ) =
Fi(t , sb ) .
( 6 )
Using the above machinery , we can to compute the probabilities R( , s ) . Observe that R( , s ) depends on two things : the probability that the user will end up at level , and the probability that the user will be absorbed in the absorbing copy of s , ie , sb , at level . Thus R( , s ) for every level = 1 . . . K can be computed by the recursion :
R( , s ) =
R( − 1 , s
)(1 − C( − 1 , s
))Pr(s t , sb )
( 7 )
X s∈A
Level 0 is slightly different since at this level the user can start his random walk in the Markov chain in any state . Assuming that the probability of starting at any state is proportional to the state ’s stationary probability we have that
R(0 , s ) =
π(s
)Pr(s
, s ) .
( 8 )
X s∈S
Since C( , s ) is a priori given as an input , we can now compute CR(A ) using its definition given in Equation ( 1 ) . 4.3 Running times Running time of computing CR(A ) : Regardless of the maximum number of levels , we only need to compute the absorption probabilities in Equation ( 6 ) once , since they are identical in every level . Evaluating this takes as much time as multiplying bP with F , Mmax times . Since |A| ≤ B and K puting CR(A ) only depends on the non zero entries of bP and and B are constants , then the total running time for comis thus O(|E| ) ; in practice |E| n2 and thus , the time required for this computation is sub quadratic . Running the Greedy algorithm : Having described the underpinnings of the computation of CR(A ) , we can now absorbing state describe the details of the Greedy algorithm , shown in Algorithm 1 . The algorithm starts from an empty set A and , given constant integer budget B , it runs for B iterations . At every iteration , a new element is added to A such that CR(A∪{s} ) is maximized . This maximization step is achieved by computing CR(A ∪ {s} ) for every candidate state s and choosing the one which gives the highest CR . If all nodes in S are considered as candidates for content placement , then CR is computed nB times in Greedy . Plugging in the running time of computing CR , this yields a total running time of O(n|E| ) . Again , the parallel version of the Greedy algorithm can attain lower running times . The degree of speedup depends on the degree of parallelism allowed by the hardware .
5 . EXPERIMENTAL EVALUATION
In this section , we give an experimental evaluation of the Greedy algorithm on real datasets . All our implementations are in Matlab and we conducted our experiments using a 12 CPU cores ( Intel Xeon E5 2680 processors , operating at 2.7 GHz ) machine with 256GB of 1333 MHz DDR3 RAM . 5.1 Experimental Setup Datasets : In our experiments , we use real world datasets . For our experiments with real navigational graphs , we pick graphs that come from domains where the RACP problem is applicable . Further , the choice of datasets is such that they help us demonstrate the scalability of our algorithms . We describe the characteristics of the datasets we use below . The Road dataset : This is the road network of the state of Minnesota3 The links in the network are undirected and correspond to roads in Minnesota , while nodes correspond to road intersections . The dataset contains 2642 nodes , and 6600 edges . Since this network depicts actual roads it is not only very sparse but the node degree distribution is also quite homogeneous , with degrees ranging from 1 to 10 , but most degrees being at most 5 . Content placement in this setting can correspond to placing billboards along the roads . The Web dataset : This dataset contains the hyperlink structure of the stanford.edu domain in 20014 . Nodes of the graph correspond to web pages and the directed edges correspond to hyperlinks between them . The graph contains 10K nodes and 36K edges . The degree distribution of the graph is power law with degrees ranging from 1 to 500 . Placing content in nodes can correspond for example to advertising educational content , link to online tutoring resources as well as online advertising .
The Science dataset : The Science dataset5 contains of the citation network of articles that appeared in the domain of high energy physics . The nodes in the network correspond to papers and the edges correspond to one paper citing the other . The purpose of this dataset is to depict the learning process of a person , who wants to obtain knowledge in highenergy physics . The person might read a paper and then based on the reference list of this paper choose his next read . Since this process does not necessary imply reading the papers in chronological order , we make edges bidirectional and from the resulting graph we pick the largest connected
3wwwciseufledu/research/sparse/matrices/Gleich/ minnesota.html 4wwwciseufledu/research/sparse/matrices/Gleich/ wb cs stanford.html 5snapstanfordedu/data/cit HepThhtml component . The end result of this preprocessing is a graph with 27K nodes and 704K edges .
The navigational models : Our navigational models are defined by the graph datasets described above . More specifically , using these graphs we define the navigational model for each dataset to be the corresponding PageRank Markov chain on the graph defined by the dataset . In these Markov chains , the user that is at node x chooses with probability α one of the outgoing links of x uniformly at random ; with probability ( 1 − α ) the user jumps to a random node of the input graph . Note that our framework works for any Markov chain defined on the input navigational graphs , as long as the chain is ergodic . Our choice of the PageRank Markov chain [ 4 ] guarantees the ergodicity of our navigational models , even when the input graph is disconnected . For all our experiments we use α = 08
The conversion model : For all of our datasets we use a conversion model generated along the same principles . We first assign the initial CR values C(0 , s ) to states in level 0 . We obtain the CR rates C( , s ) on subsequent levels with help of a function f ( ) based on formula ( 9 )
C( , s ) = f ( )C(0 , s ) .
( 9 )
The initial assignment of C(0 , s ) to states is done by assigning to every state s value C(0 , s ) chosen randomly among the following 10 candidate values:{0.2 , 0.1 , 0.07 , 0.04 , 0.03 , 0.027 , 0.018 , 0.017 , 0.015 , 0010} Note that these values are exponentially decreasing and capture our intuition that there will be small number of states with high probability of affecting the conversion of the users . Experiments with different conversion values showed quite similar results ; due to lack of space we do not report them .
For our experiments , we pick five different functions f . The types of functions depict our intuition of different possible user behaviors ; one is linear increasing with , another is exponentially decreasing , and the last three are first increasing and then decreasing with different rates ( linear , exponential , or a combination of the two ) . Every state s is assigned one of the above functions , which is then used for computing C( , s ) for that state .
511 Baseline algorithms
Baseline algorithms : In order to better judge and understand the performance of our Greedy and Par Greedy algorithms , we compare them with the following baselines . Stationary : Given the navigational model M and budget B on how many states content can be place , the Stationary algorithm picks the B states with highest stationary distribution ( highest PageRank ) .
Rank : The Rank algorithm is an extension of Stationary . That is , it first finds the stationary probability distribution π(s ) ( ie , the PageRank score ) for every state s . Then , it computes the rank of each state s as rank(s ) = π(s)×C(0 , s ) . Given budget B the Rank algorithm picks the B nodes with the highest rank(s ) score . highest indegree states .
Degree : For budget B , the Degree algorithm picks the B Basic : For budget B , we rank states s ∈ S in decreasing order of C( , 0 ) , ie , the probability of a user being converted at every state at level 0 . Then , the Basic algorithm reports the top B states from this order .
Note that comparison with Rand ( ie , the algorithm that
( a ) Road network
( b ) Web network
( c ) Science network
Figure 3 : Real networks ; x axis : number of nodes where content is placed ; y axis : the expected CR . selects random B nodes ) is omitted since its performance is many orders of magnitude worse than any other algorithms . 5.2 Experimental results
In this section , we report the experimental results on the three real datasets we described above . Our results demonstrate the superior quality of the solutions obtained by Greedy ( and Par Greedy ) and the scalability of our algorithms reasonably large datasets . Qualitative evaluation : For the qualitative evaluation of our framework we run the Greedy algorithm as well as all the baseline algorithms ( ie , Rank , Stationary , Degree and Basic ) for all our datasets and report the expected conversion rate of the solutions they obtained as a function of the budget B = {1 , . . . , 200} .
Results for the Road and Web datasets : The results obtained for the Road and the Web graph are shown in Figures 3(a ) and 3(b ) . For both datasets we observe that Greedy gives clearly the best results when compared to all other baseline algorithms . Also in both datasets the ranking of the rest of the heuristics is consistent : Basic and Rank are the second best , with Stationary and Degree to follow with solution with much lower expected conversion rates . The fact that Rank gives better results than Stationary is expected since the former takes both the stationary distribution and the conversion probability of each node into account when forming its solutions , while the latter only looks at the stationary probability . Moreover , the relatively poor performance of Degree is also expected since the degree of the nodes is not necessarily correlated neither with its conversion probability nor its stationary distribution . Finally , the fact that Basic and Rank have almost identical performance is due to the fact that the C( , s ) values are much larger ( in scale ) than the stationary probability values and , therefore , the choices of the two algorithms are very similar .
Although the general trends observed in both the Road and the Web datasets are similar , one can also observe some high level differences . More specifically , for the Road network ( Figure 3(a ) ) the expected conversion rate of the solutions obtained by Greedy increases almost linearly with the size of the solution B . On the other hand , for the Web dataset ( Figure 3(b ) ) the increase appears to be steeper , ie , the Greedy solutions appear to benefit tremendously by the addition of new nodes in the solution . We conjecture that this effect is a result of the “ diversity ” of the nodes in the Web graph . That is , in the Road network there are no “ special ” nodes – after all nodes simply correspond to road intersections with an ( average ) degree equal to four . On the other hand , the nodes of the Web dataset have larger diversity and the in degrees of the nodes are distributed in a power law fashion .
Results for the Science dataset : We also evaluate the performance of our methodology on even larger networks , we have experimented with Science dataset , which is an order of magnitude ( in terms of the number of edges ) larger than the other two . For this experiment , we have restricted our set of candidate nodes to a set of approximately 500 nodes sampled from the set of nodes in the graph with probability proportional to their in degree . The expected conversion rate achieved by the solutions of the different algorithms are shown in Figure 3(c ) . For this experiment , we use the parallel implementation of Greedy , which we call Par Greedy . Although the superiority of our method is clear in this dataset as well , the relative performance of the other heuristics is different in Science ; to see this compare the ranking of the baseline algorithms as indicated by the results in Figure 3(c ) with the ranking obtained by the results for the Road and Web datasets – shown in Figures 3(a ) and 3(b ) . We can observe that for Science the performance of Degree is clearly the second best , giving solutions between than Rank and Stationary . Clearly part of this change is due to the fact that we are only considering a subset of the nodes as candidates for content placement . More over , this subset is selected in such a way that is biased towards nodes with high in degree . As a result , among those candidates there are not so many nodes with high stationary probability and high conversion probability and , as a result , neither the Rank nor the Stationary algorithms perform as well as Degree . In fact , when we ran the experiment using all nodes as candidates , we would have obtained the same relative ranking for all baselines .
It is important to observe that in Figure 3(c ) the expected conversion rate of the solutions obtained by our algorithm increases steeply as a function of the size of the solution . This steep increase resembles the results we obtained for the Web dataset – shown in Figure 3(b ) . The explanation we had in that case , applies here as well : the nodes in the science graph ( as well as the candidate nodes ) have diverse degrees following a power law like distribution . Running times : In order to give an idea of the actual computational time required to run our experiments , we report here the running time required for executing one step of the Greedy algorithm , ie , the execution of the for loop shown in line 3 of Algorithm 1 .
Table 1 shows the running times of this execution both for the Greedy and Par Greedy algorithms . Recall that Par
0 0.02 0.04 0.06 0.08 0.1 0.12 0.14 0.16 0.18 0 50 100 150 200CRBudget ( B)GreedyRankDegreeStationaryBasic 0 0.02 0.04 0.06 0.08 0.1 0.12 0.14 0 50 100 150 200CRBudget ( B)GreedyRankDegreeStationaryBasic 0 0.002 0.004 0.006 0.008 0.01 0.012 0.014 0 50 100 150 200CRBudget ( B)GreedyRankStationaryDegreeBasic Greedy executes the searching over the candidates in a parallel fashion . All the experiments were conducted using the configuration we described in the beginning of this section . The results demonstrate that the parallel version of our algorithm offers an order of magnitude speedup to its corresponding serial implementation . Even further , the evaluation of our candidate set for the Science network was impossible to execute in the serial implementation of Greedy , but it was done in less than an hour using Par Greedy .
Table 1 : Running time of Greedy and Par Greedy for the selection of the first node of their solution .
Dataset Road Web
Science
Greedy
131 secs
7920 secs ( 2.2 hours ) n/a
Par Greedy
16 secs 670 secs 2884 secs
6 . CONCLUSIONS
In this paper , we introduced the RACP problem in navigational graphs , we studied its complexity and designed practical algorithms for solving it . The distinguishing feature of our work when compared to other existing work in information , transportation and navigational networks is that we consider memory full user navigation , where the probability of a user adopting a content depends on the number of times she has seen the same content in the past .
The main technical contribution of the paper is the development of a framework for solving the RACP problem , while taking into account both the users’ navigational and conversion models . The first model describes how the users navigate in the graph , while the other models the impact that repetition has on their inclination to adopt content placed on the graph nodes . The algorithmic framework we introduced here is flexible and can work for any navigational model that is described by a Markov chain and any conversion model that models the probability of a user adopting a content as a function of the state of the user and the number of her encounters with the content . Our algorithms exploit a connection between our model and random walks with absorbing states and provide a practical solution to the RACP problem . Our experimental evaluation on real datasets demonstrated the efficacy of these algorithms in multiple settings .
Acknowledgments : This research was supported in part by NSF grants CNS 1017529 , IIS 1218437 , CAREER 1253393 , CISE/CNS 1239021 , CISE/CNS 1012798 and ENG/EFRI0735974 as well as gifts from Microsoft and Google .
7 . REFERENCES [ 1 ] D . Agarwal , B C Chen , and P . Elango .
Spatio temporal models for estimating click through rate . In WWW , pages 21–30 , 2009 .
[ 2 ] O . Berman , D . Krass , and C . Wei Xu . Generalized flow interception facility location models with probabilistic customer flows . Communications in Statistics . Stochastic Models , 13(1):1–25 , 1997 .
[ 3 ] O . Berman , D . Krass , and W . Xu . Locating discretionary service facilities based on probabilistic customer flows . Transportation Science , 29 , 1995 .
[ 4 ] S . Brin and L . Page . The anatomy of a large scale hypertextual web search engine . In WWW , pages 107–117 , 1998 .
[ 5 ] R . F . Bruner . Repetition is the first principle of all learning . Social Science Research Network , 2001 .
[ 6 ] M . Charikar , R . Kumar , P . Raghavan , S . Rajagopalan , and A . Tomkins . On targeting markov segments . In STOC , pages 99–108 , 1999 .
[ 7 ] N . Chen . On the approximability of influence in social networks . In SODA , pages 1029–1037 , 2008 .
[ 8 ] F . Chierichetti , R . Kumar , and P . Raghavan . Markov layout . In FOCS , pages 492–501 , 2011 .
[ 9 ] P . Domingos and M . Richardson . Mining the network value of customers . In ACM SIGKDD , pages 57–66 , 2001 .
[ 10 ] P . Doyle and J . Snell . Random walks and electric networks . Mathematical Association of America , 1984 .
[ 11 ] E . Even Dar and A . Shapira . A note on maximizing the spread of influence in social networks . In WINE , pages 281–286 , 2007 .
[ 12 ] M . Garey and D . S . Johnson . Computers and
Intractability : A Guide to the Theory of NP Completeness . WH Freeman , 1979 .
[ 13 ] M . J . Hodgson . A flow capturing location allocation model . Geographical Analysis , pages 270–290 , 1990 .
[ 14 ] M . J . Hodgson , K . Rosing , A . Leontien , and
G . Storrier . Applying the flow capturing location allocation model to an authentic network : Edmonton , canada . European Journal of Operational Research , pages 427–443 , 1996 .
[ 15 ] J . Kemeny and J . Snell . Finite Markov chains .
VanNostrand , New York , 1969 .
[ 16 ] D . Kempe , J . Kleinberg , and E . Tardos . Maximizing the spread of influence throw a social network . In ACM SIGKDD , pages 137–146 , 2003 .
[ 17 ] P . Kotler and G . Armstrong . Principles of Marketing .
Pearson Education , Prentice Hall , 2005 .
[ 18 ] J . Leskovec , A . Krause , C.Guestrin , C.Faloutsos ,
J.VanBriesen , and NGlance Cost effective outbreak detection in networks . In ACM SIGKDD , pages 420–429 , 2007 .
[ 19 ] M . Richardson and P . Domingos . Mining knowledge sharing sites for viral marketing . In ACM SIGKDD , pages 61–70 , 2002 .
[ 20 ] K . Tanaka and T . Furuta . Locating flow capturing facilities on a railway network with two levels of coverage . In The Ninth International Symposium on Operations Research and Its Applications , 2010 .
[ 21 ] J . S . Trent , R . V . Friedenberg , and R . E . J . Denton . Political Campaign Communication : Principles and Practices ( Communication , Media , and Politics ) . 2011 .
[ 22 ] C . J . Weibell . Principles of learning : A conceptual framework for domain specific theories of learning . PhD thesis , Brigham Young University . Department of Instructional Psychology and Technology , 2011 .
