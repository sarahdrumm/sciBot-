Mining Lines in the Sand : On Trajectory Discovery From
Untrustworthy Data in Cyber Physical System
Lu An Tang1 , Xiao Yu1 , Quanquan Gu1 , Jiawei Han1 , Alice Leung2 , Thomas La Porta3
1Department of Computer Science , University of Illinois at Urbana Champaign ;
2BBN Technology ; 3Department of Computer Science , Pennsylvania State University ;
{tang18 , xiaoyu1 , qgu3 , hanj}@illinois.edu , aleung@bbn.com , tlp@csepsuedu
ABSTRACT A Cyber Physical System ( CPS ) integrates physical ( ie , sensor ) devices with cyber ( ie , informational ) components to form a context sensitive system that responds intelligently to dynamic changes in real world situations . The CPS has wide applications in scenarios such as environment monitoring , battlefield surveillance and traffic control . One key research problem of CPS is called “ mining lines in the sand ” . With a large number of sensors ( sand ) deployed in a designated area , the CPS is required to discover all the trajectories ( lines ) of passing intruders in real time . There are two crucial challenges that need to be addressed : ( 1 ) the collected sensor data are not trustworthy ; ( 2 ) the intruders do not send out any identification information . The system needs to distinguish multiple intruders and track their movements . In this study , we propose a method called LiSM ( Line in the Sand Miner ) to discover trajectories from untrustworthy sensor data . LiSM constructs a watching network from sensor data and computes the locations of intruder appearances based on the link information of the network . The system retrieves a cone model from the historical trajectories and tracks multiple intruders based on this model . Finally the system validates the mining results and updates the sensor ’s reliability in a feedback process . Extensive experiments on big datasets demonstrate the feasibility and applicability of the proposed methods .
1 .
INTRODUCTION
A Cyber Physical System ( CPS ) is an integration of sensor networks with informational devices [ 2 ] . The CPS employs a large number of low cost , densely deployed sensors to watch over designated areas and automatically discover passing intruders . Such a system has many promising applications in both military and civilian fields , including missile defense [ 4 ] , battlefield awareness [ 3 , 15 ] , traffic control [ 9 , 17 ] , neighborhood watch [ 6 ] , environment monitoring [ 16 ] and wildlife tracking [ 7 ] . The key problem in the above applications is called “ mining lines in the sand ” [ 1 ] , ie , discov
Figure 1 : The Framework of Battlefield CPS ering the trajectories of passing intruders from the collected sensor data .
Figure 1 shows the framework of a battlefield CPS : The sand ( seismic , acoustic and magnetic sensors ) is deployed in a designated area . It constantly collects signals of vibration , sound and magnetic force from the environment . When an intruder passes by , the sensors detect a signal change and send out detection records . The system analyzes the collected data and discovers the intruder trajectories in real time . Such a system can help military forces see through the “ fog of war ” and protect troops and bases on the battlefield .
However , the topic of “ mining lines in the sand ” is considered one of the major challenges in CPS research field , partly due to the following problems : • Untrustworthy data : Many deployment experiences have shown that untrustworthy ( ie , faulty ) data is the most serious problem that impacts CPS performance [ 13 , 16 ] . Untrustworthy data are generated due to various reasons , including hardware failure , communication limits , environmental influences and so on . It is difficult to filter them out solely based on the signal value , because the values of faulty signals are similar to correct ones .
• Tracking intruders : There are usually multiple intruders in the monitoring area and the system is required to track all of them . Since the intruders do not send out any identification information , the system has to distinguish them and track their movements . Many previous methods make sensors(ie,sand)seismic,acousticandmagneticsensorsdatacenteranalyzingthesensorrecordsandminingthelinesintrudero1intrudero1intrudero2intrudero2gatewaysensorstransmittingthesensorrecordstothedatacenter the assumption of single intruder and cannot discover multiple ones in real applications .
• Big data : A CPS usually contains hundreds , even thousands of sensors [ 2 ] . Each sensor generates a data record every few minutes ; such records form a big dataset . In several applications , actions must be taken immediately to deal with the intruders . The system is required to discover trajectories in real time . In this study , we propose a novel system called LiSM ( Line in the Sand Miner ) to discover intruder trajectories from untrustworthy sensor data . LiSM first constructs a watching network to model the relationship among the sensors , data records and intruders . Then LiSM detects the intruder ’s appearances based on the link information of the watching network . To track multiple intruders , a cone model is proposed to generate the intruder trajectories . The system employs a validation process to filter out false positives and updates sensor reliability scores . The technical contributions of this study are summarized as follows . • We construct a watching network to model the relationship among the sensors , records and intruders . Such a network helps locate the intruder appearances in every timestamp .
• We propose a cone model to track multiple intruders . The cone model is an effective tool to generate trajectories from the detected intruder appearances .
• The system validates the candidate results and filters out false positives . Then the system updates the sensor reliability scores in a feedback process .
• We conduct extensive experiments to evaluate the effectiveness and efficiency of proposed methods on big datasets . The experiment results show that our approach yields higher precision and recall than existing methods . The rest of the paper is organized as follows . Section 2 introduces the background knowledge and problem formulation ; Section 3 proposes the techniques of constructing the watching network , Section 4 introduces the trajectory mining methods ; Section 5 conducts the performance evaluations ; Section 6 briefly comments on related work ; and Section 7 concludes the paper .
2 . PROBLEM STATEMENT
Recent advances in sensor technology have produced many types of sensors for area watching purposes . Such sensors can be roughly classified into two categories by mechanism : ( 1 ) Active sensor ( eg , the infrared sensors and radar sensors ) : these sensors radiate signal pulses and detect objects by the echo bouncing off the intruders ; ( 2 ) Passive sensor ( eg , the acoustic sensors , seismic sensors and magnetic sensors ) : these sensors only receive signals from the environment . Active sensors achieve higher accuracy , but require significant more power to operate and drain batteries quickly . Furthermore , when active sensors radiate signal pulses , they are at high risk of being detected by the intruders . As a result , the CPS is usually deployed with a large number of low cost , energy saving passive sensors .
Passive sensors constantly collect signals of sound , vibration and magnetic forces from the environment . When an intruder passes by , the sensors detect it based on the signal changes . However , due to hardware limitation , the sensors can only report the area of an intruder ’s possible appearance , rather than a concrete point location . In this study ,
Figure 2 : Example : The Detection Records we model the reported area as a planar region bounded by a circle .
Definition 1 . ( Detection Record ) Let si be a sensor and tj be a timestamp , the detection record ri,j is generated by si to indicate the possible area of an intruder ’s appearance in tj . ri,j={cen(ri,j ) , rad(ri,j)} , where cen(ri,j ) and rad(ri,j ) are the center and radius of the area .
Example 1 . Figure 2 shows a list of detection records in time t1 . The solid triangle node is the intruder o1 . The round nodes are nearby sensors watching the area where o1 passes . The solid round nodes ( red ) are the responding sensors that send out detection records , such as s1 , s2 and s7 . The centers of the estimated regions are tagged as hollow triangles . Sensor s6 is a non responding sensor that does not generate any detection record . It is tagged as a shadowed round node ( blue ) .
Example 1 reveals three major problems with passive sensors : ( 1 ) Even when the intruder is detected by multiple sensors , each sensor reports the intruder ’s appearance with a margin of error . Those detection records should be aggregated for a more accurate result ; ( 2 ) Some false positive records are generated , such as r2,1 and r5,1 . The system must filter them out ; ( 3 ) The sensor , s6 , should send out a detection record but it fails to do so . It is a false negative .
Definition 2 . ( Valid Detection ) Let qk,j be the position of intruder ok in time tj . A record ri,j is a valid detection if there exists an intruder ok that dist(cen(ri,j ) , qk,j ) ≤ rad(ri,j ) .
False positive and false negative records are caused by various reasons , such as the wind blowing and animal movements . Sensor reliability is a critical factor that impacts the quality of detection results . We introduce two measurements of the sensor ’s reliability , as defined below .
Definition 3 . ( Robustness ) Let s be a sensor , the robustness ϕ(s ) denotes the proportion of valid detections in all the records generated by s .
Definition 4 . ( Sensitivity ) Let s be a sensor , the sensitivity ψ(s ) denotes the probabilities that s sends out a valid detection record when an intruder passes through s ’s watching area .
Knowledge of the sensor ’s robustness and sensitivity are important for filtering out false data . However , the two scores may change over time . In the beginning , the sensor ’s robustness and sensitivity are both high . As time elapses , sensors may be damaged by the harsh environment , or run out of battery power . Therefore , both scores will drop and s1o1s2s3s4s5s6s7recordr1,1r2,1r4,1r5,1r7,1center(97,109)(95,123)(105,99)(125,84)(92,98)r3,1(105,107)intrudero1position(100,100)r1,1r2,1r3,1r4,1r5,1r7,1radius10108767 Theoretically , if there is a real intruder appearing in the reported area of ri,j , all the sensors of S(ri,j ) should send out detection records . However , only a subset of them send records to indicate the intruder ’s appearance around ri,j . The set of watching sensors is partitioned into two parts of responding sensors and non responding sensors .
Definition 7 . ( Responding Sensors ) Let ri,j be a detection record , and S(ri,j ) be the watching sensor set of ri,j , the responding sensor set Sr(ri,j ) = {sk|sk ∈ S(ri,j ) , dist(cen(rk,j ) , cen(ri,j ) ) ≤ rad(rk,j ) + rad(ri,j)} , the nonresponding sensor set Sn(ri,j ) = S(ri,j ) − Sr(ri,j ) .
Based on Definitions 6 and 7 , we can construct a watching network . This network contains nodes representing sensors and records . Two types of links are constructed in the network : positive links connect records to responding sensors and negative links connect records to non responding sensors . Example 2 . Figure 4 shows a watching network constructed from the records in Example 1 . For each record ri,j , the system draws a circle with center at cen(ri,j ) and radius as range(s ) + rad(ri,j ) . The watching sensors S(ri,j ) are located inside this circle ( We only draw a circle of r4,1 in Figure 4 for simplicity ) . The system then connects records with positive links ( solid lines ) to responding sensors , and generates negative links ( dashed lines ) between records and non responding sensors . Since sensor s6 does not send any record , it has negative links to all the related records . Note that even though s2 is a watching sensor of r4,1 and s2 sends out a detection record r2,1 , the distance between cen(r4,1 ) and cen(r2,1 ) is larger than rad(r4,1)+rad(r2,1 ) , thus the link between s2 and r4,1 is a negative link .
Figure 4 : Example : The Watching Network
In the sensor data , many detection records are caused by the same intruder , eg , r1,1 , r3,1 and r4,1 are caused by intruder o1 . Such records are called homologous records . Definition 8 . ( Homologous Records ) Let qk,j be the position of intruder ok in time tj and Rj be the detection record set in tj . The homologous record set Hk,j = {r|ri,j ∈ Rj , dist(cen(ri,j ) , qk,j ) ≤ rad(ri,j)} .
If the intruder ’s position , qk,j , is known in advance , the system can easily find the homologous records . However , the intruder ’s position is exactly required as the mining result . The system has to approximate the homologous records based on the following property .
Property 1 . Let Hk,j be a homologous record set in tj , ri,j , rl,j ∈ Hk,j be two records , and si , sl be the sensors that send out those records . Then si is a responding sensor of rl,j and sl is a responding sensor of ri,j .
Figure 3 : List of Notations they should be dynamically updated based on the detection results .
The intruder is an object entering the watching area . The system discovers the intruder ’s movement as an intruder trajectory , which is a sequence of intruder appearances in different timestamps .
Definition 5 . ( Intruder Trajectory ) Let ok be an intruder and tj be a timestamp ; the intruder appearance pk,j is a spatial coordinate estimated by the system to indicate ok ’s position in tj . The intruder trajectory Lk is a sequence of ok ’s appearances , Lk = {pk,1 , pk,2 , . . . , pk,n} .
Since users are only interested in trajectories that are long enough , they may set a threshold δ on the trajectory size . In addition , the sensor data arrive continuously in a data stream format . The system cannot output the results after scanning the whole dataset . Users require intruder trajectories to be discovered in the data stream .
Now we formally define the problem of “ mining lines in the sand ” . Problem Statement : Let S be the set of sensors and R be the sensor data arriving by time , R = {R1 , R2 , . . . , Rj , . . .} , where Rj = {r1,j , r2,j , . . . , rm,j} . The sensors’ locations are fixed and their robustness and sensitivity scores are initialized . Given a length threshold δ , the task of “ mining lines in the sand ” is to discover the set of intruder trajectories L={L1 , L2 , . . . , Lk} in real time , where size(Lk ) ≥ δ .
Note that the total number of intruders is not known in advance . LiSM is required to discover the trajectories of all the intruders entering the watching area . We will introduce the detailed techniques of LiSM in the following sections . Figure 3 lists the notations used throughout this paper . 3 . THE WATCHING NETWORK
In Example 1 , s1 , s3 and s4 all detect the appearance of intruder o1 . However , another nearby sensor , s6 , should detect the intruder but does not generate any record . Such non responding sensor disagrees with its responding neighbors . Therefore , the first task of LiSM is to retrieve the hidden relationships of these sensors and intruders .
Definition 6 . ( Watching Sensors ) Let S be the sensor set and ri,j be a detection record , the watching sensor set S(ri,j ) = {s|s ∈ S , dist(s , cen(ri,j ) ) < range(s)+rad(ri,j)} , where dist(s , cen(ri,j ) ) denotes the distance between sensor s and the center of ri,j , range(s ) is s ’s maximum sensing range .
Notation Explanation Notation Explanation S the sensor set si , sj , sk the sensors O the intruder set oi , oj , ok the intruders Rj the record set in tj ri,j the detection record by sensor si at tj ti , tj the time stamp qk,j the position of ok in tj pi,j , pk,j the intruder appearance ( cid:306)(pi,j ) the trustworthiness of pi,j Li , Lk the intruder trajectory kL the ( cid:550) recent trajectory ( cid:307)(si ) the robustness of si ( cid:549 ) ( si ) the sensitivity of si S(ri,j ) , S(pk,j ) the watching sensor set of ri,j / pk,j Sr(ri,j ) , Sr(pk,j ) the responding sensor set of ri,j / pk,j Sn(ri,j ) , Sn(pk,j ) the non responding sensor set of ri,j / pk,j Ej(Lk ) the expectation of Lk Gj the watching network in time tj ( cid:533 ) the decay factor s1s2s3s4s5s6s7r1,1r2,1r3,1r4,1r5,1r7,1s1s2s3s5s6s4s7r2,1r1,1r3,1r7,1r4,1r5,1 an appearance pk,j , let si ∈ Sr(pk,j ) be a responding sensor , and sj ∈ Sn(pk,j ) be non responding sensor . If pk,j is a real appearance , then si reports a valid detection and sj is a false negative . The probability of pk,j being a valid detection is calculated as Eq 2 , where ϕ(si ) is the robustness of si and ψ(sj ) is the sensitivity of sj . ϕ(si ) ·
( 1 − ψ(sj ) )
Pr ( pk,j)+ =
( 2 ) si∈Sr ( pk,j ) sj∈Sn(pk,j )
Similarly , the probability of pk,j being a false positive can be written as Eq 3 .
−
Pr ( pk,j )
=
( 1 − ϕ(si ) ) ·
ψ(sj )
( 3 ) si∈Sr ( pk,j ) sj∈Sn(pk,j )
The trustworthiness of intruder appearance , τ ( pk,j ) , is then calculated as Eq 4 . Pr ( pk,j)+ − Pr ( pk,j )
τ ( pk,j ) = log
∝
ϕ(si ) 1 − ϕ(si )
+ si∈Sr ( pk,j ) sj∈Sn(pk,j )
1 − ψ(sj ) ψ(sj )
( 4 )
Figure 6 lists the algorithm to detect the intruder appearances . The algorithm first scans each detection record and retrieves the responding and non responding sensors ( Lines 1 – 4 ) . Then the system initializes the homologous record Hk,j by randomly picking a seed record from the watching network ( Lines 6 – 7 ) . For each unvisited record ri,j in Hk,j , the algorithm retrieves ri,j ’s responding sensors and checks its record rl,j . If rl,j does not belong to any existing homologous record sets and the distances from rl,j to all other records of Hk,j is less than the sum of the radius , rl,j is then added to Hk,j ( Lines 8 – 14 ) . Once Hk,j is generated , the system calculates the intruder appearance pk,j and adds it to the network ( Lines 15 – 18 ) .
Proof : Let qk,j be the position of the corresponding intruder in Hk,j . According to Definition 8 , dist(cen(ri,j ) , qk,j ) ≤ rad(ri,j ) and dist(cen(rl,j ) , qk,j ) ≤ rad(rl,j ) . Based on triangle inequality , dist(cen(ri,j),cen(rl,j ) ) ≤ dist(cen(ri,j),qk,j ) + dist(cen(rl,j),qk,j ) ≤ rad(ri,j ) + rad(rl,j ) .
By Definition 7 , si is a responding sensor of rl,j and sl is a responding sensor of ri,j .
The homologous record sets can be generated on the watching network . The system first picks a record as the seed to initialize a homologous record set , and retrieves all the responding sensors following the positive links . The records of those responding sensors are checked and added to the homologous record set .
Once the homologous record set is generated , we can estimate the position of an intruder appearance with Eq 1 , where λi,j is a normalized weight based on the radius of ri,j . The records with with lower uncertainty ( ie , smaller radius ) have higher weights in determining the position of intruder appearance . Note that we adopt a linear model to compute λi,j for general cases , the weight computation can be modified based on specific signal decay models of the sensors . pk,j = ri,j∈Hk,j
λi,j = 1 −
λi,j · cen(ri,j ) rad(ri,j ) rad(rl,j ) rl,j∈Hk,j
( 1 )
Then the system retrieves the set of watching sensors for the newly computed intruder appearance and finds its responding and non responding sensors .
Definition 9 . Let S be the sensor set and pk,j be an intruder appearance , the watching sensor set S(pk,j ) = {s|s ∈ S , dist(s , pk,j ) < range(s)} . Definition 10 . Let pk,j be an intruder appearance , and S(pk,j ) is the watching sensor set of pk,j , the responding sensor set Sr(pk,j ) = {si|si ∈ S(pk,j ) , dist(pk,j,cen(ri,j ) ) ≤ rad(ri,j)} , the non responding sensor set Sn(pk,j ) = S(pk,j)Sr(pk,j ) .
The intruder appearances are added as new nodes to the watching network . Similarly , the positive and negative links are connected between the sensors and the appearances , as shown in Figure 5 .
Figure 5 : Example : The Watching Network with Intruder Appearances
With the link information of the watching network , we can estimate the trustworthiness of each intruder appearance based on the sensor ’s robustness and sensitivity . For
Figure 6 : Algoirthm : The Intruder Appearance Detection s1s2s3s5s6s4s7r2,1r1,1r3,1r7,1r4,1r5,1p1,1p2,1p3,1s1s2s3s4s5s6s7r1,1r2,1r3,1r4,1r5,1r7,1p1,1p2,1p3,1Algorithm 1 . The Intruder Appearance Detection Input : The record set Rj in time tj , the sensor set S . Output : The watching network Gj . 1 . initialize Gj ; 2 . for each detection record ( cid:1861),(cid:1488 ) 3 . add ( cid:1861 ) , to Gj ; 4 . compute ( (cid:1861) , ) and ( (cid:1861), ) , construct the links ; 5 . repeat 6 . random select a record as the seed ; 7 . initialize homologous record set ( cid:1834)(cid:1863 ) , by the seed ; 8 . for each unvisited record ( cid:1861),(cid:1488)(cid:1834)(cid:1863 ) , 9 . tag ( cid:1861 ) , as visited ; 10 . for each responding sensor sl in ( cid:3435)(cid:1861),(cid:3439 ) 11 . if ( cid:1864 ) , does not belong to any record set 12 . for each record ( cid:1865),(cid:1488)(cid:1834)(cid:1863 ) , 13 . if ( cid:1856)(cid:1861)((cid:1855)(cid:1857)((cid:1865),),(cid:1855)(cid:1857)((cid:1864),))(cid:1853)(cid:1856)(cid:3435)(cid:1865),(cid:3439)+(cid:1853)(cid:1856)((cid:1864) , ) 14 . add ( cid:1864 ) , to ( cid:1834)(cid:1863) , ; 15 . compute the intruder appearance ( cid:1868)(cid:1863 ) , from ( cid:1834)(cid:1863) , ; 16 . add ( cid:1868)(cid:1863 ) , to Gj ; 17 . compute ( cid:3435)(cid:1868)(cid:1863),(cid:3439 ) and ( cid:3435)(cid:1868)(cid:1863),(cid:3439 ) , construct the links ; 18 . calculate ( cid:2028)((cid:1868)(cid:1863), ) ; 19 . until all the records of Gj are processed ; 20 . return Gj ; 4 . TRAJECTORY GENERATION
The watching network discovers the intruder appearances in each snapshot . It is an effective tool for “ mining dots in the sand ” . However , a more critical task is “ connecting the dots as lines ” . Since the intruders do not send out any identification information , the system has to distinguish them automatically .
After mining the intruder appearances in the first snapshot , LiSM initializes a set of candidate trajectories . Each candidate trajectory contains a discovered intruder appearance . In the following snapshots , the system matches the newly detected intruder appearances with the candidate trajectories . The appearances with the highest matching probabilities are added to the corresponding candidate trajectories .
We make the assumption that the values of intruder speed and direction follow a normal distribution , and build a cone model to predict the area of ok ’s appearance in tj .
Example 3 . Figure 7 shows the cone model for intruder ok . Suppose ω is set to 5 ; the system retrieves ok ’s latest five appearances as Lω k , and computes ok ’s speed and direction . If those parameters follow a normal distribution , the probability is 99.7 % that ok’ speed and direction of period [ tj−1 , tj ] are within three standard deviations of the mean values . The system calculates the four boundary points as shown in Figure 7 . The area of ok ’s next possible appearance is then generated as a partial cone with apex in pk,j−1 .
Let pi,j be an intruder appearance in time tj , Lk be a candidate trajectory , the trustworthiness of pi,j belonging to Lk is computed as shown in Eq 5 , where τ ( pi,j ) is the trustworthiness of pi,j , and P ( pi,j , Lk ) is the matching probability of pi,j and Lk .
τ ( pi,j ∈ Lk ) = τ ( pi,j ) · P ( pi,j , Lk )
( 5 )
The key issue is computing the matching probability between an intruder appearance and a candidate trajectory . To this end , we propose the cone model . This model stores the intruder ’s recent moving history and predicts the intruder ’s next move in a cone area . The detected intruder appearances are projected on to the area to compute the matching probability .
Definition 11 . ( ω recent Trajectory ) Let Lk be the trajectory of intruder ok , tj be the current timestamp and ω be a positive number , ω ≤ size(Lk ) . The ω recent trajectory k = {pk,j−ω , pk,j−ω+1 , . . . , pk,j−1} . k is a subset of Lk , Lω Lω The ω recent trajectory contains the ω latest appearances of intruder ok before time tj . It is a short history of the intruder ’s movement . The system can calculate ok ’s recent moving speed and direction based on Lω k . The mean and deviation of the intruder speed in period [ tj−ω , tj−1 ] are calculated as shown in Eqs . 6 and 7 .
¯vk = i=j−ω j−2 j−2 i=j−ω dist(pk,i , pk,i+1 ) ( tj−1 − tj−ω ) dist(pk,i , pk,i+1)2 ( tj−1 − tj−ω )
σ(vk ) =
Figure 7 : Example : The Cone Model
Let pi,j be an intruder appearance in the cone area , and pk,j−1 be the latest intruder appearance of Lω k , if intruder ok moves from pk,j−1 to pi,j , then ok ’s speed and direction in [ tj−1 , tj ] are estimated as Eqs . 10 and 11 .
ˆvk,j = dist(pk,j−1 , pi,j )
( tj − tj−1 )
ˆθk,j = direction(pk,j−1 , pi,j )
( tj − tj−1 )
( 10 )
( 11 )
By comparing ˆvk,j and ˆθk,j , the system can estimate the matching probability between pi,j and Lk as Eq 12 .
( cid:182 )
( cid:181 ) − ( ˆvk,j − ¯vk)2 ( cid:195 ) − ( ˆθk,j − ¯vk)2
2σ(vk)2
2σ(θk)2
( 12 )
( 6 )
( 7 )
− ¯v2 k
P ( pi,j , Lk ) =
1√ 2πσ(vk ) 1√ 2πσ(θk )
· exp exp
We use the function direction(pk,i , pk,i+1 ) to measure the angle between ok ’s moving direction and the x axis in time [ ti , ti+1 ] . The mean and deviation of the moving direction are computed as shown in Eqs . 8 and 9 .
¯θk = i=j−ω j−2 j−2 i=j−ω
σ(θk ) = direction(pk,i , pk,i+1 ) ( tj−1 − tj−ω ) direction(pk,i , pk,i+1)2 ( tj−1 − tj−ω )
− θ
2 k
( 8 )
( 9 )
When intruders pass through the watching area , they are unlikely to change moving speed and direction dramatically .
Example 4 . Suppose there are three intruder appearances detected in tj , as shown in Figure 7 . p1,j and p2,j locates in the cone area and p3,j is outside the area . Their trustworthiness scores are : τ ( p1,j ) = 0.1 , τ ( p2,j ) = 0.8 , τ ( p3,j ) = 09 Even p3,j has the highest trustworthiness , it is impossible to be an appearance of Lk . By considering the matching probability and trustworthiness of remaining two appearances , the system selects p2,j as the intruder ’s appearance in tj .
Note that we make the assumption that the values of intruder speed and direction follow a normal distribution in this study . Based on our experiment results , this assumption works well . The cone model can be adopted to other distributions/models of the intruder movements . If the trajectory Lk does not contain enough intruder appearances ( ie , size(Lk ) ≤ ω ) , the system will construct a cone model with default speed v0 and σ(v0 ) . The default pk,j 1pk,j 5pk,j 4pk,j 2p3,jp2,jp1,jpk,j 3(3(),3())vv(cid:86)(cid:84)(cid:86)(cid:84)ffiffi(3(),3())vv(cid:86)(cid:84)(cid:86)(cid:84)ffi(3(),3())vv(cid:86)(cid:84)(cid:86)(cid:84)ffi(3(),3())vv(cid:86)(cid:84)(cid:86)(cid:84 ) parameters can be specified by the user , or calculated as the mean of all the other intruders’ ω recent trajectories . In such a case , the system also releases the constraint on movement direction ( ie , the intruder may move in any direction ) . The matching probability is then written as Eq 13 .
( cid:181 ) − ( ˆvk,j − ¯vk)2
2σ(vk)2
( cid:182 )
( 13 )
P ( pi,j , Lk ) =
1√ 2πσ(vk ) exp
Figure 8 shows the detailed steps of trajectory tracking . For each candidate trajectory Lk , Algorithm 2 first checks the trajectory size . If the size is larger than ω , the system retrieves ω recent trajectory Lω k and calculates the intruder ’s speed and direction . If the size of Lk is less than ω , the system uses the default parameters ( Lines 2 – 5 ) . Then the algorithm constructs the cone model . For each intruder appearance inside the cone area , the system calculates the matching probability . The one with the highest probability is tagged as “ matched ” and added in Lk ( Lines 6 – 15 ) . Finally the system initializes new candidate trajectories for the unmatched intruder appearances ( Lines 16 – 18 ) .
Figure 8 : Algorithm : The Trajectory Tracking
In Algorithm 2 , the system initializes new trajectories based on unmatched intruder appearances in every snapshot . However , majority of them are “ ghost trajectories ” . The ghost trajectories are generated by the untrustworthy appearances ( false positives ) , such as p2,1 , p3,1 in Figure 5 . It is a burden for the system to maintain them in memory . When the time elapses , real trajectories grow longer with more subsequent appearances added in , but ghost trajectories are unlikely to get more appearances . Hence we can eventually prune them .
Definition 12 . ( Trajectory Expectation ) Let Lk be a candidate trajectory and tj be the current timestamp , the trajectory expectation Ej(Lk ) denotes the expectation that Lk is a qualified mining result in time tj . Ej(Lk ) is defined as shown in Eq 14 , where t1 is the timestamp of the first intruder appearance in Lk , and β is a decay constant .
Ej(Lk ) =
τ ( pk,i ) − β(tj − t1 )
( 14 ) pk,i∈Lk
In the end of every snapshot , the system checks the expectation of each candidate trajectory . If the expectation is less than zero , such a trajectory is unlikely to become a qualified result and should be removed from main memory . Meanwhile , if a trajectory ’s length is longer than the threshold δ , the system will report it to the user .
In many CPS applications , the sensors may be damaged by the environment or run out of battery power as time elapses ; the system should also update the sensor ’s reliability scores . Let Lk be a candidate trajectory , Lk = {pk,1 , pk,2 , . . . , pk,n} . If Lk is removed from the candidate set as a ghost trajectory , all the intruder appearances of Lk will be tagged as “ ghost appearances ” . Let pk,j be such a ghost appearance . For all the responding sensors si ∈ Sr(pk,j ) , si has reported a false positive , and its robustness should be reduced . ϕ(si ) is then updated as shown in Eq 15 , where li is the number of false positives reported by si , and ni is the total number of detection records generated by si . ϕ(si ) = 1 − li ni
( 15 )
Meanwhile , if Lk is output as a qualified mining result , all the intruder appearances of Lk are considered to be true . Let pk,j be a true appearance , for the non responding sensor sj ∈ Sn(pk,j ) , sj has made a false negative error , the sensitivity of si is then reduced as shown in Eq 16 , where fi is the number of false negatives by si , mi is the total number of intruders passed through si ’s watching area . Let li be the number of false positives by si , and ni be the total number of detection records sent by si , mi = ni − li + fi .
ψ(si ) = 1 − fi mi
= 1 − fi ni − li + fi
( 16 )
5 . PERFORMANCE EVALUATION 5.1 Experiment Setup Datasets : To test the performance of LiSM in big and untrustworthy data , we generated four datasets based on the real military trajectories from the CBMANET project [ 5 ] , in which an infantry battalion moves from Fort Dix to Lakehurst during a mission lasting 3 hours . The data generator retrieves 20 to 40 vehicle trajectories from CBMANET and simulates sensor monitoring fields along their routes with 200 to 10,000 deployed sensors . Each sensor scans the designated area every 10 seconds . If an intruder passes by , the sensor generates a detection record . The data generator randomly selects some sensors as false positive reporters , which may generate detection records without any local intruder . The set of false negative reporters is also generated , such sensors may not send detection record when an intruder passes by . The detailed features of those datasets are listed in Figure 9 . Baselines : The proposed LiSM algorithm ( LM ) is compared with two baselines : ( 1 ) The Karlman Filtering based method ( KF ) ; ( 2 ) TruAlarm method with nearest neighboring tracking strategy ( TA ) [ 14 ] . Environments : The experiments are conducted on a PC with Intel 7500 Dual CPU 2.20G Hz and 3.00 GB RAM .
Algorithm 2 . The Trajectory Tracking Input : The candidate trajectory set ( cid:2423 ) , the watching network Gj in time , the positive number ( cid:2033 ) . Output : The updated trajectory set ( cid:2423 ) . 1 . for each trajectory ( cid:1838)(cid:1863)(cid:1488)(cid:2423 ) 2 . if size((cid:1838)(cid:1863))(cid:3410)(cid:2033 ) 3 . retrieve the ( cid:2033) recent trajectory ( cid:1838)(cid:1863)(cid:2033 ) ; 4 . calculate the moving parameters of ( cid:1838)(cid:1863)(cid:2033 ) ; 5 . else ( cid:1191)=0 , ( cid:2026)()=(cid:2026)()0 ; 6 . calculate the cone model of ( cid:1838)(cid:1863)(cid:2033 ) ; 7 . ( cid:2028)(cid:1865)(cid:1853)(cid:1876)=0 , ( cid:1868)(cid:1863),(cid:1370)(cid:1486 ) ; 8 . for unmatched appearance ( cid:1868)(cid:1861 ) , inside the cone area 9 . calculate ( cid:2028)(cid:3435)(cid:1868)(cid:1861),(cid:1488)(cid:1838)(cid:1863)(cid:3439 ) ; 10 . if ( cid:2028)(cid:3435)(cid:1868)(cid:1861),(cid:1488)(cid:1838)(cid:1863)(cid:3439)>(cid:2028)(cid:1865)(cid:1853)(cid:1876 ) 11 . ( cid:2028)(cid:1865)(cid:1853)(cid:1876)=(cid:2028)(cid:3435)(cid:1868)(cid:1861),(cid:1488)(cid:1838)(cid:1863)(cid:3439 ) ; 12 . ( cid:1868)(cid:1863),(cid:1370 ) ( cid:1868)(cid:1861 ) , 13 . if ( cid:1868)(cid:1863),(cid:3405)(cid:1486 ) 14 . add ( cid:1868)(cid:1863 ) , to ( cid:1838)(cid:1863 ) ; 15 . tag ( cid:1868)(cid:1863 ) , as matched ; 16 . for unmatched intruder appearances ( cid:1868)(cid:1861),(cid:1488)(cid:1833 ) 17 . initialize a trajectory ( cid:1838)(cid:1861 ) by ( cid:1868)(cid:1861) , ; 18 . add ( cid:1838)(cid:1861 ) to ( cid:2423 ) ; 19 . return ( cid:2423 ) ; The operating system is Windows 7 Enterprise . All the algorithms are implemented in Java on Eclipse 331 platform with JDK 150 The detailed parameter settings are listed in Figure 9 .
Figure 9 : Experiment Settings
5.2 Evaluations on Mining Efficiency
In the first experiment , we evaluate the efficiency of different algorithms with default parameters . The system processes LM , KF and TA on the four datasets and records their time costs . Figure 10(a ) shows the results on the four datasets . Note that the y axis is in logarithmic scale . In general , all three algorithms are efficient enough to process the data . LM achieves the best efficiency in all the cases , because the algorithm filters out low expectation trajectory candidates in each snapshot and tracks the trajectories quickly with the cone model .
Then we study the factors that influence LM ’s efficiency . We set the decay factor β from 0.05 to 0.2 and record the algorithm ’s time cost on datasets D1 to D4 in Figure 10(b ) . With larger β , the system prunes more candidate trajectories and achieves better time efficiency . We also study the algorithm ’s running time with trajectory size threshold δ and the recent trajectory length ω . Both parameters do not influence the algorithm ’s efficiency , so we omit the results here .
Figure 10 : Efficiency : ( a ) time costs on different datasets and ( b ) influence of β .
5.3 Evaluations on Mining Effectiveness
To evaluate the quality of mining results , we retrieve the intruders’ true trajectories as ground truth and compare against the mining results . There are two stage of “ mining lines in the sand ” : ( 1 ) detecting the intruder appearances ; ( 2 ) tracking their trajectories . In this experiment , we first compare the detected intruder appearances with the ground truth . If their distance is less than a reasonable error bound ( 20 meters ) , the detection is considered as a valid result . Then we check each generated trajectory Lk , if more than 90 % of Lk ’s intruder appearances can be matched to a real trajectory in the ground truth , we consider Lk as a valid trajectory . Finally , we compute two measurements to evaluate the algorithms’ effectiveness . • Precision : The proportion of valid appearances/trajectories over the mining results . This represents the algorithm ’s selectivity for filtering out false positives .
• Recall : The proportion of valid appearances/trajectories over the ground truth . This criterion shows the algorithm ’s sensitivity for detecting the intruders . The detection precision and recall of LM , KF and TA are shown in Figure 11 . All the three methods can achieve a relative high recall of about 80 % . However , the precision of KF and TA drops rapidly in D3 and D4 , which have more untrustworthy data . The precision of KF is less than 20 % in D4 , which is only one fourth of LM ’s precision . TA ’s precision is also lower than 50 % . In contrast , LM filters out the false positive data and keeps the precision over 80 % .
Figure 11 : Effectiveness : Detecting ( a ) precision and ( b ) recall of intruder appearances on different datasets .
Then we check the tracking precision and recall of the three algorithms . The results are shown in Figure 12 . TA ’s tracking performance is much worse than its detection effectiveness . The average precision is about 40 % and the recall is less than 20 % . This is caused by TA ’s tracking strategy : the nearest neighboring tracking method always selects the nearest intruder appearance to add to the candidate trajectory . When there are multiple intruders whose trajectories intersect , the nearest neighboring method is very likely to mix up their trajectories . KF ’s precision is also not high . This is due to the low precision of KF in the detection step . If the algorithm cannot detect the intruder appearances effectively in the first stage , the tracking results are inevitably influenced by the false positives . The precision and recall of LM are much higher ; both of them are around 80 % . These results indicate that LM is more suitable than TA and KF to process datasets with many untrustworthy reports .
In the next experiment , we investigate LM ’s precision and recall with different trajectory length threshold δ . The re
Dataset |O| |S| |Ri| |(cid:1337)| fp % fn % D1 10 225 27 2.9*105 10 % 5 % D2 20 2,500 57 6.1*105 20 % 10 % D3 30 3,600 121 1.3*106 40 % 20 % D4 40 10,000 326 3.5*106 50 % 30 % |O| : intruder number , |S| : sensor number ; |Ri| : the average size of detection record set in each snapshot ; |(cid:1337)| : the total size of the detection records ; fp % : the false positive rate , fn % : the false negative rate ; the size threshold ( cid:303 ) : 4 ( cid:177 ) 16 , default 12 ; the ( cid:550) recent trajectory ( cid:550 ) : 3 ( cid:177 ) 8 , default 6 ; the decay factor ( cid:533 ) : 0.05 ( cid:177 ) 0.2 , default 0.05 ; 1 10 100 1000 10000 100000 D1D2D3D4LMKLTN(a)Time(unit:millisecond)050001000015000200002500030000350000050101502D1D2D3D4(b)Time(unit:millisecond)(cid:533)D1D2D3LMKFTA0%20%40%60%80%100%D1D2D3D4LMKLTN0%20%40%60%80%100%D1D2D3D4LMKLTN(a)DetectingPrecision(b)DetectingRecallD1D2D3LMKFTAD1D2D3LMKFTA Figure 15 : Effectiveness : Detecting ( a ) precision and ( b ) recall wrt ω .
Figure 12 : Effectiveness : Tracking ( a ) precision and ( b ) recall of intruder trajectories on different datasets . sults are shown in Figures 13 and 14 . With larger δ , fewer trajectories are reported . Hence the algorithm ’s precision increases , but the recall drops . Based on the experiment results , our suggestion is to select moderate δ ( eg , 8 to 10 ) to make LM achieve the best performance .
Figure 13 : Effectiveness : Detecting ( a ) precision and ( b ) recall wrt δ .
Figure 14 : Effectiveness : Tracking ( a ) precision and ( b ) recall wrt δ .
Finally , we study the influences of parameter ω and β . The results of LM ’s effectiveness are recorded in Figures 15 to 18 . If the length of ω recent trajectory is too short , LM may not be able to track the intruder with an accurate cone model . The decay factor β is used to filter the candidate trajectories ; if it is set too large , the algorithm may prune some trustworthy candidates . The recall of LM is then reduced .
Figure 16 : Effectiveness : Tracking ( a ) precision and ( b ) recall wrt ω .
Therefore , ω should be set as a reasonable large value ( eg , 6 to 9 ) and β should be set relatively small ( eg , 005 )
6 . RELATED WORK
The problem of mining trajectories from sensor data has received increasing attention in recent years , the related studies can be loosely classified into two categories .
Intruder Detection . Arora et al . propose the intrusion detection problem in wireless networks and design a detection model with acoustic and magnetic sensors [ 1 ] . Ozdemir et al . use the techniques of particle filtering to detect intruders [ 11 ] . Sheng and Hu propose the maximum likelihood based estimation method [ 12 ] and Tang et al . propose the TruAlarm filtering method [ 14 ] .
The main concern of these methods is to detect the intruders in a single snapshot , ie , without considering the temporal information of the intruders’ movement . Some studies focus on saving sensors’ energy and communication bandwidth , they try to provide an optimal sensor deployment plan . LiSM actually complements those technologies and improves the system ’s applicability .
Trajectory Tracking . Lin et al . propose a framework for the in network intruder tracking [ 8 ] . Zhong et al . provide the techniques to track intruders with a sequence of alarming sensors [ 18 ] . Oh et al . propose the Markov Chain data association method for target tracking [ 10 ] .
In these studies , the researchers assume that the targets’ locations at each snapshot are already known . They focus on connecting the targets’ locations at different snapshots to generate trajectories . However , as pointed out in [ 1 ] ,
0%20%40%60%80%100%D1D2D3D4LMKLTN0%20%40%60%80%100%D1D2D3D4LMKLTN(a)TrackingPrecision(b)TrackingRecallD1D2D3LMKFTAD1D2D3LMKFTA60%70%80%90%100%2468D1D2D3D40%20%40%60%80%100%2468D1D2D3D4(a)DetectingPrecision(b)DetectingRecall(cid:303)(cid:303)48121648121660%70%80%90%100%2468D1D2D3D40%20%40%60%80%100%2468D1D2D3D4(a)TrackingPrecision(b)TrackingRecall(cid:303)(cid:303)48121648121660%70%80%90%100%36912D1D2D3D460%70%80%90%100%36912D1D2D3D4(a)DetectingPrecision(b)DetectingRecall(cid:550)(cid:550)60%70%80%90%100%36912D1D2D3D460%70%80%90%100%36912D1D2D3D4(a)TrackingPrecision(b)TrackingRecall(cid:550)(cid:550 ) oratory or the US Government . The US Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notice herein . 9 . REFERENCES [ 1 ] A . Arora , P . Dutta , and S . Bapat . A line in the sand : a wireless sensor network for target detection , classification , and tracking . Computer Networks , 46(5):605–634 , 2004 .
[ 2 ] T . N . S . Foundation . Cyber physical systems . In Program Announcements and Information , 2008 .
[ 3 ] M . Hewish . Reformatting fighter tactics . In Jane ’s
International Defense Review , 2001 .
[ 4 ] I . Hwang , H . Balakrishnan , K . Roy , and C . Tomlin .
Multiple target tracking and identity management in clutter , with application to aircraft tracking . In Proceedings of the American Control Conference , 2004 .
[ 5 ] T . Krout . Cb manet scenario data distribution . In
BBN Tech . Report , 2007 .
[ 6 ] X . Li , R . Lu , X . Liang , X . Shen , J . Chen , and X . Lin .
Smart community : an internet of things application . IEEE Communications Magazine , 49(11 ) , 2011 .
[ 7 ] Z . Li , J . Han , M . Ji , L . A . Tang , Y . Yu , B . Ding , J G
Lee , and R . Kays . Movemine : Mining moving object data for discovery of animal movement patterns . ACM Transactions on Intelligent Systems and Technology , 2(4 ) , 2011 .
[ 8 ] C . Lin , W . Peng , and Y . Tseng . Efficient in network moving object tracking in wireless sensor network . IEEE Transaction on Mobile Computing , 5(8 ) , 2006 .
[ 9 ] C . Lo and W . Peng . Carweb : A traffic data collection platform . In International Conference on Mobile Data Management , 2008 .
[ 10 ] S . Oh , S . Russell , and S . Sastry . Markov chain monte carlo data association for multi target tracking . IEEE Trans . Automat . Contr . , 54(3 ) , 2009 .
[ 11 ] O . Ozdemir , R . Niu , and P . K . Varshney . Tracking in wireless sensor network using particle filtering : Physical layer considerations . In IEEE Trans . on Signal Processing , 2009 .
[ 12 ] X . Sheng and Y . Hu . Maximum likelihood multiple source localization using acoustic energy measurements with wireless sensor networks . In IEEE Trans . on Signal Processing , 2005 .
[ 13 ] R . Szewczyk , J . Polastre , and J . Mainwaring . Lessons from a sensor network expedition . In European Workshop on Wireless Sensor Networks , 2004 . [ 14 ] L . Tang , X . Yu , S . Kim , J . Han , C . Hung , and
W . Peng . Tru alarm : Trustworthiness analysis of sensor networks in cyber physical systems . In ICDM , 2010 .
[ 15 ] L . A . Tang , Q . Gu , X . Yu , J . Han , T . F . L . Porta ,
A . Leung , T . F . Abdelzaher , and L . M . Kaplan . Intrumine : Mining intruders in untrustworthy data of cyber physical systems . In SDM , 2012 .
[ 16 ] G . Tolle , J . Polastre , and RSzewczyk A macroscope in the redwoods . In The ACM Conference on Embedded Networked Sensor Systems , 2005 .
[ 17 ] Y . Zheng and X . Zhou . Computing with Spatial
Trajectories . Springer , 2011 .
[ 18 ] Z . Zhong , T . Zhu , D . Wang , and T . He . Tracking with unreliable node sequences . In INFOCOM , 2009 .
Figure 17 : Effectiveness : Detecting ( a ) precision and ( b ) recall wrt β .
Figure 18 : Effectiveness : Tracking ( a ) precision and ( b ) recall wrt β . the intruder tracking results cannot be accurate based on many false intruder detections . To the best of our knowledge , LiSM is the first study to solve both detecting and tracking problems in an integrated framework . 7 . CONCLUSION AND FUTURE WORK
In this study we investigate the problem of mining trajectories in cyber physical systems . We propose a novel method , LiSM , to discover intruder trajectories from untrustworthy sensor data . The watching network is designed to detect intruder appearances and the cone model is used to track their trajectories . We evaluate the proposed algorithms in extensive experiments on big datasets . LiSM outperforms the state of the art methods on both detection and tracking tasks with higher precision and recall .
LiSM is proposed in 2D Euclidean environment . We are going to extend LiSM on more complicated scenarios such as the 3D environment , road networks and the indoor environment with obstacles . We are also interested in integrating more information , including the weather and local traffic , to improve the system performance . 8 . ACKNOWLEDGEMENTS
The work was supported in part by US National Science Foundation grants IIS 0905215 , CNS 0931975 , CCF0905014 , IIS 1017362 , the US Army Research Laboratory under Cooperative Agreement No.W911NF 09 2 0053 ( NSCTA ) and W911NF 11 2 0086 . The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies , either expressed or implied , of the Army Research Lab
80%85%90%95%100%0050101502D1D2D3D460%70%80%90%100%0050101502D1D2D3D4(a)DetectingPrecision(b)DetectingRecall(cid:533)(cid:533)40%50%60%70%80%90%100%0050101502D1D2D3D460%70%80%90%100%0050101502D1D2D3D4(a)TrackingPrecision(b)TrackingRecall(cid:533)(cid:533 )
