Spatial Scan Statistics : Approximations and Performance
Study
Deepak Agarwal Yahoo! Research
Andrew McGregor
University of Pennsylvania
Jeff M . Phillips Duke University
Suresh Venkatasubramanian
AT&T Labs – Research
Zhengyuan Zhu
University of North Carolina
ABSTRACT Spatial scan statistics are used to determine hotspots in spatial data , and are widely used in epidemiology and biosurveillance . In recent years , there has been much effort invested in designing efficient algorithms for finding such “ high discrepancy ” regions , with methods ranging from fast heuristics for special cases , to general grid based methods , and to efficient approximation algorithms with provable guarantees on performance and quality .
In this paper , we make a number of contributions to the computational study of spatial scan statistics . First , we describe a simple exact algorithm for finding the largest discrepancy region in a domain . Second , we propose a new approximation algorithm for a large class of discrepancy functions ( including the Kulldorff scan statistic ) that improves the approximation versus runtime trade off of prior methods . Third , we extend our simple exact and our approximation algorithms to data sets which lie naturally on a grid or are accumulated onto a grid . Fourth , we conduct a detailed experimental comparison of these methods with a number of known methods , demonstrating that our approximation algorithm has far superior performance in practice to prior methods , and exhibits a good performance accuracy trade off .
All extant methods ( including those in this paper ) are suitable for data sets that are modestly sized ; if data sets are of the order of millions of data points , none of these methods scale well . For such massive data settings , it is natural to examine whether small space streaming algorithms might yield accurate answers . Here , we provide some negative results , showing that any streaming algorithms that even provide approximately optimal answers to the discrepancy maximization problem must use space linear in the input .
Categories and Subject Descriptors G.3 Mathematics of Computing Probability and Statistics
General Terms Algorithms , Design , Performance
Keywords Spatial Scan Statistics , Kulldorff Scan Statistic , Discrepancy
1 .
INTRODUCTION
With the availability of massive data and cheap computing power , the problem of detecting “ hotspots ” has become ubiquitous and has received a lot of attention in data mining [ 7 , 15 , 14 ] . In particular , the special case of detecting “ bumps ” or local clusters in spatial data has found numerous applications in epidemiology , bio surveillance , astronomy etc . While a wide range of methods have been proposed to test for spatial clustering ( after adjusting for an inhomogeneous background population ) , the spatial scan statistic is by far the most popular . The original method proposed by [ 11 ] computes the maximum discrepancy region obtained by scanning the spatial region under study with a set of circular regions of various radii . The discrepancy score for each region is based on a likelihood ratio test statistic constructed to detect significant overdensity under the Poisson or Bernoulli model . The test was shown to satisfy the optimality property of being the individually most powerful test . Roughly speaking , this means if the model is correct and the main focus is to find the actual location of clusters rather than just detect an overall clustering effect , the spatial scan statistic is optimal . However , due to the dependencies introduced by considering overlapping regions , the analytical distribution of the spatial scan statistic is often intractable and hence one takes recourse to randomization tests [ 5 ] . Such a test computes the distribution of the scan statistic by simulating data under the null hypothesis ( no clustering ) and callibrating the observed value relative to this distribution ( using a p value ) to determine the statistical significance of the most discrepant region . In general , 1000 simulations from the null distribution are enough to determine significance . In practice , when the null hypothesis holds , one may be able to conclude statistical insignificance with a lot fewer repetitions . Originally applied to small sample size problems in epidemiology , the technique has attracted interest in the post 9/11 era for surveillance of massive geographic databases leading to growing interest in computationally efficient algorithms . Recently , the scan statistic has also been used in other areas like bioinformatics [ 10 ] and for detecting chatter in massive social networks [ 17 ] .
Friedman and Fisher [ 7 ] introduced an alternative approach which greedily computes a high discrepancy rectangle , but has no guarantees as to how it compares to the optimal . Their approach is quite general , and works in arbitrary dimensional spaces , but is not conservative : many regions will remain unexplored . A series of papers by Neill and Moore [ 15 , 14 , 16 ] developed a grid based heuristic that uses pruning strategies to avoid enumerating all `n
4´ rectangular ranges ; similar ideas work for square ranges as well . [ 1 ] presented approximation Most recently , Agarwal et al . ǫ n2 log2 n ) while guaranteealgorithms that run in time O( 1 ing a solution that is at most ǫ less than the optimal solution . Their algorithm extends to any convex discrepancy function ; the above bound is for the Kulldorff scan statistic . 1.1 Our Contribution
In this paper we continue the investigation of efficient computational strategies for scan statistics . Our contributions are as follows :
• We present a new approximation heuristic for computing scan statistics based on convex discrepancy functions .
• We present an exact algorithm running in time O(g4 ) and approximation algorithms running in time O(g3 poly(log g , 1/ǫ ) ) for grid based data .
• We implement all of the above algorithms and the algorithm by Agarwal et al . , and compare them with an implementation of the algorithm of Neill and Moore . We show that our methods are superior in practice , and scale better than prior methods on both gridded and non gridded data .
• We examine the problem of computing scan statistics on streams . We show that it is hard to approximate discrepancy functions to within a constant factor using a stream algorithm without using linear space . We also have related lower bounds for additive approximations .
Figure 1 : Example of maximal discrepancy range on a data set . Xs are measured data and Os are baseline data .
2 . PRELIMINARIES
Let P be a set of n points in the plane . Measurements and baseline measures over P will be represented by two functions , m : P → R and b : P → R . R denotes a range space over P . A discrepancy function is defined as d : ( m , b , R ) → R , for R ∈ R . For instance , in an epidemiology application where the goal is to find disease clusters , the points in space could be a collection of counties . The measurement m associated with each county is the number of cases of some rare disease and the baseline measure b is the population at risk . If one assumes a Poisson distribution for the number of disease cases , the optimal discrepancy measure d obtained in this scenario is the well known Kulldorff scan statistic .
Let mR = Pp∈R m(p)/M , bR = Pp∈R b(p)/B , where M = Pp∈U m(p ) , B = Pp∈U b(p ) , and U is some box enclosing all of P . We will assume that d can be written as a convex function of mR , bR . All the discrepancy functions that we consider in this paper satisfy this condition ; most discrepancy functions considered prior to this work are convex as well . We can write d(m , b , R ) as a function d′ : [ 0 , 1]2 → R , where d(m , b , R ) = d′(mR , bR ) . We will use d to refer to either function where the context is clear . With these notations , the Kulldorff scan statistic ( ignoring constants ) is given by d(mR , bR ) = mR log„ mR bR « + ( 1 − mR ) log„ 1 − mR 1 − bR « if mR > bR and 0 otherwise .
Linear discrepancy functions are a special class of discrepancy functions where d = α · mR + β · bR + γ . It is easy to see that combinatorial ( bichromatic ) discrepancy , the difference between the number of red and blue points in a region , is a special case of a linear discrepancy function .
The main problem we study in this paper is :
Problem 2.1
( Maximizing Discrepancy ) . Given a po int set P with measurements m , baseline measure b , a range space R , and a convex discrepancy function d , find the range R ∈ R that ( approximately ) maximizes d .
An equivalent formulation , replacing the range R by the point r = ( mR , bR ) is :
Problem 22 ( Approximately ) Maximize convex discrepancy function d over all points r = ( mR , bR ) , where the range R ∈ R .
In this paper we will only consider range spaces consisting of axis parallel rectangles . Two rectangles that contain the same set of points are equivalent for the purpose of discrepancy calculation . Therefore there are O(n4 ) distinct axis parallel rectangles .
Boundary conditions . As is customary to avoid overfitting , we remove from consideration any range that has very small support in either the baseline or measurements . Formally , we require that any range and its compliment has a measure of at least C , for some arbitrary constant C ≥ 1 . In our mapping from ranges to points , this is equivalent to saying that the domain we maximize over is Sn = [ C/M , 1 − C/M ] × [ C/B , 1 − C/B ] . Often we only care about ranges with proportionally more measured data than baseline data . These points are defined by S+ n = {(mR , bR ) ∈ Sn | mR > bR} . pl pr pb p
Cr
Cr
∗ r q
∗ r ui = nr
φ
< l
2 h
φ
2
φ
( a ) Sweep Line in Algorithm Exact .
( b ) Error between contours .
( c ) Error in approximating an arc with a segment .
Figure 2 : Sweep lines , contours , and arcs .
Grid algorithms . For some algorithms , the data is assumed to lie on a grid , or is accumulated onto a set of grid cells . For such algorithms , we will assume a grid of size g × g , with measurement and baseline values associated with each grid point as before . Note that in such a grid , the effective number of points is g2 , and the number of distinct axis parallel rectangles is O((g2)2 ) = g4 , which differs from the corresponding numbers n and O(n4 ) for points and axis parallel rectangles in general position . It will be important to keep this distinction in mind when comparing grid algorithms with those taking inputs in general position .
3 . A SIMPLE EXACT ALGORITHM
In this section we present a simple algorithm running in time O(n4 ) that computes the maximum discrepancy rectangle exactly . Even though there are O(n4 ) rectangles to be considered , a naive search strategy might end up taking linear time for each rectangle ( to estimate mR , bR ) yielding a net running time of O(n5 ) . We use a simple sweep line technique and incremental updates to avoid this problem .
Any set of four points defines a unique bounding rectangle , with one point defining each side . See Figure 2(a ) . Fix a pair of points pr , pl ∈ P , and consider the set of all rectangles whose left and right extremes are defined by this pair . Choose a third point pb ∈ P in between these two ; this point defines the bottom edge of the rectangle if it is below otherwise one of pr , pl does . Now let a horizontal line segment spanning the rectangle sweep the plane upwards starting from pb . Every time the sweep line encounters a point , we update mR , bR in constant time and recompute the discrepancy , maintaining the largest value . Each sweep takes linear time , and there are O(n3 ) choices of triples ( pl , pr , pb ) . Thus , the algorithm runs in time O(n4 ) . The details of this algorithm are presented in Algorithm 1 .
If the points lie in a g × g grid , a similar argument yields an algorithm ( Exact Grid ) that runs in time O(g4 ) . This algorithm has the same asymptotic running time as the algorithm of Neill and Moore [ 15 ] , has comparable performance in practice ( see Section 7 ) , and is much simpler .
4 . AN APPROXIMATION HEURISTIC
The basis for the heuristic we present in this section is the following linearization lemma , proved in [ 1 ] .
Algorithm 1 Algorithm Exact maxd = 1 Sort all points by y coordinate . for all pairs of points ( pl , pr ) do for i = 1 to n do
Let pb be the point with ith smallest y coordinate . m = 0 , b = 0 for j = i + 1 to n do {This is the sweep line}
Let p be point with jth smallest y coordinate m = m + m(p ) , b = b + b(p ) d = d(m , b ) . if
( d > maxd ) then maxd = d parallel rectangles in time O(n2 log n ) .
One way of exploiting linearization is to represent the discrepancy function as the upper envelope of a collection of linear functions . The resulting piece wise linear function closely approximates the true discrepancy , and thus any computation performed using the linear functions will yield an answer close to the true optimum . We refer to this as the Approx Linear Algorithm . This was the approach used in [ 1 ] .
However , a better approach exploits two facts : first , we only wish to approximate the value of the maximum discrepancy rectangle and second , the function being optimized is monotone in S+ n . Recall that each range R ∈ R can be represented as a point r = ( mR , bR ) ∈ [ 0 , 1]2 . We wish to find r∗ = arg maxr∈R d(r ) , the maximum discrepancy range , or to find a range which closely approximates r∗ . To this end we will approximate the convex function with a set of t linear functions : L = {ℓi}t i=1 , where each ℓi(mR , bR ) = αimR + βibR + γi . By taking the largest point ri = arg maxr∈R ℓi(r ) for each linear function ℓi and then returning r′ = arg maxri d(ri ) we can approximate the maximum discrepancy range on d . n | d(x , y ) = z} be the contour of f at value z . For optimal point r∗ , all points in Cd(r∗ ) are also optimal , and any point r ∈ Cz such that d(r∗ ) − ǫ ≤ z ≤ d(r∗ ) gives an ǫ approximation to r∗ .
Let Cz = {(x , y ) ∈ S+
Let nr be the normal direction to Cd(r ) at r . A linear function ℓi defines a direction ui , and sorts all points along that direction .
Lemma 4.1
( [1] ) . A discrepancy function of the form d(mR , bR ) = αmR + βbR + γ can be maximized over axis
Lemma 42 If ui = nr∗ , then ℓi correctly identifies r∗ as arg maxr∈R d(r ) .
( a ) To preserve the maximum discrepancy region ( the highest point ) , we need few functions .
( b ) To approximate the function in its entirety we need many functions .
Figure 3 : Projecting onto a linear function
Proof . By definition of r∗ , there is no point r ∈ R such that d(r ) > d(r∗ ) . Since d is convex , any point p ∈ Cd(r∗ ) is less than or equal to r∗ along direction ui = nr∗ . Thus r∗ is the maximum point along ui .
Thus , if we can find a direction ui such that nr∗ = ui , then a single invocation of the linearization lemma yields the optimal solution . Figure 3 illustrates this idea , one dimension lower . The plots depicts a convex discrepancy function defined over a single input parameter . A straightfoward linear approximation of the function would require us to use multiple linear functions , illustrated in Figure 3(b ) . However , the direction approach described above requires us only to preserve the ordering of points along this direction , and thus two linear functions suffice ( Figure 3(a) ) .
However , we would like to bound the error caused by a ui 6= nr∗ , since we do not want to place an ℓi such that ui = nr for every point r ∈ R .
Lemma 43 Consider the point r such that ui = nr and ℓi(r ) = ℓi(r∗ ) . If d(r ) ≥ d(r∗ ) − ǫ , then ℓi identifies a point r′ ∈ R that gives an ǫ approximation to r∗ .
Proof . Any point p ∈ S+ n such that d(p ) ≤ d(r ) = d(r∗ ) will have ℓi(p ) < ℓi(r ) . See Figure 2(b ) . For any point q ∈ S+ n such that ℓi(q ) > ℓi(r ) , then d(q ) > d(r ) . Thus ℓi identifies a point q ∈ R such that d(q ) ≥ d(r ) ≥ d(r∗)−ǫ .
Lemma 44 Consider a piece of a convex curve that is of arc length l and the angle of the normal to the curve changes by no more than φ < π 2 . This curve segment can be approximated by a line segment such that the maximum error is no more than lφ/2 .
Proof . Set the line so that it connects both of the end points of the curve . Since the curve is convex , its error can be maximized at the mid point of the segment when the curve is two segments that bends an angle of π − φ at its mid point : see Figure 2(c ) . Let the height from the midpoint of the segment to the mid point of the curve to be h .
We now have a right triangle with angle φ/2 , adjacent side length less than l/2 , and opposite side length h . Thus we know that tan(φ/2 ) = h/(l/2 ) . Thus φ/2 = arctan(2h/l ) ≥ h/l , for φ less than π . Thus h ≤ lφ/2 .
Now let r∗ be the maximal discrepancy range .
It can lie anywhere in S+ n . We want to consider the maximal error allowed by some linear function ℓi . Let r ∈ Cd(r∗ ) have nr = ui . Also let ∆θ(r∗ , i ) be the difference in angles between nr∗ and nr = ui . Let g(r∗ , r ) be the maximal gradient anywhere on Cd(r∗ ) between r∗ and r . Now we can bound the error ǫ incurred by approximating the maximum discrepancy range on d with ℓi .
ǫ ≤ |r∗ − r| · ∆θ(r∗ , i ) · g(r∗ , r ) ,
( 4.1 ) since ∆θ(r∗ , i ) < π/2 and thus |r∗ − r| < 2 · l(r∗ , r ) , the arclength of Cd(r∗ ) between r∗ and r . Thus , we need to place a set of linear functions to minimize this quantity for any placement of r∗ in S+ n . 4.1 Approx Extents Algorithm
Using this intuition we describe a set of linear functions which exploits these properties . For each of t linear functions ℓi(mR , bR ) = αimR + βibR + γi let
π
αi = cos “ sin(hi ) 2 ” βi = − sin “ sin(hi ) 2 ”
π
γi = 0
( 4.2 ) where hi = ( i − 1 ) · π/(2t − 1 ) . For t ≤ 2 , set h1 = π/4 , as this single function often gives a very good approximation just by itself .
In summary , the Approx Extents algorithm runs by creating t linear functions according to ( 4.2 ) and then invoking the algorithm described by Lemma 4.1 in [ 1 ] on each of them . Now let the maximal range for each linear function be ri = arg maxr∈R ℓi(r ) . We return the maximum ri on d defined r′ = arg maxri d(ri ) . The details of this algorithm are presented in Algorithm 2 .
The running time of Approx Extents is O(tn2 log n ) be cause we invoke Lemma 4.1 t times .
5 . GRID ALGORITHMS
As we mentioned earlier , algorithms like those presented in [ 15 , 14 ] aggregate data to a regular g × g grid . Since such
Algorithm 2 Algorithm Approx Extents maxd = −1 for i = 1 to t do π
2
2t−1 ) π
φi = sin(i · ℓi = cos(φi)mR − sin(φi)bR Find ri = arg maxr∈R ℓi(r ) using Lemma 41 di = d(ri ) if ( di > maxd ) then maxd = di ; r′ = ri a grid contains g2 points , one can run any of the above mentioned algorithms , setting n = g2 . However , this is very inefficient , and ignores the special structure of the grid . For example , algorithm Exact would then run in time O((g2)4 ) = O(g8 ) . In this section , we present two algorithms that take advantage of grid structured data . 5.1 Exact Grid Algorithm
The first algorithm returns the maximum discrepancy rectangle in time O(g4 ) . It is quite similar to the algorithm of Section 3 , using a sweep line to explore the space of rectangles . The basic idea is as follows . We maintain four sweep lines , two horizontal and two vertical . The two vertical sweep lines move from left to right . At any moment , one of them is at x position i , and the other at x position j > i . As the second sweep line moves from i to the right most position , we maintain a count , for each row , of the total measured and baseline mass in this row between i and j . This can be done in time O(g ) for each move of the second sweep line . Once the two vertical sweep lines are fixed , two horizontal sweep lines move from bottom to top . Since we maintain counts of the total mass in each row , the discrepancy function for the range bounded by the four sweep lines can be computed in constant time every time the higher horizontal sweep line is moved . A detailed description is presented in Algorithm 3 .
Algorithm 3 Algorithm Exact Grid : Input is g × g grid with values m(i , j ) , b(i , j ) for i = 1 to g do {Left sweep line}
Initialize m[y ] = m(i , y ) , b[y ] = b(i , y ) for all y for y = 2 to g do m[y]+= m[y − 1 ] , b[y]+= b[y − 1 ] for j = i + 1 to g do {Right sweep line} m = 0 , b = 0 for y = 1 to g do m+= m(j , y ) , b+= b(j , y ) , m[y]+= m , b[y]+= b for k = 1 to g do {Bottom sweep line} for l = k to g do {Top sweep line} if k = 1 then m = m[k ] , b = b[k ] else if m = m[l ] − m[k − 1 ] , b = b[l ] − b[k − 1 ] ( d(m , b ) > max ) then max = d(m , b )
5.2 Approx Grid Algorithm
Our second algorithm is approximate , and builds upon the approximate schemes developed in [ 1 ] and in Section 4 . In all our approximate schemes , the main subroutine is an
O(n2 log n ) time algorithm for maximizing a linear discrepancy function over the space of all axis parallel rectangles . It is easy to extract from this algorithm an O(n ) algorithm Linear1D for finding the interval in one dimension that maximizes any linear discrepancy function . Naively transferring the algorithm over rectangles to the grid would yield an algorithm running in time O(g4 log g ) . We improve this to O(g3 ) . In brief , the O(n2 log n ) procedure [ 1 ] uses two horizontal sweep lines going from bottom to top . For any position of the two sweep lines , the maximum discrepancy rectangle among rectangles bounded by these lines can be found by projecting all points onto the lower sweep line and solving a one dimensional problem ( the resulting interval defines the x extents of the optimal rectangle ) . In the modified grid variant , we maintain two arrays m[ ] , b[ ] , each of size g , such that m[i ] stores the sum of all values m(i , j ) between the lower and upper sweep lines . Note that this can be maintained in constant time per entry as the upper sweep line moves . For each such movement , we run Linear1D on the values of m[ ] and b[ ] . The total running time is therefore g positions of the bottom sweep line × g positions of the top sweep line × O(g ) for updating counts and running Linear1D , for a net running time of O(g3 ) .
We describe the algorithm in detail in two parts . First we give the O(g3 ) gridded algorithm for linear discrepancy functions on a grid : Algorithm 4 .
Algorithm 4 Algorithm Linear Grid : Input is g × g grid with values m(i , j ) , b(i , j ) , and linear function ℓ maxd = −1 for i = 1 to g do {Left sweep line}
Initialize m[y ] = m(i , y ) , b[y ] = b(i , y ) for all y for j = i + 1 to g do {Right sweep line} for y = 1 to g do m[y]+= m(j , y ) , b[y]+= b(j , y )
( d , yb , yt ) = Linear1D(ℓ , m[ ] , b[] ) . if
( d > maxd ) then maxd = d ; r = [ i , j ] × [ yb , yt ]
This algorithm is then used as the core subroutine in Al gorithm 5 .
Algorithm 5 Algorithm Approx Grid maxd = −1 for i = 1 to t do
Generate ℓi according to ( 42 ) ( d , ri ) = Linear Grid ( m[ ] , b[ ] , ℓi ) . di = d(ri ) if ( di > maxd ) then maxd = di ; r′ = ri
The runtime of Approx Grid is O(tg3 ) , since there are t calls of Linear Grid which runs in O(g3 ) . This algorithm could also use a family of linear functions as in Agarwal et al . [ 1 ] . Then it would give an ǫ approximation to the maximum discrepancy range on the grid and would run in ǫ g3 log g ) . We use the former version because it is more O( 1 efficient as is demonstrated in Section 7
6 . STREAMING ALGORITHMS
In this section we consider algorithms for the data stream model [ 9 , 6 , 2 ] . Here the data points arrive in some , possibly adversarial , order . An algorithm in the streaming model has limited space , S , to catalog all the points in the stream . Unfortunately most of our results will be lower bounds .
As is typical for lower bounds in the stream model , our lower bounds are proved using reductions from communication complexity problems [ 12 ] . We denote Cδ(f ) as the δ error randomized communication complexity of function f . Also , let C 1 way ( f ) be the one way δ error randomized communication complexity of function f .
δ
Definition 1
( Indexing ) . There are two player P1 and P2 . P1 has an n bit string x and P2 has an index j ∈ [ n ] . The indexing function returns index(x , j ) = xj .
Definition 2
( Multi Party Set Disjointness ) . There are t players P1 , . . . , Pt . Pi has an n bit string xi . The tparty set disjointness [ 3 ] function returns disjn,t(x1 , . . . , xt ) = j=1Vt Wn i=1 xi j .
Theorem 61 For any 0 < δ < 1/4 , C 1 way
( indexn ) = Ω(n ) . The result remains true for instances ( x , j ) where x has exactly n/2 entries which are 1 .
δ
Theorem 6.2
( Chakrabarti et al . [ 4] ) . For any 0 <
δ < 1/4 ,
Cδ(disjn,t ) = Ω„ n t log t« .
This result remains true for the following family F of instances ( x1 , . . . xt ) satisfying
|{j : xi j = 1}| = n/2t
|{i : xi |{j : |{i : xi j = 1}| ∈ {0 , 1 , t} j = 1}| = t}| ≤ 1
∀i ∈ [ t ]
∀j ∈ [ n ]
.
( 6.1 )
( 6.2 )
( 6.3 )
For a linear discrepancy function , d(R ) = α · mR + β · bR + γ
( α > 0 , β < 0 ) . we make the assumptions that m : P → N , b : P → N and that m∗ = maxp∈P m(p ) and b∗ = maxp∈P b(p ) are constant . As a preprocessing step to any algorithm , we construct two point sets Pm and Pb : for each p ∈ P place m(p ) copies of the point in Pm and b(p ) copies of the point in Pb . For each p ∈ Pm let m(p ) = 1 and b(p ) = 0 . Similarly , for each p ∈ Pb let m(p ) = 0 and b(p ) = 1 . Henceforth we will refer to a point p being colored red if p ∈ Pm , or blue if p ∈ Pb . Note that |Pm ∪ Pn| = O(n ) and that this construction can be achieved in O(n ) time . Finally note that discrepancy for any R ∈ R is the same with respect to P as it is to Pm ∪ Pb .
We will also consider the problem of maximizing numerical discrepancy . Here we assume that the P points are drawn from some universe U . For all p ∈ P , m(p ) = 1 . Then the numerical discrepancy is , d(R ) = mR −
|R ∩ U |
|U |
.
Theorem 63 Any P pass streaming algorithm returning a t relative approximation to the numerical discrepency with probability at least 3/4 requires Ω(n/(t6P log t ) ) space . Alternatively , any P pass streaming algorithm returning an ǫ additive approximation with probability at least 3/4 requires Ω(1/(ǫP ) ) space .
Proof . Let ( x1 , . . . , xt′
) ∈ F be an instance of disjn′,t′ where n′ = n/(3t2 ) and t′ = 3t2 . We will show how to transform ( x1 , . . . , xt′ ) into a size n′t′ = n instance of the numerical discrepancy problem such that t approximating the maximum numerical discrepancy problem determines the value of disjn′,t′ .
The stream we define consists of n′t′ elements E where elements will come from a universe [ n′(t′ + 1) ] . We partition the universe into regions R1 , . . . , Rn′ where Ri = [ (i−1)(t′ + 1 ) + 1 , i(t′ + 1) ] . Each player Pi determines a size n′ subset of the elements ,
Ei = {(i − 1)(t′ + 1 ) + j + 1 : xi ∪{(i − 1)(t′ + 1 ) + 1 : xi j = 0 , j ∈ [ n′]} j = 1 , j ∈ [ n′]} .
Note that every region contains t′ elements from E . We next show how the maximum discrepancy of the set depends on the value of disjn′,t′ .
1 . If disjn′,t′ = 1 then the maximum numerical discrep ancy is at least t′ n′t′ −
1 n′(t′ + 1 )
= t′ n′(t′ + 1 ) )
, since there exists an element with multiplicity t′ .
2 . If disjn′,t′ = 0 then each element occurs at most once . Consider any interval R ⊆ [ n′(t′ + 1) ] . The numerical discrepancy in any Ri is exactly 0 . Furthermore , the numerical discrepancy in any subinterval of R whose length l ≤ t′ is at most l n′t′ − l n′(t′ + 1 )
= l n′t′(t′ + 1 )
.
Hence the numerical discrepancy in interval R is at most 2/(n′(t′ + 1) ) .
Hence , if an algorithm disambiguates between the maximum numerical discrepancy being greater than t′/(n′(t′ + 1 ) ) or less than 2/(n′(t′ + 1 ) ) then the value of disjn′,t′ is also determined . Therefore , a relative approximation better than pt′/2 > t determines disjn′,t′ .
Assume that there exists a P pass algorithm A that returns a t relative approximation to the maximum numerical discrepancy of n points ( with probability at least 3/4 ) and uses at most S(n , t ) bits of memory . This algorithm gives rise to a communication protocol for disjn′,t′ as follows . Let the stream be ordered as E1 , E2 , . . . , Et′ . Let mi,j be the memory state of A after the last elements from Ei has gone past in the j pass . Each player Pi constructs Ei from xi . P1 runs A on E1 and sends the memory state m1,1 to P2 . P2 initializes A with memory state m1,1 , runs A on E2 and sends the memory state , m1,2 , to P3 . They continue in this way where mi,j is the ( i+t′(j −1))th message sent . The memory state mt′,P determines a t approximation to the maximum discrepancy and , therefore , the value of disjn′,t′ . Each message is at most S(n , t ) bits long and there are at most t′P messages . Hence the total communication is O(t′S(n , t)P ) bits . By appealing to Theorem 6.2 , we deduce that ,
S(n , t ) = Ω„ n′ t′2P log t′« = Ω„ n t6P log t« .
The second lower bound uses a similar reduction to the first except that t′ = 3 , n′ = 1/(8ǫ ) and every point in the above construction is replaced by 8ǫn/3 identical points .
Note that the above result also applies to approximating the maximum linear discrepancy where α = −β = 1 . This is because their may be exactly 1 baseline point at every location in the discretized universe . Although the data in this lower bound lies on the grid , it applies when the data need not lie on a grid ; shifting each point slightly gives the same discrepancy values .
Corollary 61 Any P pass streaming algorithm returning a t relative approximation to the maximum linear discrepency with probability at least 3/4 requires Ω(n/(t6P log t ) ) space . Alternatively , any P pass streaming algorithm returning an ǫ additive approximation with probability at least 3/4 requires Ω(1/(ǫP ) ) space .
The next lower bound gives a dependence on β when approximating the maximum linear discrepancy .
( log(α/(δǫ)) ) ) random subset A′ of Pm . Similarly , construct B′ , a size O((|β|/ǫ)2 log(|β|/(δǫ) ) ) random subset of Pb . Let P ′ = A′ ∪B′ . Estimate d(R ) by ˜d(R ) = α |A′∩R| |B′| + γ . Then , by Theorem 6.5 , with probability at least 1 − δ , for all R ∈ R ,
|A′| +β |B′∩R|
˛˛˛˛ mR −
|A′ ∩ R|
|A′|
<
ǫ 2α bR −
|B′ ∩ R|
|B′|
<
ǫ
2|β|
.
˛˛˛˛ and ˛˛˛˛
Hence with probability at least 1 − δ , |d(R ) − ˜d(R)| ≤ ǫ for all R ∈ R . We then appeal to Lemma 41
˛˛˛˛
It should be noted that a related algorithm can be used for numerical discrepancy or when the data is known to lie on a grid . Further , observe that this algorithm ( when used in conjunction with the reservoir sampling technique [ 18 ] ) can be viewed as a streaming algorithm that uses
Theorem 64 Any one pass streaming algorithm that ǫ additively approximates the maximum linear discrepancy with probability at least 3/4 requires Ω(|β|/ǫ ) space . space .
O„ “ τ ǫ ” 2 log “ τ
δǫ ” «
Proof . Consider an instance ( x , j ) of index|β|/ǫ . Let w = |β|/(2ǫ ) be the number of 1 ’s in x . We will show how to transform ( x , j ) into a size n + 1 instance of the linear discrepancy problem such that an additive ǫ approximation of the maximum linear discrepancy problem determines the value of index|β|/ǫ(x , j ) .
The stream starts with elements determined by P1 : for each i ∈ [ |β|/ǫ ] such that xi = 1 there are two blue points with value i . The stream ends with one red point j . Note that the maximum value of αmR + βbR + γ is α + γ if index|β|/ǫ(x , j ) = 0 and is α − 2ǫ + γ if index|β|/ǫ(x , j ) = 1 . Then , by appealing to Theorem 6.1 , we deduce that the space required is Ω(|β|/ǫ ) . 6.1 Sampling Algorithms
We now present an algorithm that finds an additive ǫ approximation to the maximum linear discrepancy . It is based upon a sampling approach related to the construction of ǫnets and ǫ approximations [ 8 ] .
Theorem 65 Consider a set of points S in the plane . Let R be a set of axis aligned rectangles . An ǫ approximation is a subset A of S such that , for any R ∈ R ,
With probability at least 1 − δ , a random subset of size ,
|S ∩ R|
|S|
−
|A ∩ R|
|A|
˛˛˛˛
O„ 1
ǫ2 log„ 1
< ǫ .
˛˛˛˛ δǫ«« is an ǫ approximation .
Theorem 66 Let τ = max(α , |β| ) . There exists an al gorithm running in time
O„n + “ τ ǫ ” 4 log2 “ τ
δǫ ” “ log “ τ
ǫ ” + log log “ τ
δǫ ” ” « that returns an estimate E such that with probability at least 1 − δ , |E − maxR∈R d(R)| ≤ ǫ .
Proof . We first preprocess the point set as described above . This takes O(n ) time . We randomly construct a sample P ′ of points as follows : Randomly select a size O((α/ǫ)2
7 . EXPERIMENTS
We now present a performance study of the schemes de scribed in this paper , and compare them to prior work .
Algorithms . We implemented the simple exact algorithms Exact and Exact Grid , as well as the approximation algorithms Approx Extents and Approx Grid . We compare these to two algorithms from prior work ; the grid algorithm NM Grid of Neill and Moore [ 15 ] , and the approximation algorithm Approx Linear of Agarwal et al . [ 1 ] .
Code for NM Grid was provided by the authors [ 13 ] . Their code is a black box that solves the maximum discrepancy problem and then runs N randomization tests . It only returns a range if it is statistically significant . In order to compare their algorithm we set N = 0 and use the discrepancy generated by Exact Grid : both solve the problem exactly on the grid . The code for NM Grid has an additional parameter allowing it to find an approximate solution . Neill and Moore [ 15 ] demonstrate this giving 5× to 20× speedups while only misidentifying < 10 % of the regions . We did not investigate this additional parameter due to difficulties in extracting the discrepancy values . The other algorithms were implemented by us . All experiments were run on a machine with 3GHz Pentium IV processor and 1Gb SD RAM running CentOS .
It should be noted that given the maximum discrepancy range for a given set of data , the problem remains to determine whether it is statistically significant . This is traditionally done by running about 1000 randomization tests , where the experiment is repeated on randomly generated examples from a null hypothesis . Only if the maximum discrepancy range is larger than 95 % of the maximum discrepancy ranges from the randomization tests is it deemed significant . Thus the problem we describe in this paper , is repeatedly solved on the order of 1000 times in practical applications , making an efficient solution paramount for massive data sets . Here we study solving the maximum discrepancy problem once .
Data sets . We used a combination of real and synthetic data to evaluate the algorithms . We start with the example city in data file provided with the code for NM Grid which contains 61291 data points of the form ( x , y , b , m ) where ( x , y )
N E A E A A A
N E A E A A A
N E A E A A A x x x x
M p p p p x x
M p p p p
M p p p p r r v o o o o r
K a a a a c c
K c c v
G r r r r c c
G r r r r
G r r r r p p p p a a p p p p p p p p t t t t o o o o t t o o o o d d i i
G x x x x i
G x x x x
G x x x x n e d d e e d d e e d d e t i i t i i t i i a n
( ( a n
( ( a n
( ( r
8 1 r
8 1
8 1 t t r t s
) ) s
) ) s
) ) r d r v v v v r
K K K K
L E G G
L E G G
0 0 0 i
L E G G i i
. . .
7 7 7 d i x d i x d n r r n r r i x r r
8 8 8
1 1 1
0 1 0 1 0 1
0 0 0
0 1 0 1 0 1 s secon me s secon me s secon me
) d ( ti ) d ( ti ) d ( ti
0 0 0 0 0 0
0 1 0 1 0 1
. . .
0 0 0
0 0 0 11 0 0 0 11 0 0 0 11
0 0 0
0 0 0
. . .
7 7 7
3 3 3 lies on a 175 × 203 integer grid distributed according to a relevant population , and where b , m ∈ {0 , 1} . The population data represents the emergency patients’ home locations in Western Pennsylvania from 1999 through 2002 , and the measured data are the locations corresponding to patients from a two month span . We generate data sets of size n = {256 , 512 , 1024} first by sampling ( x , y ) coordinates from example city in . We then let x = x + u1 and y = y + u2 where u1 , u2 are drawn uniformly at random from [ 0 , 1 ] , in order to take the points off the grid . We next generate b using an exponential distribution to model the population : we set b = ⌊exp(6u)⌋ where u is uniform random in [ 0 , 1 ] . We then generate a random rectangle R of size 7 × 9 somewhere in the ( x , y ) domain . Finally we generate m = P oisson(b · f2 ) ( where f2 = .005 ) if the point is in R and m = P oisson(b · f1 ) ( where f1 = .001 ) if the point is outside R . The sample in R should indicate a larger discrepancy range . We tested various sizes of R and various values for f1 and f2 , but these do not significantly affect the runtimes or accuracies of our algorithms .
Both the gridded algorithms and the approximation algorithms can tradeoff their accuracy for runtime . For the gridded algorithms we use a g × g grid where g = {64 , 128 , 256 , 512} . For the approximation algorithms we set ǫ , the maximum error , to ǫ = {.01 , .1 , 1 , 5 , 10 , 20 , 40 , 100} for ApproxLinear and the number of linear functions t = {16 , 8 , 4 , 2 , 1} for Approx Extents and Approx Grid .
7.1 Overall Performance
Some of the algorithms we evaluate are approximate , and others are defined on a grid ( which incurs its own error ) . To compare these algorithms , we compared their performance versus error curves . In other words , we looked at , for a fixed error bound ( percentage discrepancy ) , how fast each algorithm ran , and for a fixed budget in time , what error was obtained by the algorithms .
For each data set we use the returned maximum discrepancy value dExact of Exact as ground truth . We measure error as the percentage discrepancy for an algorithm A by EA = dA/dExact where dA is its returned maximum discrepancy value of that specific data set . We used 30 data sets for size n = {256 , 512 , 1024} which are generated as described above . We do not test larger values of n in this manor because Exact becomes prohibitively slow . For each algorithm at each parameter setting we average the EA values and the runtime values over all 30 data sets of each size . Figure 4 presents the results , for all three values of n .
Approximate versus grid algorithms . The first observation we can make is that the approximation algorithms are consistently faster than the grid based algorithms , if one wishes to get within roughly 20 % of the true maximum . Approx Extents performs the best overall , in all cases .
As the desired accuracy increases , the approximation algorithms Approx Extents and Approx Linear scale better , and thus the disparity between their performance and that of the grid algorithms increases . At the 90 % accuracy level , approximation algorithms are 3400× , 94× , and 31× faster than the gridded algorithms , for point sets of size 256 , 512 , 1024 . No gridded algorithm has an expected 95 % accuracy , even for a 512 × 512 grid , while the Approx Extents algorithm can return this expected approximation with 1 linear function . This is further demonstrated in Figure 5 .
Figure 4 : Running time ( in seconds ) vs error ( as a percentage of the true answer ) for all the algorithms .
As n increases , this disparity decreases : the approximate algorithms degrade in performance ; however , their behaviour remains superior to the grid based schemes .
Variation in solutions . The values plotted in Figure 4 represent averages over 30 trials each of the algorithms . For both NM Grid and Exact Grid , the standard deviation of run times are about 25 % of the total time , where as for Approx Extents and Approx Linear the standard deviations are only about 2 % of the total time . This is likely because the true asymptotic behavior might be governed by the fact that NM Grid and Exact Grid vary in time depending on how they scan over the data and how many times they do the updates ( if statements ) , whereas the approximation algorithms perform the same operations independent of the positioning of the data .
( a ) n = 256
( b ) n = 512
0 0 0
. . .
8 p 8 p 8 p e e
3 3 3 e r r r c c c e e e n n n t t a a t a g g g e e e c c
0 0 0 c r r
. . . r e e
8 8 8 e i i s s i s p p
8 8 8 p d d d a a n n c c y y a n c y
( c ) n = 1024
0 0 0
. . .
9 9 9
3 3 3
0 0 0
. . .
9 9 9
8 8 8
1
9 5 2 0 0 9 5 2 0 0 9 5 2 0 0
0
5 2
. . . . . . . . . . . . . . .
0 0 5 0 0 0 0 5 0 0 0 0 5 0 0
4 2 6
2 5
1
% % % % % % % % % % % % % % %
9 9 9 9 8 9 9 9 9 8 9 9 9 9 8
9 9 9 9 9
5 5 5 5 5
1 1 1 1 1
E E E
9 9 9 9 9
5 5 5 5 5
. . . . .
4 4 4 4 4
2 2 2 2 2
0 0 0 0 0
4 4 4 4 4
3 3 3 3 3 x x x a a a c c c t t t
2 2 2
1 1 1
2 2 9
2 5 3 2 2 2
7 7 2 7 7 7
1
1 1 1
8 7 4 0 3 7 9 9 9
2 2 2 6 6 6
4 6 8 6 5 3 3 3 3
. . . . . . . . . . . . .
. .
1
1 1 1
8 8 9 9 9
2 0 4 8 8 8 x x x x x x x x x x x x x x x
1 1
E 8 E 7 E
8 5 0 0
     
1
3 9 9
5 4 3 x x x
8 8 6 3 3 7 7
0 0
. . . a a a c c c t t t
1 1
  
G G G
2
1 1 r r r
9
7 2 2
1 d d d i i i
1
     
7 5 8
4 5 5 4
1
.
. . .
. . . . .
4
6 7
8 2 0 0 6 x x x x
1 1 x x x x x
0 4
9 2 0 0 3
G G G
  
N N N
4 3
.
7 5 2 2
6 0 7 7
5 3 7
     
1
M M M
. .
8 0 3 3
6 8 7 5
1 r r r
1
3 3 d d d i i i
4
2 4 4
     
6 4
3 2 7 2 2
1 1
8
2 3 9 2
1 1
7.2 Behaviour of Exact Grid
From the above graphs , we also note that Exact Grid , although usually worse than NM Grid , is comparable in speed . This is noteworthy since NM Grid is a fairly complicated algorithm that uses a recursive prune and search to determine the optimal solution . On the other hand , ExactGrid can be written in a few lines of code . Moreover , the code provided for NM Grid cannot be modified easily if one wishes to use it for other functions .
As the size of the point sets increase the algorithms that are not on a grid become slower at a faster pace than those on a grid . We demonstrate this further by generating points sets with n = 10 , 000 in the same way as before and comparing the gridded algorithms : Exact Grid , NM Grid , and Approx Grid . We also run Approx Extents with t = {1 , 8} . Again we plot , in Figure 6 , the curves demonstrating the tradeoff between percentage discrepancy and time . However , since it takes too long to run Exact , we use the maximum discrepancy returned by any algorithm in place of the ground truth for each data set .
Note that NM Grid still perform better than ExactGrid . However , the difference is small , and might often be outweighed by the simplicity of the code for ExactGrid . Also Approx Grid is now working much faster than Exact Grid and NM Grid . This is probably because the true asymptotic behavior is somehow governed by the number of grid cells that have nonzero values , and ApproxGrid is faster by a factor of g/t asymptotically . So when g is large and t small this pays off .
Also notice how Approx Extents continues to perform faster than NM Grid and Exact Grid for g = 512 , and has much less error . Hence , for large data sets , ApproxExtents is better if minimizing error is important . However , if performance is critical , and error bounds on the order of 20 % are tolerable , then gridded algorithms are superior , and Approx Grid is the best algorithm to use .
Figure 5 : Running time ( in seconds ) vs error ( as a percentage of the true answer ) for all the algorithms . For each algorithm , the left column is the minimal time to achieve the percentage discrepancy ; the right column is the percentage slowdown over the fastest algorithm to reach that percentage discrepancy .
. . . .
. . . . .
1
1
4 9
7 5 5
9 9
0 0 1
1
0
1 s secon me
) d ( ti x x x x x x x x x
.
0 0 0 0 11
0 0 0 1
0
0
.
6
. . . . .
. . . .
0 6
0 4 0 0
6 4 3 x x x x x x x x x o o o x x x
A A A
  2   2  
1 p p p
3
1 1 1
2 2
1 1 . p p p
8 7 5 7
3 r r r
0 8 0 4
4 4
7 4 8
N E A A A
5
. . . .
6
0
.
  
4 2 r
1 1
4 3
G G G d
1 d d d
0 2 6 7 7
3 5 5
1 1
0 5 5
7 7 r r r r r
0 i i i
      i i t
. d d e
7 x
M p p p
Ä c
G r r r
Ä t o o o a p p p i
G x x x r
Ä Ä Ä i
G G E d x
8 1
( ( n
) ) s t
  
L L L r r r
. . . . .
7
. . .
2 6 5 5 3
1 o o o
2
6 3 3 4 2 7 2 7 9 5
1 1 1 1
A A A
4 0 0 0 0 p p p
1 1 1 e
2
7 7 4 p p p
. . . . .
6 4 4 4 7 c x x x
0 e n n n
1 1 1 1 1 i i i r
8 4 0 0 0
3 9 9 4 2 4 7 4 e e e
1 1 r r r
9 3 5 5 7
7 6 6 6 7 7 7 9 9
1 x x x x x x x x x x x x x x x
. . . . .
. . . . . . . . . . a a a c
0
.
7
5 p r e n t a g
8
. d i s c e p a n
.
8
5
0 y
A A A
1 p p p
0 0 0 0 0 0 0 0
1 1 o o o
4 8 8 8 5 9 9 9 7 2 8 8 8
4
7 3 p p p
1 1 1 1
. . . . . . . .
3 3 3 6 3 0 0 0
0
. r r r
.
. . . . . .
9 x x x
  
E E E x x x e e e n n n
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 t t t
0 0 0 0 3 0 0 0 0 0 0 0 0 0 0
. . . . . . . . . . . . . . . s s s x x x x x x x x x x x x x x x t t t
.
0
9
5
1
Figure 6 : Running time ( in seconds ) vs error ( as percentage of best known answer ) for 10000 points .
7.3 Number of Linear Functions
Both Approx Linear and Approx Extents approximate the convex discrepancy function with a set of linear functions . Approx Extents requires far fewer linear functions to get the same expected error . We verify this by plotting the percentage discrepancy ( averaged over the data sets used above with n = {256 , 512 , 1024} ) versus the number of linear functions used to approximate d ( see Figure 7 ) .
Approx Linear requires about 80 linear functions to get an expected error of about 1 % , where as Approx Extents only needs 8 : a 10× speedup . Also Approx Extents never drops below 93 % expected percentage discrepancy even with 1 linear function whereas Approx Linear drops below 90 % with less than 5 linear functions .
7.4 Variance of Percentage Discrepancy
To assess the effect of our approximation parameters on the statistical power of the resultant scan statistic , we analyzed the variation in the distribution of percentage discrep
0 0 0 0 0 0
. . . . . .
9 9 8 8 7 7
9 4 9 4 9 4
1 1 0 0
1 1 0 0
0 . . . .
0 . . . .
0 . . . .
0 0 0 0
0 0 0 0
0 0 0 0 screpancy age evpercen s screpancy age evpercen s screpancy age evpercen s di t tdd di t tdd di t tdd
1 1 0 0 di screpancy percentage
.
1
2 6 2 8 4 0
2 6 2 8 4 0
.
.
.
6 2 8 4 0
0
7
3
G A A A A r p p p p i d p p p p r r r r o o o o x x x x e e d d t i i n a
( ( r t
1 8 s
) )
! ! ! !
0
0
.
L E G G .
7
7 i x r r
8 n 8
.
.
7
7
3
3
0
0
2
0
0
. .
8
8 p
.
8
3 e
3
3
0
Figure 8 : Variance of percentage discrepancy .
0
.
7
8 r c e a a n c
0
.
9
3
0
.
9
8 r r o o x x
ü ü
L E n i x e e t a n r t s
A A p p p p
1
0
0
0 n u m b e r
1
0 l i n e r f u n t i o n
1
0
0
Figure 7 : Number of linear functions needed by Approx Linear and Approx Extents to achieve and expected error . ancy . We note that high variation in this distribution would lead to erroneous p values and invalidate our approximation algorithms . We find consistently small variance estimates both for Approx Extents and Approx Linear . In fact , Approx Extents consistently provides small variance for t = {8 , 16} , as does Approx Linear for ǫ = {.01 , 1} The coefficient of variation drops off to zero rapidly with increase in EA ( see Figure 8 ) . Also , the coefficient of variation tends to get smaller with increase in the number of points . A direct evaluation of the power curves involving large scale simulation experiments will be reported in future work . o n f t a d
5
1
6
2
2
4
2
5
0 e
1 g i s
0
0 c
0
.
.
8
8 r
. e
8 c
8
8 p 8 s y
0
0
. .
9
9
3
3
0 0
. .
9 9
8 8
Acknowledgements We thank the Anomaly Detection working group at SAMSI and Daniel Neill for comments and observations and Neill et al . for providing their code [ 13 ] for comparison .
8 . REFERENCES [ 1 ] D . Agarwal , J . M . Phillips , and
S . Venkatasubramanian . The hunting of the bump : on maximizing statistical discrepancy . Proc . 17th Ann . ACM SIAM Symp . on Disc . Alg . , pages 1137–1146 , 2006 .
[ 2 ] N . Alon , Y . Matias , and M . Szegedy . The space complexity of approximating the frequency moments . Jnl . Comp . Sys . Sci . , 58(1):137–147 , 1999 .
[ 3 ] Z . Bar Yossef , T . S . Jayram , R . Kumar , and
D . Sivakumar . An information statistics approach to data stream and communication complexity . J . Comput . Syst . Sci . , 68(4):702–732 , 2004 .
[ 4 ] A . Chakrabarti , S . Khot , and X . Sun . Near optimal lower bounds on the multi party communication complexity of set disjointness . In IEEE Conf . Comp . Compl . , pages 107–117 , 2003 .
[ 5 ] M . Dwass . Modified randomization tests for nonparametric hypotheses . An . Math . Stat . , 28:181–187 , 1957 .
[ 6 ] J . Feigenbaum , S . Kannan , M . Strauss , and
M . Viswanathan . An approximate L1 difference algorithm for massive data streams . In IEEE Symp . on Foun . of Comp . Sci . , pages 501–511 , 1999 .
[ 7 ] J . H . Friedman and N . I . Fisher . Bump hunting in high dimensional data . Stat . and Comp . , 9(2):123–143 , April 1999 .
[ 8 ] D . Haussler and E . Welzl . epsilon nets and simplex range queries . Disc . & Comp . Geom . , 2:127–151 , 1987 .
[ 9 ] M . R . Henzinger , P . Raghavan , and S . Rajagopalan .
Computing on data streams . TR 1998 001 , DEC Sys . Res . Center , 1998 .
[ 10 ] J . Hoh and J . Ott . Scan statistics to scan markers for susceptibility genes . Proc . Natl . Acad . Sci . USA , 97(17):9615–9617 , 2000 .
[ 11 ] M . Kulldorff . A spatial scan statistic . Comm . in Stat . :
Th . and Meth . , 26:1481–1496 , 1997 .
[ 12 ] E . Kushilevitz and N . Nisan . Communication
Complexity . Cambridge University Press , 1997 .
[ 13 ] D . Neill , A . Moore , K . Daniel , and R . Sabhnani . Scan statistics . http://wwwautonlaborg/autonweb/ software/10474.html , Sep 2005 .
[ 14 ] D . B . Neill and A . W . Moore . A fast multi resolution method for detection of significant spatial disease clusters . Adv . Neur . Info . Proc . Sys . , 10:651–658 , 2004 .
[ 15 ] D . B . Neill and A . W . Moore . Rapid detection of significant spatial clusters . In KDD , 2004 .
[ 16 ] D . B . Neill , A . W . Moore , F . Pereira , and T . Mitchell . Detecting significant multidimensional spatial clusters . LK Saul , et al . , eds . Adv . Neur . Info . Proc . Sys . , 17:969–976 , 2005 .
[ 17 ] C . Priebe , J . Conroy , D . Marchette , and Y . Park . Scan statistics on enron graphs . Comp . and Math . Org . Theory , 11(3):229–247 , 2005 .
[ 18 ] J . S . Vitter . Random sampling with a reservoir . ACM
Trans . Math . Softw . , 11(1):37–57 , 1985 .
