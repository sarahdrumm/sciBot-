NeMoFinder : Dissecting genome wide protein protein interactions with meso scale network motifs
Wynne Hsu Mong Li Lee
School of Computing
National University of Singapore
∗ Jin Chen
Singapore 119077 {chenjin , whsu , leeml}@compnusedusg
ABSTRACT Recent works in network analysis have revealed the existence of network motifs in biological networks such as the proteinprotein interaction ( PPI ) networks . However , existing motif mining algorithms are not sufficiently scalable to find mesoscale network motifs . Also , there has been little or no work to systematically exploit the extracted network motifs for dissecting the vast interactomes .
We describe an efficient network motif discovery algorithm , NeMoFinder , that can mine meso scale network motifs that are repeated and unique in large PPI networks . Using NeMoFinder , we successfully discovered , for the first time , up to size 12 network motifs in a large whole genome S . cerevisiae ( Yeast ) PPI network . We also show that such network motifs can be systematically exploited for indexing the reliability of PPI data that were generated via highly erroneous high throughput experimental methods .
Categories and Subject Descriptors H28 [ Information Systems ] : DATABASE MANAGEMENT—Database Applications , Data Mining
General Terms Algorithms , Experimentation , Performance
Keywords Network motif , Graph mining , Protein protein interaction network
1 .
INTRODUCTION
Recent works in network analysis [ 15 ] have revealed that the topology of complex natural networks such as protein∗
Contact author .
See Kiong Ng
Institute for Inforcomm Research
21 Heng Mui Keng Terrace
Singapore 119613 skng@i2ra staredusg protein interaction ( PPI ) networks are far from random . Many of these networks have been shown to exhibit such common global topological features as the “ small world ” and “ scale free ” properties . It turns out that in addition to these global topological characteristics , many local topological patterns can also be detected in the large complex natural networks . For example , Milo et al.[15 ] discovered various significant patterns of local connections that occurred more frequently in complex networks than in randomized networks . They called these recurring local topological substructures as “ network motifs ” . While relatively less widely studied than the global topological features , such network motifs can lead to better understanding about various classes of complex networks , as some network motifs may be particular to specific classes of networks . For example , certain triad or tetrad motifs are specific topological patterns that are found to appear in biological networks rather than in other networks [ 15 ] . The presence of such network motifs also reveals the basic structural elements that underlie the hierarchical and modular architecture of such complex natural networks as PPI networks .
Researchers have only recently begun to employ network motifs in exploring the interactomes ; for example , Saito et al . [ 17 , 16 ] used manually derived network motifs to detect false positives in highly erroneous PPI networks , while Albert et al.[1 ] used them to predict PPIs . These pioneering works have achieved promising results even though the network motifs used in these works were rather limited—Saito et al . had used only 5 predefined network motifs of size 3 in their latest work on false positive detection [ 16 ] , while Albert et al . had used only 4 predefined small network motifs for predicting interactions . This shows that the network motifs can provide a framework for the effective dissection of the complex PPI network based on the underlying structural principles .
As many of the relevant processes in biological networks have been shown to correspond to the meso scale ( 5 25 genes or proteins ) [ 19 ] , it would be interesting to investigate if it is advantageous to use network motifs that are of equivalent sizes . However , existing network motif discovery algorithms [ 15 , 9 ] are not applicable as they are mostly enumerationbased and limited to extracting smaller network motifs ( up to size 8 ) for the following reasons :
1 . The number of network motifs candidates increases ex ponentially with the motif size [ 8 , 10 ] .
Research Track Paper106 2 . Interesting network motifs are typically repeated and unique [ 15 ] , that is , the motifs occur repeatedly in the PPI network but not in the randomized networks . Such motifs do not have the downward closure property and Apriori algorithms are not applicable here .
3 . The graph isomorphism problem , which is the essential technique to identify different network motifs , is an NP problem [ 4 ] .
Such limitations impact the applicability of motif discovery approach for biological applications , as meso scale network motifs are beyond the reach of existing exhaustive enumeration algorithms .
In this paper , we present an efficient graph mining algorithm called NeMoFinder to discover meso scale repeated and unique network motifs in a large , genome scale PPI network for biological applications . The proposed algorithm utilizes repeated trees to partition a network into a set of graphs . We introduce the notion of graph cousins to facilitate the candidate generation and frequency counting processes . Experiment results indicate that NeMoFinder is scalable and outperforms existing network motif discovery methods . We also use the network motifs that are mined from the real life biological networks to detect false positives in the highly erroneous PPI network obtained from biological experimental methods . The experimental results demonstrate that the actual meso scale network motifs extracted from the biological interaction networks can achieve better performance than using small , predefined ones for assessing the reliability of PPIs from conventional high throughput experiments .
The rest of this paper is organized as follows . Section 2 introduces the basic concepts . Section 3 describes the related work in network motif algorithms . In Section 4 , we describe the proposed NeMoFinder algorithm . Section 5 presents the comparative results of using NeMoFinder for discovering network motifs for S . cerevisiae PPI networks . In Section 6 , we show how the extracted network motifs can be used to validate the interactions in a PPI network . Finally , we conclude in Section 7 .
2 . DEFINITIONS
In this work , we model a PPI network as an undirected graph G = ( V , E ) where each vertex in V represents a unique protein , and each edge in E between two vertices vA and vB indicates that there is an interaction detected between the corresponding proteins A and B . We exclude self loops from G here , as we are only interested to see the effectiveness of graph topology between proteins ( see section 6 ) .
By definition , a network motif is a frequently occurring subgraph pattern in a network ( in this case , a large genomewide PPI network such as the Yeast PPI network that consists of 4341 vertices and 10199 edges ) . The class of network motifs that we are interested in extracting from the interactomes are unique non random subgraphs [ 15 ] that occur repeatedly in the underlying biological network .
Let fg be the number of occurrences of a subgraph g in a PPI network G . We say that g is repeated if fg is more than some user specified value F .
Let fg randi be the frequency of g in a randomized network Grandi , for 1 ≤ i ≤ N , where N is the number of the randomized networks . Let sg be the number of times fg is equal or greater than fg randi , 1 ≤ i ≤ N , over the total number of randomized networks N . We say that g is unique if its sg is more than some user specified value S .
Definition 21 Network Motif . A network motif g in a PPI network G is a connected , unlabelled and undirected topological pattern of inter connections that is repeated and unique in G .
Note that it is common for proteins and their interactions in complex biological networks such as PPI networks to participate in multiple biological functional modules . It is therefore perfectly possible for multiple vertex or edgeoverlapping subgraphs to be simultaneously active at any time . Hence , during the subgraph counting process , we must consider patterns with arbitrary overlaps of vertices and edges . This results in a computationally more complex problem as the frequency of network motifs does not have the downward closed property in this case .
In addition , the uniqueness property of a network motif is also not downward closed as a result of allowing vertex and edge overlap in the network motifs . When a motif g extends ( or reduces ) to its supergraph ( or subgraph ) , the decrease ( or increase ) of fg and fg rand is non deterministic . This means that given a network motif g , we cannot directly infer whether the supergraphs and subgraphs of g are unique . In fact , even when we have found a non unique motif , we still have to generate its supergraphs and check for their frequencies and uniqueness . This implies that determining the uniqueness value of a motif is also computationally expensive .
3 . RELATED WORK
In terms of biological network motif mining , the pioneering work by Milo et al . employed an exhaustive search algorithm that counts all the subgraphs of a given number of vertices . As such , they could only discover small network motifs in the form of 3 vertex and 4 vertex subgraphs . Kashtan et al.[9 ] developed a more efficient sampling method to estimate the relative frequencies of subgraphs . Their method was useful for analyzing very large networks and for detecting high order motifs since the runtime is independent of the network size . However , the sampling approach cannot be guaranteed to discover the complete set of network motifs . It also does not scale for large size network motifs ( the algorithm takes about 2 hours to find a size 8 motif in the network of transcriptional regulation of E . coli with 423 vertices and 519 edges ) .
On the other hand , the computationally savvy graph mining community has also been diligent in developing various algorithms to efficiently discover frequent subgraphs . The initial algorithms , notably the AGM [ 8 ] and FSG [ 10 ] , were devised to find all the frequent subgraphs in a large graph database efficiently through the extension of the market basket analysis . The algorithms utilize the Apriori property to discover frequent subgraphs level by level . The gSpan [ 21 ] algorithm discovers frequent substructures by using a DFS based canonical representation of graphs and enumerated the search space in a depth first order . The FFSM [ 6 ] method improves the performance of gSpan by reducing
Research Track Paper107 redundant subgraph candidates through a vertical search scheme with join and extension operations . Finally , the SPIN [ 7 ] algorithm overcomes the problem of cycles in graph by generating the frequent substructures hierarchically in two steps : starting from trees , and then extending the frequent trees to graphs .
All the above works have focused on mining subgraphs from a collection of graphs , and considered only the frequency but not the uniqueness property of subgraphs . Furthermore , in these works , the frequency of a subgraph is determined by the number of global graphs that the subgraph occurs in , regardless of whether the subgraph occurs many times within a particular graph . This is computationally easier than the network motif discovery problem where the frequency of a motif is determined by the number of occurrences , including vertex and edge sharing ones , within one large and complex graph .
Kuramochi et al.[11 ] designed two methods hSigGram and vSigGram to look for frequent subgraphs in a sparse graph . These methods first determine the number of edge disjoint occurrences of a subgraph based on approximate and exact maximum independent set computations and then use it to prune infrequent subgraphs . However , the methods are not suitable for biological applications where a protein or an interaction can participate in multiple functional modules , in other words , the occurrences of a motif can overlap arbitrarily in a graph , which is a much more computationally challenging counting problem .
The FPF method by Schreiber et al.[18 ] extends hSigGram and vSigGram to find frequent subgraphs with arbitrary overlap . FPF uses the concepts of pattern tree and generating parent to prune redundant subgraph candidate generation . However , the method is expensive as it has to perform subgraph isomorphism test for all candidates . Furthermore , it is unable to prune the non promising subgraphs as the frequency counting does not satisfy the downward closed property .
4 . NEMOFINDER : NETWORK MOTIF
DISCOVERY ALGORITHM
In this work , we propose a network motif discovery algorithm called NeMoFinder to discover repeated and unique meso scale network motifs in a large PPI network ( Algorithm 1 ) .
The input to the algorithm is a PPI network G , a user defined frequency threshold F , a user defined uniqueness threshold S , and a user defined maximal network motif size K . The output of the algorithm is a set U of repeated and unique motifs from size 3 to size K . Note that a subgraph with k vertices is said to be a size k subgraph . The proposed algorithm consists of three main steps . First , we find repeated subgraphs in the PPI network ( Lines 4 15 ) . Then we check the frequency of the repeated subgraphs in the randomized networks ( Lines 16 21 ) . Finally , we determine the uniqueness values of the the repeated subgraphs ( Lines 22 28 ) .
We illustrate the algorithm using the example graph G in Figure 1 . Suppose we want to find all the motifs up to size 5 ( ie , K = 5 ) from G . We let the frequency threshold F = 2 , and the uniqueness threshold S = 095
Algorithm 1 NeMoFinder 1 : Input : G PPI network ;
N Number of randomized networks ; K Maximal network motif size ; F Frequency threshold ; S Uniqueness threshold ;
. ← T ; i ← k ;
. ff= ∅ and i ≤ k × ( k − 1)/2 do . ) ;
. ← F indRepeatedGraphs(k , i , D D D ← D ∪ D i ← i + 1 ; end while
2 : Output : U Repeated and unique network motif set ; 3 : D ← ∅ ; 4 : for motif size k from 3 to K do T ← F indRepeatedT rees(k ) ; 5 : 6 : GDk ← GraphP artition(G , T ) 7 : D ← D ∪ T ; 8 : D 9 : 10 : while D 11 : 12 : 13 : 14 : 15 : end for 16 : for counter i from 1 to N do 17 : Grand ← RandomizedN etworkGeneration( ) ; 18 : 19 : 20 : 21 : end for 22 : U ← ∅ ; 23 : for each g ∈ D do 24 : 25 : 26 : 27 : end if 28 : end for 29 : return U ; s ← GetU niqunessV alue(g ) ; if s ≥ S then U ← U ∪ {g} ;
.
; for each g ∈ D do
GetRandF requency(g , Grand ) ; end for
2
1
3
5
G
4
Figure 1 : Example graph G .
Step 1 . Discover Repeated Subgraphs .
The discovery of repeated size k subgraphs in a PPI net work , 2 < k ≤ K , involves the following three steps :
Step 1.1 Find Repeated Size k Trees .
Algorithm NeMoFinder starts by finding the size 2 tree t2 in G . Then the algorithm extends t2 to a size 3 tree , size 4 trees , etc . , until size K trees are obtained . Figure 2 shows all the size 2 to size 5 trees . Note that we have two size 4 trees ( t4 1 , t4 2 ) and three size 5 trees ( t5 1 , t5 2 , t5 3 ) .
When a size k tree tk is formed , NeMoFinder counts its occurrences in G . If the occurrences of tree tk is more than the user given threshold , then tk is a repeated tree , and it is added to the set Tk .
In our example , the occurrences/frequencies of the various size trees are as follows : ft2 = 7 , ft3 = 13 , ft4 1 = 6 , ft4 2 =
Research Track Paper108 t3 t4_1 t4_2 t5_2 t5_3
Figure 2 : Size 2 to size 5 trees . t2 t5_1
2
1
3
1
3
1
5
2
5
4
3
1
3
1
5
4
5
4
5
2
2
4
3
3
2
2
4
2
3
1
3
1
3
1
5
5
5
2
2
2
3
3
4
3
1
1
3
5
5
3
1
3
4
5
4
2
2
3
3
1
4
5
4
5
4
2
2
2
3
1
3
1
3
1
1
1
5
5
5
5
1
1
4
3
4
4
1
3
Figure 3 : Occurrences of t4 1 in G .
5
4
5
4
Figure 4 : Occurrences of t4 2 in G .
17 , ft5 1 = 1 , ft5 2 = 5 , ft5 3 = 7 . All frequency values except for the frequency of t5 1 are more than the user given threshold of 2 . Thus we have T2 = {t2} , T3 = {t3} , T4 = {t4 1 , t4 2} and T5 = {t5 2 , t5 3} .
Step 1.2 Use Repeated Size k Trees to Partition Graph .
Next , we use the size k trees in Tk to partition the graph G into a set of graphs GDk such that each graph Gk j in GDk embeds a size k tree in Tk , 2 ≤ k ≤ K and 1 ≤ j ≤ |GDk| . Consider the trees t4 1 and t4 2 in Figure 2 . Figure 3 and 4 shows the occurrences of t4 1 and t4 2 in G . We use t4 1 and t4 2 to partition the PPI network G to obtain the set of graphs GD4 = {G4 1 , G4 2 , G4 3 , G4 4G4 5} ( Figure 5 ) . Note that each graph in GD4 embeds the tree t4 1 and/or t4 2 .
Step 1.3 Perform graph join operation to find repeated size k graphs .
For each tree t in Tk , we generate size k subgraphs with k− 1 edges ( the rules for generating the subgraphs are given in Section 41 ) Then we join t with each of these subgraphs to generate size k subgraphs with k edges . The latter are added to the candidate set Ck .
Figure 6 shows the 4 vertex 3 edge subgraphs , h1 , . . . , h5 , generated from the two size 4 trees t4 1 and t4 2 in T4 . We join t4 1 with h1 and h2 , and join t4 1 with h3 , h4 and h5 to generate 4 vertex 4 edge subgraphs . Figure 7 shows the subgraphs obtained after joining t4 1 with h1 , and t4 2 with h3 . The non redundant subgraphs g1 1 and g1 2 are added into the candidate set C4 . For each subgraph g ∈ Ck , we check its occurrences in
GDk . If the occurrences of g is more than the threshold F , we add g to the set Dk . In our example , fg1 1 = 2 and fg1 2 = 5 . Thus , g1 2 is a repeated subgraph and is added to the set of frequent subgraphs D .
Next , we use the repeated subgraphs obtained to generate all the possible k vertex and k edge subgraphs . These repeated subgraphs are joined with the newly generated subgraphs to get ( k + 1) edge subgraphs . The repeated ( k + 1)edge subgraphs are added to D . This process continues until a complete graph of k ∗ ( k − 1)/2 edges is obtained , or no repeated subgraph can be found .
Figure 8 shows the 4 vertex and 4 edge subgraphs , h6 and h7 , generated from the repeated subgraph g1 2 . We join g1 2 with h6 and h7 to get a 4 vertex and 5 edge subgraph g2 ( see Figure 9 ) . Since the frequency of g2 in GD4 is not more than 2 , it is not a repeated subgraph and the algorithm stops .
At the end of Step 1 , the algorithm outputs the set D which contains all the repeated trees and subgraphs from size 2 to size K .
Step 2 . Determine Subgraph Frequency in Randomized Networks .
Next , we use the Markov chain algorithm [ 12 ] to gener ate randomized networks Grandi ( 1 ≤ i ≤ N ) by swapping randomly selected interactions , as was done in [ 15 ] . This ensures that the randomized networks have the same singlevertex characteristics as the PPI network , ie , each vertex in the randomized networks has the same number of neigh
Research Track Paper109 1
1
2
2
3
1
3
3
5
G4_1 2
5
4
5
4
G4_2 2
G 4_3
1
3
5
G 4_4
4
4
G4_5 g1_2 h6 h7
Figure 8 : Generate 4 edge subgraphs from repeated 4edge subgraphs of G .
Figure 5 : Set of graphs GD4 ; each graph in GD4 embeds t4 1 and/or t4 2 . g1_2 h6 g2 t4_1 t4_2 h1 h3 h2 h4 h5
Figure 6 : Generate 3 edge subgraphs from size 4 trees . bors as the corresponding vertex in the PPI network . We check the frequency of the subgraphs in D in each of the randomized networks Grandi ( 1 ≤ i ≤ N ) . The procedure is similar to Step 1 .
Step 3 . Compute Uniqueness of Subgraphs .
Finally , we compute the uniqueness value for each subgraph in D based on its frequencies in the input PPI network and the randomized networks .
NeMoFinder is scalable because the repeated trees naturally partitions the network into a set of graphs GD . Hence , the problem of counting the frequency of a size k subgraph g in the network is reduced to the problem of finding the number of graphs in GD that contain the subgraph g , which is naturally downward closed .
In order to reduce the computational complexity , NeMoFinder adopts the idea in SPIN [ 7 ] to search for repeated trees and t4_1 t4_2 h2 h3 g1_2 g1_1
Figure 7 : Examples of graph join operations for 3 edge subgraphs .
Figure 9 : Examples of graph join operations for 4 edge subgraphs . then extend them to subgraphs . However , NeMoFinder differs from SPIN in the following :
1 . The notion of frequency in SPIN is different from our NeMoFinder . SPIN simply checks whether a subgraph occurs in a graph ; it is not interested in counting how many times the subgraph occurs in the graph . In contrast , NeMoFinder considers occurrences of a subgraph in a network , including arbitrary overlaps .
2 . SPIN uses equivalence classes to find maximal labelled frequent subgraphs in a set of graphs . In contrast , NeMoFinder is focused on discovering repeated unlabelled subgraphs from a single graph . Hence , our NeMoFinder is able to utilize the symmetry property of unlabelled trees to further reduce the number of candidate trees enumerated .
4.1 Candidate Generation using Graph Cousins
Finding repeated subgraphs involves generating candidate subgraphs and frequency counting ( see Algorithm 2 ) . The standard method to generate a subgraph candidate gk from a tree tk is to add a new edge to tk and check whether the resulting graph is already in the candidate set Ck . However , Ck can become very large for meso scale subgraphs , and checking whether a graph exists in Ck requires graph isomorphism test which is a NP problem .
Given that the network motifs are meso scale , we use adjacency matrices to represent the subgraphs so as to facilitate the graph join operation to generate candidate subgraphs . A graph g with n vertices can be modelled using a n × n matrix M . An entry mi,j in an adjacency matrix is set to 1 if there is an edge from vertex i to j , and 0 otherwise . The code of M , denoted as code(M ) , is a sequence formed by linking the lower triangular entries of M in the following order : m1,1m2,1m2,2m(i , j)mn,1mn,2mn,n where ( 0 < j ≤ i ≤ n ) .
We can transform any adjacency matrix into a unique representation called canonical adjacency matrix ( CAM ) [ 4 ] . Then two subgraphs that are isomorphic to each other have the same CAM , and vice versa . The canonical adjacency matrix ( CAM ) of a subgraph g , denoted as CAM ( g ) , is the adjacency matrix of g with the maximal code . The last edge
Research Track Paper110 entry of CAM ( g ) is the rightmost non zero edge entry in code(CAM ( g) ) . By removing the edge which corresponds to the last edge entry of CAM ( g ) , we obtain a subgraph of g . We call the adjacency matrix of such a subgraph as subCAM ( g ) defined as follows :
Definition 41 subCAM of a graph . Let CAM ( g ) be canonical adjacency matrix of a graph g . Then subCAM ( g ) is a matrix obtained by setting the last edge entry in CAM ( g ) to 0 .
Given two subgraphs g and h , if subCAM ( g ) = subCAM ( h ) , then we say that h is a cousin of g . There are three types of cousin relationship between g and h :
• Type I : Direct Cousin h is isomorphic to a subgraph which has the same number of vertices and edges as
. g g , and g ff= g
.
;
• Type II : Twin Cousin h is isomorphic to subgraph g ;
• Type III : Distant Cousin h is a disconnected sub graph .
Figure 10 shows the adjacency matrices for the size 4 trees t4 1 and t4 2 and the generated subgraphs h1 , . . . , h5 in Figure 6 . From the above definitions , we see that h1 is a Type I direct cousin of t4 1 since it is isomorphic to t4 2 ; h2 is a Type III distant cousin of t4 1 since it is a disconnected subgraph ; h3 is a Type II twin cousin of t4 2 since it is isomorphic to t4 2 ; h4 is a Type I direct cousin of t4 2 since it is isomorphic to t4 1 ; h5 is a Type III direct cousin of t4 2 since it is a disconnected subgraph .
0 0 1 01 01
0 0 0 t4_1
0 1 0 01 10
0 0 0 t4_2
0 0 1 01 00 h1
0 1 0
0 1 0 11 00
0 0 0 h2
0 1 0 01 00
0 1 0 h3
0 1 0 01 01
0 0 0 h4
0 1 0 11 00 h5
0 0 0
Figure 10 : Adjacency matrices for the graphs in Figure 6 .
We now show how the subgraph generation and frequency counting are efficiently carried out based on the cousins of a graph . Given a repeated subgraph g of size k , we first find its set of cousins , H . Then we join g with each graph h ∈ H to form new subgraphs of size k that have one more edge than g . Let CAM ( g ) be CAM of g and CAM ( h ) be CAM of h , then the adjacency matrix M of the new subgraph candidate is a k × k matrix and
. mi,j =
1 if CAM ( g)i,j = 1 or CAM ( h)i,j = 1 0 otherwise
( 1 )
Algorithm 3 gives the pseudo code for the candidate gen eration procedure .
The following theorem proves that the join operation gen erates the complete set of candidate subgraphs .
.
)
Set of repeated subgraphs with k vertices and
Set of repeated subgraphs with k vertices and
Algorithm 2 FindRepeatedGraphs(k , i , D . 1 : Input : D i − 1 edges ; 2 : Output : D i edges ; 3 : C ← CandidateGeneration(k , i , D . ) ; ← F requencyCounting(k , i , C ) ; 4 : D 5 : return D
;
Algorithm 3 CandidateGeneration(k , i , D . 1 : Input : D i − 1 edges ;
Set of repeated subgraphs with k vertices and
.
)
.
2 : Output : C Set of candidates with k vertices and i edges ; 3 : C ← ∅ ; 4 : for each g ∈ D do 5 : H ← GetCousin(g ) ; for each h ∈ H do 6 : . ← join(g , h ) ; 7 : g .} ; C ← Can ∪ {g 8 : 9 : 10 : end for 11 : return C ; end for k , where each g ∈ C .
Theorem 41 Given all the subgraphs g ∈ Ck which has k vertices and l edges ( l ≥ k−1 ) , the join operation generates . the complete set of subgraphs C k has k vertices and l + 1 edges . Proof : Let M be an adjacency matrix of a subgraph g ∈ . C k and e1 be the last edge entry in M , such that matrix M1 = M − {e1} is a CAM of a subgraph g1 . Let e2 be the last edge entry in M1 . Since M1 is a connected graph , its corresponding subgraph g1 must be in Ck . Let M2 = M1 − {e2} + {e1} and M2 be an adjacency matrix of a subgraph g2 , we have g1 .fi g2 ⇒ g . Based on the definition of graph cousins , if g2 is isomorphic to g1 , g2 is a Type II twin cousin of g1 ; if g2 is connected but not isomorphic to g1 , then g2 is a Type I direct cousin of g1 ; if g2 is disconnected , g2 is a Type III distant cousin of g1 . g ∈ C . k is generated from Ck . 2 4.2 Frequency Counting
Since the join operation joins g1 with all its cousins , each
A straightforward method to count the frequency of a size k subgraph g in a graph G is to check all the graph in GDk . However , this is an NP complete subgraph isomorphism problem . Given that the discovery of network motifs requires checking the frequency of the candidate subgraphs in both the PPI network as well as the large number of randomized networks , it is critical for us to reduce the computational time of the frequency counting process . This can be achieved by leveraging the properties of the different types of cousins .
Theorem 42 Let Lx denote the set of graphs in GDk such that each graph in Lx embeds x . Let h be a Type I direct cousin of a size k subgraph g and g be the subgraph obtained by joining g and h . Then we have Lg . = Lg ∩ Lh ,
.
. is given by |Lg ∩ Lh| . and the frequency of g
. Proof : Each graph in Lg . must embed g and h since g contains all the edges of both g and h . Thus , we have Lg . ⊆ Lg ∩ Lh .
Research Track Paper111 Algorithm 4 FrequencyCounting(k , i , C ) 1 : Input : GDk Set of graphs generated by partitioning G with size k repeated trees ;
C Set of subgraph candidates with k vertices and i edges ; F Frequency threshold ;
2 : Output : D
Set of repeated subgraphs with k vertices and
else if type of h = Type I direct cousin then else if type of h = Type III remote cousin then
.
Lg ← set of graphs in GDk embedding g ; Lh ← set of graphs in GDk embedding h ; if fg < F or fh < F then
: g and h ;
. ∈ C do i edges ; ← ∅ ; 3 : D 4 : for each g 5 : Get the join parameter of g 6 : 7 : 8 : 9 : 10 : 11 : 12 : 13 : 14 : 15 : 16 : 17 : 18 : 19 : end if 20 : end for 21 : return D fg . ← 0 ; fg . ← |Lg ∩ Lh| fg . ← |Lg ∩ Lh| fg . ← CheckAllOccurances(g ) ; end if if fg . > F then ∪ {g
← D
.} ;
D
; else if type of h = Type II twin cousin then
.
On the other hand , each graph in Lg ∩ Lh embeds both g and h . Hence , the graph must embed g , since each edge in is in either g or h . Thus , we have Lg . ⊇ Lg ∩ Lh . . g Therefore , we have Lg . = Lg ∩ Lh and the frequency of g . is given by |Lg ∩ Lh| . 2 {G4 1 , G4 2 , G4 3 , G4 5} and Lh2 = {G4 1 , G4 2 , G4 3 , G4 4 , G4 5} ( see Figure 5 ) . Then , for subgraph g1 2 which is generated by joining t4 1 and h2 , the graphs in GD4 that embed g1 2 are Lg1 2 = Lt4 1 ∩ Lh2 = {G4 1 , G4 2 , G4 3 , G4 5} . Hence , the frequency value of g1 2 is 4 .
Let us consider t4 1 and h2 in Figure 7 . We have Lt4 1 =
.
Similarly , we can prove that if h is a Type III distinct cousin of a size k subgraph g , the frequency of g ( the subgraph obtained by joining g and h ) is also given by |Lg∩Lh| . However , if h is a Type II twin cousin of a size k subgraph g , then h is isomorphic to g . In order to determine the frequency of the subgraph obtained by joining g and h , we have to check all the graphs in GDk that embeds g . This frequency counting involves the NP complete subgraph isomorphism test . Hence , given that the same subgraph can be generated by joining g with its various types of cousins , we choose to join g with its Type I or Type III cousin whenever possible to avoid the subgraph isomorphism test . Algorithm 4 gives the pseudo codes for the frequency counting process .
For the complexity analysis of NeMoFinder , please refer to our technical report TRC6/06 ( June 2006 ) [ 2 ] .
5 . PERFORMANCE STUDY
We have implemented our NeMoFinder algorithm in C++ and carried out experiments to compare NeMoFinder with existing network motif discovery algorithms such as the enumeration method [ 15 ] , sampling method [ 9 ] , and FPF [ 18 ] . We use two real life datasets , the Uetz dataset and the original MIPS CYGD dataset . The Uetz dataset [ 20 ] contains 957 PPIs and 1004 proteins of S . cerevisiae and can be downloaded from the BRITE website . The MIPS CYGD dataset [ 14 ] is the whole genome PPI network of S . cerevisiae from the Munich Information Center for Protein Sequences . After removing redundancy and orphan links , this dataset contains 10199 PPIs involving 4341 proteins that have been detected with high throughout genome wide biological experimental methods .
First , we evaluate the runtime of the four network motif discovery methods ( enumeration , sampling , FPF , NeMoFinder ) in finding network motifs of varying sizes in the Uetz dataset . We set the frequency threshold to 50 , the uniqueness threshold to 0.95 , and the number of randomized networks to 100 . Figure 11 shows that NeMoFinder consistently gives the best performance , with 20 to 100 fold speed up . We also observe that only NeMoFinder manages to find all the motifs within a reasonable amount of time .
) c e S i
( e m T g n n n u R i
107
106
105
104
103
102
101
100 3
NeMoFinder FPF Sampling Enumeration
4
5
6
7
8
9
10
11
12
13
Network Motif Size
Figure 11 : Comparison of computational times to find network motifs of varying sizes in Uetz PPI network . i
) c e s ( e m T g n n n u R i
NeMoFinder FPF
107
106
105
104
103
102
101
200
150 100 Frequency Threshold
50
Figure 12 : Comparison of computational times to find network motifs in Uetz PPI network under varying frequency thresholds .
Next , we evaluate the performance of NeMoFinder under varying frequency thresholds . We set the uniqueness thresh
Research Track Paper112 old to 0.95 , the number of randomized networks to 100 , and the maximal size of network motif to 9 . The enumeration method and sampling method have been excluded from this experiment because they could not scale up to size 9 motifs . Figure 12 indicate that NeMoFinder is able to achieve up to 100 fold speedup over FPF .
We also compare the maximal motif size and the total number of identified motifs by the four algorithms to find network motifs of varying sizes in the MIPS dataset , which is much larger than the Uetz dataset . We set the frequency threshold to 50 , the uniqueness threshold to 0.95 , the number of randomized networks is set to 1000 . Figure 13 shows that NeMoFinder was able to extract network motifs up to size 12 , while the maximum sizes of the motifs discovered by FPF , sampling method and enumeration method are 9 , 8 and 5 respectively . In addition , NeMoFinder was able to find a total of 11140 motifs , while FPF , sampling method and the enumeration method discovered only 1112 , 848 and 21 network motifs respectively . The limited number of network motifs found by FPF , sampling and enumeration methods was due to the limitation of the motif size that these algorithms could handle .
Figure 13 : Comparison in size and number of network motifs that can be found by four algorithms in MIPS PPI network .
6 . A MOTIF APPLICATION : PPI
VALIDATION
Previous works in biological network motifs have focused mostly on motif discovery ; there has been little or no work in showing how the network motifs can be systematically exploited . In this section , we describe how we can exploit the extracted network motifs in PPI validation . Our results show that the inclusion of the larger meso scale network motifs indeed leads to better results .
Technological developments in high throughput PPI detection methods such as yeast two hybrid and protein chips have enabled biologists to experimentally detect PPIs at the whole genome level for many organisms . For example , currently more than 15000 PPIs have already been detected and deposited in biological databases for S . cerevisiae . The abundant number of PPIs enables scientists to analyze these organisms at the genome level . However , a significant proportion of the PPI networks obtained from high throughput biological experiments has been found to contain false positives . Recent surveys have revealed that the reliability of the popular high throughput yeast two hybrid assay can be as low as 50 % [ 13 ] . These errors in the experimental data may lead to spurious discoveries that can be potentially costly , eg , wrong drug targets for diseases .
In a first attempt to validate detected interaction candidates , Saito et al . [ 17 ] develop an interaction reliability index called interaction generaility ( IG1 ) . The IG1 measure is based on the notion that the neighbors of the interacting partners are likely to also interact with each other . In other words , it uses a very simple network motif to detect false positives by noting that interactions between partners that are involved in lone star like motifs are probably spurious . Positive results from the various experiments conducted by Saito et al . suggest that the use of even such a seemingly primitive network motif in dissecting genomewide PPI networks is helpful in increasing the reliability of currently erroneous experimental interaction data . In fact , the authors subsequently developed a second reliability index called IG2 [ 16 ] that was based on 5 possible network motifs that involved a third protein C together with the candidate interacting protein pair ( A , B ) . Their experimental results showed that IG2 outperformed IG1 , suggesting the advantage of using more sophisticated network motifs in dissecting the experimentally derived PPI networks .
In this section , we investigate whether using the actual network motifs can indeed give better performance than using the simple , predefined ones such as those employed in IG1 and IG2 . 6.1 Motif Strength
We have seen how NeMoFinder is able to discover a much more comprehensive set of network motifs as compared to the other methods ( Section 5 ) . For it to be useful in practice , it is important that the set of network motifs can provide sufficient coverage of the vast interactome . We found that 96 % of PPIs in the MIPS dataset was indeed covered by at least one network motif discovered by NeMoFinder .
First , we rank the network motifs in terms of their contribution to the PPI network with respect to their individual sizes , frequencies and uniqueness . For simplicity , we assume that the motifs are independent here . We define the strength M Sk(g ) for each motif g as :
Definition 61 MotifStrength . The strength of a sizek motif g , denoted as M Sk(g ) , is the frequency value of the motif times its uniqueness value over maxk , where maxk is the maximal value of s(g ) × f ( g ) of all size k motifs .
M Sk(g ) = s(g ) × f ( g ) maxk
( 2 )
6.2 Evaluation based on motif strength
Having defined the MotifStrength , we score each interaction in the PPI network by combining the strengths of the network motifs that contain the interaction ( edge ) .
Research Track Paper113 Definition 62 Reliability Index of PPI The reliability index of a PPI ( A , B ) , denoted as I(A , B ) , is the sum of the MotifStrength of all the motifs that contain the edge ( A , B ) .
Kfi nfi
M Sk(gi ) × k
I(A , B ) =
( 3 ) where gi , 1 ≤ i ≤ n are the motifs where edge ( A , B ) k=2 i=0 occurs and k is the size of gi .
We apply our method , as well as IG1 and IG2 , on the MIPS CYGD dataset described in Section 5 to compute reliability indices for the 10199 S . cerevisiae PPIs in the dataset . We then compare the quality of the various reliability indices in the following three different aspects :
1 . Function Homogeneity . The cellular functions of the protein partners in a genuine biological interactions are likely to be similar . As such , we would expect an interactome that has been sorted with a good reliability index to exhibit a high degree of functional homogeneity in the interactions with high reliability scores . We use the Comprehensive S . cerevisiae Genome Database ( dated 2005 06 20 ) at MIPS [ 14 ] as the ground truth for the proteins’ functional annotations . Out of the 4341 proteins in the MIPS CYGD interaction dataset , 3150 proteins have functional annotations and 4743 interactions involve the annotated proteins .
2 . Localization Coherence . With the exception of the proteins involved in cellular pathways such as the signalling pathway , the cellular localizations of the protein partners in a genuine biological interactions are expected to be the same . As such , a better reliability index would exhibit a higher degree of cellular colocalization amongst the protein partners in the sorted interactions . We use the cellular localization annotations of the S . cerevisiae proteins in the MIPS database as the basis for comparison in our experiment .
3 . Gene Expression Correlation . Studies have shown that the average correlation coefficient of gene expression profiles that corresponds to interacting protein pairs is significantly higher than those that correspond to random pairs [ 5 ] . As such , we can also use the degree of gene expression correlation to evaluate the relative quality of the PPI reliability indices . For gene expression correlation analysis , we downloaded the S . cerevisiae gene expression dataset from Eisen ’s Lab [ 3 ] . The dataset comprises expression vectors from 80 experiments on 6221 genes .
Figure 14 shows that as the reliability index value is increased , the proportion of interacting pairs with common cellular functions also increases , indicating an increase in the number of true positives in the filtered interaction data . The reliability indices generated using the NeMoFinder ’s network motifs show significant increases ( from 61 % to 87 % and 81 % ) than those using IG1 and IG2 ( from 61 % to only 68 % and 73 % respectively ) .
Figure 15 shows the relative performance in terms of cellular localization coherence . Using the reliability indices computed by the network motifs , the proportion of interacting pairs with common cellular localization increases from y t i e n e g o m o h n o i t c n u F
0.9
0.85
0.8
0.75
0.7
0.65
0.6
1
NeMoFinder<=12 NeMoFinder<=8 IG2 IG1
0.8
0.2 Proportion of interactions left in a given threshold
0.4
0.6
Figure 14 : Proportion of interacting proteins with common cellular functional roles increases at different rates under different interaction reliability measures .
85.3 % to 94.0 % and 91.7 % for the NeMoFinder network motifs , again outperforming IG1 and IG2 ( from 85.3 % to 87.0 % and 901 % ) e c n e r e h o c n o i t a z i l a c o L
0.95
0.93
0.91
0.89
0.87
0.85
1
NeMoFinder<=12 NeMoFinder<=8 IG2 IG1
0.8
0.6
0.2 Proportion of interactions left in a given threshold
0.4
Figure 15 : Proportion of interacting proteins with common cellular localizations increases at different rates under different interaction reliability measures .
The results based on gene expression correlation , shown in Figure 16 , exhibit a similar trend . Again , the increase in the average gene expression correlation between the protein partners in the sorted PPIs is much more significant when using reliability indices computed with NeMoFinder ’s network motifs ( from 26.4 % to 33.5 % and 30.8 % ) than those generated by using IG1 and IG2 ( from 26.4 % to 27.6 % and 29% ) .
These results show that the PPI reliability indices computed using the NeMoFinder network motifs are more reliable than those computed using IG1 and IG2 , demonstrating the positive effect of using a more comprehensive set of actual network motifs against a small number of simple , predefined motifs . Additionally , we also compared the performance of using motifs of different sizes . In all three evaluation experiments , the reliability indexes computed using NeMoFinder network motifs of sizes up to 12 consistently
Research Track Paper114 n o i t a l e r r o c l a n o i s s e r p x e e n e G
0.35
0.33
0.31
0.29
0.27
0.25
1
NeMoFinder <=12 NeMoFinder <=8 IG2 IG1
0.8
0.6
0.2 Proportion of interactions left in a given threshold
0.4
Figure 16 : Overall correlation of gene expression for interacting proteins increases at different rates under different interaction reliability measures . show superior performance over that computed with motifs of sizes only up to 8 . This indicates that it is advantageous to include the larger motifs , justifying the need for discovering meso scale network motifs .
7 . CONCLUSIONS
Existing network motif discovery algorithms are limited to extracting smaller network motifs and cannot be employed to mine meso scale level network motifs in large biological networks . In this paper , we have presented an efficient network motif discovery algorithm called NeMoFinder to discover larger sized repeated and unique network motifs in PPI networks . The algorithm utilizes repeated trees to partition a network into a set of graphs . We have introduced the notion of graph cousins for efficient candidate generation and frequency counting . We use NeMoFinder to successfully extract , for the first time , up to size 12 network motifs from the whole S . cerevisiae PPI network . The network motifs discovered by NeMoFinder provided a good coverage of the PPIs in the vast interactome .
In this work , we also showed an example of how the network motifs can be systematically applied in the validation of the PPIs in an interactome . Our results confirmed that employing the larger actual network motifs derived from biological networks instead of predefined small sized network motifs can indeed achieve better results . Future work will include directed network motif discovery and network motif labelling .
8 . REFERENCES [ 1 ] I . Albert and R . Albert . Conserved network motifs allow protein protein interaction prediction . Bioinformatics , 20(18):3346–3352 , 2004 .
[ 2 ] J . Chen , W . Hsu , ML . Lee , and SK . Ng . Discovering and exploiting meso scale network motifs in protein interactomes . Technical Report TRC6/06 , National University of Singapore , 2006 .
[ 3 ] MB Eisen , PT Spellman , PO Brown , and
D . Botstein . Cluster analysis and display of genome wide expression patterns . Proc . Natl Acad . Sci . USA , 95:14863–14868 , 1998 .
[ 4 ] S . Fortin . The graph isomorphism problem . Technical Report TR96 20 , Department of Computing Science , University of Alberta , 1996 .
[ 5 ] A . Grigoriev . A relationship between gene expression and protein interactions on the proteome scale . Nucleic Acids Res , 29(17):3513–3519 , 2001 .
[ 6 ] J . Huan , W . Wang , and J . Prins . Efficient mining of frequent subgraph in the presence of isomorphism . ICDM , pages 549–552 , 2003 .
[ 7 ] J . Huan , W . Wang , J . Prins , and J . Yang . Spin : Mining maximal frequent subgraphs from graph databases . SIGKDD , 2004 .
[ 8 ] A . Inokuchi , T . Washio , and H . Motoda . An apriori based algorithm for mining frequent substructures from graph . PKDD , pages 13–23 , 2000 .
[ 9 ] N . Kashtan , S . Itzkovitz , R . Milo , and U . Alon .
Efficient sampling algorithm for estimating subgraph concentrations and detecting network motifs . Bioinformatics , 20(11):1746–1758 , 2004 .
[ 10 ] M . Kuramochi and G . Karypis . An efficient algorithm for discovering frequent subgraphs . TKDE , 2004 . [ 11 ] M . Kuramochi and G . Karypis . Finding frequent patterns in a large sparse graph . In SIAM International Conference on Data Mining , 2004 .
[ 12 ] S . Maslov and K . Sneppen . Specificity and stability in topology of protein networks . Science , 296(5569):910–913 , 2002 .
[ 13 ] CV Mering , R . Krause , B . Snel , et al . Comparative assessment of largescale data sets of protein protein interactions . Nature , 417:399–403 , 2002 .
[ 14 ] HW Mewes , D . Frishman , U . Guldener , et al . Mips : a database for genomes and protein sequences . Nucleic Acids Res , 30(1):31–34 , 2002 .
[ 15 ] R . Milo , S . Shen Orr , S . Itzkovitz , N . Kashtan ,
D . Chklovskii , and U . Alon . Network motifs : Simple building blocks of complex networks . Science , 298:824–827 , 2002 .
[ 16 ] R . Saito , H . Suzuki , and Y . Hayashizaki . Construction of reliable protein protein interaction networks with a new interaction generality measure . Bioinformatics , 19:756–763 , 2002 .
[ 17 ] R . Saito , H . Suzuki , and Y . Hayashizaki . Interaction generality , a measurement to assess the reliability of a protein protein interaction . Nucleic Acids Res , 30:1163–1168 , 2002 .
[ 18 ] F . Schreiber and H . Schwobbermeyer . Frequency concepts and pattern detection for the analysis of motifs in networks . Transactions on Computational Systems Biology , 3(LNBI 3737):89–104 , 2005 .
[ 19 ] V . Spirin and LA Mirny . Protein complexes and functional modules in molecular networks . PNAS , 100(21):12123–12128 , 2003 .
[ 20 ] P . Uetz , L . Giot , G . Cagney , et al . A comprehensive analysis of protein protein interactions in saccharomyces cerevisiae . Nature , 403(6770):623–627 , 2000 .
[ 21 ] X . Yan and J . Han . gspan : Graph based substructure pattern mining . ICDM , 2002 .
Research Track Paper115
