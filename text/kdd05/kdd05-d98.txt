Reasoning about Sets using Redescription Mining
Mohammed J . Zaki
Department of Computer Science Rensselaer Polytechnic Institute
Troy , NY 12180 , USA zaki@csrpiedu
ABSTRACT Redescription mining is a newly introduced data mining problem that seeks to find subsets of data that afford multiple definitions . It can be viewed as a generalization of association rule mining , from finding implications to equivalences ; as a form of conceptual clustering , where the goal is to identify clusters that afford dual characterizations ; and as a form of constructive induction , to build features based on given descriptors that mutually reinforce each other . In this paper , we present the use of redescription mining as an important tool to reason about a collection of sets , especially their overlaps , similarities , and differences . We outline algorithms to mine all minimal ( non redundant ) redescriptions underlying a dataset using notions of minimal generators of closed itemsets . We also show the use of these algorithms in an interactive context , supporting constraint based exploration and querying . Specifically , we showcase a bioinformatics application that empowers the biologist to define a vocabulary of sets underlying a domain of genes and to reason about these sets , yielding significant biological insight .
Categories and Subject Descriptors : H28 [ Database Management ] : Database Applications Data Mining ; I26 [ Artificial Intelligence ] : Learning
General Terms : Algorithms .
Keywords : redescription , data mining , minimal generators , closed itemsets .
1 .
INTRODUCTION
Redescription mining is a recently introduced data mining problem [ 7 ] that seeks to find subsets of data affording multiple definitions . The input to redescription mining is a vocabulary of sets ( or boolean propositions ) over a domain and the goal is to construct two distinct expressions from this vocabulary that induce the same subset over the domain . Besides constituting a new class of patterns , we can think of redescriptions as a useful way to reason about overlaps , similarities , and differences in the given vocabulary .
Naren Ramakrishnan Dept . of Computer Science Virginia Tech , Blacksburg
VA 24061 , USA naren@csvtedu
B
R
Cuba
Canada
Russia China
Chile
Brazil
USA
UK
Argentina
France
G
Y
Figure 1 : An example input to redescription mining .
To see how , consider the four sets shown in Fig 1 over ten objects ( in this case , countries ) . The colors green , red , blue , and yellow ( from bottom right , counterclockwise ) refer to the sets ‘permanent members of the UN security council,’ ‘countries with a history of communism,’ ‘countries with land area > 3 ; 000 ; 000 square miles,’ and ‘popular tourist destinations in the Americas ( North and South).’ We will refer to such sets as descriptors .
Notice that the descriptors of Fig 1 induce a partition containing 6 non empty blocks although , with 10 objects , we could have had up to 10 non empty blocks . Another way to see this deficiency is from the viewpoint of the sets : four sets can support 24 = 16 different objects but there are only 10 objects and even these 10 objects are not all distinct . For instance , fChile , Brazil , Argentinag are indistinguishable from each other , and so are the members of fUK , Franceg , fRussia , Chinag . Empty blocks in a partition are key to how redescriptions arise in a dataset .
Let us define the boolean propositions G , R , B , and Y ( for ‘green,’ ‘red,’ ‘blue,’ and ‘yellow’ ) to denote containment in the above four sets . Consider the countries denoted by BY B ^ :Y , ie , the set of countries with land area > 3 ; 000 ; 000 square miles outside of the Americas ( Y and :Y denote the negation of Y ) . We can systematically restate this expression as follows :
BY = BY ( RG + RG + RG + RG )
= BY RG + BY RG + BY RG + BY RG = BY RG = BY RG + BY RG + BY RG + BY RG
= ( BY + BY + BY + BY )RG = RG
RG
RG
RG
RG
RG
RG
RG
RG
RG
RG
RG
RG
RG
RG
RG
RG
RG
RG
RG
RG
BY
BY
BY
BY
BY
BY
BY
BY
RG
RG
RG
RG
BY
BY
BY
BY
BY
BY
BY
BY
RG
RG
RG
RG
BY
BY
BY
BY
BY
BY
BY
BY
RG
RG
RG
RG
BY
BY
BY
BY
BY
BY
BY
BY
BY
BY
BY
BY
RG
RG
RG
RG
RG
RG
RG
RG
BY
BY
BY
BY
Figure 2 : Obtaining redescriptions by simple operations on Karnaugh maps . The top row shows one legal sequence of moves and the bottom row shows another sequence ; notice that both maps start from the same initial configuration . Removed cells are marked with a ‘’ If the moves are different , we obtain a non trivial redescription . In this case , the moves are ( i ) removing all but one colored cell from both maps , ( ii ) removing some uncolored cells from both maps , ( iii ) removing some uncolored cells from only the top map , followed by ( iv ) removing some uncolored cells from only the bottom map . The final maps capture the redescription between BY ( top ) and RG ( bottom ) .
The first step is by marginalizing over the variables R and G , the second step is an application of the distributive law , the third step is data specific , and gets rid of conjunctions that denote empty blocks , the fourth step is again dataspecific but this time introduces empty conjunctions , which are grouped in the fifth step , and marginalized out finally . We have arrived at our first redescription :
2 . An uncolored cell can be removed from either ( or both ) maps . Notice that this move does not affect the number of objects represented by the maps .
Some sample moves are shown in Fig 2 . At the end of the game , we read off a redescription by relating the disjunctions of cells remaining in both maps :
BY , RG ie , ‘Countries with land area > 3 ; 000 ; 000 square miles outside of the Americas’ are the same as ‘Permanent members of the UN security council who have a history of communism.’ This redescription re defines the set fRussia , Chinag . A redescription is hence a shift of vocabulary , or a different way of communicating the same information . Redescription mining can therefore be viewed as a generalization of association rule mining , from finding implications to equivalences ; as a form of conceptual clustering , where the goal is to identify clusters ( here , of countries ) that afford dual characterizations ; and as a form of constructive induction , to build features based on given descriptors that mutually reinforce each other . 1.1 Understanding Redescriptions
An intuitive way to understand the structure of redescription space is via a simple game on Karnaugh maps . The leftmost part of Fig 2 depicts the Karnaugh map for four boolean variables , reproduced in both rows . Each cell in the map is a conjunction over four boolean variables . A colored cell indicates a non empty block for our example dataset in Fig 1 . For example , the cell ( BY ; RG ) denotes the block fRussia , Chinag . We can interpret a map to be the disjunction of all its cells ; since the starting maps are the same , they both represent the same 10 objects and hence constitute a trivial redescription , ie , a tautology . The rules of the game are :
1 . A colored cell can be removed as long as it is removed from both maps . Notice that this will make the maps represent fewer objects .
( BY RG _ BY RG _ BY RG _ BY RG )
,
( BY RG _ BY RG _ BY RG _ BY RG ) simplification of which yields BY , RG , as before .
The above viewpoint reveals two important insights . First , we can obtain redescriptions for any combination of the colored cells , by just retaining them in both rows of the game . Second , even for a single choice of these sets , there are an exponential number of redescriptions , each of which merely differs from another in the choice of uncolored cells that were retained . Interestingly , the form of expressions participating in a redescription follows in a very natural way from the subset of colored and uncolored cells that are retained .
In Fig 2 both maps permit descriptions as conjunctions because we are retaining all cells in a single row or column . Fig 3 presents situations ( from different datasets ) with expressions in different forms . The top left part of the figure represents a disjunction of all cells in the bottom three rows , or B _ Y . The bottom left part of Fig 3 represents a disjunction of all cells in the rightmost two columns , which is represented quite succinctly as R . These maps hence capture the redescription B _ Y , R . On the other hand , the right maps denote the redescription B _ Y , R _ G . The reader can easily design examples where we can neither simplify into conjunctions or disjunctions , and must instead adopt a more general bias , such as CNF ( conjunctive normal form ) . In this paper , due to space constraints , we restrict the discussion of redescription mining to those relating conjunctions on both sides ( possibly involving negations ) . But the above discussion highlights how the framework can be extended to mining disjunctions and more general forms .
RG
RG
RG
RG
RG
RG
RG
RG
BY
BY
BY
BY
BY
BY
BY
BY
RG
RG
RG
RG
BY
BY
BY
BY
BY
BY
BY
BY
RG
RG
RG
RG
Figure 3 : Examples of redescriptions in different biases . The left maps redescribe a disjunction ( top ) to a conjunction ( bottom ) . The right maps redescribe a disjunction ( top ) into another disjunction ( bottom ) . 1.2 Practical Usage Contexts
One reason why we adopt the conjunctions bias is its suitability for the application context of geneset exploration in bioinformatics . Here we are given G , a set of genes and D , a set of descriptors ( gene subsets ) . Example descriptors are : ‘genes localized in cellular compartment nucleus,’ ‘genes upexpressed two fold or more in heat stress,’ ‘genes encoding for proteins that form the Immunoglobin complex,’ ‘genes involved in glucose biosynthesis,’ and even ‘genes targeted by Professor X for further study.’ It can be argued that , in the post sequencing era , bioinformatics is suffering from an information overload of descriptors , as every scientist pursues a preferred way of identifying subsets of genes from the massive cardinality of the genome . The goal of redescription mining is to connect these diverse vocabularies , by relating set theoretic constructs formed over the corresponding descriptors . For instance , we might find that ‘genes expressed in the desiccation experiment except those participating in universal stress response’ are the same as ‘genes significantly expressed 2 fold positively or negatively in the salt stress experiment.’ The underlying premise is that genesets that can indeed be defined in ( at least ) two ways are likely to exhibit concerted behavior and are , hence , interesting .
Typically a biologist would like to study gene sets by first identifying a focus set of genes and then systematically slicing and dissecting the set , to answer questions such as : ffl What redescriptions do a given set of genes participate in ? What redescriptions does the presence of a given descriptor induce ? ffl Starting with two dissimilar ( not disjoint ) sets of genes , say X and Y , how can we systematically remove elements from both sides , so that we obtain a redescription ? Note that we are only allowed to discard elements that correspond to unions of cells ( colored or uncolored ) in the Karnaugh map . ffl Are there genesets that cannot be redescribed into each other through systematic removals of elements ? If so , what is the best approximation that can be achieved ? ffl Since redescriptions induce equivalence classes over the space of possible descriptor expressions , what are the ‘densest’ such classes ?
Because systematic projection of elements out of a set involves either set intersection or set differences , we can address all of the above questions by mining redescriptions between conjunctions of descriptors . 1.3 Connections to Association Rule Mining
The astute reader would have noticed the connections between redescription mining and association rule mining . If we think of objects ( eg , countries , genes ) as transactions and descriptors ( including their negations ) as items , then a colored cell in the Karnaugh map corresponds to a closed itemset from the association mining literature [ 11 ] . This is because each cell is minimal in its contents ( transactions ) but maximal in its use of descriptors ( items ) . In particular , all such closed sets will contain all descriptors , in either negated or non negated form1 . A reducible row or column or submatrix of the Karnaugh map with some uncolored as well as colored cells corresponds to a non closed itemset . For instance , the disjunction of all four cells in the third row , corresponding to BY , can also be represented by just the fourth cell , ie , BY RG . The combination of descriptors BY is hence not closed ( and its closure is given by BY RG ) . A row or column or submatrix of the Karnaugh map with only colored cells that is reducible to conjunctive form ( eg , the first two columns in the last row of Fig 2 ) is also a closed itemset ; this will undoubtedly cover more transactions and be described by fewer items . With these observations , we can effectively relate our goal of mining redescriptions in conjunctive form to the task of mining closed itemsets ( descriptor sets ) and then obtaining all reducible submatrices of the Karnaugh map ( again , restricting our bias to conjunctions ) to yield redescriptions . It is interesting that this natural extension of the association rule framework ( from implications to equivalences ) has not been studied before ( The reader should keep in mind that the Karnaugh map metaphor is used in this paper primarily as a conceptual tool to understand redescription spaces and that our algorithms do not explicitly reason with cells of the Karnaugh map , as outlined here . ) 1.4 Contributions of this Paper
We hasten to add that such a generalization of the association rule framework is not as easy as it appears . First , the datasets for redescription mining are highly dense . Since each gene participates in either a descriptor or its negation , the datasets are exactly 50 % sparse . Studying redescriptions within this context poses a unique set of challenging problems . One of our contributions is that we explain how we can curtail the complexity by adopting a constraint based approach where we study the lattice of closed descriptor sets only around genes or descriptors of interest .
Our second contribution is a precise theoretical formulation for a basis for all redescriptions using the notion of minimal generators of closed descriptor sets . We formulate three classes of redescriptions : ( i ) exact , ( ii ) conditional , and ( iii ) approximate . They differ from the viewpoint of
1Throughout this paragraph , it is important to remember that both the given descriptors and their negations constitute the items ; without the negations , the analogies in this paragraph will not hold .
Jaccard ’s coefficient . The Jaccard ’s coefficient J between two sets X and Y is the ratio of the size of their intersection jX\Y j to the size of their union , ie , jX[Y j . An exact redescription has J = 1 . An approximate redescription has J < 1 . Notice that this can happen when either X or Y is a subset of the other and also when the two sets straddle , ie , X , Y 6= fg 6= Y , X . A conditional redescription can be viewed as originating as an approximate redescription but which has been transformed into an exact redescription by supplying further information . For instance , the redescription X , Y could have J < 1 but X \ Z , Y \ Z might hold at J = 1 . In other words , conditional on Z , X and Y can be redescribed into each other . We write such redescriptions as X , Y jZ . Note that approximate redescriptions correspond to the minimal non redundant exact or inexact rules described in [ 11 ] , and thus we focus in this paper only on exact and conditional redescriptions .
Finally , the algorithmic approach proposed here also differs significantly from CARTwheels , an alternating algorithm for mining redescriptions presented in [ 7 ] . For instance , these two algorithms employ different biases : CARTwheels uses a disjunction of conjunctions bias , with length restrictions on the size of the expression ( determined by the size of the CARTs used in the alternation ) , whereas our approach uses only a conjunctions bias ( for this reason , it is not possible to compare the results of the two algorithms ) . More importantly , CARTwheels ’s stochastic search policy can mine all redescriptions in a dataset only at the expense of redundancy ( ie , revisiting some redescriptions again and again ) . It is hence not suited for interactive and responsive analysis of very large scale datasets . Our proposed framework overcomes these drawbacks ; we showcase its application to studying the transcriptome of the yeast S . cerevisiae with public domain datasets ( taken from [ 7] ) .
2 . FORMAL CONCEPTS
Let D = fd1 ; d2 ; : : : ; dng be a set of binary valued attributes or descriptors , and let G = fg1 ; g2 ; : : : ; gmg be a set of genes . Without loss of generality , we assume that , discounting identical genes , m < 2n ( if m = 2n there can be no redescriptions , since all cells are colored ; m cannot be greater than 2n since n descriptors can only afford that much variability ) . A dataset S is then a subset of G . 2D ( note that 2D denotes the power set of D , ie , the set of all subsets of D ) ; in other words , the dataset S is a set of tuples of the form ( g ; X ) , where g 2 G is a gene , and X D a set of descriptors describing the given gene g . As mentioned in the introduction , the descriptors can be defined over many vocabularies , such as gene expression , functional categorization . A subset of genes G G is also called a geneset , and a subset of descriptors X D is also called a dset . For example , consider the dataset shown in Table 1 . Here we have six genes and seven descriptors ; gene g1 participates in the descriptors fd1,d2,d4,d5,d6g . In what follows , we omit set notation for convenience and instead represent the descriptors as a conjunction of boolean propositions as shown in Table 1 .
For a dset X D , we denote its corresponding geneset as g(X ) , ie , the set of all genes described by X . For a geneset Y , we denote its corresponding dset as d(Y ) , ie , the set of descriptors common to all the genes in Y . The composition of the two functions , namely , g that maps from dsets to genesets , and d that maps from genesets to dsets , is called
Table 1 : Sample dataset .
Gene Descriptors g1 g2 g3 g4 g5 g6 d1d2d4d5d6 d2d3d5d7 d1d2d4d5d6 d1d2d3d5d6d7 d1d2d3d4d5d6d7 d2d3d4 a closure operator [ 3 ] , given as c(X ) = d(g(X) ) . A dset X is said to be closed if and only if ( iff ) c(X ) = X [ 3 , 11 ] . In other words , dset X must be a fixed point of the closure operator . For instance , X = d1d5 is not closed since c(d1d5 ) = d(g(d1d5 ) ) = d(g1g3g4g5 ) = d1d2d5d6 . On the other hand d1d2d5d6 is closed since c(d1d2d5d6 ) = d(g(d1d2d5d6 ) ) = d(g1g3g4g5 ) = d1d2d5d6 . Equivalently , a dset X is closed if there exists no proper superset Y X with g(X ) = g(Y ) . Note that a dset X is said to be frequent iff its corresponding geneset has enough cardinality , ie , iff jg(X)j minsup , where minsup is some user specified threshold .
Let X be a closed dset . We say that a dset Y is a generator of X iff 1 ) Y X , and 2 ) g(Y ) = g(X ) . Equivalently , Y is a generator of X if c(Y ) = X . Y is called a proper generator iff Y fl X . A proper generator cannot be closed , since by definition , no closed subset of X can have the same geneset as X . We say that Y fl X is a minimal generator [ 1 ] of X iff Y is a proper generator of X , and there does not exist another proper generator Z fl Y of X .
Note that a closed dset X maximally describes its corresponding geneset G = g(X ) , ie , X represents the maximal set of descriptors describing the maximal set of genes G ; no other descriptor can be added to X to describe the same geneset G , and no other gene can be added to G without changing the dset X ( ie , without removing some descriptors from X ) . As mentioned before , in Fig 2 this corresponds to colored cells and clusters of colored cells that are reducible ( into a conjunctive form ) . On the other hand , a minimal generator of X , say Y , minimally describes the same geneset G , since by definition g(X ) = G = g(Y ) , and since Y is minimal , no descriptor can be removed from Y , and yet describe the same geneset G . In Karnaugh map terminology , a minimal generator is a submatrix containing both colored and uncolored cells that can be simplified to a conjunction representing only the colored cells .
Figure 4 shows all the 10 closed dsets along with their genesets and their minimal generators , for our example dataset , arranged in a lattice ( ie , a link exists between two closed dsets X and Y iff there does not exist another closed dset Z such that X fl Z fl Y ) . For example the dset X = d1d2d4d5d6 maximally describes the geneset G = g1g3g5 , and its minimal generators are , Y1 = d1d4 , Y2 = d4d5 , and Y3 = d4d6 .
Definition 21 Let X ; Y ; Z D be dsets , and let G G be a geneset . A conditional redescription for a geneset G is a rule of the form G : ( X ( ) Y )jZ , such that i ) X 6= ; and Y 6= ; , ii ) X \ Y = X \ Z = Y \ Z = ; , iii ) g(X [ Z ) = g(Y [ Z ) = G . Here the dset Z is called the condition . The rule means that the dsets X and Y are equivalent or describe the same geneset G given dset Z . If Z = ; , then the rule is simply an ( unconditional ) redescription for geneset G ; in this case we get the simpler conditions : i ) X 6= ; and Y 6= ; , ii ) X \ Y = ; and iii ) g(X ) = g(Y ) = G . dset : d1 d2 d3 d4 d5 d6 d7 geneset : g5 mingen : d1 d3 d4 , d3 d4 d5 , d3 d4 d6 , d4 d7 dset : d2 d3 d4 geneset : g5 g6 mingen : d3 d4 dset : d1 d2 d3 d5 d6 d7 geneset : g4 g5 mingen : d1 d3 , d1 d7 , d3 d6 , d6 d7 dset : d1 d2 d4 d5 d6 geneset : g1 g3 g5 mingen : d1 d4 , d4 d5 , d4 d6 dset : d2 d3 d5 d7 geneset : g2 g4 g5 mingen : d3 d5 , d7 dset : d1 d2 d5 d6 geneset : g1 g3 g4 g5 mingen : d1 , d6 dset : d2 d3 geneset : g2 g4 g5 g6 mingen : d3 dset : d2 d5 geneset : g1 g2 g3 g4 g5 mingen : d5 dset : d2 d4 geneset : g1 g3 g5 g6 mingen : d4 dset : d2 geneset : g1 g2 g3 g4 g5 g6 mingen : d2
Figure 4 : Closed dsets , genesets , and minimal generators .
Table 2 : Non redundant redescriptions .
Geneset Redescription g1g3g4g5 g2g4g5 g1g3g5 g4g5 g5 d1 ( ) d6 d3d5 ( ) d7 d1 ( ) d5jd4 d5 ( ) d6jd4 d1 ( ) d6jd4 d1d3 ( ) d6d7 d1d7 ( ) d3d6 d3 ( ) d7jd6 d3 ( ) d7jd1 d1 ( ) d6jd3 d1 ( ) d6jd7 d1 ( ) d5jd3d4 d1 ( ) d6jd3d4 d5 ( ) d6jd3d4 d1d3 ( ) d7jd4 d3d6 ( ) d7jd4 d3d5 ( ) d7jd4
Definition 22 Let X ; Y ; Z D and let G G G : X ( ) Y jZ is a minimal ( conditional ) redescription for geneset G iff there does not exist another redescription of the same geneset G G : X 0 ( ) Y 0jZ 0 , such that Z Z 0 and X 0 X and Y 0 Y . A minimal redescription is also called a non redundant redescription .
In other words a non redundant redescription describes a ( maximal ) geneset using a minimal number of descriptors . Table 2 shows all the non redundant redescriptions for the given genesets in our example database . Those genesets not shown , have no redescriptions . For example , there are no redescriptions involving the geneset G = g5g6 . It is minimally described by the dset Y = d3d4 , which is a minimal generator of the maximal descriptor set ( ie , closed ) d2d3d4 for G .
3 . ALGORITHMS
We now turn to efficient algorithms for mining the set of all non redundant redescriptions . The process requires three main steps : 1 ) mining the lattice of closed dsets from a given dataset , 2 ) computing the minimal generators of the closed dsets , and 3 ) non redundant redescription mining from the minimal generators . We detail each step below . 3.1 Constructing Closed Dset Lattice
To generate the minimal redescriptions , we need to construct the lattice of dsets . However , current closed set mining algorithms such as Closet+ [ 9 ] , Mafia [ 2 ] , and Charm [ 12 ] do not output the lattice explicitly ; their output is simply a list of all the closed sets found . It is possible to generate the lattice from a collection of closed sets C , but unfortunately , lattice construction has time complexity O(jCj2 ) [ 5 ] , which is too slow for a large number of closed dsets .
We decided to extend Charm to directly compute the lattice while it generates the closed dsets . The basic idea is that when a new closed set X is found , we efficiently determine all its possible closed supersets , P = fY jY 2 C ^ X fl Y g . The minimal elements in P form the \immediate" supersets or parents of X in the closed dset lattice . This approach leads to a very efficient algorithm , which we call CHARM L [ 13 ] .
CHARM L ( S G . 2D ) : 1 . [ ; ] = fdi : di 2 Dg 2 . Charm L Extend ( [; ] , Lr = f;g ) 3 . return L //lattice of closed sets
[ Xi ] = ;
Charm L Extend ( [P ] , Lc ) : 4 . for each Xi in [ P ] with increasing jg(Xi)j 5 . 6 . Update C ( Xi , [ P ] ) 7 . 8 . for each Xj > Xi in [ P ]
X = Xi [ Xj , g(X ) = g(Xi ) \ g(Xj ) and
C(X ) = C(Xi ) \ C(Xj )
Charm L Property(X ; Xi ; Xj )
9 . 10 . Ln = Subsumption Check Lattice Gen(Lc ; Xi ; C(Xi ) ) 11 . Charm L Extend ( [Xi ] , Ln ) 12 . delete [ Xi ]
Figure 5 : The CHARM L Algorithm .
Figure 5 gives the pseudo code for CHARM L(see [ 13 ] for full details ) . Let L denote the closed dset lattice , and Lr the root node of the lattice ; we assume that Lr = ; . CHARM L groups all dsets with prefix P , in an equivalence class , denoted [ P ] . CHARM L starts by initializing the prefix class [ ; ] with the individual descriptors ( line 1 ) . It then makes a call to the extension subroutine , passing it the parent equivalence class and the lattice root as the current lattice node .
Charm L Extend takes as input the current lattice node Lc ( initially the root node ) , and an equivalence class [ P ] . For each dset Xi 2 [ P ] ( line 4 ) , we combine it with other dsets Xj > Xi in [ P ] ( line 7 ) to form a longer dset . The routine Charm L Property tests inserts the newly created dset X = Xi [ Xj in the new class [ Xi ] . It also tests if two closed set properties are satisfied : 1 ) if g(Xi ) g(Xj ) we can replace the dset Xi with the larger dset Xi [ Xj , since whenever Xi describes a geneset , it also involves the descriptors in Xj , and 2 ) if g(Xi ) g(Xj ) then we replace Xj with Xj [ Xi for the same reason ( see [ 12 ] for more details ) . These properties allow CHARM L to efficiently prune the search tree . The routine Subsumption Check
Lattice Gen checks if the new prefix Xi is a closed set and if so inserts it into the closed dset lattice .
Whenever CHARM L generates a new closed dset it assigns it a unique closed dset identifier , called cid , and it maintains for each element Xi 2 [ P ] its corresponding cidset , denoted C(Xi ) , which is the set of all cids of already mined closed dsets that are supersets of Xi . Given C(Xi ) and C(Xj ) , one can obtain the set of closed dsets that contain X = Xi [ Xj by simply intersecting the two cidsets , ie , C(X ) = C(Xi ) \ C(Xj ) ( line 8 ) . Subsumption CheckLattice Gen enumerates all closed sets which are not subsumed ( ie , do not have the same geneset as some superset ) , but in addition , it also generates a new lattice node Ln for the new closed set Xi , and inserts it in the appropriate place in the closed dset lattice L . This new lattice node Ln becomes the current node in the next recursive call of the extension subroutine ( line 11 ) . Since the list of closed supersets of Xi may change whenever a new closed dset is added to the lattice , a check is made in line 6 to update C(Xi ) for each remaining element in the class .
Subsumption Check Lattice Gen(Lc ; X ; C(X) ) : 1 .
P = fZ 2 CjZ:cid 2 C(X)g //eliminate subsumed dsets for each Z 2 P do
2 . 3 .
4 . 5 .
6 . 7 . 8 . 9 . 10 . 11 . if jg(X)j = jg(Z)j then return Lc
//Insert X as parent of Lc Ln = X Lcparentsadd(Ln ) , Lnchildrenadd(Lc ) //Adjust Lattice P min = fZ 2 PjZ is Minimalg for all Z 2 P min do
Lnparentsadd(Z ) , Zchildrenadd(Ln ) for all Zc 2 Z:children do if Zc Ln then
Zcparentsremove(Z ) , Zchildrenremove(Zc )
12 . return Ln
Figure 6 : Subsumption Checking & Lattice Growth .
Subsumption Check and Lattice Generation : To check if a dset Xi is closed ( Figure 5 , line 10 ) , we apply SubsumptionCheck Lattice Gen shown in Figure 6 . This routine takes as input the current lattice node Lc , the new dset X , and the cidset C(X ) . The first task is to check if X is subsumed . For this we consider all closed dsets P that are supersets of X ( line 1 ) . If X has the same geneset ( jg(X)j ) cardinality as any of its supersets Z 2 P ( lines 2 ) , then X is subsumed ( this is true , since for X fl Z , g(X ) = g(Z ) ( ) jg(X)j = jg(Z)j ) and we return ( line 3 ) . Otherwise , the new lattice node is initialized as Ln = X ( line 4 ) . Each node in the lattice maintains a list of parents ( immediate supersets ) and children ( immediate subsets ) . We add the new node Ln as a parent of the current node Lc , and Lc as child of Ln ( line 5 ) . Out of all the closed supersets of Ln = X , the minimal supersets are found P min ( line 6 ) . Each minimal superset Z 2 P min becomes a parent of Ln ( and Ln a child of Z ) ( line 8 ) . Finally , for every child Zc of Z , if Zc fl Ln then its parent pointers have to be adjusted ; we remove Z from Zc ’s parents ( and Zc from Z ’s children ) ( lines 9 10 ) . Finally , we return the new lattice node Ln ( line 12 ) .
Updating C : Consider the Update C routine in CHARML ( Figure 5 , line 6 ) . After the recursive call to Charm LExtend ( Figure 5 , line 11 ) , new closed sets may have been generated , so we need to update the cidsets for all remaining elements in class [ P ] . That is for all dsets Xj 2 [ P ] , with Xj Xi , Update C adds the cids of all newly generated closed sets to C(Xj ) . 3.2 Finding Minimal Generators
Once the set of all closed dsets , C , for a given dataset has been found using CHARM L , the next step is to generate the set of minimal generators , M(X ) , for each dset X 2 C . Note that a minimal generator Z of a closed dset X is a minimal dset that is a subset of X , but not a subset of any of X ’s immediate closed subsets in the closed dset lattice L . Let Y = fY1 ; Y2 ; ; Ykg be the set of immediate closed subsets of X in L , and let M(Yi ) be the set of minimal generators of dset Yi . Further define the dset i = X , Yi to be those elements in X that are not in Yi , and let = f 1 ; 2 ; ; kg . A dset Z is called a hitting set of iff Z \ i 6= ; for all i 2 [ 1 ; k ] . A dset Z is called a minimal hitting set if there does not exist another hitting set Z 0 , such that Z 0 fl Z .
Theorem 31 Given dset X , the set of minimal generators of X , namely M(X ) is the same as the set of minimal hitting sets of .
A similar theorem was independently reported in [ 6 ] .
//X is a closed dset , //Y , the set of adjacent closed subsets of X in L MinimalGenerators(X ; Y ) : 1 . 2 . 3 . 4 . 5 . 6 . M(X ) = fZ 2 H(X)jZ is minimal inH(X)g ;
H(X ) = ; ; = f i = X , YijYi 2 Yg ; for each k tuple ( z1 ; z2 ; ; zk ) , with zi 2 i
Z = fz1 ; z2 ; ; zkg ; //removes duplicate zi ’s H(X ) = H(X ) [ fZg ;
Figure 7 : Finding Minimal Generators .
Our novel algorithm to find minimal generators is shown in Figure 7 , and is based on the above theorem . Given closed set X and the set Y of its immediate closed subsets ( say jYj = k ) , we first determine the set of differences ( line 2 ) . Next we construct each possible k tuple of the form ( z1 ; z2 ; ; zk ) by picking exactly one descriptor from each difference , ie , zi 2 i ( line 3 ) . Let Z be the set constructed from this k tuple , ie , Z = fz1 ; z2 ; ; zkg ( line 4 ) . Whereas the k tuple may have duplicate items , Z will , by set definition , remove any duplicate elements . By construction , it is clear that Z is a hitting set for . All such hitting sets are added to a set M ( X ) ( line 5 ) , and finally only the minimal dsets in M ( X ) are added to M(X ) ( line 6 ) , which thus contains all minimal hitting sets of , which are also the minimal generators of X .
For example , consider the dset X = d1d2d5d6 . As shown in Figure 4 , it has only one immediate closed subset Y1 = fd2 ; d5g . Thus 1 = d1d6 . In line 6 , each element in 1 will be picked in turn and added to H(X ) , and since a single element is minimal , we have M(X ) = fd1 ; d6g , as shown in Figure 4 . For the dset X = d1d2d3d4d5d6d7 , with immediate subsets Y = fd2d3d4 ; d1d2d3d5d6d7 ; d1d2d4d5d6g , we have = fd1d5d6d7 ; d4 ; d3d7g . Picking all 3 tuples with one element from each 1 we get the hitting sets H(X ) = fd1d3d4 ; d1d4d7 ; d3d4d5 ; d4d5d7 ; d3d4d6 ; d4d6d7 ; d3d4d7 ; d4d7g . The minimal sets in H(X ) are given as M(X ) = fd1d3d4 ; d3d4d5 ; d3d4d6 ; d4d7g which are the minimal generators for X . Figure 4 shows the minimal generators for all closed dsets . 3.3 Non redundant Redescription Generation
GenerateRedescriptions ( X 2 C ) : for all pairs Y ; Z 2 M(X )
Q = Y \ Z ; output : g(X ) : Y , Q ( ) Z , QjQ
Figure 8 : Non redundant Redescription Generation .
Let C be the set of all closed dsets . Given any closed dsets X 2 C and its corresponding geneset G = g(X ) , as well as the set of minimal generators of X , given as M(X ) = fY jY is a minimal generator of Xg , Figure 8 shows the algorithm for generating minimal/non redundant ( conditional ) redescriptions . For each distinct pair Y ; Z 2 M(X ) , we generate the rule G : Y , Q ( ) Z , QjQ , where Q = Y \ Z is the condition dset . Since we use minimal generators to produce the rule , we can guarantee that the rule is minimal . For example , consider the closed dset X = d1d2d5d6 with geneset G = g(X ) = g1g3g4g5 and minimal generators M = fd1 ; d6g , as shown in Figure 4 . The only possible ( unconditional ) redescription is G : d1 ( ) d6 , as shown in Table 2 . For the closed dset X = d1d2d4d5d6 , with geneset G = g(X ) = g1g3g5 , and minimal generator set M = fd1d4 ; d4d5 ; d4d6g , we obtain the following conditional redescriptions : G : d1 ( ) d5jd4 ; d5 ( ) d6jd4 ; d1 ( ) d6jd4 . All other redescriptions shown in Table 2 are obtained in a similar manner . Note that an unconditional redescription is found for any disjoint pair of minimal generators , whereas a conditional redescription is found for any nondisjoint pair of minimal generators .
Observe that ( exact ) redescriptions always occur in pairs . When X , Y holds , so does :X , :Y . Due to our support threshold minsup , however , we may not mine both forms explicitly . Even if both forms conform to the support threshold , recall that we mine only those redescriptions where both sides obey the conjunctions bias ; so if X or Y is a conjunction of more than one descriptor , its negation would be a disjunction , and hence outside the purview of our bias . 3.4 Constraint Based Mining
As described above , our methods are oblivious of the meaning of a descriptor , ie , the mining process is not aware which of them are ‘positive’ and which are negated . In general a large number of negated descriptors leads to a combinatorial blowup in the number of closed dsets . To make mining tractable we introduce several constraints . The first constraint enforces the presence of certain descriptors in the mined redescriptions . The input is in the form of a set of constraints : fC1 ; C2 ; ; CkjCi fl D ; i = 1 ; ; kg . Each constraint Ci specifies those descriptors that must all be present in a redescription . Each redescripion output must satisfy at least one constraint Ci . Thus the set of constraints are treated as a disjunction over conjunctions of descriptors . We efficiently check each constraint during mining . In the CHARM L pseudo code shown in Figure 5 , we do the
Table 3 : Datasets used in this paper . DB NumGenes NumDesc AvgSize G1 G2 G3
824 1700 1189
74 332 168
88 81 52 following test on each prefix class [ P ] ( before line 4 ) . Let U = Si Xi 2 [ P ] , then it suffices to check if U is a superset of at least one constraint Cj . If not , U cannot possibly satisfy any constraint and thus we can discard the entire search tree under [ P ] . This leads to very effective pruning . Another check of the constraints is made before adding a new closed set to the lattice .
We also introduce a constraint on the genesets . As in the case of dsets , the input is in the form of sets over G and the meaning is similar . The check of these gene constraints are also done effectively while mining as follows : whenever we obtain a new geneset g(X ) in Fig 5 ( line 4 ) , we keep track of the genes not in the intersection . If at least one constraint Ci remains unaffected , the new dset is kept for the next step , or else it is pruned .
We also implemented the ability to impose a length constraint on the mined closed dsets . To implement this , it is not correct to simply stop extending a dset if its length exceeds some threshold , since this would most likely produce a non closed set , leading to wrong minimal generators . The correct way is to impose the length constraint on the minimal generators! Note that every minimal generator will be visited by the CHARM L algorithm while computing closed sets . So while we never produce a minimal generator with length exceeding the constraint , a closed dsets might be longer . This ensures that the set of dsets with the length constraint are a subset of those without the constraint .
Finally , we have developed an interactive language , using MATLAB style scripting capabilities , to support the exploration of genesets through redescription analysis . The language contains primitives to define subsets of genes and descriptors , to request that a redescription be attempted for a selected set of genes ( or involving those induced by a selected set of descriptors ) , to impose constraints on the mining process , manage the resulting mined redescriptions , and to investigate how the space of possible answers changes with varying inputs . The next section contains running examples of how a bioinformatician would use this language .
4 . EXPERIMENTAL RESULTS
We now present an application of redescription mining to studying gene expression datasets from microarray experiments conducted on the budding yeast Saccharomyces cerevisiae . We utilize the three datasets from [ 7 ] ( see Table 3 ) to study the scalability and performance of our implementations . The biological results are explained and detailed with specific reference to one of them , namely G1 .
The specific details of the datasets can be had from [ 7 ] but we briefly review their characteristics here . All datasets define a small set of yeast genes ( NumGenes in Table 3 ) but relatively greater number of descriptors ( NumDesc ) . The average number of descriptors per dataset is also high ( AvgSize ) . The descriptors are drawn a variety of sources . Some denote expression levels in specific microarray measurements taken from Gasch et al . [ 4 ] and Wyrick et al . [ 10 ] . For instance , ‘genes negatively expressed one fold or below in the 15 minute time point of the 1M sorbitol experiment’ is one such descriptor . A second class of descriptors asserts membership of genes in targeted taxonomic categories of the Gene Ontology ( biological processes ( GO BIO ) , cellular components ( GO CEL ) or molecular functions ( GO MOL) ) . A final class of descriptors is based on clustering time course datasets using a k means clustering algorithm [ 8 ] and using the clusters as descriptors . All descriptors are given an identifier as well as mnemonic for ease of interpretation . 4.1 Biological Results
We now present two interactive scenarios of how a biologist will use our algorithms , with the G1 dataset , as well as one example of a cluster of genes dense in conceptual descriptor space . For the results presented in this section , we negated each of the 824 descriptors in the G1 dataset and added it back to the descriptor pool , so that the algorithm can be used to mine set differences in addition to intersections . This yields a 74 . 1648 input boolean matrix . Recall that , by construction , such a dataset will be exactly 50 % sparse .
> load yeast descriptors ; > descriptors([YOR374W] ) ; ans = [ d127 , d183 , d184 , ] ;
> explain(d184 ) ; ans = ( GASCH ENV 05004 ) Heat Shock 20 mins hs 1 >= 5
> genes([d184] ) ; ans = [ g4 , g10 , g12 , ] ;
> find(descriptors,’Heat Shock*15*’ ) ; ans = [ d146 , d181 , d183 , ] ;
> explain(d183 ) ; ans = ( GASCH ENV 05003 ) Heat Shock 15 mins hs 1 >= 5 > Jaccards(\d183",\d184" ) ; ans = 0.857 ;
> dsubset = find(descriptors,’GO*MOL*’ ) ; > dsubset = dsubset + [ d183 d184 ] ; > gsubset = genes(dsubset ) ; > constraints = mustinclude([d183 d184] ) ; > minsup = 15 ; jac = 1 ; > redescribe(gsubset,dsubset,constraints,minsup,jac ) ; no redescriptions found . > dsubset = [ ] ; > dsubset = find(descriptors,’GO*BIO* j GO*CEL* j GO*MOL*’ ) ; > dsubset = dsubset + [ d183 d184 ] ; > gsubset = genes(dsubset ) ; > redescribe(gsubset,dsubset,constraints,minsup,jac ) ; 1 redescriptions found . ans = \d183 d1212 d1284 d1339" is redescribed as \d184 d1133"
> prettyprint(ans ) ; ans = ( GASCH ENV 05003 ) Heat Shock 15 mins hs 1 >= 5 EXCEPT ( GO MOL 1578 ) mannose transporter EXCEPT ( GO CEL 30312 ) external protective structure EXCEPT ( GO BIO 06000 ) fructose metabolism IS REDESCRIBED AS ( GASCH ENV 05004 ) Heat Shock 20 mins hs 1 >= 5 EXCEPT ( GO MOL 05554 ) molecular function unknown ;
Figure 9 : Interactive exploration of genesets using redescription analysis . 411 Interactive Scenario 1
The first scenario is depicted in Fig 9 and illustrates a biologist who explores descriptors around his favorite gene
| YOR374W , an ORF in S . cerevisiae that encodes for an aldehyde dehydrogenase ( an enzyme EC1215 that catalyzes the reaction from faldehyde , NAD+ , H20g to facid , NADHg ) , and which he knows to be very highly expressed in time point 20 minutes of the Gasch heat shock condition ( more than five fold ) . Aldehyde dehydrogenase is important enzymatically because the system must obtain increased energy from acetaldehyde under strenuous growth conditions . The biologist begins the analysis by identifying the descriptors that Y0R374W participates in . One of them is descriptor d184 that denotes all ORFs that are expressed more than five fold in the above time point ; it contains 19 genes . Looking at the nearby time point ( 15 minutes ) the biologist notices that the corresponding descriptor ( d183 ) contains 21 genes , with 18 in common with d184 . The Jaccard ’s coefficient between these descriptors is already high ( 0.857 ) but the biologist is curious to determine if there could be an exact redescription by using the GO vocabularies . This might be significant if physiologically some response/repair could be associated with the transition between the time points . He adds the GO molecular function taxonomy into the session but the Jaccard ’s coefficient doesn’t improve . Then , he removes the GO molecular function taxonomy and adds the cellular component taxonomy and the biological process taxonomy , in turn . None of the three choices improves the quality of the redescription . Finally , he adds all three taxonomies simultaneously , and the system presents him with a perfect redescription : d183 , d388 , d460 , d515 , d184 , d309
( In Fig 9 note that the set subtractions represented as conjunctions of negated descriptors ; in this convention , subtraction of descriptor d388 is captured as conjunction of descriptor d1212 , whose index is 824 plus the original d388 ) : In other words , to make d183 equivalent to d184 , we need to subtract descriptors d388 , d460 , and d515 on the left ( to remove 3 genes ) and subtract descriptor d309 on the right ( to remove 1 gene ) , bringing the commonality to 18 , as desired . As Fig 9 explains , d388 refers to the GO molecular function category : mannose transporter , d460 refers to the GO cellular component category : external protective structure , and d515 refers to the GO biological process category : fructose metabolism . d309 , on the right side , incidentally happens to refer to genes whose molecular function , according to GO , is unknown . The implied message , from the above redescription , is that as we go from time point 15 minutes to time point 20 minutes genes belonging to the above three categories drop out of the highly expressed ( 5 fold ) category .
412 Interactive Scenario 2
The above example showed how we can relate two different time points but the task is relatively easy given the high degree of initial overlap between the sets . Let us add more complexity to the mix and , this time , relate not only a different time point but also a less stringent threshold . One such descriptor is d141 which is the set of genes expressed more than ( just ) two fold in the 10 minutes time point ( not 20 minutes , as in descriptor d184 ) . Since d141 contains 50 genes , it cannot enjoy a Jaccard ’s coefficient of more than 0.38 with descriptor d184 . This time , the system is configured to use all available descriptors . It arrives at 34 redescriptions involving d141 as well as d184 , but all of
G1
G1
G1
) s ( e m T i
) s ( e m T i
) s ( e m T i
100
10
1
0.1
0.01
0.001
0.5
1000
100
10
1
0.1
0.01
0.001
0.0001
1e 05
1000
100
10
1
0.1
0.01
0.001
0.0001
1e 05
Total Lattice Mingen Rules y t i l i a n d r a C y t i l i a n d r a C y t i l i a n d r a C
0.4
0.3
0.25
0.2
Minimum Support ( % )
G2
Total Lattice Mingen Rules
0.3
0.2
0.15 0.125
0.1
Minimum Support ( % )
G3
Total Lattice Mingen Rules
0.2
0.15
0.1
0.05
Minimum Support ( % )
Closed Exact Cond
1e+08
1e+07
1e+06
100000
10000
1000
100
10
1 0.5
0.4
0.3
0.25
0.2
Minimum Support ( % )
G2
1e+08
1e+07
1e+06
100000
10000
1000
100
10
1
1e+09 1e+08 1e+07 1e+06 100000 10000 1000 100 10 1
Closed Exact Cond
0.3
0.2
0.15 0.125
0.1
Minimum Support ( % )
G3
Closed Exact Cond
0.2
0.15
0.1
0.05
Minimum Support ( % ) h t g n e L t e s D t h g n e L t e s D h t g n e L t e s D
40
35
30
25
20
15
10
0.5
45
40
35
30
25
20
15
10
5
50
45
40
35
30
25
20
15
10
0.4
0.3
0.25
0.2
Minimum Support ( % )
G2
0.3
0.2
0.15 0.125
0.1
Minimum Support ( % )
G3
0.2
0.15
0.1
0.05
Minimum Support ( % )
Figure 10 : Mining time , rule cardinality , and length of longest closed dset for three datasets . them are expressed conditionally ; example : d141 , d515 , d608 , d184jd183
Recall that d515 refers to the fructose metabolism category , but it cannot possibly help in improving the Jaccard ’s coefficient as it removes only one gene from d141 . Descriptor d608 , on the other hand , refers to the set of genes expressed four fold or above in a different experiment ( histone depletion ) . In other words , to go from genes expressed 2 fold or above to genes expressed 5 fold or above ( across time points ) , we have to remove the genes associated with fructose metabolism and that have relatively high positive expression in histone depletion . The conditional descriptor d183 can be viewed as a further conjunct on both sides , but since it already has significant overlap with d183 , has only an incremental ‘trimming’ role to offer ( eg , the removal of few genes from both sides ) . The implied message from this redescription is that the genes that are only moderately expressed ( between 2 and 5 fold ) in the heat shock time points are those that are highly expressed in the histone depletion time point . Further inspection of the 34 redescriptions mined above reveals that all of them contain the only other aldehyde dehydrogenase represented in the dataset YMR170C ( NAD(P)+ ) . This brings out the ability of redescription mining to bring concerted genes together .
413 Identifying Dense Conceptual Clusters
If we view closed itemsets as biclusters then it is of interest to determine dense conceptual clusters underlying a given set of constraints . We restricted our attention to a set of genes clustered together in a k means descriptor ( d77 ; HS2 KMC 01 ) for the Heat Shock experiment . When queried for all redescriptions ( at J = 1 and a minimum support threshold of 13 ) that involve this descriptor , we obtained 867 redescriptions! Recall that the total number of input descriptors is less than double of this number . On closer inspection , we noticed that all these redescriptions comprised only 98 descriptors and all were conditional re descriptions , with an almost majority having d77 as the conditional . Hence , this means that , coupled with d77 , many of these descriptors forms a minimum generator of the closure of d77 . Sometimes , two or more of these descriptors need to be conjoined in order to form the minimum generator . Thus these descriptors , together with the genes they cover ( 14 of them , out of the total 74 ) form a dense bicluster in the dataset . 4.2 Performance Results
We ran some more experiments to test the performance of our approach . Here we only consider ‘positive’ descriptors , since the whole set of descriptors ( including negative ones ) can only be mined using constraints . For example , if all descriptors are used , then the average size would be the same as NumDesc , for each dataset . Our experiments were run on a 3.2Ghz Pentium4 machine with 2GB of memory running Linux , with a 7200rpms 200GB IDE disk .
Figure 10 shows the running time for the various steps in mining redescriptions , as well as the rule cardinalities for the different datasets as a function of minimum support threshold . The left column shows the time , where the legends ‘Total’ means the total execution time for the entire algorithm , ‘Lattice’ means the time it takes to build the frequent closed dset lattice , ’Mingen’ means the time it takes to generate the minimal generators for each closed dset , and ‘Rules’ means the time it takes to extract the self and conditional redescriptions . The middle column shows the cardinalities , where the legends ‘Closed’ means the number of frequent closed dsets mined , ‘Exact’ means the number of exact redescriptions and ‘Cond’ means the number of conditional redescriptions mined . The right column shows the longest closed dset found at a given support threshold .
We can observe that for the G1 and G2 datasets most of the time is spent in mining the closed dsets and constructing the lattice , whereas the minimal generator time is lower and rule generation time is even lower . However , as we decrease minimum support , more closed dsets are found and there is an increase in the number of exact redescriptions . At the same time there is an even bigger explosion in the number of conditional rules . This leads to an increase in the running time for rule generation . Notice also that for G1 and G2 the longest closed set has size 40 . For G3 , the effect is even more pronounced . We find that the number of exact and conditional rules increases dramatically , and thus the rule generation time dominates . The times for closed dset mining , lattice generation , and minimal generators is negligible . The longest dset mined for G3 has length 50!
5 . DISCUSSION
We have demonstrated a formal approach to redescription mining , along with examples of how a biologist would use such a facility interactively . As biologists are empowered to create their own vocabularies and descriptors and reason with them , there will be greater understanding of large scale bioinformatics datasets .
In future work , we plan to increase the expressiveness of our formulation in many ways . First , we would like to redescribe not just in a propositional logic , as described here , but employing a form of predicate logic . An example from bioinformatics would be the use of a homology relation to relate , for instance , descriptors from a yeast vocabulary to descriptors in a vocabulary designed for mouse genes . This is a natural generalization of the type of redescriptions considered here . Second , we would like to create chains of ( approximate ) redescriptions , effectively forming a story from one gene set to another . Given two disjoint sets , for instance , even though there could be no redescription connecting them , there could be a chain of approximate redescriptions going from one to the other . Finally , we would like to use redescriptions as a basis for knowledge management in domains rich in descriptors . Towards this goal , we aim to extend the expressiveness of our mining algorithms towards other classes of expressions such as disjunctions , and also more generality , eg , CNF or DNF .
Acknowledgments Zaki ’s work was supported in part by NSF CAREER Award IIS 0092978 , DOE Career Award DE FG02 02ER25538 , NSF grant EIA 0103708 , and NSF grant EMT 0432098 . Ramakrishnan ’s work was supported in part by NSF grants IBN0219332 and EIA 0103660 . We acknowledge the help of Deept Kumar , who furnished us with the datasets from [ 7 ] and Laxmi Parida , for useful discussions .
6 . REFERENCES [ 1 ] Y . Bastide , N . Pasquier , R . Taouil , G . Stumme , and L . Lakhal . Mining minimal non redundant association rules using frequent closed itemsets . In 1st International Conference on Computational Logic , July 2000 .
[ 2 ] D . Burdick , M . Calimlim , and J . Gehrke . MAFIA : a maximal frequent itemset algorithm for transactional databases . In IEEE Intl . Conf . on Data Engineering , pages pp . 443{452 , April 2001 .
[ 3 ] B . Ganter and R . Wille . Formal Concept Analysis : Mathematical Foundations . Springer Verlag , 1999 .
[ 4 ] AP Gasch , PT Spellman , CM Kao , O . Carmel Harel , MB
Eisen , G . Storz , D . Botstein , and PO Brown . Genomic Expression Programs in the Response of Yeast Cells to Environmental Changes . Mol . Biol . Cell , Vol . 11:pages 4241{4257 , 2000 .
[ 5 ] L . Nourine and O . Raynaud . A fast algorithm for building lattices . Information Processing Letters , 71:199{204 , 1999 .
[ 6 ] JL Pflatz and RE Jamison . Closure systems and their structure . Information Sciences , 139:275{286 , 2001 .
[ 7 ] N . Ramakrishnan , D . Kumar , B . Mishra , M . Potts , and RF
Helm . Turning CARTwheels : An Alternating Algorithm for Mining Redescriptions . In Proc . KDD’04 , pages 266{275 , Aug 2004 .
[ 8 ] A . Sturn , J . Quackenbush , and Z . Trajanoski . Genesis : Cluster Analysis of Microarray Data . Bioinformatics , Vol . 18(1):pages 207{208 , 2002 .
[ 9 ] J . Wang , J . Han , and J . Pei . Closet+ : Searching for the best strategies for mining frequent closed itemsets . In ACM SIGKDD Int’l Conf . on Knowledge Discovery and Data Mining , August 2003 .
[ 10 ] JJ Wyrick , FC Holstege , EG Jennings , HC Causton ,
D . Shore , M . Grunstein , ES Lander , and RA Young . Chromosomal Landscape of Nucleosome Dependent Gene Expression and Silencing in Yeast . Nature , Vol . 402:pages 418{421 , 1999 .
[ 11 ] M . J . Zaki . Generating non redundant association rules . In 6th
ACM SIGKDD Int’l Conf . on Knowledge Discovery and Data Mining , pages pp . 34{43 , August 2000 .
[ 12 ] M . J . Zaki and C J Hsiao . ChARM : An efficient algorithm for closed itemset mining . In 2nd SIAM International Conference on Data Mining , pages pp . 457{473 , April 2002 .
[ 13 ] M . J . Zaki and C J Hsiao . Efficient algorithms for mining closed itemsets and their lattice structure . IEEE Transactions on Knowledge and Data Engineering , 17(4):462{478 , April 2005 .
