An Efficient Data Mining Technique for Discovering Interesting Sequential Patterns
Show Jane Yen* and Yue Shi Lee**
*Dept . of Computer Science and Information Engineering , Fu Jen Catholic University , Taipei , TAIWAN , ROC
**Dept . of Information Management , Ming Chuan University , Taipei , TAIWAN , ROC
Email : sjyen@csiefjuedutw , leeys@mcuedutw
Abstract
Mining sequential patterns is to discover sequential purchasing behaviors of most customers from a large amount of customer transactions . In this paper , a data mining language is presented . From the data mining language , users can specify the interested items and the criteria of the sequential patterns to be discovered . Also , an efficient data mining technique is proposed to extract the sequential patterns according to the users` requests .
1 Data mining language
The definitions about mining sequential patterns are presented in [ 1,2 ] . Our data mining language , which refers to [ 3 ] , is defined as follows :
Mining <Sequential Patterns> From <TDB> With <{D1},{D2} , …,{Dm}> Support <s%>
1 . In the From clause , <TDB> is used to specify the database name to which users query the sequential patterns . 2 . In the With clause , <{D1},{D2} , …,{Dm}> are userspecified items which ordered by increasing purchasing time , Besides , the notation “ * ” can be in the itemsets Di , which denotes any itemsets and {Di} can be the notation “ * ” , which represents any sequence . 3 . Support clause is followed by the user specified minimum support s % .
In order to find the interesting sequential patterns efficiently , we need to transform the original transaction data into another type . Each item in each customer sequence is transformed into a bit string . The length of a bit string is the number of the transactions in the customer sequence . If the ith transaction of the customer sequence contains an item , then the ith bit in the bit string for this item is set to 1 . Otherwise , the ith bit is set to 0 . sequence contains the two sequences S1 and S2 . We present an operation called sequential bit string operation to check if the sequence customer
Suppose a
S1S2 is also contained in this customer sequence . The process of this operation is described as follows : Let the bit strings for sequence S1 and S2 in customer sequence c is B1 and B2 , respectively . Bit string B1 is scanned from left to right until a bit value 1 is visited . We set this bit and all bits on the left hand side of this bit to 0 and set all bits on the right hand side of this bit to 1 , and assign the resultant bit string to a template Tb . Then , the bit string for sequence S1S2 in c can be obtained by performing logical AND operation on bit strings Tb and B2 . If the number of 1 ’s in the bit string for sequence S1S2 is not then S1S2 is contained in customer sequence c . zero , Otherwise , the customer sequence c does not contain S1S2 .
2 Mining interesting sequential patterns
Suppose the user specifies a sequence which contains k itemsets D1 , D2 , … and Dm in the With clause and S = {D1}{D2}…{Dm} . In the following , we describe the algorithm to find interesting sequential patterns : Step 1 . Find all the frequent ( m+1) sequences Step 11 Scan the bit string database , if all items in S are contained in a record , then output the items in this record and the bit string for each item into 1 itemset database . If S is a frequent sequence , then find all frequent 1 itemsets . The frequent itemsets are found in each iteration . For the kth iteration ( k≥1 ) , the candidate ( k+1) itemsets are generated , and scan the ( k+1) itemset database to find ( k+1) frequent itemsets .
The method to generate the candidate ( k+1) itemsets is described as follows [ 1 ] . Suppose the two frequent kitemsets X and Y in a record in the k itemset database generate candidate ( k+1) itemset Z . We perform logical AND operation on the two bit strings for X and Y , and the resultant bit string is the bit string for Z . If this bit string is not zero , then output Z and its bit string into ( k+1)itemset database . Besides , we also output the frequent kitemsets and its bit string in each record into the frequent itemset database . Step 12 Each frequent itemset ( ie , frequent 1 sequence ) is given a unique number , and replace the frequent itemsets in the frequent itemset database with their numbers to form a 1 sequence database .
Proceedings of the 2001 IEEE International Conference on Data Mining ( ICDM(cid:146)01 ) 0 7695 1119 8/01 $17.00 ' 2001 IEEE
Step 13 Generate candidate k sequences ( k=2,3 ) , and scan ( k 1) sequence database to generate k sequence database and find all the frequent k sequences . the itemset D1 ,
The candidate 2 itemsets are generated as follows : For each frequent 1 sequence f except D1 , if there is a notation “ * ” appears before the itemset D1 in the With clause , then the candidate 2 sequence {f}{D1} is generated . If the then the notation “ * ” appears after candidate 2 sequence {D1}{f} is generated . If the reverse order of a candidate 2 sequence is contained in the specified sequence S , then this candidate 2 sequence can be pruned . The method to generate candidate 3 sequences is described as follows : For every two frequent 2sequences S1={D1}{r} which is a sub sequence of S and S2={D1}{t} ( or S1={D1}{r} and S2={t}{D1} ) , we can and generate {D1}{t}{r}Òor {t}{D1}{r}Ó . candidate 3 sequences
{D1}{r}{t} the
For each record in the ( k 1) sequence database , we use the frequent ( k 1) sequences in the record and apply the above method to generate the candidate k sequences . Suppose that the two frequent ( k 1) sequences X and Y in a record generate the candidate k sequence Z . We perform the sequential bit string operation on the two bit strings for X and Y , and the resultant bit string is the bit string for Z . If this bit string is not zero , then output Z and its bit string into k sequence database . After scanning ( k 1)sequence database , the k sequence database can be generated and the candidate k sequences can be counted . Step 14 Frequent are generated in each iteration . For the ( h 2)th iteration , we use frequent h sequences to generate candidate ( h+1)sequence , and scan h sequence database to generate ( h+1)sequence database , and find all ( h+1)sequences .
( h+1) sequences the frequent
( 3≤h≤m )
We use the following method to generate candidate any two frequent h sequence ( h+1) sequences : For S1={s1}{s2}…{sh 1}{r} and S2={s1}{s2}…{sh 1}{t} , in which {s1}{s2}…{sh 1} is a sub sequence of S or {r} and {t} are contained in S , the candidate ( h+1) sequences {s1}{s2}…{sh 1}{r}{t} and {s1}{s2}…{sh 1}{t}{r} can be generated . If a generated candidate ( h+1) sequence contains more than one itemsets which are not contained in S , then the candidate ( h+1) sequence can be pruned . The methods to generate ( h+1) sequence database and the frequent ( h+1) sequences are the same as step 13 Step 2 . The frequent ( m+n+1) sequences ( n≥1 ) which contain the specified sequence S are generated in each iteration . For the nth iteration , we use the frequent ( m+n ) sequences to generate candidate ( m+n+1) sequences and scan and 1 sequence database to generate ( m+n+1) sequence database in which the candidate ( m+n+1) sequences are contained in each
( m+n) sequence database the record but the bit string are not , and find the frequent ( m+n+1) sequences .
S2
=
The method to generate candidate ( m+n+1) sequences is as follows : For every two frequent ( m+n) sequences S1 = and {s1}{s2}…{si}{r}{si+1}…{sm+n 1} {s1} {s2}…{sj}{t}{sj+1}…{sm+n 1} ( i≤j ) , in which {r} is not contained in S2 and {t} is not contained in S1 , a candidate ( m+n+1) sequence {s1}{s2}…{r}…{t}… {sm+n 1} can be generated . For each record in ( m+n) sequence database , we also use every two frequent ( m+n) sequences in this record and apply the above method to generate a candidate ( m+n+1) sequence , and perform the sequential bit string operations on the bit strings for the itemsets in the candidate ( m+n+1) sequence by scanning the 1 sequence database . If the resultant bit string is not zero , then output the candidate ( m+n+1) sequence into the ( m+n+1)sequence database , and count the support for the candidate ( m+n+1) sequence . After ( m+n) sequence database , the ( m+n+1) sequence database can be generated and the frequent ( m+n+1) sequences can be found . Step 3 . For each frequent sequence , the code for each itemset in the frequent sequence is replaced with the itemset itself . If a frequent sequence is not contained in another frequent sequences , then this frequent sequence is a sequential pattern . scanning
3 Conclusions
In this paper , we introduce a data mining language . From the data mining language , users can specify the items or the sequences and the minimum support threshold of the sequential patterns to be discovered , which they are interested in . We propose an efficient data mining technique to process the user requirement . Our algorithms can reduce the number of the combinations of itemsets or sequences in each customer sequence for counting the supports of the candidate sequences , and reduce the number of the candidate sequences according to the user ’s requests .
References
[ 1 ] Rakesh Agrawal , et al . , “ Mining Sequential Patterns , ” Proc . of the Int'l Conference on Data Engineering , pp . 3 14 , 1995 . [ 2 ] Rakesh Agrawal , et al . , “ Mining Sequential Patterns : Generalizations and Performance Improvements , ” Proc . of the 5th Int'l Conference on Extending Database Technology , pp . 317 , 1996 . [ 3 ] Show Jane Yen and ALP Chen , “ An Efficient Data Mining Technique for Discovering Interesting Association Rules , ” Proc . the 8th Int'l Conference and Workshop on Database and of Expert Systems Applications , pp . 664 669 , 1997 .
Proceedings of the 2001 IEEE International Conference on Data Mining ( ICDM(cid:146)01 ) 0 7695 1119 8/01 $17.00 ' 2001 IEEE
